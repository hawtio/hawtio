var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ.log = Logger.get("activemq");
    ActiveMQ.jmxDomain = 'org.apache.activemq';
    function getSelectionQueuesFolder(workspace) {
        function findQueuesFolder(node) {
            if (node) {
                if (node.title === "Queues" || node.title === "Queue") {
                    return node;
                }
                var parent = node.parent;
                if (parent) {
                    return findQueuesFolder(parent);
                }
            }
            return null;
        }
        var selection = workspace.selection;
        if (selection) {
            return findQueuesFolder(selection);
        }
        return null;
    }
    ActiveMQ.getSelectionQueuesFolder = getSelectionQueuesFolder;
    function getSelectionTopicsFolder(workspace) {
        function findTopicsFolder(node) {
            var answer = null;
            if (node) {
                if (node.title === "Topics" || node.title === "Topic") {
                    answer = node;
                }
                if (answer === null) {
                    angular.forEach(node.children, function (child) {
                        if (child.title === "Topics" || child.title === "Topic") {
                            answer = child;
                        }
                    });
                }
            }
            return answer;
        }
        var selection = workspace.selection;
        if (selection) {
            return findTopicsFolder(selection);
        }
        return null;
    }
    ActiveMQ.getSelectionTopicsFolder = getSelectionTopicsFolder;
    function selectCurrentMessage(message, key, $scope) {
        $scope.gridOptions.selectAll(false);
        var idx = Core.pathGet(message, ["rowIndex"]);
        var jmsMessageID = Core.pathGet(message, ["entity", key]);
        $scope.rowIndex = idx;
        var selected = $scope.gridOptions.selectedItems;
        selected.splice(0, selected.length);
        if (idx >= 0 && idx < $scope.messages.length) {
            $scope.row = $scope.messages.find(function (msg) { return msg[key] === jmsMessageID; });
            if ($scope.row) {
                selected.push($scope.row);
            }
        }
        else {
            $scope.row = null;
        }
    }
    ActiveMQ.selectCurrentMessage = selectCurrentMessage;
    function decorate($scope) {
        $scope.selectRowIndex = function (idx) {
            $scope.rowIndex = idx;
            var selected = $scope.gridOptions.selectedItems;
            selected.splice(0, selected.length);
            if (idx >= 0 && idx < $scope.messages.length) {
                $scope.row = $scope.messages[idx];
                if ($scope.row) {
                    selected.push($scope.row);
                }
            }
            else {
                $scope.row = null;
            }
        };
        $scope.$watch("showMessageDetails", function () {
            if (!$scope.showMessageDetails) {
                $scope.row = null;
                $scope.gridOptions.selectedItems.splice(0, $scope.gridOptions.selectedItems.length);
            }
        });
    }
    ActiveMQ.decorate = decorate;
})(ActiveMQ || (ActiveMQ = {}));
var StringHelpers;
(function (StringHelpers) {
    var dateRegex = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:/i;
    function isDate(str) {
        if (!angular.isString(str)) {
            return false;
        }
        return dateRegex.test(str);
    }
    StringHelpers.isDate = isDate;
    function obfusicate(str) {
        if (!angular.isString(str)) {
            return null;
        }
        return str.chars().map(function (c) {
            return '*';
        }).join('');
    }
    StringHelpers.obfusicate = obfusicate;
    function toString(obj) {
        if (!obj) {
            return '{ null }';
        }
        var answer = [];
        angular.forEach(obj, function (value, key) {
            var val = value;
            if (('' + key).toLowerCase() === 'password') {
                val = StringHelpers.obfusicate(value);
            }
            else if (angular.isObject(val)) {
                val = toString(val);
            }
            answer.push(key + ': ' + val);
        });
        return '{ ' + answer.join(', ') + ' }';
    }
    StringHelpers.toString = toString;
})(StringHelpers || (StringHelpers = {}));
var Core;
(function (Core) {
    function createConnectToServerOptions(options) {
        var defaults = {
            scheme: 'http',
            host: null,
            port: null,
            path: null,
            useProxy: true,
            jolokiaUrl: null,
            userName: null,
            password: null,
            view: null,
            name: null
        };
        var opts = options || {};
        return angular.extend(defaults, opts);
    }
    Core.createConnectToServerOptions = createConnectToServerOptions;
    function createConnectOptions(options) {
        return createConnectToServerOptions(options);
    }
    Core.createConnectOptions = createConnectOptions;
})(Core || (Core = {}));
var UrlHelpers;
(function (UrlHelpers) {
    var log = Logger.get("UrlHelpers");
    function noHash(url) {
        if (url.startsWith('#')) {
            return url.last(url.length - 1);
        }
        else {
            return url;
        }
    }
    UrlHelpers.noHash = noHash;
    function extractPath(url) {
        if (url.has('?')) {
            return url.split('?')[0];
        }
        else {
            return url;
        }
    }
    UrlHelpers.extractPath = extractPath;
    function contextActive(url, thingICareAbout) {
        var cleanUrl = extractPath(url);
        if (thingICareAbout.endsWith('/') && thingICareAbout.startsWith("/")) {
            return cleanUrl.has(thingICareAbout);
        }
        if (thingICareAbout.startsWith("/")) {
            return noHash(cleanUrl).startsWith(thingICareAbout);
        }
        return cleanUrl.endsWith(thingICareAbout);
    }
    UrlHelpers.contextActive = contextActive;
    function join() {
        var paths = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paths[_i - 0] = arguments[_i];
        }
        var tmp = [];
        var length = paths.length - 1;
        paths.forEach(function (path, index) {
            if (Core.isBlank(path)) {
                return;
            }
            if (index !== 0 && path.first(1) === '/') {
                path = path.slice(1);
            }
            if (index !== length && path.last(1) === '/') {
                path = path.slice(0, path.length - 1);
            }
            if (!Core.isBlank(path)) {
                tmp.push(path);
            }
        });
        var rc = tmp.join('/');
        return rc;
    }
    UrlHelpers.join = join;
    UrlHelpers.parseQueryString = hawtioPluginLoader.parseQueryString;
    function maybeProxy(jolokiaUrl, url) {
        if (jolokiaUrl && jolokiaUrl.startsWith('proxy/')) {
            log.debug("Jolokia URL is proxied, applying proxy to: ", url);
            return join('proxy', url);
        }
        var origin = window.location['origin'];
        if (url && (url.startsWith('http') && !url.startsWith(origin))) {
            log.debug("Url doesn't match page origin: ", origin, " applying proxy to: ", url);
            return join('proxy', url);
        }
        log.debug("No need to proxy: ", url);
        return url;
    }
    UrlHelpers.maybeProxy = maybeProxy;
    function escapeColons(url) {
        var answer = url;
        if (url.startsWith('proxy')) {
            answer = url.replace(/:/g, '\\:');
        }
        else {
            answer = url.replace(/:([^\/])/, '\\:$1');
        }
        return answer;
    }
    UrlHelpers.escapeColons = escapeColons;
})(UrlHelpers || (UrlHelpers = {}));
var Core;
(function (Core) {
    Core.injector = null;
    var _urlPrefix = null;
    Core.connectionSettingsKey = "jvmConnect";
    function _resetUrlPrefix() {
        _urlPrefix = null;
    }
    Core._resetUrlPrefix = _resetUrlPrefix;
    function url(path) {
        if (path) {
            if (path.startsWith && path.startsWith("/")) {
                if (!_urlPrefix) {
                    _urlPrefix = $('base').attr('href') || "";
                    if (_urlPrefix.endsWith && _urlPrefix.endsWith('/')) {
                        _urlPrefix = _urlPrefix.substring(0, _urlPrefix.length - 1);
                    }
                }
                if (_urlPrefix) {
                    return _urlPrefix + path;
                }
            }
        }
        return path;
    }
    Core.url = url;
    function windowLocation() {
        return window.location;
    }
    Core.windowLocation = windowLocation;
    String.prototype.unescapeHTML = function () {
        var txt = document.createElement("textarea");
        txt.innerHTML = this;
        return txt.value;
    };
    if (!Object.keys) {
        console.debug("Creating hawt.io version of Object.keys()");
        Object.keys = function (obj) {
            var keys = [], k;
            for (k in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, k)) {
                    keys.push(k);
                }
            }
            return keys;
        };
    }
    function _resetJolokiaUrls() {
        jolokiaUrls = [
            Core.url("jolokia"),
            "/jolokia"
        ];
        return jolokiaUrls;
    }
    Core._resetJolokiaUrls = _resetJolokiaUrls;
    var jolokiaUrls = Core._resetJolokiaUrls();
    function trimLeading(text, prefix) {
        if (text && prefix) {
            if (text.startsWith(prefix)) {
                return text.substring(prefix.length);
            }
        }
        return text;
    }
    Core.trimLeading = trimLeading;
    function trimTrailing(text, postfix) {
        if (text && postfix) {
            if (text.endsWith(postfix)) {
                return text.substring(0, text.length - postfix.length);
            }
        }
        return text;
    }
    Core.trimTrailing = trimTrailing;
    function loadConnectionMap() {
        var localStorage = Core.getLocalStorage();
        try {
            var answer = angular.fromJson(localStorage[Core.connectionSettingsKey]);
            if (!answer) {
                return {};
            }
            else {
                return answer;
            }
        }
        catch (e) {
            delete localStorage[Core.connectionSettingsKey];
            return {};
        }
    }
    Core.loadConnectionMap = loadConnectionMap;
    function saveConnectionMap(map) {
        Logger.get("Core").debug("Saving connection map: ", StringHelpers.toString(map));
        localStorage[Core.connectionSettingsKey] = angular.toJson(map);
    }
    Core.saveConnectionMap = saveConnectionMap;
    function getConnectOptions(name, localStorage) {
        if (localStorage === void 0) { localStorage = Core.getLocalStorage(); }
        if (!name) {
            return null;
        }
        return Core.loadConnectionMap()[name];
    }
    Core.getConnectOptions = getConnectOptions;
    Core.ConnectionName = null;
    function getConnectionNameParameter(search) {
        if (Core.ConnectionName) {
            return Core.ConnectionName;
        }
        var connectionName = undefined;
        if ('con' in window) {
            connectionName = window['con'];
            Logger.get("Core").debug("Found connection name from window: ", connectionName);
        }
        else {
            connectionName = search["con"];
            if (angular.isArray(connectionName)) {
                connectionName = connectionName[0];
            }
            if (connectionName) {
                connectionName = connectionName.unescapeURL();
                Logger.get("Core").debug("Found connection name from URL: ", connectionName);
            }
            else {
                Logger.get("Core").debug("No connection name found, using direct connection to JVM");
            }
        }
        Core.ConnectionName = connectionName;
        return connectionName;
    }
    Core.getConnectionNameParameter = getConnectionNameParameter;
    function createServerConnectionUrl(options) {
        Logger.get("Core").debug("Connect to server, options: ", StringHelpers.toString(options));
        var answer = null;
        if (options.jolokiaUrl) {
            answer = options.jolokiaUrl;
        }
        if (answer === null) {
            answer = options.scheme || 'http';
            answer += '://' + (options.host || 'localhost');
            if (options.port) {
                answer += ':' + options.port;
            }
            if (options.path) {
                answer = UrlHelpers.join(answer, options.path);
            }
        }
        answer = UrlHelpers.join('proxy', answer);
        Logger.get("Core").debug("Using URL: ", answer);
        return answer;
    }
    Core.createServerConnectionUrl = createServerConnectionUrl;
    function getJolokiaUrl() {
        var query = hawtioPluginLoader.parseQueryString();
        var localMode = query['localMode'];
        if (localMode) {
            Logger.get("Core").debug("local mode so not using jolokia URL");
            jolokiaUrls = [];
            return null;
        }
        var uri = null;
        var connectionName = Core.getConnectionNameParameter(query);
        if (connectionName) {
            var connectOptions = Core.getConnectOptions(connectionName);
            if (connectOptions) {
                uri = createServerConnectionUrl(connectOptions);
                Logger.get("Core").debug("Using jolokia URI: ", uri, " from local storage");
            }
            else {
                Logger.get("Core").debug("Connection parameter found but no stored connections under name: ", connectionName);
            }
        }
        if (!uri) {
            var fakeCredentials = {
                username: 'public',
                password: 'biscuit'
            };
            var localStorage = getLocalStorage();
            if ('userDetails' in window) {
                fakeCredentials = window['userDetails'];
            }
            else if ('userDetails' in localStorage) {
                fakeCredentials = angular.fromJson(localStorage['userDetails']);
            }
            uri = jolokiaUrls.find(function (url) {
                var jqxhr = $.ajax(url, {
                    async: false,
                    username: fakeCredentials.username,
                    password: fakeCredentials.password
                });
                return jqxhr.status === 200 || jqxhr.status === 401 || jqxhr.status === 403;
            });
            Logger.get("Core").debug("Using jolokia URI: ", uri, " via discovery");
        }
        return uri;
    }
    Core.getJolokiaUrl = getJolokiaUrl;
    function adjustHeight() {
        var windowHeight = $(window).height();
        var headerHeight = $("#main-nav").height();
        var containerHeight = windowHeight - headerHeight;
        $("#main").css("min-height", "" + containerHeight + "px");
    }
    Core.adjustHeight = adjustHeight;
    function isChromeApp() {
        var answer = false;
        try {
            answer = (chrome && chrome.app && chrome.extension) ? true : false;
        }
        catch (e) {
            answer = false;
        }
        return answer;
    }
    Core.isChromeApp = isChromeApp;
    function addCSS(path) {
        if ('createStyleSheet' in document) {
            document.createStyleSheet(path);
        }
        else {
            var link = $("<link>");
            $("head").append(link);
            link.attr({
                rel: 'stylesheet',
                type: 'text/css',
                href: path
            });
        }
    }
    Core.addCSS = addCSS;
    var dummyStorage = {};
    function getLocalStorage() {
        var storage = window.localStorage || (function () {
            return dummyStorage;
        })();
        return storage;
    }
    Core.getLocalStorage = getLocalStorage;
    function asArray(value) {
        return angular.isArray(value) ? value : [value];
    }
    Core.asArray = asArray;
    function parseBooleanValue(value, defaultValue) {
        if (defaultValue === void 0) { defaultValue = false; }
        if (!angular.isDefined(value) || !value) {
            return defaultValue;
        }
        if (value.constructor === Boolean) {
            return value;
        }
        if (angular.isString(value)) {
            switch (value.toLowerCase()) {
                case "true":
                case "1":
                case "yes":
                    return true;
                default:
                    return false;
            }
        }
        if (angular.isNumber(value)) {
            return value !== 0;
        }
        throw new Error("Can't convert value " + value + " to boolean");
    }
    Core.parseBooleanValue = parseBooleanValue;
    function toString(value) {
        if (angular.isNumber(value)) {
            return numberToString(value);
        }
        else {
            return angular.toJson(value, true);
        }
    }
    Core.toString = toString;
    function booleanToString(value) {
        return "" + value;
    }
    Core.booleanToString = booleanToString;
    function parseIntValue(value, description) {
        if (description === void 0) { description = "integer"; }
        if (angular.isString(value)) {
            try {
                return parseInt(value);
            }
            catch (e) {
                console.log("Failed to parse " + description + " with text '" + value + "'");
            }
        }
        else if (angular.isNumber(value)) {
            return value;
        }
        return null;
    }
    Core.parseIntValue = parseIntValue;
    function numberToString(value) {
        return "" + value;
    }
    Core.numberToString = numberToString;
    function parseFloatValue(value, description) {
        if (description === void 0) { description = "float"; }
        if (angular.isString(value)) {
            try {
                return parseFloat(value);
            }
            catch (e) {
                console.log("Failed to parse " + description + " with text '" + value + "'");
            }
        }
        else if (angular.isNumber(value)) {
            return value;
        }
        return null;
    }
    Core.parseFloatValue = parseFloatValue;
    function pathGet(object, paths) {
        var pathArray = (angular.isArray(paths)) ? paths : (paths || "").split(".");
        var value = object;
        angular.forEach(pathArray, function (name) {
            if (value) {
                try {
                    value = value[name];
                }
                catch (e) {
                    return null;
                }
            }
            else {
                return null;
            }
        });
        return value;
    }
    Core.pathGet = pathGet;
    function pathSet(object, paths, newValue) {
        var pathArray = (angular.isArray(paths)) ? paths : (paths || "").split(".");
        var value = object;
        var lastIndex = pathArray.length - 1;
        angular.forEach(pathArray, function (name, idx) {
            var next = value[name];
            if (idx >= lastIndex || !angular.isObject(next)) {
                next = (idx < lastIndex) ? {} : newValue;
                value[name] = next;
            }
            value = next;
        });
        return value;
    }
    Core.pathSet = pathSet;
    function $applyNowOrLater($scope) {
        if ($scope.$$phase || $scope.$root.$$phase) {
            setTimeout(function () {
                Core.$apply($scope);
            }, 50);
        }
        else {
            $scope.$apply();
        }
    }
    Core.$applyNowOrLater = $applyNowOrLater;
    function $applyLater($scope, timeout) {
        if (timeout === void 0) { timeout = 50; }
        setTimeout(function () {
            Core.$apply($scope);
        }, timeout);
    }
    Core.$applyLater = $applyLater;
    function $apply($scope) {
        var phase = $scope.$$phase || $scope.$root.$$phase;
        if (!phase) {
            $scope.$apply();
        }
    }
    Core.$apply = $apply;
    function $digest($scope) {
        var phase = $scope.$$phase || $scope.$root.$$phase;
        if (!phase) {
            $scope.$digest();
        }
    }
    Core.$digest = $digest;
    function getOrCreateElements(domElement, arrayOfElementNames) {
        var element = domElement;
        angular.forEach(arrayOfElementNames, function (name) {
            if (element) {
                var children = $(element).children(name);
                if (!children || !children.length) {
                    $("<" + name + "></" + name + ">").appendTo(element);
                    children = $(element).children(name);
                }
                element = children;
            }
        });
        return element;
    }
    Core.getOrCreateElements = getOrCreateElements;
    var _escapeHtmlChars = {
        "#": "&#35;",
        "'": "&#39;",
        "<": "&lt;",
        ">": "&gt;",
        "\"": "&quot;"
    };
    function unescapeHtml(str) {
        angular.forEach(_escapeHtmlChars, function (value, key) {
            var regex = new RegExp(value, "g");
            str = str.replace(regex, key);
        });
        str = str.replace(/&gt;/g, ">");
        return str;
    }
    Core.unescapeHtml = unescapeHtml;
    function escapeHtml(str) {
        if (angular.isString(str)) {
            var newStr = "";
            for (var i = 0; i < str.length; i++) {
                var ch = str.charAt(i);
                var ch = _escapeHtmlChars[ch] || ch;
                newStr += ch;
            }
            return newStr;
        }
        else {
            return str;
        }
    }
    Core.escapeHtml = escapeHtml;
    function isBlank(str) {
        if (str === undefined || str === null) {
            return true;
        }
        if (angular.isString(str)) {
            return str.isBlank();
        }
        else {
            return false;
        }
    }
    Core.isBlank = isBlank;
    function notification(type, message, options) {
        if (options === void 0) { options = null; }
        if (options === null) {
            options = {};
        }
        if (type === 'error' || type === 'warning') {
            if (!angular.isDefined(options.onclick)) {
                options.onclick = window['showLogPanel'];
            }
        }
        toastr[type](message, '', options);
    }
    Core.notification = notification;
    function clearNotifications() {
        toastr.clear();
    }
    Core.clearNotifications = clearNotifications;
    function trimQuotes(text) {
        if (text) {
            while (text.endsWith('"') || text.endsWith("'")) {
                text = text.substring(0, text.length - 1);
            }
            while (text.startsWith('"') || text.startsWith("'")) {
                text = text.substring(1, text.length);
            }
        }
        return text;
    }
    Core.trimQuotes = trimQuotes;
    function humanizeValue(value) {
        if (value) {
            var text = value + '';
            try {
                text = text.underscore();
            }
            catch (e) {
            }
            try {
                text = text.humanize();
            }
            catch (e) {
            }
            return trimQuotes(text);
        }
        return value;
    }
    Core.humanizeValue = humanizeValue;
})(Core || (Core = {}));
var ControllerHelpers;
(function (ControllerHelpers) {
    var log = Logger.get("ControllerHelpers");
    function createClassSelector(config) {
        return function (selector, model) {
            if (selector === model && selector in config) {
                return config[selector];
            }
            return '';
        };
    }
    ControllerHelpers.createClassSelector = createClassSelector;
    function createValueClassSelector(config) {
        return function (model) {
            if (model in config) {
                return config[model];
            }
            else {
                return '';
            }
        };
    }
    ControllerHelpers.createValueClassSelector = createValueClassSelector;
    function bindModelToSearchParam($scope, $location, modelName, paramName, initialValue, to, from) {
        if (!(modelName in $scope)) {
            $scope[modelName] = initialValue;
        }
        var toConverter = to || Core.doNothing;
        var fromConverter = from || Core.doNothing;
        function currentValue() {
            return fromConverter($location.search()[paramName] || initialValue);
        }
        var value = currentValue();
        Core.pathSet($scope, modelName, value);
        $scope.$watch(modelName, function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue !== undefined && newValue !== null) {
                    $location.search(paramName, toConverter(newValue));
                }
                else {
                    $location.search(paramName, '');
                }
            }
        });
    }
    ControllerHelpers.bindModelToSearchParam = bindModelToSearchParam;
    function reloadWhenParametersChange($route, $scope, $location, parameters) {
        if (parameters === void 0) { parameters = ["nid"]; }
        var initial = angular.copy($location.search());
        $scope.$on('$routeUpdate', function () {
            var current = $location.search();
            var changed = [];
            angular.forEach(parameters, function (param) {
                if (current[param] !== initial[param]) {
                    changed.push(param);
                }
            });
            if (changed.length) {
                $route.reload();
            }
        });
    }
    ControllerHelpers.reloadWhenParametersChange = reloadWhenParametersChange;
})(ControllerHelpers || (ControllerHelpers = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Core;
(function (Core) {
    var log = Logger.get("Core");
    var TasksImpl = (function () {
        function TasksImpl() {
            this.tasks = {};
            this.tasksExecuted = false;
            this._onComplete = null;
        }
        TasksImpl.prototype.addTask = function (name, task) {
            this.tasks[name] = task;
            if (this.tasksExecuted) {
                this.executeTask(name, task);
            }
        };
        TasksImpl.prototype.executeTask = function (name, task) {
            if (angular.isFunction(task)) {
                log.debug("Executing task : ", name);
                try {
                    task();
                }
                catch (error) {
                    log.debug("Failed to execute task: ", name, " error: ", error);
                }
            }
        };
        TasksImpl.prototype.onComplete = function (cb) {
            this._onComplete = cb;
        };
        TasksImpl.prototype.execute = function () {
            var _this = this;
            if (this.tasksExecuted) {
                return;
            }
            angular.forEach(this.tasks, function (task, name) {
                _this.executeTask(name, task);
            });
            this.tasksExecuted = true;
            if (angular.isFunction(this._onComplete)) {
                this._onComplete();
            }
        };
        TasksImpl.prototype.reset = function () {
            this.tasksExecuted = false;
        };
        return TasksImpl;
    })();
    Core.TasksImpl = TasksImpl;
    var ParameterizedTasksImpl = (function (_super) {
        __extends(ParameterizedTasksImpl, _super);
        function ParameterizedTasksImpl() {
            var _this = this;
            _super.call(this);
            this.tasks = {};
            this.onComplete(function () {
                _this.reset();
            });
        }
        ParameterizedTasksImpl.prototype.addTask = function (name, task) {
            this.tasks[name] = task;
        };
        ParameterizedTasksImpl.prototype.execute = function () {
            var _this = this;
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i - 0] = arguments[_i];
            }
            if (this.tasksExecuted) {
                return;
            }
            var theArgs = params;
            var keys = Object.keys(this.tasks);
            keys.forEach(function (name) {
                var task = _this.tasks[name];
                if (angular.isFunction(task)) {
                    log.debug("Executing task: ", name, " with parameters: ", theArgs);
                    try {
                        task.apply(task, theArgs);
                    }
                    catch (e) {
                        log.debug("Failed to execute task: ", name, " error: ", e);
                    }
                }
            });
            this.tasksExecuted = true;
            if (angular.isFunction(this._onComplete)) {
                this._onComplete();
            }
        };
        return ParameterizedTasksImpl;
    })(TasksImpl);
    Core.ParameterizedTasksImpl = ParameterizedTasksImpl;
    var ConditionalTasksImpl = (function (_super) {
        __extends(ConditionalTasksImpl, _super);
        function ConditionalTasksImpl() {
            _super.apply(this, arguments);
        }
        ConditionalTasksImpl.prototype.executeConditionalTask = function (name, task) {
            if (angular.isFunction(task)) {
                log.debug("Executing task : ", name);
                try {
                    return task();
                }
                catch (error) {
                    log.debug("Failed to execute conditional task: ", name, " error: ", error);
                    return false;
                }
            }
        };
        ConditionalTasksImpl.prototype.execute = function () {
            var _this = this;
            if (this.tasksExecuted) {
                return;
            }
            var success = true;
            angular.forEach(this.tasks, function (task, name) {
                success = success && _this.executeConditionalTask(name, task);
            });
            this.tasksExecuted = true;
            if (angular.isFunction(this._onComplete) && success) {
                this._onComplete();
            }
        };
        return ConditionalTasksImpl;
    })(TasksImpl);
    Core.ConditionalTasksImpl = ConditionalTasksImpl;
    Core.postLoginTasks = new Core.TasksImpl();
    Core.preLogoutTasks = new Core.TasksImpl();
    Core.postLogoutTasks = new Core.ConditionalTasksImpl();
})(Core || (Core = {}));
var Core;
(function (Core) {
    function operationToString(name, args) {
        if (!args || args.length === 0) {
            return name + '()';
        }
        else {
            return name + '(' + args.map(function (arg) {
                if (angular.isString(arg)) {
                    arg = angular.fromJson(arg);
                }
                return arg.type;
            }).join(',') + ')';
        }
    }
    Core.operationToString = operationToString;
})(Core || (Core = {}));
var Core;
(function (Core) {
    var Folder = (function () {
        function Folder(title) {
            this.title = title;
            this.key = null;
            this.typeName = null;
            this.children = [];
            this.folderNames = [];
            this.domain = null;
            this.objectName = null;
            this.map = {};
            this.entries = {};
            this.addClass = null;
            this.parent = null;
            this.isLazy = false;
            this.icon = null;
            this.tooltip = null;
            this.entity = null;
            this.version = null;
            this.mbean = null;
            this.expand = false;
            this.addClass = escapeTreeCssStyles(title);
        }
        Folder.prototype.get = function (key) {
            return this.map[key];
        };
        Folder.prototype.isFolder = function () {
            return this.children.length > 0;
        };
        Folder.prototype.navigate = function () {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i - 0] = arguments[_i];
            }
            var node = this;
            paths.forEach(function (path) {
                if (node) {
                    node = node.get(path);
                }
            });
            return node;
        };
        Folder.prototype.hasEntry = function (key, value) {
            var entries = this.entries;
            if (entries) {
                var actual = entries[key];
                return actual && value === actual;
            }
            return false;
        };
        Folder.prototype.parentHasEntry = function (key, value) {
            if (this.parent) {
                return this.parent.hasEntry(key, value);
            }
            return false;
        };
        Folder.prototype.ancestorHasEntry = function (key, value) {
            var parent = this.parent;
            while (parent) {
                if (parent.hasEntry(key, value))
                    return true;
                parent = parent.parent;
            }
            return false;
        };
        Folder.prototype.ancestorHasType = function (typeName) {
            var parent = this.parent;
            while (parent) {
                if (typeName === parent.typeName)
                    return true;
                parent = parent.parent;
            }
            return false;
        };
        Folder.prototype.getOrElse = function (key, defaultValue) {
            if (defaultValue === void 0) { defaultValue = new Folder(key); }
            var answer = this.map[key];
            if (!answer) {
                answer = defaultValue;
                this.map[key] = answer;
                this.children.push(answer);
                answer.parent = this;
            }
            return answer;
        };
        Folder.prototype.sortChildren = function (recursive) {
            var children = this.children;
            if (children) {
                this.children = children.sortBy("title");
                if (recursive) {
                    angular.forEach(children, function (child) { return child.sortChildren(recursive); });
                }
            }
        };
        Folder.prototype.moveChild = function (child) {
            if (child && child.parent !== this) {
                child.detach();
                child.parent = this;
                this.children.push(child);
            }
        };
        Folder.prototype.insertBefore = function (child, referenceFolder) {
            child.detach();
            child.parent = this;
            var idx = _.indexOf(this.children, referenceFolder);
            if (idx >= 0) {
                this.children.splice(idx, 0, child);
            }
        };
        Folder.prototype.insertAfter = function (child, referenceFolder) {
            child.detach();
            child.parent = this;
            var idx = _.indexOf(this.children, referenceFolder);
            if (idx >= 0) {
                this.children.splice(idx + 1, 0, child);
            }
        };
        Folder.prototype.detach = function () {
            var oldParent = this.parent;
            if (oldParent) {
                var oldParentChildren = oldParent.children;
                if (oldParentChildren) {
                    var idx = oldParentChildren.indexOf(this);
                    if (idx < 0) {
                        oldParent.children = oldParent.children.remove({ key: this.key });
                    }
                    else {
                        oldParentChildren.splice(idx, 1);
                    }
                }
                this.parent = null;
            }
        };
        Folder.prototype.findDescendant = function (filter) {
            if (filter(this)) {
                return this;
            }
            var answer = null;
            angular.forEach(this.children, function (child) {
                if (!answer) {
                    answer = child.findDescendant(filter);
                }
            });
            return answer;
        };
        Folder.prototype.findAncestor = function (filter) {
            if (filter(this)) {
                return this;
            }
            if (this.parent != null) {
                return this.parent.findAncestor(filter);
            }
            else {
                return null;
            }
        };
        return Folder;
    })();
    Core.Folder = Folder;
})(Core || (Core = {}));
;
var Folder = (function (_super) {
    __extends(Folder, _super);
    function Folder() {
        _super.apply(this, arguments);
    }
    return Folder;
})(Core.Folder);
;
var Jmx;
(function (Jmx) {
    Jmx.log = Logger.get("JMX");
    var attributesToolBars = {};
    function findLazyLoadingFunction(workspace, folder) {
        var factories = workspace.jmxTreeLazyLoadRegistry[folder.domain];
        var lazyFunction = null;
        if (factories && factories.length) {
            angular.forEach(factories, function (customLoader) {
                if (!lazyFunction) {
                    lazyFunction = customLoader(folder);
                }
            });
        }
        return lazyFunction;
    }
    Jmx.findLazyLoadingFunction = findLazyLoadingFunction;
    function registerLazyLoadHandler(domain, lazyLoaderFactory) {
        if (!Core.lazyLoaders) {
            Core.lazyLoaders = {};
        }
        var array = Core.lazyLoaders[domain];
        if (!array) {
            array = [];
            Core.lazyLoaders[domain] = array;
        }
        array.push(lazyLoaderFactory);
    }
    Jmx.registerLazyLoadHandler = registerLazyLoadHandler;
    function unregisterLazyLoadHandler(domain, lazyLoaderFactory) {
        if (Core.lazyLoaders) {
            var array = Core.lazyLoaders[domain];
            if (array) {
                array.remove(lazyLoaderFactory);
            }
        }
    }
    Jmx.unregisterLazyLoadHandler = unregisterLazyLoadHandler;
    function addAttributeToolBar(pluginName, jmxDomain, fn) {
        var array = attributesToolBars[jmxDomain];
        if (!array) {
            array = [];
            attributesToolBars[jmxDomain] = array;
        }
        array.push(fn);
    }
    Jmx.addAttributeToolBar = addAttributeToolBar;
    function getAttributeToolBar(node, defaultValue) {
        if (defaultValue === void 0) { defaultValue = "app/jmx/html/attributeToolBar.html"; }
        var answer = null;
        var jmxDomain = (node) ? node.domain : null;
        if (jmxDomain) {
            var array = attributesToolBars[jmxDomain];
            if (array) {
                for (var idx in array) {
                    var fn = array[idx];
                    answer = fn(node);
                    if (answer)
                        break;
                }
            }
        }
        return (answer) ? answer : defaultValue;
    }
    Jmx.getAttributeToolBar = getAttributeToolBar;
    function updateTreeSelectionFromURL($location, treeElement, activateIfNoneSelected) {
        if (activateIfNoneSelected === void 0) { activateIfNoneSelected = false; }
        updateTreeSelectionFromURLAndAutoSelect($location, treeElement, null, activateIfNoneSelected);
    }
    Jmx.updateTreeSelectionFromURL = updateTreeSelectionFromURL;
    function updateTreeSelectionFromURLAndAutoSelect($location, treeElement, autoSelect, activateIfNoneSelected) {
        if (activateIfNoneSelected === void 0) { activateIfNoneSelected = false; }
        var dtree = treeElement.dynatree("getTree");
        if (dtree) {
            var node = null;
            var key = $location.search()['nid'];
            if (key) {
                try {
                    node = dtree.activateKey(key);
                }
                catch (e) {
                }
            }
            if (node) {
                node.expand(true);
            }
            else {
                if (!treeElement.dynatree("getActiveNode")) {
                    var root = treeElement.dynatree("getRoot");
                    var children = root ? root.getChildren() : null;
                    if (children && children.length) {
                        var first = children[0];
                        first.expand(true);
                        if (autoSelect) {
                            var result = autoSelect(first);
                            if (result) {
                                first = result;
                            }
                        }
                        if (activateIfNoneSelected) {
                            first.expand();
                            first.activate();
                        }
                    }
                    else {
                    }
                }
            }
        }
    }
    Jmx.updateTreeSelectionFromURLAndAutoSelect = updateTreeSelectionFromURLAndAutoSelect;
    function getUniqueTypeNames(children) {
        var typeNameMap = {};
        angular.forEach(children, function (mbean) {
            var typeName = mbean.typeName;
            if (typeName) {
                typeNameMap[typeName] = mbean;
            }
        });
        var typeNames = Object.keys(typeNameMap);
        return typeNames;
    }
    Jmx.getUniqueTypeNames = getUniqueTypeNames;
    function enableTree($scope, $location, workspace, treeElement, children, redraw, onActivateFn) {
        if (redraw === void 0) { redraw = false; }
        if (onActivateFn === void 0) { onActivateFn = null; }
        if (treeElement.length) {
            if (!onActivateFn) {
                onActivateFn = function (node) {
                    var data = node.data;
                    workspace.updateSelectionNode(data);
                    Core.$apply($scope);
                };
            }
            workspace.treeElement = treeElement;
            treeElement.dynatree({
                onActivate: onActivateFn,
                onLazyRead: function (treeNode) {
                    var folder = treeNode.data;
                    var plugin = null;
                    if (folder) {
                        plugin = Jmx.findLazyLoadingFunction(workspace, folder);
                    }
                    if (plugin) {
                        console.log("Lazy loading folder " + folder.title);
                        var oldChildren = folder.childen;
                        plugin(workspace, folder, function () {
                            treeNode.setLazyNodeStatus(DTNodeStatus_Ok);
                            var newChildren = folder.children;
                            if (newChildren !== oldChildren) {
                                treeNode.removeChildren();
                                angular.forEach(newChildren, function (newChild) {
                                    treeNode.addChild(newChild);
                                });
                            }
                        });
                    }
                    else {
                        treeNode.setLazyNodeStatus(DTNodeStatus_Ok);
                    }
                },
                onExpand: function (flag, node) {
                    node.data.expand = flag;
                    if (node.data.isFolder()) {
                        var parent = node.data.children[0].parent;
                        if (parent) {
                            parent.expand = flag;
                        }
                    }
                },
                onClick: function (node, event) {
                    if (event["metaKey"]) {
                        event.preventDefault();
                        var url = $location.absUrl();
                        if (node && node.data) {
                            var key = node.data["key"];
                            if (key) {
                                var hash = $location.search();
                                hash["nid"] = key;
                                var idx = url.indexOf('?');
                                if (idx <= 0) {
                                    url += "?";
                                }
                                else {
                                    url = url.substring(0, idx + 1);
                                }
                                url += $.param(hash);
                            }
                        }
                        window.open(url, '_blank');
                        window.focus();
                        return false;
                    }
                    return true;
                },
                persist: false,
                debugLevel: 0,
                children: children
            });
            if (redraw) {
                workspace.redrawTree();
            }
        }
    }
    Jmx.enableTree = enableTree;
})(Jmx || (Jmx = {}));
var Core;
(function (Core) {
    var log = Logger.get("Core");
    var Workspace = (function () {
        function Workspace(jolokia, jolokiaStatus, jmxTreeLazyLoadRegistry, $location, $compile, $templateCache, localStorage, $rootScope, userDetails) {
            this.jolokia = jolokia;
            this.jolokiaStatus = jolokiaStatus;
            this.jmxTreeLazyLoadRegistry = jmxTreeLazyLoadRegistry;
            this.$location = $location;
            this.$compile = $compile;
            this.$templateCache = $templateCache;
            this.localStorage = localStorage;
            this.$rootScope = $rootScope;
            this.userDetails = userDetails;
            this.operationCounter = 0;
            this.tree = new Core.Folder('MBeans');
            this.mbeanTypesToDomain = {};
            this.mbeanServicesToDomain = {};
            this.attributeColumnDefs = {};
            this.treePostProcessors = [];
            this.topLevelTabs = [];
            this.subLevelTabs = [];
            this.keyToNodeMap = {};
            this.pluginRegisterHandle = null;
            this.pluginUpdateCounter = null;
            this.treeWatchRegisterHandle = null;
            this.treeWatcherCounter = null;
            this.treeElement = null;
            this.mapData = {};
            if (!('autoRefresh' in localStorage)) {
                localStorage['autoRefresh'] = true;
            }
            if (!('updateRate' in localStorage)) {
                localStorage['updateRate'] = 5000;
            }
        }
        Workspace.prototype.createChildWorkspace = function (location) {
            var child = new Workspace(this.jolokia, this.jolokiaStatus, this.jmxTreeLazyLoadRegistry, this.$location, this.$compile, this.$templateCache, this.localStorage, this.$rootScope, this.userDetails);
            angular.forEach(this, function (value, key) { return child[key] = value; });
            child.$location = location;
            return child;
        };
        Workspace.prototype.getLocalStorage = function (key) {
            return this.localStorage[key];
        };
        Workspace.prototype.setLocalStorage = function (key, value) {
            this.localStorage[key] = value;
        };
        Workspace.prototype.loadTree = function () {
            var flags = { ignoreErrors: true, maxDepth: 7 };
            var data = this.jolokia.list(null, onSuccess(null, flags));
            if (data) {
                this.jolokiaStatus.xhr = null;
            }
            this.populateTree({
                value: data
            });
        };
        Workspace.prototype.addTreePostProcessor = function (processor, priority, name) {
            if (priority === void 0) { priority = 0; }
            if (name === void 0) { name = "unnamed"; }
            var postProcessor = {
                processor: processor,
                priority: priority,
                name: name
            };
            this.treePostProcessors.push(postProcessor);
            var tree = this.tree;
            if (tree) {
                processor(tree);
            }
        };
        Workspace.prototype.removeTreePostProcessors = function (name) {
            this.treePostProcessors.remove(function (el) {
                return el.name == name;
            });
        };
        Workspace.prototype.maybeMonitorPlugins = function () {
            if (this.treeContainsDomainAndProperties("hawtio", { type: "Registry" })) {
                if (this.pluginRegisterHandle === null) {
                    this.pluginRegisterHandle = this.jolokia.register(angular.bind(this, this.maybeUpdatePlugins), {
                        type: "read",
                        mbean: "hawtio:type=Registry",
                        attribute: "UpdateCounter"
                    });
                }
            }
            else {
                if (this.pluginRegisterHandle !== null) {
                    this.jolokia.unregister(this.pluginRegisterHandle);
                    this.pluginRegisterHandle = null;
                    this.pluginUpdateCounter = null;
                }
            }
            if (this.treeContainsDomainAndProperties("hawtio", { type: "TreeWatcher" })) {
                if (this.treeWatchRegisterHandle === null) {
                    this.treeWatchRegisterHandle = this.jolokia.register(angular.bind(this, this.maybeReloadTree), {
                        type: "read",
                        mbean: "hawtio:type=TreeWatcher",
                        attribute: "Counter"
                    });
                }
            }
        };
        Workspace.prototype.maybeUpdatePlugins = function (response) {
            if (this.pluginUpdateCounter === null) {
                this.pluginUpdateCounter = response.value;
                return;
            }
            if (this.pluginUpdateCounter !== response.value) {
                if (Core.parseBooleanValue(localStorage['autoRefresh'])) {
                    window.location.reload();
                }
            }
        };
        Workspace.prototype.maybeReloadTree = function (response) {
            var counter = response.value;
            if (this.treeWatcherCounter === null) {
                this.treeWatcherCounter = counter;
                return;
            }
            if (this.treeWatcherCounter !== counter) {
                this.treeWatcherCounter = counter;
                var workspace = this;
                function wrapInValue(response) {
                    var wrapper = {
                        value: response
                    };
                    workspace.populateTree(wrapper);
                }
                this.jolokia.list(null, onSuccess(wrapInValue, { ignoreErrors: true, maxDepth: 2 }));
            }
        };
        Workspace.prototype.folderGetOrElse = function (folder, value) {
            if (folder) {
                try {
                    return folder.getOrElse(value);
                }
                catch (e) {
                    log.warn("Failed to find value " + value + " on folder " + folder);
                }
            }
            return null;
        };
        Workspace.prototype.populateTree = function (response) {
            log.debug("JMX tree has been loaded, data: ", response.value);
            var rootId = 'root';
            var separator = '-';
            this.mbeanTypesToDomain = {};
            this.mbeanServicesToDomain = {};
            this.keyToNodeMap = {};
            var tree = new Core.Folder('MBeans');
            tree.key = rootId;
            var domains = response.value;
            for (var domainName in domains) {
                var domainClass = escapeDots(domainName);
                var domain = domains[domainName];
                for (var mbeanName in domain) {
                    log.debug("JMX tree mbean name: " + mbeanName);
                    var entries = {};
                    var folder = this.folderGetOrElse(tree, domainName);
                    folder.domain = domainName;
                    if (!folder.key) {
                        folder.key = rootId + separator + domainName;
                    }
                    var folderNames = [domainName];
                    folder.folderNames = folderNames;
                    folderNames = folderNames.clone();
                    var items = mbeanName.split(',');
                    var paths = [];
                    var typeName = null;
                    var serviceName = null;
                    items.forEach(function (item) {
                        var pos = item.indexOf('=');
                        var kv = [];
                        if (pos > 0) {
                            kv[0] = item.substr(0, pos);
                            kv[1] = item.substr(pos + 1);
                        }
                        else {
                            kv[0] = item;
                        }
                        var key = kv[0];
                        var value = kv[1] || key;
                        entries[key] = value;
                        var moveToFront = false;
                        var lowerKey = key.toLowerCase();
                        if (lowerKey === "type") {
                            typeName = value;
                            if (folder.map[value]) {
                                moveToFront = true;
                            }
                        }
                        if (lowerKey === "service") {
                            serviceName = value;
                        }
                        if (moveToFront) {
                            paths.splice(0, 0, value);
                        }
                        else {
                            paths.push(value);
                        }
                    });
                    var configureFolder = function (folder, name) {
                        folder.domain = domainName;
                        if (!folder.key) {
                            folder.key = rootId + separator + folderNames.join(separator);
                        }
                        this.keyToNodeMap[folder.key] = folder;
                        folder.folderNames = folderNames.clone();
                        var classes = "";
                        var entries = folder.entries;
                        var entryKeys = Object.keys(entries).filter(function (n) { return n.toLowerCase().indexOf("type") >= 0; });
                        if (entryKeys.length) {
                            angular.forEach(entryKeys, function (entryKey) {
                                var entryValue = entries[entryKey];
                                if (!folder.ancestorHasEntry(entryKey, entryValue)) {
                                    classes += " " + domainClass + separator + entryValue;
                                }
                            });
                        }
                        else {
                            var kindName = folderNames.last();
                            if (kindName === name) {
                                kindName += "-folder";
                            }
                            if (kindName) {
                                classes += " " + domainClass + separator + kindName;
                            }
                        }
                        folder.addClass = escapeTreeCssStyles(classes);
                        return folder;
                    };
                    var lastPath = paths.pop();
                    var ws = this;
                    paths.forEach(function (value) {
                        folder = ws.folderGetOrElse(folder, value);
                        if (folder) {
                            folderNames.push(value);
                            angular.bind(ws, configureFolder, folder, value)();
                        }
                    });
                    var key = rootId + separator + folderNames.join(separator) + separator + lastPath;
                    var objectName = domainName + ":" + mbeanName;
                    if (folder) {
                        folder = this.folderGetOrElse(folder, lastPath);
                        if (folder) {
                            folder.entries = entries;
                            folder.key = key;
                            angular.bind(this, configureFolder, folder, lastPath)();
                            folder.title = Core.trimQuotes(lastPath);
                            folder.objectName = objectName;
                            folder.mbean = domain[mbeanName];
                            folder.typeName = typeName;
                            var addFolderByDomain = function (owner, typeName) {
                                var map = owner[typeName];
                                if (!map) {
                                    map = {};
                                    owner[typeName] = map;
                                }
                                var value = map[domainName];
                                if (!value) {
                                    map[domainName] = folder;
                                }
                                else {
                                    var array = null;
                                    if (angular.isArray(value)) {
                                        array = value;
                                    }
                                    else {
                                        array = [value];
                                        map[domainName] = array;
                                    }
                                    array.push(folder);
                                }
                            };
                            if (serviceName) {
                                angular.bind(this, addFolderByDomain, this.mbeanServicesToDomain, serviceName)();
                            }
                            if (typeName) {
                                angular.bind(this, addFolderByDomain, this.mbeanTypesToDomain, typeName)();
                            }
                        }
                    }
                    else {
                        log.info("No folder found for lastPath: " + lastPath);
                    }
                }
            }
            tree.sortChildren(true);
            this.enableLazyLoading(tree);
            this.tree = tree;
            var processors = this.treePostProcessors.clone();
            processors.sort(function (e1, e2) {
                return e1.priority - e2.priority;
            });
            angular.forEach(processors, function (processor) { return processor.processor(tree); });
            this.maybeMonitorPlugins();
            var rootScope = this.$rootScope;
            if (rootScope) {
                rootScope.$broadcast('jmxTreeUpdated');
            }
        };
        Workspace.prototype.enableLazyLoading = function (folder) {
            var _this = this;
            var children = folder.children;
            if (children && children.length) {
                angular.forEach(children, function (child) {
                    _this.enableLazyLoading(child);
                });
            }
            else {
                var lazyFunction = Jmx.findLazyLoadingFunction(this, folder);
                if (lazyFunction) {
                    folder.isLazy = true;
                }
            }
        };
        Workspace.prototype.hash = function () {
            var hash = this.$location.search();
            var params = Core.hashToString(hash);
            if (params) {
                return "?" + params;
            }
            return "";
        };
        Workspace.prototype.getActiveTab = function () {
            var workspace = this;
            return this.topLevelTabs.find(function (tab) {
                if (!angular.isDefined(tab.isActive)) {
                    return workspace.isLinkActive(tab.href());
                }
                else {
                    return tab.isActive(workspace);
                }
            });
        };
        Workspace.prototype.getStrippedPathName = function () {
            var pathName = Core.trimLeading((this.$location.path() || '/'), "#");
            pathName = Core.trimLeading(pathName, "/");
            return pathName;
        };
        Workspace.prototype.linkContains = function () {
            var words = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                words[_i - 0] = arguments[_i];
            }
            var pathName = this.getStrippedPathName();
            return words.all(function (word) {
                return pathName.has(word);
            });
        };
        Workspace.prototype.isLinkActive = function (href) {
            var pathName = this.getStrippedPathName();
            var link = Core.trimLeading(href, "#");
            link = Core.trimLeading(link, "/");
            var idx = link.indexOf('?');
            if (idx >= 0) {
                link = link.substring(0, idx);
            }
            if (!pathName.length) {
                return link === pathName;
            }
            else {
                return pathName.startsWith(link);
            }
        };
        Workspace.prototype.isLinkPrefixActive = function (href) {
            var pathName = this.getStrippedPathName();
            var link = Core.trimLeading(href, "#");
            link = Core.trimLeading(link, "/");
            var idx = link.indexOf('?');
            if (idx >= 0) {
                link = link.substring(0, idx);
            }
            return pathName.startsWith(link);
        };
        Workspace.prototype.isTopTabActive = function (path) {
            var tab = this.$location.search()['tab'];
            if (angular.isString(tab)) {
                return tab.startsWith(path);
            }
            return this.isLinkActive(path);
        };
        Workspace.prototype.getSelectedMBeanName = function () {
            var selection = this.selection;
            if (selection) {
                return selection.objectName;
            }
            return null;
        };
        Workspace.prototype.validSelection = function (uri) {
            var workspace = this;
            var filter = function (t) {
                var fn = t.href;
                if (fn) {
                    var href = fn();
                    if (href) {
                        if (href.startsWith("#/")) {
                            href = href.substring(2);
                        }
                        return href === uri;
                    }
                }
                return false;
            };
            var tab = this.subLevelTabs.find(filter);
            if (!tab) {
                tab = this.topLevelTabs.find(filter);
            }
            if (tab) {
                var validFn = tab['isValid'];
                return !angular.isDefined(validFn) || validFn(workspace);
            }
            else {
                log.info("Could not find tab for " + uri);
                return false;
            }
        };
        Workspace.prototype.removeAndSelectParentNode = function () {
            var selection = this.selection;
            if (selection) {
                var parent = selection.parent;
                if (parent) {
                    var idx = parent.children.indexOf(selection);
                    if (idx < 0) {
                        idx = parent.children.findIndex(function (n) { return n.key === selection.key; });
                    }
                    if (idx >= 0) {
                        parent.children.splice(idx, 1);
                    }
                    this.updateSelectionNode(parent);
                }
            }
        };
        Workspace.prototype.selectParentNode = function () {
            var selection = this.selection;
            if (selection) {
                var parent = selection.parent;
                if (parent) {
                    this.updateSelectionNode(parent);
                }
            }
        };
        Workspace.prototype.selectionViewConfigKey = function () {
            return this.selectionConfigKey("view/");
        };
        Workspace.prototype.selectionConfigKey = function (prefix) {
            if (prefix === void 0) { prefix = ""; }
            var key = null;
            var selection = this.selection;
            if (selection) {
                key = prefix + selection.domain;
                var typeName = selection.typeName;
                if (!typeName) {
                    typeName = selection.title;
                }
                key += "/" + typeName;
                if (selection.isFolder()) {
                    key += "/folder";
                }
            }
            return key;
        };
        Workspace.prototype.moveIfViewInvalid = function () {
            var workspace = this;
            var uri = Core.trimLeading(this.$location.path(), "/");
            if (this.selection) {
                var key = this.selectionViewConfigKey();
                if (this.validSelection(uri)) {
                    this.setLocalStorage(key, uri);
                    return false;
                }
                else {
                    log.info("the uri '" + uri + "' is not valid for this selection");
                    var defaultPath = this.getLocalStorage(key);
                    if (!defaultPath || !this.validSelection(defaultPath)) {
                        defaultPath = null;
                        angular.forEach(this.subLevelTabs, function (tab) {
                            var fn = tab.isValid;
                            if (!defaultPath && tab.href && angular.isDefined(fn) && fn(workspace)) {
                                defaultPath = tab.href();
                            }
                        });
                    }
                    if (!defaultPath) {
                        defaultPath = "#/jmx/help";
                    }
                    log.info("moving the URL to be " + defaultPath);
                    if (defaultPath.startsWith("#")) {
                        defaultPath = defaultPath.substring(1);
                    }
                    this.$location.path(defaultPath);
                    return true;
                }
            }
            else {
                return false;
            }
        };
        Workspace.prototype.updateSelectionNode = function (node) {
            var originalSelection = this.selection;
            this.selection = node;
            var key = null;
            if (node) {
                key = node['key'];
            }
            var $location = this.$location;
            var q = $location.search();
            if (key) {
                q['nid'] = key;
            }
            $location.search(q);
            if (originalSelection) {
                key = this.selectionViewConfigKey();
                if (key) {
                    var defaultPath = this.getLocalStorage(key);
                    if (defaultPath) {
                        this.$location.path(defaultPath);
                    }
                }
            }
        };
        Workspace.prototype.redrawTree = function () {
            var treeElement = this.treeElement;
            if (treeElement && angular.isDefined(treeElement.dynatree) && angular.isFunction(treeElement.dynatree)) {
                var node = treeElement.dynatree("getTree");
                if (angular.isDefined(node)) {
                    try {
                        node.reload();
                    }
                    catch (e) {
                    }
                }
            }
        };
        Workspace.prototype.expandSelection = function (flag) {
            var treeElement = this.treeElement;
            if (treeElement && angular.isDefined(treeElement.dynatree) && angular.isFunction(treeElement.dynatree)) {
                var node = treeElement.dynatree("getActiveNode");
                if (angular.isDefined(node)) {
                    node.expand(flag);
                }
            }
        };
        Workspace.prototype.matchesProperties = function (entries, properties) {
            if (!entries)
                return false;
            for (var key in properties) {
                var value = properties[key];
                if (!value || entries[key] !== value) {
                    return false;
                }
            }
            return true;
        };
        Workspace.prototype.hasInvokeRightsForName = function (objectName) {
            var methods = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                methods[_i - 1] = arguments[_i];
            }
            var canInvoke = true;
            if (objectName) {
                var mbean = Core.parseMBean(objectName);
                if (mbean) {
                    var mbeanFolder = this.findMBeanWithProperties(mbean.domain, mbean.attributes);
                    if (mbeanFolder) {
                        return this.hasInvokeRights.apply(this, [mbeanFolder].concat(methods));
                    }
                    else {
                        log.debug("Failed to find mbean folder with name " + objectName);
                    }
                }
                else {
                    log.debug("Failed to parse mbean name " + objectName);
                }
            }
            return canInvoke;
        };
        Workspace.prototype.hasInvokeRights = function (selection) {
            var methods = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                methods[_i - 1] = arguments[_i];
            }
            var canInvoke = true;
            if (selection) {
                var selectionFolder = selection;
                var mbean = selectionFolder.mbean;
                if (mbean) {
                    if (angular.isDefined(mbean.canInvoke)) {
                        canInvoke = mbean.canInvoke;
                    }
                    if (canInvoke && methods && methods.length > 0) {
                        var opsByString = mbean['opByString'];
                        var ops = mbean['op'];
                        if (opsByString && ops) {
                            methods.forEach(function (method) {
                                if (!canInvoke) {
                                    return;
                                }
                                var op = null;
                                if (method.endsWith(')')) {
                                    op = opsByString[method];
                                }
                                else {
                                    op = ops[method];
                                }
                                if (!op) {
                                    log.debug("Could not find method:", method, " to check permissions, skipping");
                                    return;
                                }
                                if (angular.isDefined(op.canInvoke)) {
                                    canInvoke = op.canInvoke;
                                }
                            });
                        }
                    }
                }
            }
            return canInvoke;
        };
        Workspace.prototype.treeContainsDomainAndProperties = function (domainName, properties) {
            var _this = this;
            if (properties === void 0) { properties = null; }
            var workspace = this;
            var tree = workspace.tree;
            if (tree) {
                var folder = tree.get(domainName);
                if (folder) {
                    if (properties) {
                        var children = folder.children || [];
                        var checkProperties = function (node) {
                            if (!_this.matchesProperties(node.entries, properties)) {
                                if (node.domain === domainName && node.children && node.children.length > 0) {
                                    return node.children.some(checkProperties);
                                }
                                else {
                                    return false;
                                }
                            }
                            else {
                                return true;
                            }
                        };
                        return children.some(checkProperties);
                    }
                    return true;
                }
                else {
                }
            }
            else {
            }
            return false;
        };
        Workspace.prototype.matches = function (folder, properties, propertiesCount) {
            if (folder) {
                var entries = folder.entries;
                if (properties) {
                    if (!entries)
                        return false;
                    for (var key in properties) {
                        var value = properties[key];
                        if (!value || entries[key] !== value) {
                            return false;
                        }
                    }
                }
                if (propertiesCount) {
                    return entries && Object.keys(entries).length === propertiesCount;
                }
                return true;
            }
            return false;
        };
        Workspace.prototype.hasDomainAndProperties = function (domainName, properties, propertiesCount) {
            if (properties === void 0) { properties = null; }
            if (propertiesCount === void 0) { propertiesCount = null; }
            var node = this.selection;
            if (node) {
                return this.matches(node, properties, propertiesCount) && node.domain === domainName;
            }
            return false;
        };
        Workspace.prototype.findMBeanWithProperties = function (domainName, properties, propertiesCount) {
            if (properties === void 0) { properties = null; }
            if (propertiesCount === void 0) { propertiesCount = null; }
            var tree = this.tree;
            if (tree) {
                return this.findChildMBeanWithProperties(tree.get(domainName), properties, propertiesCount);
            }
            return null;
        };
        Workspace.prototype.findChildMBeanWithProperties = function (folder, properties, propertiesCount) {
            var _this = this;
            if (properties === void 0) { properties = null; }
            if (propertiesCount === void 0) { propertiesCount = null; }
            var workspace = this;
            if (folder) {
                var children = folder.children;
                if (children) {
                    var answer = children.find(function (node) { return _this.matches(node, properties, propertiesCount); });
                    if (answer) {
                        return answer;
                    }
                    return children.map(function (node) { return workspace.findChildMBeanWithProperties(node, properties, propertiesCount); }).find(function (node) { return node; });
                }
            }
            return null;
        };
        Workspace.prototype.selectionHasDomainAndLastFolderName = function (objectName, lastName) {
            var lastNameLower = (lastName || "").toLowerCase();
            function isName(name) {
                return (name || "").toLowerCase() === lastNameLower;
            }
            var node = this.selection;
            if (node) {
                if (objectName === node.domain) {
                    var folders = node.folderNames;
                    if (folders) {
                        var last = folders.last();
                        return (isName(last) || isName(node.title)) && node.isFolder() && !node.objectName;
                    }
                }
            }
            return false;
        };
        Workspace.prototype.selectionHasDomain = function (domainName) {
            var node = this.selection;
            if (node) {
                return domainName === node.domain;
            }
            return false;
        };
        Workspace.prototype.selectionHasDomainAndType = function (objectName, typeName) {
            var node = this.selection;
            if (node) {
                return objectName === node.domain && typeName === node.typeName;
            }
            return false;
        };
        Workspace.prototype.hasMBeans = function () {
            var answer = false;
            var tree = this.tree;
            if (tree) {
                var children = tree.children;
                if (angular.isArray(children) && children.length > 0) {
                    answer = true;
                }
            }
            return answer;
        };
        Workspace.prototype.hasFabricMBean = function () {
            return this.hasDomainAndProperties('io.fabric8', { type: 'Fabric' });
        };
        Workspace.prototype.isFabricFolder = function () {
            return this.hasDomainAndProperties('io.fabric8');
        };
        Workspace.prototype.isCamelContext = function () {
            return this.hasDomainAndProperties('org.apache.camel', { type: 'context' });
        };
        Workspace.prototype.isCamelFolder = function () {
            return this.hasDomainAndProperties('org.apache.camel');
        };
        Workspace.prototype.isEndpointsFolder = function () {
            return this.selectionHasDomainAndLastFolderName('org.apache.camel', 'endpoints');
        };
        Workspace.prototype.isEndpoint = function () {
            return this.hasDomainAndProperties('org.apache.camel', { type: 'endpoints' });
        };
        Workspace.prototype.isRoutesFolder = function () {
            return this.selectionHasDomainAndLastFolderName('org.apache.camel', 'routes');
        };
        Workspace.prototype.isRoute = function () {
            return this.hasDomainAndProperties('org.apache.camel', { type: 'routes' });
        };
        Workspace.prototype.isOsgiFolder = function () {
            return this.hasDomainAndProperties('osgi.core');
        };
        Workspace.prototype.isKarafFolder = function () {
            return this.hasDomainAndProperties('org.apache.karaf');
        };
        Workspace.prototype.isOsgiCompendiumFolder = function () {
            return this.hasDomainAndProperties('osgi.compendium');
        };
        return Workspace;
    })();
    Core.Workspace = Workspace;
})(Core || (Core = {}));
var Workspace = (function (_super) {
    __extends(Workspace, _super);
    function Workspace() {
        _super.apply(this, arguments);
    }
    return Workspace;
})(Core.Workspace);
;
var UI;
(function (UI) {
    UI.colors = ["#5484ED", "#A4BDFC", "#46D6DB", "#7AE7BF", "#51B749", "#FBD75B", "#FFB878", "#FF887C", "#DC2127", "#DBADFF", "#E1E1E1"];
})(UI || (UI = {}));
var Core;
(function (Core) {
    Core.log = Logger.get("Core");
    Core.lazyLoaders = {};
})(Core || (Core = {}));
var numberTypeNames = {
    'byte': true,
    'short': true,
    'int': true,
    'long': true,
    'float': true,
    'double': true,
    'java.lang.byte': true,
    'java.lang.short': true,
    'java.lang.integer': true,
    'java.lang.long': true,
    'java.lang.float': true,
    'java.lang.double': true
};
function lineCount(value) {
    var rows = 0;
    if (value) {
        rows = 1;
        value.toString().each(/\n/, function () { return rows++; });
    }
    return rows;
}
function safeNull(value) {
    if (typeof value === 'boolean') {
        return value;
    }
    else if (typeof value === 'number') {
        return value;
    }
    if (value) {
        return value;
    }
    else {
        return "";
    }
}
function safeNullAsString(value, type) {
    if (typeof value === 'boolean') {
        return "" + value;
    }
    else if (typeof value === 'number') {
        return "" + value;
    }
    else if (typeof value === 'string') {
        return "" + value;
    }
    else if (type === 'javax.management.openmbean.CompositeData' || type === '[Ljavax.management.openmbean.CompositeData;' || type === 'java.util.Map') {
        var data = angular.toJson(value, true);
        return data;
    }
    else if (type === 'javax.management.ObjectName') {
        return "" + (value == null ? "" : value.canonicalName);
    }
    else if (type === 'javax.management.openmbean.TabularData') {
        var arr = [];
        for (var key in value) {
            var val = value[key];
            var line = "" + key + "=" + val;
            arr.push(line);
        }
        arr = arr.sortBy(function (row) { return row.toString(); });
        return arr.join("\n");
    }
    else if (angular.isArray(value)) {
        return value.join("\n");
    }
    else if (value) {
        return "" + value;
    }
    else {
        return "";
    }
}
function toSearchArgumentArray(value) {
    if (value) {
        if (angular.isArray(value))
            return value;
        if (angular.isString(value))
            return value.split(',');
    }
    return [];
}
function folderMatchesPatterns(node, patterns) {
    if (node) {
        var folderNames = node.folderNames;
        if (folderNames) {
            return patterns.any(function (ignorePaths) {
                for (var i = 0; i < ignorePaths.length; i++) {
                    var folderName = folderNames[i];
                    var ignorePath = ignorePaths[i];
                    if (!folderName)
                        return false;
                    var idx = ignorePath.indexOf(folderName);
                    if (idx < 0) {
                        return false;
                    }
                }
                return true;
            });
        }
    }
    return false;
}
function scopeStoreJolokiaHandle($scope, jolokia, jolokiaHandle) {
    if (jolokiaHandle) {
        $scope.$on('$destroy', function () {
            closeHandle($scope, jolokia);
        });
        $scope.jolokiaHandle = jolokiaHandle;
    }
}
function closeHandle($scope, jolokia) {
    var jolokiaHandle = $scope.jolokiaHandle;
    if (jolokiaHandle) {
        jolokia.unregister(jolokiaHandle);
        $scope.jolokiaHandle = null;
    }
}
function onSuccess(fn, options) {
    if (options === void 0) { options = {}; }
    options['mimeType'] = 'application/json';
    if (angular.isDefined(fn)) {
        options['success'] = fn;
    }
    if (!options['method']) {
        options['method'] = "POST";
    }
    options['canonicalNaming'] = false;
    options['canonicalProperties'] = false;
    if (!options['error']) {
        options['error'] = function (response) {
            Core.defaultJolokiaErrorHandler(response, options);
        };
    }
    return options;
}
function supportsLocalStorage() {
    try {
        return 'localStorage' in window && window['localStorage'] !== null;
    }
    catch (e) {
        return false;
    }
}
function isNumberTypeName(typeName) {
    if (typeName) {
        var text = typeName.toString().toLowerCase();
        var flag = numberTypeNames[text];
        return flag;
    }
    return false;
}
function escapeMBeanPath(mbean) {
    return mbean.replace(/\//g, '!/').replace(':', '/');
}
function escapeDots(text) {
    return text.replace(/\./g, '-');
}
function escapeTreeCssStyles(text) {
    return escapeDots(text).replace(/span/g, 'sp-an');
}
function showLogPanel() {
    var log = $("#log-panel");
    var body = $('body');
    localStorage['showLog'] = 'true';
    log.css({ 'bottom': '50%' });
    body.css({
        'overflow-y': 'hidden'
    });
}
function logLevelClass(level) {
    if (level) {
        var first = level[0];
        if (first === 'w' || first === "W") {
            return "warning";
        }
        else if (first === 'e' || first === "E") {
            return "error";
        }
        else if (first === 'i' || first === "I") {
            return "info";
        }
        else if (first === 'd' || first === "D") {
            return "";
        }
    }
    return "";
}
var Core;
(function (Core) {
    function toPath(hashUrl) {
        if (Core.isBlank(hashUrl)) {
            return hashUrl;
        }
        if (hashUrl.startsWith("#")) {
            return hashUrl.substring(1);
        }
        else {
            return hashUrl;
        }
    }
    Core.toPath = toPath;
    function parseMBean(mbean) {
        var answer = {};
        var parts = mbean.split(":");
        if (parts.length > 1) {
            answer['domain'] = parts.first();
            parts = parts.exclude(parts.first());
            parts = parts.join(":");
            answer['attributes'] = {};
            var nameValues = parts.split(",");
            nameValues.forEach(function (str) {
                var nameValue = str.split('=');
                var name = nameValue.first().trim();
                nameValue = nameValue.exclude(nameValue.first());
                answer['attributes'][name] = nameValue.join('=').trim();
            });
        }
        return answer;
    }
    Core.parseMBean = parseMBean;
    function executePostLoginTasks() {
        Core.log.debug("Executing post login tasks");
        Core.postLoginTasks.execute();
    }
    Core.executePostLoginTasks = executePostLoginTasks;
    function executePreLogoutTasks(onComplete) {
        Core.log.debug("Executing pre logout tasks");
        Core.preLogoutTasks.onComplete(onComplete);
        Core.preLogoutTasks.execute();
    }
    Core.executePreLogoutTasks = executePreLogoutTasks;
    function executePostLogoutTasks(onComplete) {
        Core.log.debug("Executing post logout tasks");
        Core.postLogoutTasks.onComplete(onComplete);
        Core.postLogoutTasks.execute();
    }
    Core.executePostLogoutTasks = executePostLogoutTasks;
    function logout(jolokiaUrl, userDetails, localStorage, $scope, successCB, errorCB) {
        if (successCB === void 0) { successCB = null; }
        if (errorCB === void 0) { errorCB = null; }
        if (jolokiaUrl) {
            var url = "auth/logout/";
            Core.executePreLogoutTasks(function () {
                $.ajax(url, {
                    type: "POST",
                    success: function () {
                        if (localStorage['jvmConnect'] && localStorage['jvmConnect'] != "undefined") {
                            var jvmConnect = angular.fromJson(localStorage['jvmConnect']);
                            _.each(jvmConnect, function (value) {
                                delete value['userName'];
                                delete value['password'];
                            });
                            localStorage.setItem('jvmConnect', angular.toJson(jvmConnect));
                        }
                        localStorage.removeItem('activemqUserName');
                        localStorage.removeItem('activemqPassword');
                        Core.executePostLogoutTasks(function () {
                            Core.log.debug("Executing logout callback after successfully executed postLogoutTasks");
                            userDetails.username = null;
                            userDetails.password = null;
                            userDetails.loginDetails = null;
                            userDetails.rememberMe = false;
                            userDetails.remoteJolokiaUserDetails = null;
                            delete localStorage['userDetails'];
                            if (successCB && angular.isFunction(successCB)) {
                                successCB();
                            }
                            Core.$apply($scope);
                        });
                    },
                    error: function (xhr, textStatus, error) {
                        if (localStorage['jvmConnect'] && localStorage['jvmConnect'] != "undefined") {
                            var jvmConnect = angular.fromJson(localStorage['jvmConnect']);
                            _.each(jvmConnect, function (value) {
                                delete value['userName'];
                                delete value['password'];
                            });
                            localStorage.setItem('jvmConnect', angular.toJson(jvmConnect));
                        }
                        localStorage.removeItem('activemqUserName');
                        localStorage.removeItem('activemqPassword');
                        Core.executePostLogoutTasks(function () {
                            userDetails.username = null;
                            userDetails.password = null;
                            userDetails.loginDetails = null;
                            userDetails.rememberMe = false;
                            userDetails.remoteJolokiaUserDetails = null;
                            delete localStorage['userDetails'];
                            switch (xhr.status) {
                                case 401:
                                    Core.log.debug('Failed to log out, ', error);
                                    break;
                                case 403:
                                    Core.log.debug('Failed to log out, ', error);
                                    break;
                                case 0:
                                    break;
                                default:
                                    Core.log.debug('Failed to log out, ', error);
                                    break;
                            }
                            if (errorCB && angular.isFunction(errorCB)) {
                                errorCB();
                            }
                            Core.$apply($scope);
                        });
                    }
                });
            });
        }
    }
    Core.logout = logout;
    function createHref($location, href, removeParams) {
        if (removeParams === void 0) { removeParams = null; }
        var hashMap = angular.copy($location.search());
        if (removeParams) {
            angular.forEach(removeParams, function (param) { return delete hashMap[param]; });
        }
        var hash = Core.hashToString(hashMap);
        if (hash) {
            var prefix = (href.indexOf("?") >= 0) ? "&" : "?";
            href += prefix + hash;
        }
        return href;
    }
    Core.createHref = createHref;
    function hashToString(hash) {
        var keyValuePairs = [];
        angular.forEach(hash, function (value, key) {
            keyValuePairs.push(key + "=" + encodeURIComponent(value));
        });
        var params = keyValuePairs.join("&");
        return params;
    }
    Core.hashToString = hashToString;
    function stringToHash(hashAsString) {
        var entries = {};
        if (hashAsString) {
            var text = decodeURI(hashAsString);
            var items = text.split('&');
            angular.forEach(items, function (item) {
                var kv = item.split('=');
                var key = kv[0];
                var value = kv[1] || key;
                entries[key] = value;
            });
        }
        return entries;
    }
    Core.stringToHash = stringToHash;
    function registerForChanges(jolokia, $scope, arguments, callback, options) {
        var decorated = {
            responseJson: '',
            success: function (response) {
                var json = angular.toJson(response.value);
                if (decorated.responseJson !== json) {
                    decorated.responseJson = json;
                    callback(response);
                }
            }
        };
        angular.extend(decorated, options);
        return Core.register(jolokia, $scope, arguments, onSuccess(undefined, decorated));
    }
    Core.registerForChanges = registerForChanges;
    var responseHistory = null;
    function getOrInitObjectFromLocalStorage(key) {
        var answer = undefined;
        if (!(key in localStorage)) {
            localStorage[key] = angular.toJson({});
        }
        return angular.fromJson(localStorage[key]);
    }
    Core.getOrInitObjectFromLocalStorage = getOrInitObjectFromLocalStorage;
    function argumentsToString(arguments) {
        return StringHelpers.toString(arguments);
    }
    function keyForArgument(argument) {
        if (!('type' in argument)) {
            return null;
        }
        var answer = argument['type'];
        switch (answer.toLowerCase()) {
            case 'exec':
                answer += ':' + argument['mbean'] + ':' + argument['operation'];
                var argString = argumentsToString(argument['arguments']);
                if (!Core.isBlank(argString)) {
                    answer += ':' + argString;
                }
                break;
            case 'read':
                answer += ':' + argument['mbean'] + ':' + argument['attribute'];
                break;
            default:
                return null;
        }
        return answer;
    }
    function createResponseKey(arguments) {
        var answer = '';
        if (angular.isArray(arguments)) {
            answer = arguments.map(function (arg) {
                return keyForArgument(arg);
            }).join(':');
        }
        else {
            answer = keyForArgument(arguments);
        }
        return answer;
    }
    function getResponseHistory() {
        if (responseHistory === null) {
            responseHistory = {};
            Core.log.debug("Created response history", responseHistory);
        }
        return responseHistory;
    }
    Core.getResponseHistory = getResponseHistory;
    Core.MAX_RESPONSE_CACHE_SIZE = 20;
    function getOldestKey(responseHistory) {
        var oldest = null;
        var oldestKey = null;
        angular.forEach(responseHistory, function (value, key) {
            if (!value || !value.timestamp) {
                oldest = 0;
                oldestKey = key;
            }
            else if (oldest === null || value.timestamp < oldest) {
                oldest = value.timestamp;
                oldestKey = key;
            }
        });
        return oldestKey;
    }
    function addResponse(arguments, value) {
        var responseHistory = getResponseHistory();
        var key = createResponseKey(arguments);
        if (key === null) {
            Core.log.debug("key for arguments is null, not caching: ", StringHelpers.toString(arguments));
            return;
        }
        var keys = Object.extended(responseHistory).keys();
        if (keys.length >= Core.MAX_RESPONSE_CACHE_SIZE) {
            Core.log.debug("Cache limit (", Core.MAX_RESPONSE_CACHE_SIZE, ") met or  exceeded (", keys.length, "), trimming oldest response");
            var oldestKey = getOldestKey(responseHistory);
            if (oldestKey !== null) {
                Core.log.debug("Deleting key: ", oldestKey);
                delete responseHistory[oldestKey];
            }
            else {
                Core.log.debug("Got null key, could be a cache problem, wiping cache");
                keys.forEach(function (key) {
                    Core.log.debug("Deleting key: ", key);
                    delete responseHistory[key];
                });
            }
        }
        responseHistory[key] = value;
    }
    function getResponse(jolokia, arguments, callback) {
        var responseHistory = getResponseHistory();
        var key = createResponseKey(arguments);
        if (key === null) {
            jolokia.request(arguments, callback);
            return;
        }
        if (key in responseHistory && 'success' in callback) {
            var value = responseHistory[key];
            setTimeout(function () {
                callback['success'](value);
            }, 10);
        }
        else {
            Core.log.debug("Unable to find existing response for key: ", key);
            jolokia.request(arguments, callback);
        }
    }
    function register(jolokia, scope, arguments, callback) {
        if (!angular.isDefined(scope.$jhandle) || !angular.isArray(scope.$jhandle)) {
            scope.$jhandle = [];
        }
        else {
        }
        if (angular.isDefined(scope.$on)) {
            scope.$on('$destroy', function (event) {
                unregister(jolokia, scope);
            });
        }
        var handle = null;
        if ('success' in callback) {
            var cb = callback.success;
            var args = arguments;
            callback.success = function (response) {
                addResponse(args, response);
                cb(response);
            };
        }
        if (angular.isArray(arguments)) {
            if (arguments.length >= 1) {
                var args = [callback];
                angular.forEach(arguments, function (value) { return args.push(value); });
                var registerFn = jolokia.register;
                handle = registerFn.apply(jolokia, args);
                scope.$jhandle.push(handle);
                getResponse(jolokia, arguments, callback);
            }
        }
        else {
            handle = jolokia.register(callback, arguments);
            scope.$jhandle.push(handle);
            getResponse(jolokia, arguments, callback);
        }
        return function () {
            if (handle !== null) {
                scope.$jhandle.remove(handle);
                jolokia.unregister(handle);
            }
        };
    }
    Core.register = register;
    function unregister(jolokia, scope) {
        if (angular.isDefined(scope.$jhandle)) {
            scope.$jhandle.forEach(function (handle) {
                jolokia.unregister(handle);
            });
            delete scope.$jhandle;
        }
    }
    Core.unregister = unregister;
    function defaultJolokiaErrorHandler(response, options) {
        if (options === void 0) { options = {}; }
        var stacktrace = response.stacktrace;
        if (stacktrace) {
            var silent = options['silent'];
            if (!silent) {
                var operation = Core.pathGet(response, ['request', 'operation']) || "unknown";
                if (stacktrace.indexOf("javax.management.InstanceNotFoundException") >= 0 || stacktrace.indexOf("javax.management.AttributeNotFoundException") >= 0 || stacktrace.indexOf("java.lang.IllegalArgumentException: No operation") >= 0) {
                    Core.log.debug("Operation ", operation, " failed due to: ", response['error']);
                }
                else {
                    Core.log.warn("Operation ", operation, " failed due to: ", response['error']);
                }
            }
            else {
                Core.log.debug("Operation ", operation, " failed due to: ", response['error']);
            }
        }
    }
    Core.defaultJolokiaErrorHandler = defaultJolokiaErrorHandler;
    function logJolokiaStackTrace(response) {
        var stacktrace = response.stacktrace;
        if (stacktrace) {
            var operation = Core.pathGet(response, ['request', 'operation']) || "unknown";
            Core.log.info("Operation ", operation, " failed due to: ", response['error']);
        }
    }
    Core.logJolokiaStackTrace = logJolokiaStackTrace;
    function xmlNodeToString(xmlNode) {
        try {
            return (new XMLSerializer()).serializeToString(xmlNode);
        }
        catch (e) {
            try {
                return xmlNode.xml;
            }
            catch (e) {
                console.log('WARNING: XMLSerializer not supported');
            }
        }
        return false;
    }
    Core.xmlNodeToString = xmlNodeToString;
    function isTextNode(node) {
        return node && node.nodeType === 3;
    }
    Core.isTextNode = isTextNode;
    function fileExtension(name, defaultValue) {
        if (defaultValue === void 0) { defaultValue = ""; }
        var extension = defaultValue;
        if (name) {
            var idx = name.lastIndexOf(".");
            if (idx > 0) {
                extension = name.substring(idx + 1, name.length).toLowerCase();
            }
        }
        return extension;
    }
    Core.fileExtension = fileExtension;
    function getUUID() {
        var d = new Date();
        var ms = (d.getTime() * 1000) + d.getUTCMilliseconds();
        var random = Math.floor((1 + Math.random()) * 0x10000);
        return ms.toString(16) + random.toString(16);
    }
    Core.getUUID = getUUID;
    var _versionRegex = /[^\d]*(\d+)\.(\d+)(\.(\d+))?.*/;
    function parseVersionNumbers(text) {
        if (text) {
            var m = text.match(_versionRegex);
            if (m && m.length > 4) {
                var m1 = m[1];
                var m2 = m[2];
                var m4 = m[4];
                if (angular.isDefined(m4)) {
                    return [parseInt(m1), parseInt(m2), parseInt(m4)];
                }
                else if (angular.isDefined(m2)) {
                    return [parseInt(m1), parseInt(m2)];
                }
                else if (angular.isDefined(m1)) {
                    return [parseInt(m1)];
                }
            }
        }
        return null;
    }
    Core.parseVersionNumbers = parseVersionNumbers;
    function versionToSortableString(version, maxDigitsBetweenDots) {
        if (maxDigitsBetweenDots === void 0) { maxDigitsBetweenDots = 4; }
        return (version || "").split(".").map(function (x) {
            var length = x.length;
            return (length >= maxDigitsBetweenDots) ? x : x.padLeft(' ', maxDigitsBetweenDots - length);
        }).join(".");
    }
    Core.versionToSortableString = versionToSortableString;
    function time(message, fn) {
        var start = new Date().getTime();
        var answer = fn();
        var elapsed = new Date().getTime() - start;
        console.log(message + " " + elapsed);
        return answer;
    }
    Core.time = time;
    function compareVersionNumberArrays(v1, v2) {
        if (v1 && !v2) {
            return 1;
        }
        if (!v1 && v2) {
            return -1;
        }
        if (v1 === v2) {
            return 0;
        }
        for (var i = 0; i < v1.length; i++) {
            var n1 = v1[i];
            if (i >= v2.length) {
                return 1;
            }
            var n2 = v2[i];
            if (!angular.isDefined(n1)) {
                return -1;
            }
            if (!angular.isDefined(n2)) {
                return 1;
            }
            if (n1 > n2) {
                return 1;
            }
            else if (n1 < n2) {
                return -1;
            }
        }
        return 0;
    }
    Core.compareVersionNumberArrays = compareVersionNumberArrays;
    function valueToHtml(value) {
        if (angular.isArray(value)) {
            var size = value.length;
            if (!size) {
                return "";
            }
            else if (size === 1) {
                return valueToHtml(value[0]);
            }
            else {
                var buffer = "<ul>";
                angular.forEach(value, function (childValue) {
                    buffer += "<li>" + valueToHtml(childValue) + "</li>";
                });
                return buffer + "</ul>";
            }
        }
        else if (angular.isObject(value)) {
            var buffer = "<table>";
            angular.forEach(value, function (childValue, key) {
                buffer += "<tr><td>" + key + "</td><td>" + valueToHtml(childValue) + "</td></tr>";
            });
            return buffer + "</table>";
        }
        else if (angular.isString(value)) {
            var uriPrefixes = ["http://", "https://", "file://", "mailto:"];
            var answer = value;
            angular.forEach(uriPrefixes, function (prefix) {
                if (answer.startsWith(prefix)) {
                    answer = "<a href='" + value + "'>" + value + "</a>";
                }
            });
            return answer;
        }
        return value;
    }
    Core.valueToHtml = valueToHtml;
    function tryParseJson(text) {
        text = text.trim();
        if ((text.startsWith("[") && text.endsWith("]")) || (text.startsWith("{") && text.endsWith("}"))) {
            try {
                return JSON.parse(text);
            }
            catch (e) {
            }
        }
        return null;
    }
    Core.tryParseJson = tryParseJson;
    function maybePlural(count, word) {
        var pluralWord = (count === 1) ? word : word.pluralize();
        return "" + count + " " + pluralWord;
    }
    Core.maybePlural = maybePlural;
    function objectNameProperties(objectName) {
        var entries = {};
        if (objectName) {
            var idx = objectName.indexOf(":");
            if (idx > 0) {
                var path = objectName.substring(idx + 1);
                var items = path.split(',');
                angular.forEach(items, function (item) {
                    var kv = item.split('=');
                    var key = kv[0];
                    var value = kv[1] || key;
                    entries[key] = value;
                });
            }
        }
        return entries;
    }
    Core.objectNameProperties = objectNameProperties;
    function setPageTitle($document, title) {
        $document.attr('title', title.getTitleWithSeparator(' '));
    }
    Core.setPageTitle = setPageTitle;
    function setPageTitleWithTab($document, title, tab) {
        $document.attr('title', title.getTitleWithSeparator(' ') + " " + tab);
    }
    Core.setPageTitleWithTab = setPageTitleWithTab;
    function getMBeanTypeFolder(workspace, domain, typeName) {
        if (workspace) {
            var mbeanTypesToDomain = workspace.mbeanTypesToDomain || {};
            var types = mbeanTypesToDomain[typeName] || {};
            var answer = types[domain];
            if (angular.isArray(answer) && answer.length) {
                return answer[0];
            }
            return answer;
        }
        return null;
    }
    Core.getMBeanTypeFolder = getMBeanTypeFolder;
    function getMBeanTypeObjectName(workspace, domain, typeName) {
        var folder = Core.getMBeanTypeFolder(workspace, domain, typeName);
        return Core.pathGet(folder, ["objectName"]);
    }
    Core.getMBeanTypeObjectName = getMBeanTypeObjectName;
    function toSafeDomID(text) {
        return text ? text.replace(/(\/|\.)/g, "_") : text;
    }
    Core.toSafeDomID = toSafeDomID;
    function forEachLeafFolder(folders, fn) {
        angular.forEach(folders, function (folder) {
            var children = folder["children"];
            if (angular.isArray(children) && children.length > 0) {
                forEachLeafFolder(children, fn);
            }
            else {
                fn(folder);
            }
        });
    }
    Core.forEachLeafFolder = forEachLeafFolder;
    function extractHashURL(url) {
        var parts = url.split('#');
        if (parts.length === 0) {
            return url;
        }
        var answer = parts[1];
        if (parts.length > 1) {
            var remaining = parts.last(parts.length - 2);
            remaining.forEach(function (part) {
                answer = answer + "#" + part;
            });
        }
        return answer;
    }
    Core.extractHashURL = extractHashURL;
    function authHeaderValue(userDetails) {
        return getBasicAuthHeader(userDetails.username, userDetails.password);
    }
    Core.authHeaderValue = authHeaderValue;
    function getBasicAuthHeader(username, password) {
        var authInfo = username + ":" + password;
        authInfo = authInfo.encodeBase64();
        return "Basic " + authInfo;
    }
    Core.getBasicAuthHeader = getBasicAuthHeader;
    var httpRegex = new RegExp('^(https?):\/\/(([^:/?#]*)(?::([0-9]+))?)');
    function parseUrl(url) {
        if (Core.isBlank(url)) {
            return null;
        }
        var matches = url.match(httpRegex);
        if (matches === null) {
            return null;
        }
        var scheme = matches[1];
        var host = matches[3];
        var port = matches[4];
        var parts = null;
        if (!Core.isBlank(port)) {
            parts = url.split(port);
        }
        else {
            parts = url.split(host);
        }
        var portNum = Core.parseIntValue(port);
        var path = parts[1];
        if (path && path.startsWith('/')) {
            path = path.slice(1, path.length);
        }
        return {
            scheme: scheme,
            host: host,
            port: portNum,
            path: path
        };
    }
    Core.parseUrl = parseUrl;
    function getDocHeight() {
        var D = document;
        return Math.max(Math.max(D.body.scrollHeight, D.documentElement.scrollHeight), Math.max(D.body.offsetHeight, D.documentElement.offsetHeight), Math.max(D.body.clientHeight, D.documentElement.clientHeight));
    }
    Core.getDocHeight = getDocHeight;
    function useProxyIfExternal(connectUrl) {
        if (Core.isChromeApp()) {
            return connectUrl;
        }
        var host = window.location.host;
        if (!connectUrl.startsWith("http://" + host + "/") && !connectUrl.startsWith("https://" + host + "/")) {
            var idx = connectUrl.indexOf("://");
            if (idx > 0) {
                connectUrl = connectUrl.substring(idx + 3);
            }
            connectUrl = connectUrl.replace(":", "/");
            connectUrl = Core.trimLeading(connectUrl, "/");
            connectUrl = Core.trimTrailing(connectUrl, "/");
            connectUrl = Core.url("/proxy/" + connectUrl);
        }
        return connectUrl;
    }
    Core.useProxyIfExternal = useProxyIfExternal;
    function checkInjectorLoaded() {
        if (!Core.injector) {
            Core.injector = angular.element(document.documentElement).injector();
        }
    }
    Core.checkInjectorLoaded = checkInjectorLoaded;
    function getRecentConnections(localStorage) {
        if (Core.isBlank(localStorage['recentConnections'])) {
            Core.clearConnections();
        }
        return angular.fromJson(localStorage['recentConnections']);
    }
    Core.getRecentConnections = getRecentConnections;
    function addRecentConnection(localStorage, name) {
        var recent = getRecentConnections(localStorage);
        recent = recent.add(name).unique().first(5);
        localStorage['recentConnections'] = angular.toJson(recent);
    }
    Core.addRecentConnection = addRecentConnection;
    function removeRecentConnection(localStorage, name) {
        var recent = getRecentConnections(localStorage);
        recent = recent.exclude(function (n) {
            return n === name;
        });
        localStorage['recentConnections'] = angular.toJson(recent);
    }
    Core.removeRecentConnection = removeRecentConnection;
    function clearConnections() {
        localStorage['recentConnections'] = '[]';
    }
    Core.clearConnections = clearConnections;
    function saveConnection(options) {
        var connectionMap = Core.loadConnectionMap();
        var clone = Object.clone(options);
        delete clone.userName;
        delete clone.password;
        connectionMap[options.name] = clone;
        Core.saveConnectionMap(connectionMap);
    }
    Core.saveConnection = saveConnection;
    function connectToServer(localStorage, options) {
        Core.log.debug("Connecting with options: ", StringHelpers.toString(options));
        addRecentConnection(localStorage, options.name);
        if (!('userName' in options)) {
            var userDetails = Core.injector.get('userDetails');
            options.userName = userDetails.username;
            options.password = userDetails.password;
        }
        saveConnection(options);
        var $window = Core.injector.get('$window');
        var url = (options.view || '#/welcome') + '?con=' + options.name;
        url = url.replace(/\?/g, "&");
        url = url.replace(/&/, "?");
        var newWindow = $window.open(url);
        newWindow['con'] = options.name;
        $window['passUserDetails'] = {
            username: options.userName,
            password: options.password,
            loginDetails: {}
        };
        putKeycloakToken(newWindow);
    }
    Core.connectToServer = connectToServer;
    function putKeycloakToken(newWindow) {
        var keycloakContext = Core.injector.get('keycloakContext');
        if (keycloakContext.enabled) {
            var tokenInfo = {
                token: keycloakContext.keycloak.token,
                refreshToken: keycloakContext.keycloak.refreshToken
            };
            newWindow['keycloakToken'] = tokenInfo;
        }
    }
    function extractTargetUrl($location, scheme, port) {
        if (angular.isUndefined(scheme)) {
            scheme = $location.scheme();
        }
        var host = $location.host();
        var qUrl = $location.absUrl();
        var idx = qUrl.indexOf("url=");
        if (idx > 0) {
            qUrl = qUrl.substr(idx + 4);
            var value = decodeURIComponent(qUrl);
            if (value) {
                idx = value.indexOf("/proxy/");
                if (idx > 0) {
                    value = value.substr(idx + 7);
                    idx = value.indexOf("://");
                    if (idx > 0) {
                        value = value.substr(idx + 3);
                    }
                    var data = value.split("/");
                    if (data.length >= 1) {
                        host = data[0];
                    }
                    if (angular.isUndefined(port) && data.length >= 2) {
                        var qPort = Core.parseIntValue(data[1], "port number");
                        if (qPort) {
                            port = qPort;
                        }
                    }
                }
            }
        }
        if (angular.isUndefined(port)) {
            port = $location.port();
        }
        var url = scheme + "://" + host;
        if (port != 80) {
            url += ":" + port;
        }
        return url;
    }
    Core.extractTargetUrl = extractTargetUrl;
    function isProxyUrl($location) {
        var url = $location.url();
        return url.indexOf('/hawtio/proxy/') > 0;
    }
    Core.isProxyUrl = isProxyUrl;
    function doNothing(value) {
        return value;
    }
    Core.doNothing = doNothing;
    Core.bindModelToSearchParam = ControllerHelpers.bindModelToSearchParam;
    Core.reloadWhenParametersChange = ControllerHelpers.reloadWhenParametersChange;
    function createJolokia(url, username, password) {
        var jolokiaParams = {
            url: url,
            username: username,
            password: password,
            canonicalNaming: false,
            ignoreErrors: true,
            mimeType: 'application/json'
        };
        return new Jolokia(jolokiaParams);
    }
    Core.createJolokia = createJolokia;
    function throttled(fn, millis) {
        var nextInvokeTime = 0;
        var lastAnswer = null;
        return function () {
            var now = Date.now();
            if (nextInvokeTime < now) {
                nextInvokeTime = now + millis;
                lastAnswer = fn();
            }
            else {
            }
            return lastAnswer;
        };
    }
    Core.throttled = throttled;
    function parseJsonText(text, message) {
        if (message === void 0) { message = "JSON"; }
        var answer = null;
        try {
            answer = angular.fromJson(text);
        }
        catch (e) {
            Core.log.info("Failed to parse " + message + " from: " + text + ". " + e);
        }
        return answer;
    }
    Core.parseJsonText = parseJsonText;
    function humanizeValueHtml(value) {
        var formattedValue = "";
        if (value === true) {
            formattedValue = '<i class="icon-check"></i>';
        }
        else if (value === false) {
            formattedValue = '<i class="icon-check-empty"></i>';
        }
        else {
            formattedValue = Core.humanizeValue(value);
        }
        return formattedValue;
    }
    Core.humanizeValueHtml = humanizeValueHtml;
    function getQueryParameterValue(url, parameterName) {
        var parts;
        var query = (url || '').split('?');
        if (query && query.length > 0) {
            parts = query[1];
        }
        else {
            parts = '';
        }
        var vars = parts.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            if (decodeURIComponent(pair[0]) == parameterName) {
                return decodeURIComponent(pair[1]);
            }
        }
        return null;
    }
    Core.getQueryParameterValue = getQueryParameterValue;
    function createRemoteWorkspace(remoteJolokia, $location, localStorage, $rootScope, $compile, $templateCache, userDetails) {
        if ($rootScope === void 0) { $rootScope = null; }
        if ($compile === void 0) { $compile = null; }
        if ($templateCache === void 0) { $templateCache = null; }
        if (userDetails === void 0) { userDetails = null; }
        var jolokiaStatus = {
            xhr: null
        };
        var jmxTreeLazyLoadRegistry = Core.lazyLoaders;
        var profileWorkspace = new Core.Workspace(remoteJolokia, jolokiaStatus, jmxTreeLazyLoadRegistry, $location, $compile, $templateCache, localStorage, $rootScope, userDetails);
        Core.log.info("Loading the profile using jolokia: " + remoteJolokia);
        profileWorkspace.loadTree();
        return profileWorkspace;
    }
    Core.createRemoteWorkspace = createRemoteWorkspace;
    function humanizeMilliseconds(value) {
        if (!angular.isNumber(value)) {
            return "XXX";
        }
        var seconds = value / 1000;
        var years = Math.floor(seconds / 31536000);
        if (years) {
            return maybePlural(years, "year");
        }
        var days = Math.floor((seconds %= 31536000) / 86400);
        if (days) {
            return maybePlural(days, "day");
        }
        var hours = Math.floor((seconds %= 86400) / 3600);
        if (hours) {
            return maybePlural(hours, 'hour');
        }
        var minutes = Math.floor((seconds %= 3600) / 60);
        if (minutes) {
            return maybePlural(minutes, 'minute');
        }
        seconds = Math.floor(seconds % 60);
        if (seconds) {
            return maybePlural(seconds, 'second');
        }
        return value + " ms";
    }
    Core.humanizeMilliseconds = humanizeMilliseconds;
    function storeConnectionRegex(regexs, name, json) {
        if (!regexs.any(function (r) {
            r['name'] === name;
        })) {
            var regex = '';
            if (json['useProxy']) {
                regex = '/hawtio/proxy/';
            }
            else {
                regex = '//';
            }
            regex += json['host'] + ':' + json['port'] + '/' + json['path'];
            regexs.push({
                name: name,
                regex: regex.escapeURL(true),
                color: UI.colors.sample()
            });
            writeRegexs(regexs);
        }
    }
    Core.storeConnectionRegex = storeConnectionRegex;
    function getRegexs() {
        var regexs = [];
        try {
            regexs = angular.fromJson(localStorage['regexs']);
        }
        catch (e) {
            delete localStorage['regexs'];
        }
        return regexs;
    }
    Core.getRegexs = getRegexs;
    function removeRegex(name) {
        var regexs = Core.getRegexs();
        var hasFunc = function (r) {
            return r['name'] === name;
        };
        if (regexs.any(hasFunc)) {
            regexs = regexs.exclude(hasFunc);
            Core.writeRegexs(regexs);
        }
    }
    Core.removeRegex = removeRegex;
    function writeRegexs(regexs) {
        localStorage['regexs'] = angular.toJson(regexs);
    }
    Core.writeRegexs = writeRegexs;
    function maskPassword(value) {
        if (value) {
            var text = '' + value;
            var userInfoPattern = "(.*://.*:)(.*)(@)";
            value = value.replace(new RegExp(userInfoPattern, 'i'), "$1xxxxxx$3");
        }
        return value;
    }
    Core.maskPassword = maskPassword;
    function matchFilterIgnoreCase(text, filter) {
        if (angular.isUndefined(text) || angular.isUndefined(filter)) {
            return true;
        }
        if (text == null || filter == null) {
            return true;
        }
        text = text.toString().trim().toLowerCase();
        filter = filter.toString().trim().toLowerCase();
        if (text.length === 0 || filter.length === 0) {
            return true;
        }
        var tokens = filter.split(",");
        tokens = tokens.filter(function (t) {
            return t.length > 0;
        }).map(function (t) {
            return t.trim();
        });
        var answer = tokens.some(function (t) {
            var bool = text.indexOf(t) > -1;
            return bool;
        });
        return answer;
    }
    Core.matchFilterIgnoreCase = matchFilterIgnoreCase;
})(Core || (Core = {}));
var IDE;
(function (IDE) {
    function getIdeMBean(workspace) {
        return Core.getMBeanTypeObjectName(workspace, "hawtio", "IdeFacade");
    }
    IDE.getIdeMBean = getIdeMBean;
    function isOpenInIdeaSupported(workspace, localStorage) {
        var value = localStorage["openInIDEA"];
        return value !== "false";
    }
    IDE.isOpenInIdeaSupported = isOpenInIdeaSupported;
    function isOpenInTextMateSupported(workspace, localStorage) {
        var value = localStorage["openInTextMate"];
        return value !== "false";
    }
    IDE.isOpenInTextMateSupported = isOpenInTextMateSupported;
    function findClassAbsoluteFileName(mbean, jolokia, localStorage, fileName, className, onResult) {
        var sourceRoots = [];
        var answer = null;
        if (mbean) {
            answer = jolokia.execute(mbean, "findClassAbsoluteFileName", fileName, className, sourceRoots, onSuccess(onResult));
        }
        else {
            onResult(answer);
        }
        return answer;
    }
    IDE.findClassAbsoluteFileName = findClassAbsoluteFileName;
    function asNumber(value, defaultValue) {
        if (defaultValue === void 0) { defaultValue = 0; }
        if (angular.isNumber(value)) {
            return value;
        }
        else if (angular.isString(value)) {
            return parseInt(value);
        }
        else {
            return defaultValue;
        }
    }
    function max(v1, v2) {
        return (v1 >= v2) ? v1 : v2;
    }
    function ideaOpenAndNavigate(mbean, jolokia, absoluteFileName, line, column, fn) {
        if (fn === void 0) { fn = null; }
        var answer = null;
        if (mbean) {
            line = max(asNumber(line) - 1, 0);
            column = max(asNumber(column) - 1, 0);
            answer = jolokia.execute(mbean, "ideaOpenAndNavigate", absoluteFileName, line, column, onSuccess(fn));
        }
        return answer;
    }
    IDE.ideaOpenAndNavigate = ideaOpenAndNavigate;
})(IDE || (IDE = {}));
var IDE;
(function (IDE) {
    var log = Logger.get("IDE");
    var OpenInIdeDirective = (function () {
        function OpenInIdeDirective(localStorage, workspace, jolokia) {
            var _this = this;
            this.localStorage = localStorage;
            this.workspace = workspace;
            this.jolokia = jolokia;
            this.restrict = 'E';
            this.replace = true;
            this.transclude = false;
            this.scope = {
                fileName: '@',
                className: '@',
                line: '@',
                column: '@'
            };
            this.link = function (scope, element, attrs) {
                return _this.doLink(scope, element, attrs);
            };
        }
        OpenInIdeDirective.prototype.doLink = function ($scope, $element, $attrs) {
            var workspace = this.workspace;
            var jolokia = this.jolokia;
            var mbean = IDE.getIdeMBean(workspace);
            var fileName = $scope.fileName;
            if (mbean && fileName) {
                var className = $scope.className;
                var line = $scope.line;
                var col = $scope.col;
                if (!angular.isDefined(line) || line === null)
                    line = 0;
                if (!angular.isDefined(col) || col === null)
                    col = 0;
                if (IDE.isOpenInIdeaSupported(workspace, localStorage)) {
                    var ideaButton = $('<button class="btn btn-mini"><img src="app/ide/img/intellijidea.png" width="16" height="16"></button>');
                    function onResult(absoluteName) {
                        if (!absoluteName) {
                            log.info("Could not find file in source code: " + fileName + " class: " + className);
                            ideaButton.attr("title", "Could not find source file: " + fileName);
                        }
                        else {
                            ideaButton.attr("title", "Opening in IDEA: " + absoluteName);
                            IDE.ideaOpenAndNavigate(mbean, jolokia, absoluteName, line, col);
                        }
                    }
                    ideaButton.on("click", function () {
                        log.info("Finding local file name: " + fileName + " className: " + className);
                        IDE.findClassAbsoluteFileName(mbean, jolokia, localStorage, fileName, className, onResult);
                    });
                    $element.append(ideaButton);
                }
            }
        };
        return OpenInIdeDirective;
    })();
    IDE.OpenInIdeDirective = OpenInIdeDirective;
})(IDE || (IDE = {}));
var IDE;
(function (IDE) {
    var pluginName = 'ide';
    IDE._module = angular.module(pluginName, ['bootstrap', 'hawtioCore']);
    IDE._module.directive('hawtioOpenIde', ["localStorage", "workspace", "jolokia", function (localStorage, workspace, jolokia) {
        return new IDE.OpenInIdeDirective(localStorage, workspace, jolokia);
    }]);
    IDE._module.run(["helpRegistry", function (helpRegistry) {
        helpRegistry.addDevDoc('IDE', 'app/ide/doc/developer.md');
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(IDE || (IDE = {}));
var Core;
(function (Core) {
    var PageTitle = (function () {
        function PageTitle() {
            this.titleElements = [];
        }
        PageTitle.prototype.addTitleElement = function (element) {
            this.titleElements.push(element);
        };
        PageTitle.prototype.getTitle = function () {
            return this.getTitleExcluding([], ' ');
        };
        PageTitle.prototype.getTitleWithSeparator = function (separator) {
            return this.getTitleExcluding([], separator);
        };
        PageTitle.prototype.getTitleExcluding = function (excludes, separator) {
            return this.getTitleArrayExcluding(excludes).join(separator);
        };
        PageTitle.prototype.getTitleArrayExcluding = function (excludes) {
            return this.titleElements.map(function (element) {
                var answer = '';
                if (element) {
                    answer = element();
                    if (answer === null) {
                        return '';
                    }
                }
                return answer;
            }).exclude(excludes).exclude('');
        };
        return PageTitle;
    })();
    Core.PageTitle = PageTitle;
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core.pluginName = 'hawtioCore';
    Core.templatePath = 'app/core/html/';
    Core.jolokiaUrl = Core.getJolokiaUrl();
    Logger.get("Core").debug("jolokiaUrl " + Core.jolokiaUrl);
    Core._module = angular.module(Core.pluginName, ['bootstrap', 'ngResource', 'ui', 'ui.bootstrap.dialog', 'hawtio-ui']);
    Core._module.config(["$locationProvider", "$routeProvider", "$dialogProvider", function ($locationProvider, $routeProvider, $dialogProvider) {
        $locationProvider.html5Mode(true);
        $dialogProvider.options({
            backdropFade: true,
            dialogFade: true
        });
        $routeProvider.when('/help', {
            redirectTo: '/help/index'
        }).when('/login', { templateUrl: Core.templatePath + 'login.html' }).when('/welcome', { templateUrl: Core.templatePath + 'welcome.html' }).when('/about', { templateUrl: Core.templatePath + 'about.html' }).when('/help/:topic/', { templateUrl: Core.templatePath + 'help.html' }).when('/help/:topic/:subtopic', { templateUrl: Core.templatePath + 'help.html' });
    }]);
    Core._module.constant('layoutTree', Core.templatePath + 'layoutTree.html');
    Core._module.constant('layoutFull', Core.templatePath + 'layoutFull.html');
    Core._module.filter("valueToHtml", function () { return Core.valueToHtml; });
    Core._module.filter('humanize', function () { return Core.humanizeValue; });
    Core._module.filter('humanizeMs', function () { return Core.humanizeMilliseconds; });
    Core._module.filter('maskPassword', function () { return Core.maskPassword; });
    Core._module.run(["$rootScope", "$routeParams", "jolokia", "workspace", "localStorage", "viewRegistry", "layoutFull", "helpRegistry", "pageTitle", "branding", "toastr", "metricsWatcher", "userDetails", "preferencesRegistry", "postLoginTasks", "preLogoutTasks", "$location", "ConnectOptions", "locationChangeStartTasks", "$http", "$route", function ($rootScope, $routeParams, jolokia, workspace, localStorage, viewRegistry, layoutFull, helpRegistry, pageTitle, branding, toastr, metricsWatcher, userDetails, preferencesRegistry, postLoginTasks, preLogoutTasks, $location, ConnectOptions, locationChangeStartTasks, $http, $route) {
        Core.checkInjectorLoaded();
        postLoginTasks.addTask("ResetPreLogoutTasks", function () {
            Core.checkInjectorLoaded();
            preLogoutTasks.reset();
        });
        postLoginTasks.addTask("ResetPostLogoutTasks", function () {
            Core.checkInjectorLoaded();
            Core.postLogoutTasks.reset();
        });
        preLogoutTasks.addTask("ResetPostLoginTasks", function () {
            Core.checkInjectorLoaded();
            postLoginTasks.reset();
        });
        $rootScope.lineCount = lineCount;
        $rootScope.params = $routeParams;
        $rootScope.is = function (type, value) {
            return angular['is' + type](value);
        };
        $rootScope.empty = function (value) {
            return $.isEmptyObject(value);
        };
        $rootScope.$on('UpdateRate', function (event, rate) {
            jolokia.stop();
            if (rate > 0) {
                jolokia.start(rate);
            }
            Logger.get("Core").debug("Set update rate to: ", rate);
        });
        $rootScope.$emit('UpdateRate', localStorage['updateRate']);
        $rootScope.$on('$locationChangeStart', function ($event, newUrl, oldUrl) {
            locationChangeStartTasks.execute($event, newUrl, oldUrl);
        });
        locationChangeStartTasks.addTask('ConParam', function ($event, newUrl, oldUrl) {
            if (!Core.injector) {
                return;
            }
            var $location = Core.injector.get('$location');
            var ConnectOptions = Core.injector.get('ConnectOptions');
            if (!ConnectOptions.name || !newUrl) {
                return;
            }
            var newQuery = $location.search();
            if (!newQuery.con) {
                Core.log.debug("Lost connection parameter (", ConnectOptions.name, ") from query params: ", newQuery, " resetting");
                newQuery['con'] = ConnectOptions.name;
                $location.search(newQuery);
            }
        });
        locationChangeStartTasks.addTask('UpdateSession', function () {
            Core.log.debug("Updating session expiry");
            $http({ method: 'post', url: 'refresh' }).success(function (data) {
                Core.log.debug("Updated session, response: ", data);
            }).error(function () {
                Core.log.debug("Failed to update session expiry");
            });
            Core.log.debug("Made request");
        });
        $rootScope.log = function (variable) {
            console.log(variable);
        };
        $rootScope.alert = function (text) {
            alert(text);
        };
        viewRegistry['fullscreen'] = layoutFull;
        viewRegistry['notree'] = layoutFull;
        viewRegistry['help'] = layoutFull;
        viewRegistry['welcome'] = layoutFull;
        viewRegistry['preferences'] = layoutFull;
        viewRegistry['about'] = layoutFull;
        viewRegistry['login'] = layoutFull;
        viewRegistry['ui'] = layoutFull;
        helpRegistry.addUserDoc('index', 'app/core/doc/overview.md');
        helpRegistry.addUserDoc('preferences', 'app/core/doc/preferences.md');
        helpRegistry.addSubTopic('index', 'faq', 'app/core/doc/FAQ.md');
        helpRegistry.addSubTopic('index', 'changes', 'app/core/doc/CHANGES.md');
        helpRegistry.addSubTopic('index', 'developer', 'app/core/doc/developer.md');
        helpRegistry.addDevDoc('Core', 'app/core/doc/coreDeveloper.md');
        helpRegistry.addDevDoc('UI', '#/ui/developerPage');
        helpRegistry.addDevDoc('datatable', 'app/datatable/doc/developer.md');
        helpRegistry.addDevDoc('Force Graph', 'app/forcegraph/doc/developer.md');
        preferencesRegistry.addTab("Core", "app/core/html/corePreferences.html");
        preferencesRegistry.addTab("Plugins", "app/core/html/pluginPreferences.html");
        preferencesRegistry.addTab("Console Logging", "app/core/html/loggingPreferences.html");
        preferencesRegistry.addTab("Editor", "app/ui/html/editorPreferences.html");
        preferencesRegistry.addTab("Jolokia", "app/core/html/jolokiaPreferences.html");
        preferencesRegistry.addTab("Reset", "app/core/html/resetPreferences.html");
        toastr.options = {
            'closeButton': true,
            'showMethod': 'slideDown',
            'hideMethod': 'slideUp'
        };
        var throttledError = {
            level: null,
            message: null,
            action: Core.throttled(function () {
                if (throttledError.level === "WARN") {
                    Core.notification('warning', throttledError.message);
                }
                if (throttledError.level === "ERROR") {
                    Core.notification('error', throttledError.message);
                }
            }, 500)
        };
        window['logInterceptors'].push(function (level, message) {
            throttledError.level = level;
            throttledError.message = message;
            throttledError.action();
        });
        setTimeout(function () {
            Core.checkInjectorLoaded();
            $("#main-body").fadeIn(2000).after(function () {
                Logger.get("Core").info(branding.appName + " started");
                Core.$apply($rootScope);
                $(window).trigger('resize');
                $route.reload();
            });
        }, 500);
    }]);
})(Core || (Core = {}));
hawtioPluginLoader.addUrl("plugin");
hawtioPluginLoader.addModule(Core.pluginName);
hawtioPluginLoader.addModule('angularFileUpload');
hawtioPluginLoader.registerPreBootstrapTask(function (nextTask) {
    $.support.cors = true;
    nextTask();
});
hawtioPluginLoader.registerPreBootstrapTask(function (nextTask) {
    $("a[title]").tooltip({
        selector: '',
        delay: { show: 1000, hide: 100 }
    });
    nextTask();
});
hawtioPluginLoader.registerPreBootstrapTask(function (nextTask) {
    Core.adjustHeight();
    $(window).resize(Core.adjustHeight);
    nextTask();
});
hawtioPluginLoader.registerPreBootstrapTask(function (nextTask) {
    if (Core._module && Core.isChromeApp()) {
        Core._module.config([
            '$compileProvider',
            function ($compileProvider) {
                $compileProvider.urlSanitizationWhitelist(/^\s*(https?|ftp|mailto|chrome-extension):/);
            }
        ]);
    }
    nextTask();
});
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ.pluginName = 'activemq';
    ActiveMQ._module = angular.module(ActiveMQ.pluginName, ['bootstrap', 'ngResource', 'ui.bootstrap.dialog', 'hawtioCore', 'camel', 'hawtio-ui']);
    ActiveMQ._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/activemq/browseQueue', { templateUrl: 'app/activemq/html/browseQueue.html' }).when('/activemq/diagram', { templateUrl: 'app/activemq/html/brokerDiagram.html', reloadOnSearch: false }).when('/activemq/createDestination', { templateUrl: 'app/activemq/html/createDestination.html' }).when('/activemq/createQueue', { templateUrl: 'app/activemq/html/createQueue.html' }).when('/activemq/createTopic', { templateUrl: 'app/activemq/html/createTopic.html' }).when('/activemq/deleteQueue', { templateUrl: 'app/activemq/html/deleteQueue.html' }).when('/activemq/deleteTopic', { templateUrl: 'app/activemq/html/deleteTopic.html' }).when('/activemq/sendMessage', { templateUrl: 'app/camel/html/sendMessage.html' }).when('/activemq/durableSubscribers', { templateUrl: 'app/activemq/html/durableSubscribers.html' }).when('/activemq/jobs', { templateUrl: 'app/activemq/html/jobs.html' });
    }]);
    ActiveMQ._module.run(["$location", "workspace", "viewRegistry", "helpRegistry", "preferencesRegistry", function ($location, workspace, viewRegistry, helpRegistry, preferencesRegistry) {
        viewRegistry['activemq'] = 'app/activemq/html/layoutActiveMQTree.html';
        helpRegistry.addUserDoc('activemq', 'app/activemq/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties("org.apache.activemq");
        });
        preferencesRegistry.addTab("ActiveMQ", "app/activemq/html/preferences.html", function () {
            return workspace.treeContainsDomainAndProperties("org.apache.activemq");
        });
        workspace.addTreePostProcessor(postProcessTree);
        var attributes = workspace.attributeColumnDefs;
        attributes[ActiveMQ.jmxDomain + "/Broker/folder"] = [
            { field: 'BrokerName', displayName: 'Name', width: "**" },
            { field: 'TotalProducerCount', displayName: 'Producer #' },
            { field: 'TotalConsumerCount', displayName: 'Consumer #' },
            { field: 'StorePercentUsage', displayName: 'Store %' },
            { field: 'TempPercentUsage', displayName: 'Temp %' },
            { field: 'MemoryPercentUsage', displayName: 'Memory %' },
            { field: 'TotalEnqueueCount', displayName: 'Enqueue #' },
            { field: 'TotalDequeueCount', displayName: 'Dequeue #' }
        ];
        attributes[ActiveMQ.jmxDomain + "/Queue/folder"] = [
            { field: 'Name', displayName: 'Name', width: "***" },
            { field: 'QueueSize', displayName: 'Queue Size' },
            { field: 'ProducerCount', displayName: 'Producer #' },
            { field: 'ConsumerCount', displayName: 'Consumer #' },
            { field: 'EnqueueCount', displayName: 'Enqueue #' },
            { field: 'DequeueCount', displayName: 'Dequeue #' },
            { field: 'MemoryPercentUsage', displayName: 'Memory %' },
            { field: 'DispatchCount', displayName: 'Dispatch #', visible: false }
        ];
        attributes[ActiveMQ.jmxDomain + "/Topic/folder"] = [
            { field: 'Name', displayName: 'Name', width: "****" },
            { field: 'ProducerCount', displayName: 'Producer #' },
            { field: 'ConsumerCount', displayName: 'Consumer #' },
            { field: 'EnqueueCount', displayName: 'Enqueue #' },
            { field: 'DequeueCount', displayName: 'Dequeue #' },
            { field: 'MemoryPercentUsage', displayName: 'Memory %' },
            { field: 'DispatchCount', displayName: 'Dispatch #', visible: false }
        ];
        attributes[ActiveMQ.jmxDomain + "/Consumer/folder"] = [
            { field: 'ConnectionId', displayName: 'Name', width: "**" },
            { field: 'PrefetchSize', displayName: 'Prefetch Size' },
            { field: 'Priority', displayName: 'Priority' },
            { field: 'DispatchedQueueSize', displayName: 'Dispatched Queue #' },
            { field: 'SlowConsumer', displayName: 'Slow ?' },
            { field: 'Retroactive', displayName: 'Retroactive' },
            { field: 'Selector', displayName: 'Selector' }
        ];
        attributes[ActiveMQ.jmxDomain + "/networkConnectors/folder"] = [
            { field: 'Name', displayName: 'Name', width: "**" },
            { field: 'UserName', displayName: 'User Name' },
            { field: 'PrefetchSize', displayName: 'Prefetch Size' },
            { field: 'ConduitSubscriptions', displayName: 'Conduit Subscriptions?' },
            { field: 'Duplex', displayName: 'Duplex' },
            { field: 'DynamicOnly', displayName: 'Dynamic Only' }
        ];
        attributes[ActiveMQ.jmxDomain + "/PersistenceAdapter/folder"] = [
            { field: 'IndexDirectory', displayName: 'Index Directory', width: "**" },
            { field: 'LogDirectory', displayName: 'Log Directory', width: "**" }
        ];
        workspace.topLevelTabs.push({
            id: "activemq",
            content: "ActiveMQ",
            title: "Manage your ActiveMQ message brokers",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties("org.apache.activemq"); },
            href: function () { return "#/jmx/attributes?tab=activemq"; },
            isActive: function () { return workspace.isTopTabActive("activemq"); }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-envelope"></i> Browse',
            title: "Browse the messages on the queue",
            isValid: function (workspace) { return isQueue(workspace) && workspace.hasInvokeRights(workspace.selection, "browse()"); },
            href: function () { return "#/activemq/browseQueue"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-pencil"></i> Send',
            title: "Send a message to this destination",
            isValid: function (workspace) { return (isQueue(workspace) || isTopic(workspace)) && workspace.hasInvokeRights(workspace.selection, "sendTextMessage(java.util.Map,java.lang.String,java.lang.String,java.lang.String)"); },
            href: function () { return "#/activemq/sendMessage"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-picture"></i> Diagram',
            title: "View a diagram of the producers, destinations and consumers",
            isValid: function (workspace) { return workspace.isTopTabActive("activemq") || workspace.selectionHasDomain(ActiveMQ.jmxDomain); },
            href: function () { return "#/activemq/diagram"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-plus"></i> Create',
            title: "Create a new destination",
            isValid: function (workspace) { return isBroker(workspace) && workspace.hasInvokeRights(getBroker(workspace), "addQueue", "addTopic"); },
            href: function () { return "#/activemq/createDestination"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-plus"></i> Create',
            title: "Create a new queue",
            isValid: function (workspace) { return isQueuesFolder(workspace) && workspace.hasInvokeRights(getBroker(workspace), "addQueue"); },
            href: function () { return "#/activemq/createQueue"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-plus"></i> Create',
            title: "Create a new topic",
            isValid: function (workspace) { return isTopicsFolder(workspace) && workspace.hasInvokeRights(getBroker(workspace), "addQueue"); },
            href: function () { return "#/activemq/createTopic"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-remove"></i> Delete Topic',
            title: "Delete this topic",
            isValid: function (workspace) { return isTopic(workspace) && workspace.hasInvokeRights(getBroker(workspace), "removeTopic"); },
            href: function () { return "#/activemq/deleteTopic"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-remove"></i> Delete',
            title: "Delete or purge this queue",
            isValid: function (workspace) { return isQueue(workspace) && workspace.hasInvokeRights(getBroker(workspace), "removeQueue"); },
            href: function () { return "#/activemq/deleteQueue"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-list"></i> Durable Subscribers',
            title: "Manage durable subscribers",
            isValid: function (workspace) { return isBroker(workspace); },
            href: function () { return "#/activemq/durableSubscribers"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-list"></i> Jobs',
            title: "Manage jobs",
            isValid: function (workspace) { return isJobScheduler(workspace); },
            href: function () { return "#/activemq/jobs"; }
        });
        function postProcessTree(tree) {
            var activemq = tree.get("org.apache.activemq");
            setConsumerType(activemq);
            if (activemq) {
                angular.forEach(activemq.children, function (broker) {
                    angular.forEach(broker.children, function (child) {
                        var grandChildren = child.children;
                        if (grandChildren) {
                            var names = ["Topic", "Queue"];
                            angular.forEach(names, function (name) {
                                var idx = grandChildren.findIndex(function (n) { return n.title === name; });
                                if (idx > 0) {
                                    var old = grandChildren[idx];
                                    grandChildren.splice(idx, 1);
                                    grandChildren.splice(0, 0, old);
                                }
                            });
                        }
                    });
                });
            }
        }
        function setConsumerType(node) {
            if (node) {
                var parent = node.parent;
                var entries = node.entries;
                if (parent && !parent.typeName && entries) {
                    var endpoint = entries["endpoint"];
                    if (endpoint === "Consumer" || endpoint === "Producer") {
                        parent.typeName = endpoint;
                    }
                    var connectorName = entries["connectorName"];
                    if (connectorName && !node.icon) {
                        node.icon = Core.url("/img/icons/activemq/connector.png");
                    }
                }
                angular.forEach(node.children, function (child) { return setConsumerType(child); });
            }
        }
    }]);
    hawtioPluginLoader.addModule(ActiveMQ.pluginName);
    function getBroker(workspace) {
        var answer = null;
        var selection = workspace.selection;
        if (selection) {
            answer = selection.findAncestor(function (current) {
                var entries = current.entries;
                if (entries) {
                    return (('type' in entries && entries.type === 'Broker') && 'brokerName' in entries && !('destinationName' in entries) && !('destinationType' in entries));
                }
                else {
                    return false;
                }
            });
        }
        return answer;
    }
    ActiveMQ.getBroker = getBroker;
    function isQueue(workspace) {
        return workspace.hasDomainAndProperties(ActiveMQ.jmxDomain, { 'destinationType': 'Queue' }, 4) || workspace.selectionHasDomainAndType(ActiveMQ.jmxDomain, 'Queue');
    }
    ActiveMQ.isQueue = isQueue;
    function isTopic(workspace) {
        return workspace.hasDomainAndProperties(ActiveMQ.jmxDomain, { 'destinationType': 'Topic' }, 4) || workspace.selectionHasDomainAndType(ActiveMQ.jmxDomain, 'Topic');
    }
    ActiveMQ.isTopic = isTopic;
    function isQueuesFolder(workspace) {
        return workspace.selectionHasDomainAndLastFolderName(ActiveMQ.jmxDomain, 'Queue');
    }
    ActiveMQ.isQueuesFolder = isQueuesFolder;
    function isTopicsFolder(workspace) {
        return workspace.selectionHasDomainAndLastFolderName(ActiveMQ.jmxDomain, 'Topic');
    }
    ActiveMQ.isTopicsFolder = isTopicsFolder;
    function isJobScheduler(workspace) {
        return workspace.hasDomainAndProperties(ActiveMQ.jmxDomain, { 'service': 'JobScheduler' }, 4);
    }
    ActiveMQ.isJobScheduler = isJobScheduler;
    function isBroker(workspace) {
        if (workspace.selectionHasDomainAndType(ActiveMQ.jmxDomain, 'Broker')) {
            var self = Core.pathGet(workspace, ["selection"]);
            var parent = Core.pathGet(workspace, ["selection", "parent"]);
            return !(parent && (parent.ancestorHasType('Broker') || self.ancestorHasType('Broker')));
        }
        return false;
    }
    ActiveMQ.isBroker = isBroker;
})(ActiveMQ || (ActiveMQ = {}));
var Fabric;
(function (Fabric) {
    function createSshHostConfiguration() {
        return {
            hostName: null,
            port: null,
            username: null,
            password: null,
            maximumContainerCount: null,
            tags: [],
            path: null,
            passPhrase: null,
            privateKeyFile: null,
            preferredAddress: null
        };
    }
    Fabric.createSshHostConfiguration = createSshHostConfiguration;
    function createSshConfiguration() {
        return {
            hosts: [],
            defaultPath: null,
            defaultPort: null,
            defaultUsername: null,
            defaultPassword: null,
            fallbackRepositories: [],
            defaultPassPhrase: null,
            defaultPrivateKeyFile: null
        };
    }
    Fabric.createSshConfiguration = createSshConfiguration;
    function createDockerHostConfiguration() {
        return {
            hostName: null,
            port: null,
            username: null,
            password: null,
            maximumContainerCount: null,
            tags: [],
            path: null,
            passPhrase: null,
            privateKeyFile: null,
            preferredAddress: null
        };
    }
    Fabric.createDockerHostConfiguration = createDockerHostConfiguration;
    function createDockerConfiguration() {
        return {
            hosts: []
        };
    }
    Fabric.createDockerConfiguration = createDockerConfiguration;
    ;
    ;
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric.log = Logger.get("Fabric");
    Fabric.jmxDomain = 'io.fabric8';
    Fabric.managerMBean = Fabric.jmxDomain + ":type=Fabric";
    Fabric.clusterManagerMBean = Fabric.jmxDomain + ":type=ClusterServiceManager";
    Fabric.clusterBootstrapManagerMBean = Fabric.jmxDomain + ":type=ClusterBootstrapManager";
    Fabric.openShiftFabricMBean = Fabric.jmxDomain + ":type=OpenShift";
    Fabric.mqManagerMBean = Fabric.jmxDomain + ":type=MQManager";
    Fabric.healthMBean = Fabric.jmxDomain + ":service=Health";
    Fabric.schemaLookupDomain = "hawtio";
    Fabric.schemaLookupType = "SchemaLookup";
    Fabric.schemaLookupMBean = Fabric.schemaLookupDomain + ":type=" + Fabric.schemaLookupType;
    Fabric.useDirectoriesInGit = true;
    Fabric.fabricTopLevel = "fabric/profiles/";
    Fabric.profileSuffix = ".profile";
    Fabric.jolokiaWebAppGroupId = Fabric.jmxDomain + ".fabric-jolokia";
    Fabric.currentContainerId = '';
    Fabric.currentContainer = {};
    Fabric.DEFAULT_REST_API = "/api/fabric8";
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    function doAction(action, jolokia, arguments, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        jolokia.request({
            type: 'exec',
            mbean: Fabric.managerMBean,
            operation: action,
            arguments: arguments
        }, {
            method: 'POST',
            success: success,
            error: error
        });
    }
    Fabric.doAction = doAction;
    function applyPatches(jolokia, files, targetVersion, newVersionName, proxyUser, proxyPass, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('applyPatches(java.util.List,java.lang.String,java.lang.String,java.lang.String,java.lang.String)', jolokia, [files, targetVersion, newVersionName, proxyUser, proxyPass], success, error);
    }
    Fabric.applyPatches = applyPatches;
    function setContainerProperty(jolokia, containerId, property, value, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('setContainerProperty(java.lang.String, java.lang.String, java.lang.Object)', jolokia, [containerId, property, value], success, error);
    }
    Fabric.setContainerProperty = setContainerProperty;
    function deleteConfigFile(jolokia, version, profile, file, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('deleteConfigurationFile(java.lang.String, java.lang.String, java.lang.String)', jolokia, [version, profile, file], success, error);
    }
    Fabric.deleteConfigFile = deleteConfigFile;
    function deleteConfigFiles(jolokia, version, profiles, files, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('deleteConfigurationFiles(java.lang.String, java.util.List, java.util.List)', jolokia, [version, profiles, files], success, error);
    }
    Fabric.deleteConfigFiles = deleteConfigFiles;
    function newConfigFile(jolokia, version, profile, pid, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('setConfigurationFile(java.lang.String, java.lang.String, java.lang.String, java.lang.String)', jolokia, [version, profile, pid, ''], success, error);
    }
    Fabric.newConfigFile = newConfigFile;
    function saveConfigFile(jolokia, version, profile, pid, data, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('setConfigurationFile(java.lang.String, java.lang.String, java.lang.String, java.lang.String)', jolokia, [version, profile, pid, data], success, error);
    }
    Fabric.saveConfigFile = saveConfigFile;
    function addProfilesToContainer(jolokia, container, profiles, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('addProfilesToContainer(java.lang.String, java.util.List)', jolokia, [container, profiles], success, error);
    }
    Fabric.addProfilesToContainer = addProfilesToContainer;
    function removeProfilesFromContainer(jolokia, container, profiles, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('removeProfilesFromContainer(java.lang.String, java.util.List)', jolokia, [container, profiles], success, error);
    }
    Fabric.removeProfilesFromContainer = removeProfilesFromContainer;
    function applyProfiles(jolokia, version, profiles, containers, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('applyProfilesToContainers(java.lang.String, java.util.List, java.util.List)', jolokia, [version, profiles, containers], success, error);
    }
    Fabric.applyProfiles = applyProfiles;
    function migrateContainers(jolokia, version, containers, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('applyVersionToContainers(java.lang.String, java.util.List)', jolokia, [version, containers], success, error);
    }
    Fabric.migrateContainers = migrateContainers;
    function changeProfileParents(jolokia, version, id, parents, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('changeProfileParents(java.lang.String, java.lang.String, java.util.List)', jolokia, [version, id, parents], success, error);
    }
    Fabric.changeProfileParents = changeProfileParents;
    function createProfile(jolokia, version, id, parents, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('createProfile(java.lang.String, java.lang.String, java.util.List)', jolokia, [version, id, parents], success, error);
    }
    Fabric.createProfile = createProfile;
    function copyProfile(jolokia, version, sourceName, targetName, force, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('copyProfile(java.lang.String, java.lang.String, java.lang.String, boolean)', jolokia, [version, sourceName, targetName, force], success, error);
    }
    Fabric.copyProfile = copyProfile;
    function createVersionWithParentAndId(jolokia, base, id, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('createVersion(java.lang.String, java.lang.String)', jolokia, [base, id], success, error);
    }
    Fabric.createVersionWithParentAndId = createVersionWithParentAndId;
    function createVersionWithId(jolokia, id, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('createVersion(java.lang.String)', jolokia, [id], success, error);
    }
    Fabric.createVersionWithId = createVersionWithId;
    function createVersion(jolokia, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('createVersion()', jolokia, [], success, error);
    }
    Fabric.createVersion = createVersion;
    function deleteVersion(jolokia, id, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('deleteVersion(java.lang.String)', jolokia, [id], success, error);
    }
    Fabric.deleteVersion = deleteVersion;
    function getVersionIds(jolokia) {
        return jolokia.execute(Fabric.managerMBean, "versionIds", { method: 'GET' });
    }
    Fabric.getVersionIds = getVersionIds;
    function getContainerIdsForProfile(jolokia, version, profileId) {
        return jolokia.execute(Fabric.managerMBean, "containerIdsForProfile", version, profileId, { method: 'POST' });
    }
    Fabric.getContainerIdsForProfile = getContainerIdsForProfile;
    function getContainerIdsForProfiles(jolokia, version, profileIds, checkParents) {
        return jolokia.execute(Fabric.managerMBean, "containerIdsForProfiles(java.lang.String, java.util.List, boolean)", version, profileIds, checkParents, { method: 'POST' });
    }
    Fabric.getContainerIdsForProfiles = getContainerIdsForProfiles;
    function getContainerIds(jolokia) {
        return jolokia.execute(Fabric.managerMBean, "containerIds", { method: 'POST' });
    }
    Fabric.getContainerIds = getContainerIds;
    function getProfile(jolokia, version, id, mandatory) {
        return jolokia.execute(Fabric.managerMBean, "getProfile(java.lang.String, java.lang.String, boolean)", version, id, mandatory, { method: 'GET' });
    }
    Fabric.getProfile = getProfile;
    function deleteProfile(jolokia, version, id, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('deleteProfile(java.lang.String, java.lang.String)', jolokia, [version, id], success, error);
    }
    Fabric.deleteProfile = deleteProfile;
    function profileWebAppURL(jolokia, webAppId, profileId, versionId, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('profileWebAppURL', jolokia, [webAppId, profileId, versionId], success, error);
    }
    Fabric.profileWebAppURL = profileWebAppURL;
    function restApiUrl(jolokia, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('restApiUrl', jolokia, [], success, error);
    }
    Fabric.restApiUrl = restApiUrl;
    function stopContainer(jolokia, id, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('stopContainer(java.lang.String)', jolokia, [id], success, error);
    }
    Fabric.stopContainer = stopContainer;
    function destroyContainer(jolokia, id, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('destroyContainer(java.lang.String)', jolokia, [id], success, error);
    }
    Fabric.destroyContainer = destroyContainer;
    function startContainer(jolokia, id, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('startContainer(java.lang.String)', jolokia, [id], success, error);
    }
    Fabric.startContainer = startContainer;
    function containerWebAppURL(jolokia, webAppId, containerId, success, error) {
        if (error === void 0) { error = Core.defaultJolokiaErrorHandler; }
        doAction('containerWebAppURL', jolokia, [webAppId, containerId], success, error);
    }
    Fabric.containerWebAppURL = containerWebAppURL;
    function getDefaultVersionIdAsync(jolokia, callback) {
        doAction('defaultVersion', jolokia, [], function (response) {
            callback(response.value['id']);
        });
    }
    Fabric.getDefaultVersionIdAsync = getDefaultVersionIdAsync;
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    var dialogConfigs = {};
    function getCreateLocationDialog($dialog, resolve) {
        return $dialog.dialog({
            resolve: resolve,
            templateUrl: 'app/fabric/html/newLocation.html',
            controller: ["$scope", "dialog", "jolokia", "selectedContainers", "callbacks", function ($scope, dialog, jolokia, selectedContainers, callbacks) {
                $scope.newLocationName = "";
                $scope.close = function (result) {
                    dialog.close();
                    if (result) {
                        selectedContainers.each(function (container) {
                            Fabric.setContainerProperty(jolokia, container.id, 'location', $scope.newLocationName, callbacks.successs, callbacks.error);
                        });
                    }
                };
            }]
        });
    }
    Fabric.getCreateLocationDialog = getCreateLocationDialog;
    function getVersionCreateDialog($dialog) {
        var key = 'createVersion';
        if (!(key in dialogConfigs)) {
            dialogConfigs[key] = $dialog.dialog({
                templateUrl: 'app/fabric/html/createVersionDialog.html',
                controller: ["$scope", "dialog", "jolokia", "$location", function ($scope, dialog, jolokia, $location) {
                    $scope.name = '';
                    $scope.close = function (result) {
                        dialog.close();
                        if (result) {
                            Fabric.doCreateVersion($scope, jolokia, $location, $scope.name);
                        }
                    };
                }]
            });
        }
        return dialogConfigs[key];
    }
    Fabric.getVersionCreateDialog = getVersionCreateDialog;
    function getVersionDeleteDialog($dialog) {
        var key = 'deleteVersion';
        if (!(key in dialogConfigs)) {
            dialogConfigs[key] = $dialog.dialog({
                templateUrl: 'app/fabric/html/selectVersionDialog.html',
                controller: ["$scope", "dialog", "jolokia", "$location", "$rootScope", function ($scope, dialog, jolokia, $location, $rootScope) {
                    $scope.excludes = [];
                    $scope.$watch('selectedVersion.id', function (newValue, oldValue) {
                        if (newValue) {
                            if ($scope.excludes.find(function (v) {
                                return v === newValue;
                            })) {
                                $scope.warning = "This version is in use and cannot be deleted.";
                                $scope.invalid = true;
                            }
                            else {
                                $scope.warning = "This operation cannot be undone!";
                                $scope.invalid = false;
                            }
                        }
                    });
                    Fabric.getVersionsInUse(jolokia, function (used) {
                        $scope.excludes = used;
                        Core.$apply($scope);
                    });
                    $scope.invalid = false;
                    $scope.title = "Delete Version";
                    $scope.text = "Select the version to delete:";
                    $scope.warning = "This operation cannot be undone!";
                    $scope.action = "Delete";
                    $scope.cancel = "Cancel";
                    $scope.close = function (result) {
                        dialog.close();
                        if (result) {
                            var selectedVersion = $scope.selectedVersion.id;
                            Fabric.deleteVersion(jolokia, selectedVersion, function () {
                                $rootScope.$broadcast('wikiBranchesUpdated');
                                Fabric.getDefaultVersionIdAsync(jolokia, function (versionId) {
                                    Fabric.viewVersion(versionId, $location, $scope);
                                    Core.$apply($scope);
                                });
                            }, function (response) {
                                Fabric.log.debug("Failed to delete version ", selectedVersion, " due to ", response.error);
                                Fabric.log.debug("Stack trace: ", response.stacktrace);
                                Core.$apply($scope);
                            });
                        }
                    };
                }]
            });
        }
        return dialogConfigs[key];
    }
    Fabric.getVersionDeleteDialog = getVersionDeleteDialog;
    function getChangeDefaultVersionDialog($dialog) {
        var key = 'changeDefault';
        if (!(key in dialogConfigs)) {
            dialogConfigs[key] = $dialog.dialog({
                templateUrl: 'app/fabric/html/selectVersionDialog.html',
                controller: ["$scope", "dialog", "jolokia", "$location", function ($scope, dialog, jolokia, $location) {
                    $scope.title = "Change Default Version";
                    $scope.text = "Change the default version to:";
                    $scope.action = "Change";
                    $scope.cancel = "Cancel";
                    $scope.close = function (result) {
                        dialog.close();
                        if (result) {
                            var newDefault = $scope.selectedVersion.id;
                            Fabric.setDefaultVersion(jolokia, newDefault, function () {
                                Core.notification('success', "Set default version to " + newDefault);
                                Core.$apply($scope);
                            });
                        }
                    };
                }]
            });
        }
        return dialogConfigs[key];
    }
    Fabric.getChangeDefaultVersionDialog = getChangeDefaultVersionDialog;
    function getVersionPatchDialog($dialog) {
        var key = 'patchVersion';
        if (!(key in dialogConfigs)) {
            dialogConfigs[key] = $dialog.dialog({
                templateUrl: 'app/fabric/html/selectVersionDialog.html',
                controller: ["$scope", "dialog", "jolokia", "$location", function ($scope, dialog, jolokia, $location) {
                    $scope.title = "Patch Version";
                    $scope.text = "Select the version to patch:";
                    $scope.action = "Continue";
                    $scope.cancel = "Cancel";
                    $scope.close = function (result) {
                        dialog.close();
                        if (result) {
                            $location.url('/fabric/patching').search({ versionId: $scope.selectedVersion.id });
                            Core.$apply($scope);
                        }
                    };
                }]
            });
        }
        return dialogConfigs[key];
    }
    Fabric.getVersionPatchDialog = getVersionPatchDialog;
    function addWikiBranchMenuExtensions(wikiBranchMenu, $dialog, workspace) {
        wikiBranchMenu.addExtension({
            title: "Create Version",
            valid: function () {
                return Fabric.isFMCContainer(workspace);
            },
            action: function () {
                getVersionCreateDialog($dialog).open();
            },
            objectName: Fabric.managerMBean,
            methodName: 'createVersion'
        });
        wikiBranchMenu.addExtension({
            title: "Delete Version",
            valid: function () {
                return Fabric.isFMCContainer(workspace);
            },
            action: function () {
                getVersionDeleteDialog($dialog).open();
            },
            objectName: Fabric.managerMBean,
            methodName: 'deleteVersion'
        });
        wikiBranchMenu.addExtension({
            title: "Change Default",
            valid: function () {
                return Fabric.isFMCContainer(workspace);
            },
            action: function () {
                getChangeDefaultVersionDialog($dialog).open();
            },
            objectName: Fabric.managerMBean,
            methodName: 'setDefaultVersion'
        });
        wikiBranchMenu.addExtension({
            title: "Patch Version",
            valid: function () {
                return Fabric.isFMCContainer(workspace) && !Fabric.hasOpenShiftFabric(workspace);
            },
            action: function () {
                getVersionPatchDialog($dialog).open();
            },
            objectName: Fabric.managerMBean,
            methodName: 'applyPatches',
            argumentTypes: 'java.util.List,java.lang.String,java.lang.String,java.lang.String,java.lang.String'
        });
    }
    Fabric.addWikiBranchMenuExtensions = addWikiBranchMenuExtensions;
})(Fabric || (Fabric = {}));
var CodeEditor;
(function (CodeEditor) {
    CodeEditor.GlobalCodeMirrorOptions = {
        theme: "default",
        tabSize: 4,
        lineNumbers: true,
        indentWithTabs: true,
        lineWrapping: true,
        autoCloseTags: true
    };
    function detectTextFormat(value) {
        var answer = "text";
        if (value) {
            answer = "javascript";
            var trimmed = value.toString().trimLeft().trimRight();
            if (trimmed && trimmed.first() === '<' && trimmed.last() === '>') {
                answer = "xml";
            }
        }
        return answer;
    }
    CodeEditor.detectTextFormat = detectTextFormat;
    function autoFormatEditor(editor) {
        if (editor) {
            var totalLines = editor.lineCount();
            var start = { line: 0, ch: 0 };
            var end = { line: totalLines - 1, ch: editor.getLine(totalLines - 1).length };
            editor.autoFormatRange(start, end);
            editor.setSelection(start, start);
        }
    }
    CodeEditor.autoFormatEditor = autoFormatEditor;
    function createEditorSettings(options) {
        if (options === void 0) { options = {}; }
        options.extraKeys = options.extraKeys || {};
        (function (mode) {
            mode = mode || { name: "text" };
            if (typeof mode !== "object") {
                mode = { name: mode };
            }
            var modeName = mode.name;
            if (modeName === "javascript") {
                angular.extend(mode, {
                    "json": true
                });
            }
        })(options.mode);
        (function (options) {
            var javascriptFolding = CodeMirror.newFoldFunction(CodeMirror.braceRangeFinder);
            var xmlFolding = CodeMirror.newFoldFunction(CodeMirror.tagRangeFinder);
            var foldFunction = function (codeMirror, line) {
                var mode = codeMirror.getOption("mode");
                var modeName = mode["name"];
                if (!mode || !modeName)
                    return;
                if (modeName === 'javascript') {
                    javascriptFolding(codeMirror, line);
                }
                else if (modeName === "xml" || modeName.startsWith("html")) {
                    xmlFolding(codeMirror, line);
                }
                ;
            };
            options.onGutterClick = foldFunction;
            options.extraKeys = angular.extend(options.extraKeys, {
                "Ctrl-Q": function (codeMirror) {
                    foldFunction(codeMirror, codeMirror.getCursor().line);
                }
            });
        })(options);
        var readOnly = options.readOnly;
        if (!readOnly) {
            options.matchBrackets = true;
        }
        angular.extend(options, CodeEditor.GlobalCodeMirrorOptions);
        return options;
    }
    CodeEditor.createEditorSettings = createEditorSettings;
})(CodeEditor || (CodeEditor = {}));
var UI;
(function (UI) {
    UI.log = Logger.get("UI");
    UI.scrollBarWidth = null;
    function findParentWith($scope, attribute) {
        if (attribute in $scope) {
            return $scope;
        }
        if (!$scope.$parent) {
            return null;
        }
        return findParentWith($scope.$parent, attribute);
    }
    UI.findParentWith = findParentWith;
    function getIfSet(attribute, $attr, def) {
        if (attribute in $attr) {
            var wantedAnswer = $attr[attribute];
            if (wantedAnswer && !wantedAnswer.isBlank()) {
                return wantedAnswer;
            }
        }
        return def;
    }
    UI.getIfSet = getIfSet;
    function observe($scope, $attrs, key, defValue, callbackFunc) {
        if (callbackFunc === void 0) { callbackFunc = null; }
        $attrs.$observe(key, function (value) {
            if (!angular.isDefined(value)) {
                $scope[key] = defValue;
            }
            else {
                $scope[key] = value;
            }
            if (angular.isDefined(callbackFunc) && callbackFunc) {
                callbackFunc($scope[key]);
            }
        });
    }
    UI.observe = observe;
    function getScrollbarWidth() {
        if (!angular.isDefined(UI.scrollBarWidth)) {
            var div = document.createElement('div');
            div.innerHTML = '<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>';
            div = div.firstChild;
            document.body.appendChild(div);
            UI.scrollBarWidth = div.offsetWidth - div.clientWidth;
            document.body.removeChild(div);
        }
        return UI.scrollBarWidth;
    }
    UI.getScrollbarWidth = getScrollbarWidth;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI.pluginName = 'hawtio-ui';
    UI.templatePath = 'app/ui/html/';
    UI._module = angular.module(UI.pluginName, ['bootstrap', 'ngResource', 'ui', 'ui.bootstrap']);
    UI._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/ui/developerPage', { templateUrl: UI.templatePath + 'developerPage.html', reloadOnSearch: false });
    }]);
    UI._module.factory('UI', function () {
        return UI;
    });
    UI._module.factory('marked', function () {
        marked.setOptions({
            gfm: true,
            tables: true,
            breaks: false,
            pedantic: true,
            sanitize: false,
            smartLists: true,
            langPrefix: 'language-'
        });
        return marked;
    });
    UI._module.directive('compile', ['$compile', function ($compile) {
        return function (scope, element, attrs) {
            scope.$watch(function (scope) {
                return scope.$eval(attrs.compile);
            }, function (value) {
                element.html(value);
                $compile(element.contents())(scope);
            });
        };
    }]);
    UI._module.controller("CodeEditor.PreferencesController", ["$scope", "localStorage", "$templateCache", function ($scope, localStorage, $templateCache) {
        $scope.exampleText = $templateCache.get("exampleText");
        $scope.codeMirrorEx = $templateCache.get("codeMirrorExTemplate");
        $scope.javascript = "javascript";
        $scope.preferences = CodeEditor.GlobalCodeMirrorOptions;
        $scope.$watch("preferences", function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.codeMirrorEx += " ";
                localStorage['CodeMirrorOptions'] = angular.toJson(angular.extend(CodeEditor.GlobalCodeMirrorOptions, $scope.preferences));
            }
        }, true);
    }]);
    UI._module.run(["localStorage", function (localStorage) {
        var opts = localStorage['CodeMirrorOptions'];
        if (opts) {
            opts = angular.fromJson(opts);
            CodeEditor.GlobalCodeMirrorOptions = angular.extend(CodeEditor.GlobalCodeMirrorOptions, opts);
        }
    }]);
    hawtioPluginLoader.addModule(UI.pluginName);
})(UI || (UI = {}));
var UI;
(function (UI) {
    function hawtioDropDown($templateCache) {
        return {
            restrict: 'A',
            replace: true,
            templateUrl: UI.templatePath + 'dropDown.html',
            scope: {
                config: '=hawtioDropDown'
            },
            controller: ["$scope", "$element", "$attrs", function ($scope, $element, $attrs) {
                if (!$scope.config) {
                    $scope.config = {};
                }
                if (!('open' in $scope.config)) {
                    $scope.config['open'] = false;
                }
                $scope.action = function (config, $event) {
                    if ('items' in config && !('action' in config)) {
                        config.open = !config.open;
                        $event.preventDefault();
                        $event.stopPropagation();
                    }
                    else if ('action' in config) {
                        var action = config['action'];
                        if (angular.isFunction(action)) {
                            action();
                        }
                        else if (angular.isString(action)) {
                            $scope.$parent.$eval(action, {
                                config: config,
                                '$event': $event
                            });
                        }
                    }
                };
                $scope.$watch('config.items', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        $scope.menuStyle = $scope.menuStyle + " ";
                    }
                }, true);
                $scope.submenu = function (config) {
                    if (config && config.submenu) {
                        return "sub-menu";
                    }
                    return "";
                };
                $scope.icon = function (config) {
                    if (config && !Core.isBlank(config.icon)) {
                        return config.icon;
                    }
                    else {
                        return 'icon-spacer';
                    }
                };
                $scope.open = function (config) {
                    if (config && !config.open) {
                        return '';
                    }
                    return 'open';
                };
            }],
            link: function ($scope, $element, $attrs) {
                $scope.menuStyle = $templateCache.get("withsubmenus.html");
                if ('processSubmenus' in $attrs) {
                    if (!Core.parseBooleanValue($attrs['processSubmenus'])) {
                        $scope.menuStyle = $templateCache.get("withoutsubmenus.html");
                    }
                }
            }
        };
    }
    UI.hawtioDropDown = hawtioDropDown;
    UI._module.directive('hawtioDropDown', ["$templateCache", UI.hawtioDropDown]);
})(UI || (UI = {}));
var ContainerHelpers;
(function (ContainerHelpers) {
    ContainerHelpers.NO_LOCATION = "No Location";
    function extractLocations(containers) {
        var locations = containers.map(function (container) {
            if (Core.isBlank(container['location'])) {
                return ContainerHelpers.NO_LOCATION;
            }
            else {
                return container['location'];
            }
        });
        locations.push(ContainerHelpers.NO_LOCATION);
        locations = locations.unique().sortBy('');
        locations = locations.exclude(function (location) {
            return Core.isBlank(location);
        });
        return locations;
    }
    ContainerHelpers.extractLocations = extractLocations;
    function getCreateLocationDialog($scope, $dialog) {
        return Fabric.getCreateLocationDialog($dialog, {
            selectedContainers: function () {
                return $scope.selectedContainers;
            },
            callbacks: function () {
                return {
                    success: function (response) {
                        Core.$apply($scope);
                    },
                    error: function (response) {
                        Core.$apply($scope);
                    }
                };
            }
        });
    }
    ContainerHelpers.getCreateLocationDialog = getCreateLocationDialog;
    function buildLocationMenu($scope, jolokia, locations) {
        var locationMenu = {
            icon: 'icon-location-arrow',
            title: 'Set Location',
            items: []
        };
        var menuItems = [];
        locations.forEach(function (location) {
            menuItems.push({
                title: location,
                action: function () {
                    $scope.selectedContainers.forEach(function (container) {
                        var arg = location;
                        if (arg === ContainerHelpers.NO_LOCATION) {
                            arg = "";
                        }
                        Fabric.setContainerProperty(jolokia, container.id, 'location', arg, function () {
                            Core.$apply($scope);
                        }, function () {
                            Core.$apply($scope);
                        });
                    });
                }
            });
        });
        menuItems.push({
            title: "New...",
            action: function () {
                $scope.createLocationDialog.open();
            }
        });
        locationMenu.items = menuItems;
        return locationMenu;
    }
    ContainerHelpers.buildLocationMenu = buildLocationMenu;
    function isCurrentContainer(container) {
        if (!container) {
            return false;
        }
        if (Core.isBlank(Fabric.currentContainerId)) {
            return false;
        }
        if (angular.isObject(container)) {
            return container['id'] === Fabric.currentContainerId;
        }
        if (angular.isString(container)) {
            return container === Fabric.currentContainerId;
        }
        return false;
    }
    ContainerHelpers.isCurrentContainer = isCurrentContainer;
    ;
    function canConnect(container) {
        if (!container) {
            return false;
        }
        if (Core.isBlank(container['jolokiaUrl'])) {
            return false;
        }
        if (!Core.parseBooleanValue(container['alive'])) {
            return false;
        }
        return true;
    }
    ContainerHelpers.canConnect = canConnect;
    ;
    function statusTitle(container) {
        var answer = 'Alive';
        if (!container.alive) {
            answer = 'Not Running';
        }
        else {
            answer += ' - ' + Core.humanizeValue(container.provisionResult);
        }
        return answer;
    }
    ContainerHelpers.statusTitle = statusTitle;
    function statusIcon(row) {
        if (row) {
            switch (row.provisionResult) {
                case 'success':
                    if (row.alive) {
                        return "green icon-play-circle";
                    }
                    else {
                        return "orange icon-off";
                    }
                case 'downloading':
                    return "icon-download-alt";
                case 'installing':
                    return "icon-hdd";
                case 'analyzing':
                case 'finalizing':
                    return "icon-refresh icon-spin";
                case 'resolving':
                    return "icon-sitemap";
                case 'error':
                    return "red icon-warning-sign";
            }
            if (!row.alive) {
                return "orange icon-off";
            }
        }
        return "icon-refresh icon-spin";
    }
    ContainerHelpers.statusIcon = statusIcon;
    function gotoContainer($location, container) {
        $location.path('/fabric/container/' + container.id);
    }
    ContainerHelpers.gotoContainer = gotoContainer;
    function doDeleteContainer($scope, jolokia, name, onDelete) {
        if (onDelete === void 0) { onDelete = null; }
        Fabric.destroyContainer(jolokia, name, function () {
            if (onDelete) {
                onDelete();
            }
            Core.$apply($scope);
        });
    }
    ContainerHelpers.doDeleteContainer = doDeleteContainer;
    function doStartContainer($scope, jolokia, name) {
        if ($scope.fabricVerboseNotifications) {
            Core.notification('info', "Starting " + name);
        }
        Fabric.startContainer(jolokia, name, function () {
            Core.$apply($scope);
        });
    }
    ContainerHelpers.doStartContainer = doStartContainer;
    function doStopContainer($scope, jolokia, name) {
        if ($scope.fabricVerboseNotifications) {
            Core.notification('info', "Stopping " + name);
        }
        Fabric.stopContainer(jolokia, name, function () {
            Core.$apply($scope);
        });
    }
    ContainerHelpers.doStopContainer = doStopContainer;
    function stopContainers($scope, jolokia, c) {
        c.forEach(function (c) { return doStopContainer($scope, jolokia, c.id); });
    }
    ContainerHelpers.stopContainers = stopContainers;
    function startContainers($scope, jolokia, c) {
        c.forEach(function (c) { return doStartContainer($scope, jolokia, c.id); });
    }
    ContainerHelpers.startContainers = startContainers;
    function anyStartable(containers) {
        return containers.length > 0 && containers.any(function (container) {
            var answer = false;
            if (!container.alive) {
                answer = true;
                switch (container.provisionResult) {
                    case 'downloading':
                    case 'installing':
                    case 'analyzing':
                    case 'finalizing':
                    case 'resolving':
                        answer = false;
                }
            }
            return answer;
        });
    }
    ContainerHelpers.anyStartable = anyStartable;
    function anyStoppable(containers) {
        return containers.length > 0 && containers.any(function (c) { return c.alive === true; });
    }
    ContainerHelpers.anyStoppable = anyStoppable;
    function allAlive(containers, state) {
        if (state === void 0) { state = true; }
        return containers.length > 0 && containers.every(function (c) { return c.alive === state; });
    }
    ContainerHelpers.allAlive = allAlive;
    function decorate($scope, $location, jolokia) {
        if ($scope.containerHelpersAdded) {
            return;
        }
        $scope.containerHelpersAdded = true;
        $scope.isCurrentContainer = isCurrentContainer;
        $scope.canConnect = canConnect;
        $scope.getStatusTitle = statusTitle;
        $scope.showContainer = function (container) {
            gotoContainer($location, container);
        };
        $scope.statusIcon = statusIcon;
        $scope.everySelectionAlive = function (state) {
            return allAlive($scope.selectedContainers, state);
        };
        $scope.anySelectionStartable = function () {
            return anyStartable($scope.selectedContainers);
        };
        $scope.anySelectionStoppable = function () {
            return anyStoppable($scope.selectedContainers);
        };
        $scope.startContainer = function (name) {
            doStartContainer($scope, jolokia, name);
        };
        $scope.stopContainer = function (name) {
            doStopContainer($scope, jolokia, name);
        };
        $scope.startSelectedContainers = function () {
            startContainers($scope, jolokia, $scope.selectedContainers);
        };
        $scope.stopSelectedContainers = function () {
            stopContainers($scope, jolokia, $scope.selectedContainers);
        };
    }
    ContainerHelpers.decorate = decorate;
})(ContainerHelpers || (ContainerHelpers = {}));
var Fabric;
(function (Fabric) {
    function getResolvers(id) {
        var answer;
        switch (id) {
            case 'child':
                answer = [];
                break;
            case 'ssh':
                answer = ['localip', 'localhostname', 'publicip', 'publichostname', 'manualip'];
                break;
            case 'jclouds':
                answer = ['localip', 'localhostname', 'publicip', 'publichostname', 'manualip'];
                break;
            case 'openshift':
                answer = [];
                break;
            case 'docker':
                answer = [];
                break;
        }
        return answer;
    }
    Fabric.getResolvers = getResolvers;
    function customizeSchema(id, schema) {
        Core.pathSet(schema, ["properties", "name", "required"], true);
        Core.pathSet(schema, ['properties', 'name', 'input-attributes', 'ng-pattern'], "/^[a-z0-9_-]*$/");
        delete schema.properties['metadataMap'];
        delete schema.properties['zookeeperUrl'];
        delete schema.properties['zookeeperPassword'];
        delete schema.properties['globalResolver'];
        delete schema.properties['zooKeeperServerPort'];
        delete schema.properties['zooKeeperServerConnectionPort'];
        delete schema.properties['agentEnabled'];
        delete schema.properties['autoImportEnabled'];
        delete schema.properties['importPath'];
        delete schema.properties['users'];
        delete schema.properties['systemProperties'];
        ['zooKeeperServerInitLimit', 'zooKeeperServerTickTime', 'zooKeeperServerSyncLimit', 'zooKeeperServerDataDir', 'waitForProvision', 'ensembleStart', 'migrationTimeout', 'dataStoreProperties'].forEach(function (attr) {
            Core.pathSet(schema, ['properties', attr, 'control-attributes', 'ng-show'], 'entity.ensembleServer');
        });
        Core.pathSet(schema, ['properties', 'providerType', 'type'], 'hidden');
        Core.pathSet(schema, ['properties', 'profiles', 'type'], 'hidden');
        Core.pathSet(schema, ['properties', 'version', 'type'], 'hidden');
        Core.pathSet(schema.properties, ['name', 'label'], 'Container Name');
        Core.pathSet(schema.properties, ['name', 'container-name-available'], 'true');
        Core.pathSet(schema.properties, ['name', 'tooltip'], 'Name of the container to create (or prefix of the container name if you create multiple containers)');
        Core.pathSet(schema.properties, ['number', 'label'], 'Number of containers');
        Core.pathSet(schema.properties, ['number', 'tooltip'], 'The number of containers to create; when set higher than 1 a number will be appended to each container name. Max value: 99');
        Core.pathSet(schema.properties, ['number', 'input-attributes', 'min'], '1');
        Core.pathSet(schema.properties, ['number', 'input-attributes', 'max'], '99');
        Core.pathSet(schema.properties, ['number', 'input-attributes', 'ng-pattern'], "/^[1-9][0-9]?$/");
        Core.pathSet(schema.properties, ['number', 'required'], true);
        Core.pathSet(schema.properties, ['login', 'input-attributes', "autofill"], "true");
        Core.pathSet(schema.properties, ['password', 'input-attributes', "autofill"], "true");
        Core.pathSet(schema.properties, ['jmxUser', 'input-attributes', "autofill"], "true");
        Core.pathSet(schema.properties, ['jmxUser', 'tooltip'], 'The username for connecting to the container using JMX');
        Core.pathSet(schema.properties, ['jmxPassword', 'input-attributes', "autofill"], "true");
        Core.pathSet(schema.properties, ['jmxPassword', 'tooltip'], 'The password for connecting to the container using JMX');
        Core.pathSet(schema.properties, ['resolver', 'input-element'], "select");
        Core.pathSet(schema.properties, ['resolver', 'input-attributes', "ng-options"], "r for r in resolvers");
        switch (id) {
            case 'child':
                delete schema.properties['manualIp'];
                delete schema.properties['preferredAddress'];
                delete schema.properties['resolver'];
                delete schema.properties['ensembleServer'];
                delete schema.properties['proxyUri'];
                delete schema.properties['adminAccess'];
                delete schema.properties['minimumPort'];
                delete schema.properties['maximumPort'];
                schema.properties['jmxPassword']['type'] = 'password';
                Core.pathSet(schema.properties, ['parent', 'label'], 'Parent Container');
                Core.pathSet(schema.properties, ['parent', 'tooltip'], 'The name of the parent container used to create the child container');
                Core.pathSet(schema.properties, ['parent', 'input-element'], "select");
                Core.pathSet(schema.properties, ['parent', 'input-attributes', "ng-options"], "c for c in child.rootContainers");
                bulkSet(schema, ["jmxUser", "jmxPassword", "parent"], 'required', true);
                schema['tabs'] = {
                    'Common': ['name', 'parent', 'jmxUser', 'jmxPassword', 'number'],
                    'Advanced': ['*']
                };
                break;
            case 'ssh':
                delete schema.properties['jmxUser'];
                delete schema.properties['jmxPassword'];
                delete schema.properties['parent'];
                bulkSet(schema, ['host'], 'required', true);
                Core.pathSet(schema.properties, ['password', 'type'], 'password');
                schema['tabs'] = {
                    'Common': ['name', 'host', 'port', 'username', 'password', 'privateKeyFile', 'passPhrase'],
                    'Advanced': ['*']
                };
                break;
            case 'jclouds':
                delete schema.properties['jmxUser'];
                delete schema.properties['jmxPassword'];
                delete schema.properties['parent'];
                schema['tabs'] = {
                    'Common': ['name', 'owner', 'credential', 'providerName', 'imageId', 'hardwareId', 'locationId', 'number', 'instanceType'],
                    'Advanced': ['*']
                };
                break;
            case 'openshift':
                delete schema.properties['jmxUser'];
                delete schema.properties['jmxPassword'];
                delete schema.properties['parent'];
                delete schema.properties['manualIp'];
                delete schema.properties['preferredAddress'];
                delete schema.properties['ensembleServer'];
                delete schema.properties['proxyUri'];
                delete schema.properties['adminAccess'];
                delete schema.properties['path'];
                delete schema.properties['bindAddress'];
                delete schema.properties['hostNameContext'];
                delete schema.properties['resolver'];
                Core.pathSet(schema.properties, ['resolver', 'default'], 'publichostname');
                Core.pathSet(schema.properties, ['serverUrl', 'label'], 'OpenShift Broker');
                Core.pathSet(schema.properties, ['serverUrl', 'tooltip'], 'The OpenShift broker host name of the cloud to create the container inside. This is either the URL for your local OpenShift Enterprise installation, or its the public OpenShift online URL: openshift.redhat.com');
                Core.pathSet(schema.properties, ['login', 'label'], 'OpenShift Login');
                Core.pathSet(schema.properties, ['login', 'tooltip'], 'Your personal login to the OpenShift portal');
                Core.pathSet(schema.properties, ['login', 'input-attributes', "autofill"], "true");
                Core.pathSet(schema.properties, ['password', 'label'], 'OpenShift Password');
                Core.pathSet(schema.properties, ['password', 'tooltip'], 'Your personal password on the OpenShift portal');
                Core.pathSet(schema.properties, ['password', 'type'], 'password');
                Core.pathSet(schema.properties, ['name', 'input-attributes', 'ng-pattern'], "/^[a-z0-9]*$/");
                Core.pathSet(schema.properties, ['tryLogin', 'type'], 'string');
                Core.pathSet(schema.properties, ['tryLogin', 'input-attributes', "ng-model"], "openShift.tryLogin");
                Core.pathSet(schema.properties, ['tryLogin', 'label'], 'Authenticate');
                Core.pathSet(schema.properties, ['tryLogin', 'tooltip'], 'Authenticate with the OpenShift Broker using your login and password');
                Core.pathSet(schema.properties, ['tryLogin', 'formTemplate'], '<a ng-click="openShift.login()" ng-disabled="!entity.login || !entity.password || !entity.serverUrl" ' + 'title="Test you entered the correct OpenShift Broker, login and password" class="btn btn-primary">Login to OpenShift</a>' + '<div class="alert" ng-show="openShift.loginFailed" ' + 'title="Are you sure you correctly entered the OpenShift Broker, login and password correctly?">Login failed</div>');
                Core.pathSet(schema.properties, ['domain', 'label'], 'OpenShift Domain');
                Core.pathSet(schema.properties, ['domain', 'tooltip'], 'What is your unique domain name used for applications you create on OpenShift. Often this is your own user name or group name');
                Core.pathSet(schema.properties, ['domain', 'input-element'], "select");
                Core.pathSet(schema.properties, ['domain', 'input-attributes', "ng-options"], "c for c in openShift.domains");
                Core.pathSet(schema.properties, ['gearProfile', 'tooltip'], 'Which kind of gear to create');
                Core.pathSet(schema.properties, ['gearProfile', 'input-element'], "select");
                Core.pathSet(schema.properties, ['gearProfile', 'input-attributes', "ng-options"], "c for c in openShift.gearProfiles");
                bulkSet(schema, ['serverUrl', 'login', 'password', 'domain'], 'required', true);
                schema['tabs'] = {
                    'Common': ['name', 'serverUrl', 'login', 'password', 'tryLogin', 'domain', 'gearProfile', 'number'],
                    'Advanced': ['environmentalVariables', 'jvmOpts', '*']
                };
                break;
            case 'docker':
                delete schema.properties['jmxUser'];
                delete schema.properties['jmxPassword'];
                delete schema.properties['parent'];
                delete schema.properties['manualIp'];
                delete schema.properties['preferredAddress'];
                delete schema.properties['resolver'];
                delete schema.properties['ensembleServer'];
                delete schema.properties['proxyUri'];
                delete schema.properties['adminAccess'];
                delete schema.properties['path'];
                delete schema.properties['bindAddress'];
                delete schema.properties['hostNameContext'];
                schema['tabs'] = {
                    'Common': ['name', 'number'],
                    'Advanced': ['environmentalVariables', 'jvmOpts', '*']
                };
                break;
            case 'kubernetes':
                delete schema.properties['jmxUser'];
                delete schema.properties['jmxPassword'];
                delete schema.properties['parent'];
                delete schema.properties['manualIp'];
                delete schema.properties['preferredAddress'];
                delete schema.properties['resolver'];
                delete schema.properties['ensembleServer'];
                delete schema.properties['proxyUri'];
                delete schema.properties['adminAccess'];
                delete schema.properties['path'];
                delete schema.properties['bindAddress'];
                delete schema.properties['hostNameContext'];
                schema['tabs'] = {
                    'Common': ['name', 'number'],
                    'Advanced': ['environmentalVariables', 'jvmOpts', '*']
                };
                break;
            default:
        }
        return schema;
    }
    Fabric.customizeSchema = customizeSchema;
    function bulkSet(schema, properties, field, value) {
        properties.each(function (name) {
            Core.pathSet(schema, ['properties', name, field], value);
        });
    }
    function setGlobalResolverEnum(schema) {
        var globalResolverEnum = ['localip', 'localhostname', 'publicip', 'publichostname'];
        Core.pathSet(schema, ['properties', 'globalResolver', 'enum'], globalResolverEnum);
    }
})(Fabric || (Fabric = {}));
var Git;
(function (Git) {
    function createGitRepository(workspace, jolokia, localStorage) {
        var mbean = getGitMBean(workspace);
        if (mbean && jolokia) {
            return new Git.JolokiaGit(mbean, jolokia, localStorage, workspace.userDetails);
        }
        return null;
    }
    Git.createGitRepository = createGitRepository;
    Git.jmxDomain = "hawtio";
    Git.mbeanType = "GitFacade";
    function hasGit(workspace) {
        return getGitMBean(workspace) !== null;
    }
    Git.hasGit = hasGit;
    function getGitMBean(workspace) {
        return Core.getMBeanTypeObjectName(workspace, Git.jmxDomain, Git.mbeanType);
    }
    Git.getGitMBean = getGitMBean;
    function getGitMBeanFolder(workspace) {
        return Core.getMBeanTypeFolder(workspace, Git.jmxDomain, Git.mbeanType);
    }
    Git.getGitMBeanFolder = getGitMBeanFolder;
    function isGitMBeanFabric(workspace) {
        var folder = getGitMBeanFolder(workspace);
        return folder && folder.entries["repo"] === "fabric";
    }
    Git.isGitMBeanFabric = isGitMBeanFabric;
})(Git || (Git = {}));
var UI;
(function (UI) {
    var Dialog = (function () {
        function Dialog() {
            this.show = false;
            this.options = {
                backdropFade: true,
                dialogFade: true
            };
        }
        Dialog.prototype.open = function () {
            this.show = true;
        };
        Dialog.prototype.close = function () {
            this.show = false;
            this.removeBackdropFadeDiv();
            setTimeout(this.removeBackdropFadeDiv, 100);
        };
        Dialog.prototype.removeBackdropFadeDiv = function () {
            $("div.modal-backdrop").remove();
        };
        return Dialog;
    })();
    UI.Dialog = Dialog;
    function multiItemConfirmActionDialog(options) {
        var $dialog = Core.injector.get("$dialog");
        return $dialog.dialog({
            resolve: {
                options: function () {
                    return options;
                }
            },
            templateUrl: 'app/ui/html/multiItemConfirmActionDialog.html',
            controller: ["$scope", "dialog", "options", function ($scope, dialog, options) {
                $scope.options = options;
                $scope.close = function (result) {
                    dialog.close();
                    options.onClose(result);
                };
            }]
        });
    }
    UI.multiItemConfirmActionDialog = multiItemConfirmActionDialog;
})(UI || (UI = {}));
var Git;
(function (Git) {
    var JolokiaGit = (function () {
        function JolokiaGit(mbean, jolokia, localStorage, userDetails, branch) {
            if (branch === void 0) { branch = "master"; }
            this.mbean = mbean;
            this.jolokia = jolokia;
            this.localStorage = localStorage;
            this.userDetails = userDetails;
            this.branch = branch;
        }
        JolokiaGit.prototype.getRepositoryLabel = function (fn, error) {
            return this.jolokia.request({ type: "read", mbean: this.mbean, attribute: ["RepositoryLabel"] }, onSuccess(function (result) {
                fn(result.value.RepositoryLabel);
            }, { error: error }));
        };
        JolokiaGit.prototype.exists = function (branch, path, fn) {
            var result;
            if (angular.isDefined(fn) && fn) {
                result = this.jolokia.execute(this.mbean, "exists", branch, path, onSuccess(fn));
            }
            else {
                result = this.jolokia.execute(this.mbean, "exists", branch, path);
            }
            if (angular.isDefined(result) && result) {
                return true;
            }
            else {
                return false;
            }
        };
        JolokiaGit.prototype.read = function (branch, path, fn) {
            return this.jolokia.execute(this.mbean, "read", branch, path, onSuccess(fn));
        };
        JolokiaGit.prototype.write = function (branch, path, commitMessage, contents, fn) {
            var authorName = this.getUserName();
            var authorEmail = this.getUserEmail();
            return this.jolokia.execute(this.mbean, "write", branch, path, commitMessage, authorName, authorEmail, contents, onSuccess(fn));
        };
        JolokiaGit.prototype.writeBase64 = function (branch, path, commitMessage, contents, fn) {
            var authorName = this.getUserName();
            var authorEmail = this.getUserEmail();
            return this.jolokia.execute(this.mbean, "writeBase64", branch, path, commitMessage, authorName, authorEmail, contents, onSuccess(fn));
        };
        JolokiaGit.prototype.createDirectory = function (branch, path, commitMessage, fn) {
            var authorName = this.getUserName();
            var authorEmail = this.getUserEmail();
            return this.jolokia.execute(this.mbean, "createDirectory", branch, path, commitMessage, authorName, authorEmail, onSuccess(fn));
        };
        JolokiaGit.prototype.revertTo = function (branch, objectId, blobPath, commitMessage, fn) {
            var authorName = this.getUserName();
            var authorEmail = this.getUserEmail();
            return this.jolokia.execute(this.mbean, "revertTo", branch, objectId, blobPath, commitMessage, authorName, authorEmail, onSuccess(fn));
        };
        JolokiaGit.prototype.rename = function (branch, oldPath, newPath, commitMessage, fn) {
            var authorName = this.getUserName();
            var authorEmail = this.getUserEmail();
            return this.jolokia.execute(this.mbean, "rename", branch, oldPath, newPath, commitMessage, authorName, authorEmail, onSuccess(fn));
        };
        JolokiaGit.prototype.remove = function (branch, path, commitMessage, fn) {
            var authorName = this.getUserName();
            var authorEmail = this.getUserEmail();
            return this.jolokia.execute(this.mbean, "remove", branch, path, commitMessage, authorName, authorEmail, onSuccess(fn));
        };
        JolokiaGit.prototype.completePath = function (branch, completionText, directoriesOnly, fn) {
            return this.jolokia.execute(this.mbean, "completePath", branch, completionText, directoriesOnly, onSuccess(fn));
        };
        JolokiaGit.prototype.history = function (branch, objectId, path, limit, fn) {
            return this.jolokia.execute(this.mbean, "history", branch, objectId, path, limit, onSuccess(fn));
        };
        JolokiaGit.prototype.commitTree = function (commitId, fn) {
            return this.jolokia.execute(this.mbean, "getCommitTree", commitId, onSuccess(fn));
        };
        JolokiaGit.prototype.commitInfo = function (commitId, fn) {
            return this.jolokia.execute(this.mbean, "getCommitInfo", commitId, onSuccess(fn));
        };
        JolokiaGit.prototype.diff = function (objectId, baseObjectId, path, fn) {
            return this.jolokia.execute(this.mbean, "diff", objectId, baseObjectId, path, onSuccess(fn));
        };
        JolokiaGit.prototype.getContent = function (objectId, blobPath, fn) {
            return this.jolokia.execute(this.mbean, "getContent", objectId, blobPath, onSuccess(fn));
        };
        JolokiaGit.prototype.readJsonChildContent = function (path, nameWildcard, search, fn) {
            return this.jolokia.execute(this.mbean, "readJsonChildContent", this.branch, path, nameWildcard, search, onSuccess(fn));
        };
        JolokiaGit.prototype.branches = function (fn) {
            return this.jolokia.execute(this.mbean, "branches", onSuccess(fn));
        };
        JolokiaGit.prototype.getUserName = function () {
            return this.localStorage["gitUserName"] || this.userDetails.username || "anonymous";
        };
        JolokiaGit.prototype.getUserEmail = function () {
            return this.localStorage["gitUserEmail"] || "anonymous@gmail.com";
        };
        return JolokiaGit;
    })();
    Git.JolokiaGit = JolokiaGit;
})(Git || (Git = {}));
var PluginHelpers;
(function (PluginHelpers) {
    function createControllerFunction(_module, pluginName) {
        return function (name, inlineAnnotatedConstructor) {
            return _module.controller(pluginName + '.' + name, inlineAnnotatedConstructor);
        };
    }
    PluginHelpers.createControllerFunction = createControllerFunction;
    function createRoutingFunction(templateUrl) {
        return function (templateName, reloadOnSearch) {
            if (reloadOnSearch === void 0) { reloadOnSearch = true; }
            return {
                templateUrl: UrlHelpers.join(templateUrl, templateName),
                reloadOnSearch: reloadOnSearch
            };
        };
    }
    PluginHelpers.createRoutingFunction = createRoutingFunction;
})(PluginHelpers || (PluginHelpers = {}));
var DockerRegistry;
(function (DockerRegistry) {
    DockerRegistry.context = '/docker-registry';
    DockerRegistry.hash = UrlHelpers.join('#', DockerRegistry.context);
    DockerRegistry.defaultRoute = UrlHelpers.join(DockerRegistry.hash, 'list');
    DockerRegistry.basePath = UrlHelpers.join('app', DockerRegistry.context);
    DockerRegistry.templatePath = UrlHelpers.join(DockerRegistry.basePath, 'html');
    DockerRegistry.pluginName = 'DockerRegistry';
    DockerRegistry.log = Logger.get(DockerRegistry.pluginName);
    DockerRegistry.SEARCH_FRAGMENT = '/v1/search';
    function getDockerImageRepositories(callback) {
        var DockerRegistryRestURL = Core.injector.get("DockerRegistryRestURL");
        var $http = Core.injector.get("$http");
        DockerRegistryRestURL.then(function (restURL) {
            $http.get(UrlHelpers.join(restURL, DockerRegistry.SEARCH_FRAGMENT)).success(function (data) {
                callback(restURL, data);
            }).error(function (data) {
                DockerRegistry.log.debug("Error fetching image repositories:", data);
                callback(restURL, null);
            });
        });
    }
    DockerRegistry.getDockerImageRepositories = getDockerImageRepositories;
    function completeDockerRegistry() {
        var $q = Core.injector.get("$q");
        var $rootScope = Core.injector.get("$rootScope");
        var deferred = $q.defer();
        getDockerImageRepositories(function (restURL, repositories) {
            if (repositories && repositories.results) {
                var results = repositories.results;
                results = results.sortBy(function (res) {
                    return res.name;
                }).first(15);
                results = results.map(function (res) {
                    return res.name;
                });
                deferred.resolve(results);
            }
            else {
                deferred.reject([]);
            }
        });
        return deferred.promise;
    }
    DockerRegistry.completeDockerRegistry = completeDockerRegistry;
})(DockerRegistry || (DockerRegistry = {}));
var Wiki;
(function (Wiki) {
    Wiki.log = Logger.get("Wiki");
    Wiki.camelNamespaces = ["http://camel.apache.org/schema/spring", "http://camel.apache.org/schema/blueprint"];
    Wiki.springNamespaces = ["http://www.springframework.org/schema/beans"];
    Wiki.droolsNamespaces = ["http://drools.org/schema/drools-spring"];
    Wiki.dozerNamespaces = ["http://dozer.sourceforge.net"];
    Wiki.activemqNamespaces = ["http://activemq.apache.org/schema/core"];
    Wiki.excludeAdjustmentPrefixes = ["http://", "https://", "#"];
    (function (ViewMode) {
        ViewMode[ViewMode["List"] = 0] = "List";
        ViewMode[ViewMode["Icon"] = 1] = "Icon";
    })(Wiki.ViewMode || (Wiki.ViewMode = {}));
    var ViewMode = Wiki.ViewMode;
    ;
    Wiki.customWikiViewPages = ["/formTable", "/camel/diagram", "/camel/canvas", "/camel/properties", "/dozer/mappings"];
    Wiki.hideExtensions = [".profile"];
    var defaultFileNamePattern = /^[a-zA-Z0-9._-]*$/;
    var defaultFileNamePatternInvalid = "Name must be: letters, numbers, and . _ or - characters";
    var defaultFileNameExtensionPattern = "";
    var defaultLowerCaseFileNamePattern = /^[a-z0-9._-]*$/;
    var defaultLowerCaseFileNamePatternInvalid = "Name must be: lower-case letters, numbers, and . _ or - characters";
    Wiki.documentTemplates = [
        {
            label: "Folder",
            tooltip: "Create a new folder to contain documents",
            folder: true,
            icon: "/img/icons/wiki/folder.gif",
            exemplar: "myfolder",
            regex: defaultLowerCaseFileNamePattern,
            invalid: defaultLowerCaseFileNamePatternInvalid
        },
        {
            label: "App",
            tooltip: "Creates a new App folder used to configure and run containers",
            addClass: "icon-cog green",
            exemplar: 'myapp',
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            extension: '',
            generated: {
                mbean: ['io.fabric8', { type: 'KubernetesTemplateManager' }],
                init: function (workspace, $scope) {
                },
                generate: function (options) {
                    Wiki.log.debug("Got options: ", options);
                    options.form.name = options.name;
                    options.form.path = options.parentId;
                    options.form.branch = options.branch;
                    var json = angular.toJson(options.form);
                    var jolokia = Core.injector.get("jolokia");
                    jolokia.request({
                        type: 'exec',
                        mbean: 'io.fabric8:type=KubernetesTemplateManager',
                        operation: 'createAppByJson',
                        arguments: [json]
                    }, onSuccess(function (response) {
                        Wiki.log.debug("Generated app, response: ", response);
                        options.success(undefined);
                    }, {
                        error: function (response) {
                            options.error(response.error);
                        }
                    }));
                },
                form: function (workspace, $scope) {
                    if (!$scope.doDockerRegistryCompletion) {
                        $scope.fetchDockerRepositories = function () {
                            return DockerRegistry.completeDockerRegistry();
                        };
                    }
                    return {
                        summaryMarkdown: 'Add app summary here',
                        replicaCount: 1
                    };
                },
                schema: {
                    description: 'App settings',
                    type: 'java.lang.String',
                    properties: {
                        'dockerImage': {
                            'description': 'Docker Image',
                            'type': 'java.lang.String',
                            'input-attributes': {
                                'required': '',
                                'class': 'input-xlarge',
                                'typeahead': 'repo for repo in fetchDockerRepositories() | filter:$viewValue',
                                'typeahead-wait-ms': '200'
                            }
                        },
                        'summaryMarkdown': {
                            'description': 'Short Description',
                            'type': 'java.lang.String',
                            'input-attributes': { 'class': 'input-xlarge' }
                        },
                        'replicaCount': {
                            'description': 'Replica Count',
                            'type': 'java.lang.Integer',
                            'input-attributes': {
                                min: '0'
                            }
                        },
                        'labels': {
                            'description': 'Labels',
                            'type': 'map',
                            'items': {
                                'type': 'string'
                            }
                        }
                    }
                }
            }
        },
        {
            label: "Fabric8 Profile",
            tooltip: "Create a new empty fabric profile. Using a hyphen ('-') will create a folder heirarchy, for example 'my-awesome-profile' will be available via the path 'my/awesome/profile'.",
            profile: true,
            addClass: "icon-book green",
            exemplar: "user-profile",
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            fabricOnly: true
        },
        {
            label: "Properties File",
            tooltip: "A properties file typically used to configure Java classes",
            exemplar: "properties-file.properties",
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            extension: ".properties"
        },
        {
            label: "JSON File",
            tooltip: "A file containing JSON data",
            exemplar: "document.json",
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            extension: ".json"
        },
        {
            label: "Key Store File",
            tooltip: "Creates a keystore (database) of cryptographic keys, X.509 certificate chains, and trusted certificates.",
            exemplar: 'keystore.jks',
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            extension: ".jks",
            generated: {
                mbean: ['hawtio', { type: 'KeystoreService' }],
                init: function (workspace, $scope) {
                    var mbean = 'hawtio:type=KeystoreService';
                    var response = workspace.jolokia.request({ type: "read", mbean: mbean, attribute: "SecurityProviderInfo" }, {
                        success: function (response) {
                            $scope.securityProviderInfo = response.value;
                            Core.$apply($scope);
                        },
                        error: function (response) {
                            console.log('Could not find the supported security algorithms: ', response.error);
                            Core.$apply($scope);
                        }
                    });
                },
                generate: function (options) {
                    var encodedForm = JSON.stringify(options.form);
                    var mbean = 'hawtio:type=KeystoreService';
                    var response = options.workspace.jolokia.request({
                        type: 'exec',
                        mbean: mbean,
                        operation: 'createKeyStoreViaJSON(java.lang.String)',
                        arguments: [encodedForm]
                    }, {
                        method: 'POST',
                        success: function (response) {
                            options.success(response.value);
                        },
                        error: function (response) {
                            options.error(response.error);
                        }
                    });
                },
                form: function (workspace, $scope) {
                    return {
                        storeType: $scope.securityProviderInfo.supportedKeyStoreTypes[0],
                        createPrivateKey: false,
                        keyLength: 4096,
                        keyAlgorithm: $scope.securityProviderInfo.supportedKeyAlgorithms[0],
                        keyValidity: 365
                    };
                },
                schema: {
                    "description": "Keystore Settings",
                    "type": "java.lang.String",
                    "properties": {
                        "storePassword": {
                            "description": "Keystore password.",
                            "type": "password",
                            'input-attributes': { "required": "", "ng-minlength": 6 }
                        },
                        "storeType": {
                            "description": "The type of store to create",
                            "type": "java.lang.String",
                            'input-element': "select",
                            'input-attributes': { "ng-options": "v for v in securityProviderInfo.supportedKeyStoreTypes" }
                        },
                        "createPrivateKey": {
                            "description": "Should we generate a self-signed private key?",
                            "type": "boolean"
                        },
                        "keyCommonName": {
                            "description": "The common name of the key, typically set to the hostname of the server",
                            "type": "java.lang.String",
                            'control-group-attributes': { 'ng-show': "formData.createPrivateKey" }
                        },
                        "keyLength": {
                            "description": "The length of the cryptographic key",
                            "type": "Long",
                            'control-group-attributes': { 'ng-show': "formData.createPrivateKey" }
                        },
                        "keyAlgorithm": {
                            "description": "The key algorithm",
                            "type": "java.lang.String",
                            'input-element': "select",
                            'input-attributes': { "ng-options": "v for v in securityProviderInfo.supportedKeyAlgorithms" },
                            'control-group-attributes': { 'ng-show': "formData.createPrivateKey" }
                        },
                        "keyValidity": {
                            "description": "The number of days the key will be valid for",
                            "type": "Long",
                            'control-group-attributes': { 'ng-show': "formData.createPrivateKey" }
                        },
                        "keyPassword": {
                            "description": "Password to the private key",
                            "type": "password",
                            'control-group-attributes': { 'ng-show': "formData.createPrivateKey" }
                        }
                    }
                }
            }
        },
        {
            label: "Markdown Document",
            tooltip: "A basic markup document using the Markdown wiki markup, particularly useful for ReadMe files in directories",
            exemplar: "ReadMe.md",
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            extension: ".md"
        },
        {
            label: "Text Document",
            tooltip: "A plain text file",
            exemplar: "document.text",
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            extension: ".txt"
        },
        {
            label: "HTML Document",
            tooltip: "A HTML document you can edit directly using the HTML markup",
            exemplar: "document.html",
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            extension: ".html"
        },
        {
            label: "XML Document",
            tooltip: "An empty XML document",
            exemplar: "document.xml",
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            extension: ".xml"
        },
        {
            label: "Integration Flows",
            tooltip: "Camel routes for defining your integration flows",
            children: [
                {
                    label: "Camel XML document",
                    tooltip: "A vanilla Camel XML document for integration flows",
                    icon: "/img/icons/camel.svg",
                    exemplar: "camel.xml",
                    regex: defaultFileNamePattern,
                    invalid: defaultFileNamePatternInvalid,
                    extension: ".xml"
                },
                {
                    label: "Camel OSGi Blueprint XML document",
                    tooltip: "A vanilla Camel XML document for integration flows when using OSGi Blueprint",
                    icon: "/img/icons/camel.svg",
                    exemplar: "camel-blueprint.xml",
                    regex: defaultFileNamePattern,
                    invalid: defaultFileNamePatternInvalid,
                    extension: ".xml"
                },
                {
                    label: "Camel Spring XML document",
                    tooltip: "A vanilla Camel XML document for integration flows when using the Spring framework",
                    icon: "/img/icons/camel.svg",
                    exemplar: "camel-spring.xml",
                    regex: defaultFileNamePattern,
                    invalid: defaultFileNamePatternInvalid,
                    extension: ".xml"
                }
            ]
        },
        {
            label: "Data Mapping Document",
            tooltip: "Dozer based configuration of mapping documents",
            icon: "/img/icons/dozer/dozer.gif",
            exemplar: "dozer-mapping.xml",
            regex: defaultFileNamePattern,
            invalid: defaultFileNamePatternInvalid,
            extension: ".xml"
        }
    ];
    function isWikiEnabled(workspace, jolokia, localStorage) {
        return Git.createGitRepository(workspace, jolokia, localStorage) !== null;
    }
    Wiki.isWikiEnabled = isWikiEnabled;
    function goToLink(link, $timeout, $location) {
        var href = Core.trimLeading(link, "#");
        $timeout(function () {
            Wiki.log.debug("About to navigate to: " + href);
            $location.url(href);
        }, 100);
    }
    Wiki.goToLink = goToLink;
    function customViewLinks($scope) {
        var branch = $scope.branch;
        var prefix = Core.trimLeading(Wiki.startLink(branch), "#");
        return Wiki.customWikiViewPages.map(function (path) { return prefix + path; });
    }
    Wiki.customViewLinks = customViewLinks;
    function createWizardTree(workspace, $scope) {
        var root = new Folder("New Documents");
        addCreateWizardFolders(workspace, $scope, root, Wiki.documentTemplates);
        return root;
    }
    Wiki.createWizardTree = createWizardTree;
    function addCreateWizardFolders(workspace, $scope, parent, templates) {
        angular.forEach(templates, function (template) {
            if (template['fabricOnly'] && !Fabric.hasFabric(workspace)) {
                return;
            }
            if (template.generated) {
                if (template.generated.mbean) {
                    var exists = workspace.treeContainsDomainAndProperties.apply(workspace, template.generated.mbean);
                    if (!exists) {
                        return;
                    }
                }
                if (template.generated.init) {
                    template.generated.init(workspace, $scope);
                }
            }
            var title = template.label || key;
            var node = new Folder(title);
            node.parent = parent;
            node.entity = template;
            var addClass = template.addClass;
            if (addClass) {
                node.addClass = addClass;
            }
            var key = template.exemplar;
            var parentKey = parent.key || "";
            node.key = parentKey ? parentKey + "_" + key : key;
            var icon = template.icon;
            if (icon) {
                node.icon = Core.url(icon);
            }
            var tooltip = template["tooltip"] || template["description"] || '';
            node.tooltip = tooltip;
            if (template["folder"]) {
                node.isFolder = function () {
                    return true;
                };
            }
            parent.children.push(node);
            var children = template.children;
            if (children) {
                addCreateWizardFolders(workspace, $scope, node, children);
            }
        });
    }
    Wiki.addCreateWizardFolders = addCreateWizardFolders;
    function startLink(branch) {
        var start = "#/wiki";
        if (branch) {
            start += "/branch/" + branch;
        }
        return start;
    }
    Wiki.startLink = startLink;
    function isIndexPage(path) {
        return path && (path.endsWith("index.md") || path.endsWith("index.html") || path.endsWith("index")) ? true : false;
    }
    Wiki.isIndexPage = isIndexPage;
    function viewLink(branch, pageId, $location, fileName) {
        if (fileName === void 0) { fileName = null; }
        var link = null;
        var start = startLink(branch);
        if (pageId) {
            var view = isIndexPage(pageId) ? "/book/" : "/view/";
            link = start + view + encodePath(Core.trimLeading(pageId, "/"));
        }
        else {
            var path = $location.path();
            link = "#" + path.replace(/(edit|create)/, "view");
        }
        if (fileName && pageId && pageId.endsWith(fileName)) {
            return link;
        }
        if (fileName) {
            if (!link.endsWith("/")) {
                link += "/";
            }
            link += fileName;
        }
        return link;
    }
    Wiki.viewLink = viewLink;
    function branchLink(branch, pageId, $location, fileName) {
        if (fileName === void 0) { fileName = null; }
        return viewLink(branch, pageId, $location, fileName);
    }
    Wiki.branchLink = branchLink;
    function editLink(branch, pageId, $location) {
        var link = null;
        var format = Wiki.fileFormat(pageId);
        switch (format) {
            case "image":
                break;
            default:
                var start = startLink(branch);
                if (pageId) {
                    link = start + "/edit/" + encodePath(pageId);
                }
                else {
                    var path = $location.path();
                    link = "#" + path.replace(/(view|create)/, "edit");
                }
        }
        return link;
    }
    Wiki.editLink = editLink;
    function createLink(branch, pageId, $location, $scope) {
        var path = $location.path();
        var start = startLink(branch);
        var link = '';
        if (pageId) {
            link = start + "/create/" + encodePath(pageId);
        }
        else {
            link = "#" + path.replace(/(view|edit|formTable)/, "create");
        }
        var idx = link.lastIndexOf("/");
        if (idx > 0 && !$scope.children && !path.startsWith("/wiki/formTable")) {
            link = link.substring(0, idx + 1);
        }
        return link;
    }
    Wiki.createLink = createLink;
    function encodePath(pageId) {
        return pageId.split("/").map(encodeURIComponent).join("/");
    }
    Wiki.encodePath = encodePath;
    function decodePath(pageId) {
        return pageId.split("/").map(decodeURIComponent).join("/");
    }
    Wiki.decodePath = decodePath;
    function fileFormat(name, fileExtensionTypeRegistry) {
        var extension = fileExtension(name);
        var answer = null;
        if (!fileExtensionTypeRegistry) {
            fileExtensionTypeRegistry = Core.injector.get("fileExtensionTypeRegistry");
        }
        angular.forEach(fileExtensionTypeRegistry, function (array, key) {
            if (array.indexOf(extension) >= 0) {
                answer = key;
            }
        });
        return answer;
    }
    Wiki.fileFormat = fileFormat;
    function fileName(path) {
        if (path) {
            var idx = path.lastIndexOf("/");
            if (idx > 0) {
                return path.substring(idx + 1);
            }
        }
        return path;
    }
    Wiki.fileName = fileName;
    function fileParent(path) {
        if (path) {
            var idx = path.lastIndexOf("/");
            if (idx > 0) {
                return path.substring(0, idx);
            }
        }
        return "";
    }
    Wiki.fileParent = fileParent;
    function hideFileNameExtensions(name) {
        if (name) {
            angular.forEach(Wiki.hideExtensions, function (extension) {
                if (name.endsWith(extension)) {
                    name = name.substring(0, name.length - extension.length);
                }
            });
        }
        return name;
    }
    Wiki.hideFileNameExtensions = hideFileNameExtensions;
    function gitRestURL(branch, path) {
        var url = gitRelativeURL(branch, path);
        url = Core.url('/' + url);
        var connectionName = Core.getConnectionNameParameter(location.search);
        if (connectionName) {
            var connectionOptions = Core.getConnectOptions(connectionName);
            if (connectionOptions) {
                connectionOptions.path = url;
                url = Core.createServerConnectionUrl(connectionOptions);
            }
        }
        return url;
    }
    Wiki.gitRestURL = gitRestURL;
    function gitRelativeURL(branch, path) {
        branch = branch || "master";
        path = path || "/";
        return UrlHelpers.join("git/" + branch, path);
    }
    Wiki.gitRelativeURL = gitRelativeURL;
    function fileIconHtml(row) {
        var name = row.name;
        var path = row.path;
        var branch = row.branch;
        var directory = row.directory;
        var xmlNamespaces = row.xmlNamespaces;
        var iconUrl = row.iconUrl;
        var entity = row.entity;
        if (entity) {
            name = name || entity.name;
            path = path || entity.path;
            branch = branch || entity.branch;
            directory = directory || entity.directory;
            xmlNamespaces = xmlNamespaces || entity.xmlNamespaces;
            iconUrl = iconUrl || entity.iconUrl;
        }
        branch = branch || "master";
        var css = null;
        var icon = null;
        var extension = fileExtension(name);
        if (xmlNamespaces && xmlNamespaces.length) {
            if (xmlNamespaces.any(function (ns) { return Wiki.camelNamespaces.any(ns); })) {
                icon = "img/icons/camel.svg";
            }
            else if (xmlNamespaces.any(function (ns) { return Wiki.dozerNamespaces.any(ns); })) {
                icon = "img/icons/dozer/dozer.gif";
            }
            else if (xmlNamespaces.any(function (ns) { return Wiki.activemqNamespaces.any(ns); })) {
                icon = "img/icons/messagebroker.svg";
            }
            else {
                Wiki.log.debug("file " + name + " has namespaces " + xmlNamespaces);
            }
        }
        if (iconUrl) {
            css = null;
            icon = UrlHelpers.join("git", iconUrl);
            var connectionName = Core.getConnectionNameParameter(location.search);
            if (connectionName) {
                var connectionOptions = Core.getConnectOptions(connectionName);
                if (connectionOptions) {
                    connectionOptions.path = Core.url('/' + icon);
                    icon = Core.createServerConnectionUrl(connectionOptions);
                }
            }
        }
        if (!icon) {
            if (directory) {
                switch (extension) {
                    case 'profile':
                        css = "icon-book";
                        break;
                    default:
                        css = "icon-folder-close";
                }
            }
            else {
                switch (extension) {
                    case 'png':
                    case 'svg':
                    case 'jpg':
                    case 'gif':
                        css = null;
                        icon = Wiki.gitRelativeURL(branch, path);
                        var connectionName = Core.getConnectionNameParameter(location.search);
                        if (connectionName) {
                            var connectionOptions = Core.getConnectOptions(connectionName);
                            if (connectionOptions) {
                                connectionOptions.path = Core.url('/' + icon);
                                icon = Core.createServerConnectionUrl(connectionOptions);
                            }
                        }
                        break;
                    case 'json':
                    case 'xml':
                        css = "icon-file-text";
                        break;
                    case 'md':
                        css = "icon-file-text-alt";
                        break;
                    default:
                        css = "icon-file-alt";
                }
            }
        }
        if (icon) {
            return "<img src='" + Core.url(icon) + "'>";
        }
        else {
            return "<i class='" + css + "'></i>";
        }
    }
    Wiki.fileIconHtml = fileIconHtml;
    function iconClass(row) {
        var name = row.getProperty("name");
        var extension = fileExtension(name);
        var directory = row.getProperty("directory");
        if (directory) {
            return "icon-folder-close";
        }
        if ("xml" === extension) {
            return "icon-cog";
        }
        else if ("md" === extension) {
            return "icon-file-text-alt";
        }
        return "icon-file-alt";
    }
    Wiki.iconClass = iconClass;
    function initScope($scope, $routeParams, $location) {
        $scope.pageId = Wiki.pageId($routeParams, $location);
        var branch = $routeParams["branch"];
        if (branch == 'default-version') {
            branch = $scope.defaultVersion;
        }
        $scope.branch = branch || $location.search()["branch"];
        $scope.objectId = $routeParams["objectId"];
        $scope.startLink = Wiki.startLink($scope.branch);
        $scope.historyLink = startLink($scope.branch) + "/history/" + ($scope.pageId || "");
    }
    Wiki.initScope = initScope;
    function loadBranches(jolokia, wikiRepository, $scope, isFmc) {
        if (isFmc === void 0) { isFmc = false; }
        if (isFmc) {
            $scope.branches = Fabric.getVersionIds(jolokia);
            var defaultVersion = Fabric.getDefaultVersionId(jolokia);
            if (!$scope.branch) {
                $scope.branch = defaultVersion;
            }
            $scope.branches = $scope.branches.sortBy(function (v) { return Core.versionToSortableString(v); }, true);
            Core.$apply($scope);
        }
        else {
            wikiRepository.branches(function (response) {
                $scope.branches = response.sortBy(function (v) { return Core.versionToSortableString(v); }, true);
                if (!$scope.branch && $scope.branches.find(function (branch) {
                    return branch === "master";
                })) {
                    $scope.branch = "master";
                }
                Core.$apply($scope);
            });
        }
    }
    Wiki.loadBranches = loadBranches;
    function pageId($routeParams, $location) {
        var pageId = $routeParams['page'];
        if (!pageId) {
            for (var i = 0; i < 100; i++) {
                var value = $routeParams['path' + i];
                if (angular.isDefined(value)) {
                    if (!pageId) {
                        pageId = value;
                    }
                    else {
                        pageId += "/" + value;
                    }
                }
                else
                    break;
            }
            return pageId || "/";
        }
        if (!pageId) {
            pageId = pageIdFromURI($location.path());
        }
        return pageId;
    }
    Wiki.pageId = pageId;
    function pageIdFromURI(url) {
        var wikiPrefix = "/wiki/";
        if (url && url.startsWith(wikiPrefix)) {
            var idx = url.indexOf("/", wikiPrefix.length + 1);
            if (idx > 0) {
                return url.substring(idx + 1, url.length);
            }
        }
        return null;
    }
    Wiki.pageIdFromURI = pageIdFromURI;
    function fileExtension(name) {
        if (name.indexOf('#') > 0)
            name = name.substring(0, name.indexOf('#'));
        return Core.fileExtension(name, "markdown");
    }
    Wiki.fileExtension = fileExtension;
    function onComplete(status) {
        console.log("Completed operation with status: " + JSON.stringify(status));
    }
    Wiki.onComplete = onComplete;
    function parseJson(text) {
        if (text) {
            try {
                return JSON.parse(text);
            }
            catch (e) {
                Core.notification("error", "Failed to parse JSON: " + e);
            }
        }
        return null;
    }
    Wiki.parseJson = parseJson;
    function adjustHref($scope, $location, href, fileExtension) {
        var extension = fileExtension ? "." + fileExtension : "";
        var path = $location.path();
        var folderPath = path;
        var idx = path.lastIndexOf("/");
        if (idx > 0) {
            var lastName = path.substring(idx + 1);
            if (lastName.indexOf(".") >= 0) {
                folderPath = path.substring(0, idx);
            }
        }
        if (href.startsWith('../')) {
            var parts = href.split('/');
            var pathParts = folderPath.split('/');
            var parents = parts.filter(function (part) {
                return part === "..";
            });
            parts = parts.last(parts.length - parents.length);
            pathParts = pathParts.first(pathParts.length - parents.length);
            return '#' + pathParts.join('/') + '/' + parts.join('/') + extension + $location.hash();
        }
        if (href.startsWith('/')) {
            return Wiki.branchLink($scope.branch, href + extension, $location) + extension;
        }
        if (!Wiki.excludeAdjustmentPrefixes.any(function (exclude) {
            return href.startsWith(exclude);
        })) {
            return '#' + folderPath + "/" + href + extension + $location.hash();
        }
        else {
            return null;
        }
    }
    Wiki.adjustHref = adjustHref;
})(Wiki || (Wiki = {}));
var Fabric;
(function (Fabric) {
    ;
    var IconRegistry = (function () {
        function IconRegistry() {
            this.icons = {};
        }
        IconRegistry.prototype.addIcons = function (icon, domain) {
            var _this = this;
            var domains = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                domains[_i - 2] = arguments[_i];
            }
            this.addIcon(icon, domain);
            if (domains && angular.isArray(domains)) {
                domains.forEach(function (domain) {
                    _this.addIcon(icon, domain);
                });
            }
        };
        IconRegistry.prototype.addIcon = function (icon, domain) {
            this.icons[domain] = icon;
        };
        IconRegistry.prototype.getIcons = function (things) {
            var _this = this;
            var answer = [];
            if (things && angular.isArray(things)) {
                things.forEach(function (thing) {
                    if (_this.icons[thing]) {
                        answer.push(_this.icons[thing]);
                    }
                });
            }
            return answer.unique();
        };
        IconRegistry.prototype.getIcon = function (thing) {
            return this.icons[thing];
        };
        return IconRegistry;
    })();
    Fabric.IconRegistry = IconRegistry;
    Fabric.javaIcon = {
        title: "Java",
        type: "img",
        src: "img/icons/java.svg"
    };
    Fabric.serviceIconRegistry = new IconRegistry();
    Fabric.serviceIconRegistry.addIcons({
        title: "Kubernetes",
        type: "img",
        src: "img/icons/kubernetes.svg"
    }, "io.kubernetes");
    Fabric.serviceIconRegistry.addIcons({
        title: "Fabric8",
        type: "img",
        src: "img/icons/fabric8_icon.svg"
    }, "io.fabric8", "org.fusesource.fabric");
    Fabric.serviceIconRegistry.addIcons({
        title: "hawtio",
        type: "img",
        src: "img/hawtio_icon.svg"
    }, "hawtio");
    Fabric.serviceIconRegistry.addIcons({
        title: "Apache ActiveMQ",
        type: "img",
        src: "img/icons/messagebroker.svg"
    }, "org.apache.activemq");
    Fabric.serviceIconRegistry.addIcons({
        title: "Apache Camel",
        type: "img",
        src: "img/icons/camel.svg"
    }, "org.apache.camel");
    Fabric.serviceIconRegistry.addIcons({
        title: "Apache CXF",
        type: "icon",
        src: "icon-puzzle-piece"
    }, "org.apache.cxf");
    Fabric.serviceIconRegistry.addIcons({
        title: "Apache Karaf",
        type: "icon",
        src: "icon-beaker"
    }, "org.apache.karaf");
    Fabric.serviceIconRegistry.addIcons({
        title: "Apache Zookeeper",
        type: "icon",
        src: "icon-group"
    }, "org.apache.zookeeper");
    Fabric.serviceIconRegistry.addIcons({
        title: "Jetty",
        type: "img",
        src: "img/icons/jetty.svg"
    }, "org.eclipse.jetty.server");
    Fabric.serviceIconRegistry.addIcons({
        title: "Apache Tomcat",
        type: "img",
        src: "img/icons/tomcat.svg"
    }, "Catalina", "Tomcat");
    Fabric.serviceIconRegistry.addIcons({
        title: "WildFly",
        type: "img",
        src: "img/icons/wildfly.svg"
    }, "jboss", "wildfly");
    Fabric.serviceIconRegistry.addIcons({
        title: "Apache Cassandra",
        type: "img",
        src: "img/icons/cassandra.svg",
        "class": "girthy"
    }, "org.apache.cassandra.db", "org.apache.cassandra.metrics", "org.apache.cassandra.net", "org.apache.cassandra.request");
    Fabric.containerIconRegistry = new IconRegistry();
    Fabric.containerIconRegistry.addIcons({
        title: "Apache Karaf",
        type: "icon",
        src: "icon-beaker"
    }, "karaf");
    Fabric.containerIconRegistry.addIcons({
        title: "Apache Cassandra",
        type: "img",
        src: "img/icons/cassandra.svg",
        "class": "girthy"
    }, "Cassandra");
    Fabric.containerIconRegistry.addIcons({
        title: "Apache Tomcat",
        type: "img",
        src: "img/icons/tomcat.svg"
    }, "Tomcat");
    Fabric.containerIconRegistry.addIcons({
        title: "Apache TomEE",
        type: "img",
        src: "img/icons/tomcat.svg"
    }, "TomEE");
    Fabric.containerIconRegistry.addIcons({
        title: "Jetty",
        type: "img",
        src: "img/icons/jetty.svg"
    }, "Jetty");
    Fabric.containerIconRegistry.addIcons({
        title: "Kubernetes",
        type: "img",
        src: "img/icons/kubernetes.svg"
    }, "kubelet");
    Fabric.containerIconRegistry.addIcons({
        title: "WildFly",
        type: "img",
        src: "img/icons/wildfly.svg"
    }, "WildFly");
    Fabric.containerIconRegistry.addIcons(Fabric.javaIcon, "java");
})(Fabric || (Fabric = {}));
var Core;
(function (Core) {
    var log = Logger.get('Keycloak');
    var checkKeycloakEnabled = function (callback) {
        var keycloakEnabledUrl = "keycloak/enabled";
        $.ajax(keycloakEnabledUrl, {
            type: "GET",
            success: function (response) {
                log.debug("Got response for check if keycloak is enabled: ", response);
                var keycloakEnabled = (response === true || response === "true");
                var keycloakContext = createKeycloakContext(keycloakEnabled);
                callback(keycloakContext);
            },
            error: function (xhr, textStatus, error) {
                log.debug("Failed to retrieve if keycloak is enabled.: ", error);
                var keycloakContext = createKeycloakContext(false);
                callback(keycloakContext);
            }
        });
    };
    var createKeycloakContext = function (keycloakEnabled) {
        var keycloakAuth = new Keycloak('keycloak/client-config');
        var keycloakContext = {
            enabled: keycloakEnabled,
            keycloak: keycloakAuth
        };
        Core._module.factory('keycloakContext', function () {
            return keycloakContext;
        });
        return keycloakContext;
    };
    var initKeycloakIfNeeded = function (keycloakContext, nextTask) {
        if (keycloakContext.enabled) {
            log.debug('Keycloak authentication required. Initializing Keycloak');
            var keycloak = keycloakContext.keycloak;
            var kcInitOptions;
            if ('keycloakToken' in window) {
                kcInitOptions = window['keycloakToken'];
                log.debug('Initialize keycloak with token passed from different window');
            }
            else {
                kcInitOptions = { onLoad: 'login-required' };
            }
            keycloak.init(kcInitOptions).success(function () {
                var keycloakUsername = keycloak.tokenParsed.preferred_username;
                log.debug("Keycloak authenticated with Subject " + keycloakUsername + ". Validating subject matches");
                validateSubjectMatches(keycloakUsername, function () {
                    log.debug("Keycloak authentication finished! Continue next task");
                    nextTask();
                });
            }).error(function () {
                log.warn("Keycloak authentication failed!");
                Core.notification('error', 'Failed to log in to Keycloak');
            });
        }
        else {
            log.debug('Keycloak authentication not required. Skip Keycloak bootstrap');
            nextTask();
        }
    };
    var validateSubjectMatches = function (keycloakUser, callback) {
        var keycloakValidateUrl = "keycloak/validate-subject-matches?keycloakUser=" + encodeURIComponent(keycloakUser);
        $.ajax(keycloakValidateUrl, {
            type: "GET",
            success: function (response) {
                log.debug("Got response for validate subject matches: ", response);
                callback();
            },
            error: function (xhr, textStatus, error) {
                log.debug("Failed to validate subject matches: ", error);
                callback();
            }
        });
    };
    hawtioPluginLoader.registerPreBootstrapTask(function (nextTask) {
        log.debug('Prebootstrap task executed');
        checkKeycloakEnabled(function (keycloakContext) {
            initKeycloakIfNeeded(keycloakContext, nextTask);
        });
    });
    var loginControllerProcessed = false;
    Core.keycloakLoginController = function ($scope, jolokia, userDetails, jolokiaUrl, workspace, localStorage, keycloakContext, postLogoutTasks) {
        if (loginControllerProcessed) {
            log.debug('Skip processing login controller as it was already processed this request!');
            return;
        }
        loginControllerProcessed = true;
        setTimeout(function () {
            loginControllerProcessed = false;
        }, 30000);
        log.debug("keycloakLoginController triggered");
        var keycloakAuth = keycloakContext.keycloak;
        postLogoutTasks.addTask('KeycloakLogout', function () {
            if (keycloakAuth.authenticated) {
                log.debug("postLogoutTask: Going to trigger keycloak logout");
                keycloakAuth.logout();
                return false;
            }
            else {
                log.debug("postLogoutTask: Keycloak not authenticated. Skip calling keycloak logout");
                return true;
            }
        });
        keycloakAuth.onAuthLogout = function () {
            log.debug('keycloakAuth.onAuthLogout triggered!');
            Core.logout(jolokiaUrl, userDetails, localStorage, $scope);
        };
        var setPeriodicTokenRefresh = function () {
            if (keycloakAuth.authenticated) {
                setTimeout(function () {
                    keycloakAuth.updateToken(10).success(function (refreshed) {
                        if (refreshed) {
                            log.debug('Keycloak token refreshed. Set new value to userDetails');
                            userDetails.password = keycloakAuth.token;
                        }
                    }).error(function () {
                        log.warn('Failed to refresh keycloak token!');
                    });
                    setPeriodicTokenRefresh();
                }, 5000);
            }
            else {
                log.debug('Keycloak not authenticated any more. Skip period for token refreshing');
            }
        };
        var doKeycloakJaasLogin = function () {
            if (jolokiaUrl) {
                var url = "auth/login/";
                if (keycloakAuth.token && keycloakAuth.token != '') {
                    log.debug('Keycloak authentication token found! Going to trigger JAAS');
                    $.ajax(url, {
                        type: "POST",
                        success: function (response) {
                            log.debug('Callback from JAAS login!');
                            userDetails.username = keycloakAuth.tokenParsed.preferred_username;
                            userDetails.password = keycloakAuth.token;
                            userDetails.loginDetails = response;
                            setPeriodicTokenRefresh();
                            jolokia.start();
                            workspace.loadTree();
                            Core.executePostLoginTasks();
                            Core.$apply($scope);
                        },
                        error: function (xhr, textStatus, error) {
                            switch (xhr.status) {
                                case 401:
                                    Core.notification('error', 'Failed to log in, ' + error);
                                    break;
                                case 403:
                                    Core.notification('error', 'Failed to log in, ' + error);
                                    break;
                                default:
                                    Core.notification('error', 'Failed to log in, ' + error);
                                    break;
                            }
                            Core.$apply($scope);
                        },
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', Core.getBasicAuthHeader(keycloakAuth.tokenParsed.preferred_username, keycloakAuth.token));
                        }
                    });
                }
                else {
                    Core.notification('error', 'Keycloak auth token not found.');
                }
            }
        };
        doKeycloakJaasLogin();
    };
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core._module.controller("Core.LoginController", ["$scope", "jolokia", "userDetails", "jolokiaUrl", "workspace", "localStorage", "branding", "keycloakContext", "postLoginTasks", "postLogoutTasks", function ($scope, jolokia, userDetails, jolokiaUrl, workspace, localStorage, branding, keycloakContext, postLoginTasks, postLogoutTasks) {
        jolokia.stop();
        $scope.keycloakEnabled = keycloakContext.enabled;
        if ($scope.keycloakEnabled) {
            Core.keycloakLoginController($scope, jolokia, userDetails, jolokiaUrl, workspace, localStorage, keycloakContext, postLogoutTasks);
        }
        else {
            loginController($scope, jolokia, userDetails, jolokiaUrl, workspace, localStorage, branding, postLoginTasks);
        }
    }]);
    var loginController = function ($scope, jolokia, userDetails, jolokiaUrl, workspace, localStorage, branding, postLoginTasks) {
        $scope.userDetails = userDetails;
        $scope.entity = {
            username: '',
            password: ''
        };
        $scope.backstretch = $.backstretch(branding.loginBg);
        $scope.rememberMe = false;
        if ('userDetails' in localStorage) {
            $scope.rememberMe = true;
            var details = angular.fromJson(localStorage['userDetails']);
            $scope.entity.username = details.username;
            $scope.entity.password = details.password;
        }
        $scope.branding = branding;
        $scope.$watch('userDetails', function (newValue) {
            if (newValue.username) {
                $scope.entity.username = newValue.username;
            }
            if (newValue.password) {
                $scope.entity.password = newValue.password;
            }
        }, true);
        $scope.$on('$routeChangeStart', function () {
            if ($scope.backstretch) {
                $scope.backstretch.destroy();
            }
        });
        $scope.doLogin = function () {
            if (jolokiaUrl) {
                var url = "auth/login/";
                if ($scope.entity.username.trim() != '') {
                    $.ajax(url, {
                        type: "POST",
                        success: function (response) {
                            userDetails.username = $scope.entity.username;
                            userDetails.password = $scope.entity.password;
                            userDetails.loginDetails = response;
                            if ($scope.rememberMe) {
                                localStorage['userDetails'] = angular.toJson(userDetails);
                            }
                            else {
                                delete localStorage['userDetails'];
                            }
                            jolokia.start();
                            workspace.loadTree();
                            Core.executePostLoginTasks();
                            Core.$apply($scope);
                        },
                        error: function (xhr, textStatus, error) {
                            switch (xhr.status) {
                                case 401:
                                    Core.notification('error', 'Failed to log in, ' + error);
                                    break;
                                case 403:
                                    Core.notification('error', 'Failed to log in, ' + error);
                                    break;
                                default:
                                    Core.notification('error', 'Failed to log in, ' + error);
                                    break;
                            }
                            Core.$apply($scope);
                        },
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', Core.getBasicAuthHeader($scope.entity.username, $scope.entity.password));
                        }
                    });
                }
            }
        };
    };
})(Core || (Core = {}));
var Fabric;
(function (Fabric) {
    Fabric.OpenShiftCredentials = {
        username: null,
        password: null
    };
    function fabricCreated(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "Fabric" });
    }
    Fabric.fabricCreated = fabricCreated;
    function canBootstrapFabric(workspace) {
        return hasClusterBootstrapManager(workspace);
    }
    Fabric.canBootstrapFabric = canBootstrapFabric;
    function hasClusterBootstrapManager(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "ClusterBootstrapManager" });
    }
    Fabric.hasClusterBootstrapManager = hasClusterBootstrapManager;
    function hasClusterServiceManager(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "ClusterServiceManager" });
    }
    Fabric.hasClusterServiceManager = hasClusterServiceManager;
    function hasZooKeeper(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "ZooKeeper" });
    }
    Fabric.hasZooKeeper = hasZooKeeper;
    function hasOpenShiftFabric(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "OpenShift" });
    }
    Fabric.hasOpenShiftFabric = hasOpenShiftFabric;
    function hasMQManager(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "MQManager" });
    }
    Fabric.hasMQManager = hasMQManager;
    function hasSchemaMBean(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.schemaLookupDomain, { type: Fabric.schemaLookupType });
    }
    Fabric.hasSchemaMBean = hasSchemaMBean;
    function hasGitMBean(workspace) {
        return workspace.treeContainsDomainAndProperties(Git.jmxDomain, { type: Git.mbeanType });
    }
    Fabric.hasGitMBean = hasGitMBean;
    function isFMCContainer(workspace) {
        var hasFabric = Fabric.hasFabric(workspace);
        var hasSchemaMBean = Fabric.hasSchemaMBean(workspace);
        var hasGitMBean = Fabric.hasGitMBean(workspace);
        return hasFabric && hasSchemaMBean && hasGitMBean;
    }
    Fabric.isFMCContainer = isFMCContainer;
    function hasFabric(workspace) {
        return fabricCreated(workspace) && (hasClusterServiceManager(workspace) || hasClusterBootstrapManager(workspace) || hasZooKeeper(workspace));
    }
    Fabric.hasFabric = hasFabric;
    function initScope($scope, $location, jolokia, workspace) {
        if ($scope.fabricInitialized) {
            return;
        }
        else {
            $scope.fabricInitialized = true;
        }
        ContainerHelpers.decorate($scope, $location, jolokia);
        $scope.gotoProfile = function (versionId, profileId) {
            Fabric.gotoProfile(workspace, jolokia, workspace.localStorage, $location, versionId, profileId);
        };
        $scope.refreshProfile = function (versionId, profileId) {
            Fabric.log.debug('Refreshing profile: ' + profileId + '/' + versionId);
            if (!versionId || !profileId) {
                return;
            }
            jolokia.request({
                type: 'exec',
                mbean: Fabric.managerMBean,
                operation: 'refreshProfile',
                arguments: [versionId, profileId]
            }, {
                method: 'POST',
                success: function () {
                    Core.notification('success', 'Triggered refresh of profile ' + profileId + '/' + versionId);
                    Core.$apply($scope);
                },
                error: function (response) {
                    Fabric.log.warn('Failed to trigger refresh for profile ' + profileId + '/' + versionId + ' due to: ', response.error);
                    Fabric.log.info("Stack trace: ", response.stacktrace);
                    Core.$apply($scope);
                }
            });
        };
        $scope.getVersionsToExclude = function () {
            if (!$scope.selectedContainers || $scope.selectedContainers.length === 0) {
                return [];
            }
            var answer = $scope.selectedContainers.map(function (c) { return c['versionId']; });
            answer = answer.unique();
            if (answer.length > 1) {
                return [];
            }
            else {
                return answer;
            }
        };
        $scope.hasFabricWiki = function () {
            return Git.isGitMBeanFabric(workspace);
        };
        $scope.createRequiredContainers = function (profile) {
            var profileId = profile.id;
            var args = {};
            if (profileId) {
                args["profileIds"] = profileId;
            }
            var versionId = profile.versionId || profile.version;
            if (versionId) {
                args["versionId"] = versionId;
            }
            var requirements = profile.requirements;
            if (requirements) {
                var min = requirements.minimumInstances;
                if (min) {
                    var delta = min - (profile.count || 0);
                    if (delta > 1) {
                        args["number"] = delta;
                    }
                }
            }
            $location.url('/fabric/containers/createContainer').search(args);
        };
        $scope.createContainer = function () {
            var kind = null;
            var providers = registeredProviders(jolokia);
            angular.forEach(["openshift", "docker", "jclouds"], function (value) {
                if (!kind && providers[value]) {
                    kind = value;
                }
            });
            if (!kind) {
                kind = 'child';
            }
            $location.url('/fabric/containers/createContainer').search('tab', kind);
        };
        $scope.createChildContainer = function (container) {
            if (!container.root || !container.alive) {
                return;
            }
            $location.url('/fabric/containers/createContainer').search({ 'tab': 'child', 'parentId': container.id });
        };
        $scope.showProfile = function (profile) {
            var version = profile.versionId || profile.version || $scope.activeVersionId;
            Fabric.gotoProfile(workspace, jolokia, localStorage, $location, version, profile);
        };
        $scope.getSelectedClass = function (obj) {
            var answer = [];
            if (obj.selected) {
                answer.push('selected');
            }
            if (angular.isDefined(obj['root']) && obj['root'] === false) {
                answer.push('child-container');
            }
            return answer.join(' ');
        };
        $scope.isEnsembleContainer = function (containerId) {
            if (angular.isArray($scope.ensembleContainerIds)) {
                return $scope.ensembleContainerIds.any(containerId);
            }
            return false;
        };
        $scope.connect = {
            dialog: new UI.Dialog(),
            saveCredentials: false,
            userName: null,
            password: null,
            container: null,
            view: null,
            onOK: function () {
                var userName = $scope.connect.userName;
                var password = $scope.connect.password;
                var userDetails = Core.injector.get('userDetails');
                if (!userDetails.password) {
                    userDetails.password = password;
                }
                var container = $scope.connect.container;
                if ($scope.connect.saveCredentials) {
                    $scope.connect.saveCredentials = false;
                    if (userName) {
                        localStorage['fabric.userName'] = userName;
                    }
                    if (password) {
                        localStorage['fabric.password'] = password;
                    }
                }
                var options = Core.createConnectOptions({
                    jolokiaUrl: container.jolokiaUrl,
                    userName: userName,
                    password: password,
                    useProxy: true,
                    view: $scope.connect.view,
                    name: container.id
                });
                Core.connectToServer(localStorage, options);
                $scope.connect.container = {};
                setTimeout(function () {
                    $scope.connect.dialog.close();
                    Core.$apply($scope);
                }, 100);
            }
        };
        $scope.doConnect = function (container, view) {
            if (!$scope.canConnect(container)) {
                return;
            }
            var userDetails = Core.injector.get('userDetails');
            $scope.connect.userName = (userDetails.remoteJolokiaUserDetails && userDetails.remoteJolokiaUserDetails.username ? userDetails.remoteJolokiaUserDetails.username : userDetails.username);
            $scope.connect.password = (userDetails.remoteJolokiaUserDetails && userDetails.remoteJolokiaUserDetails.password ? userDetails.remoteJolokiaUserDetails.password : userDetails.password);
            $scope.connect.container = container;
            $scope.connect.view = view || "#/openlogs";
            var alwaysPrompt = localStorage['fabricAlwaysPrompt'];
            if ((alwaysPrompt && alwaysPrompt !== "false") || !$scope.connect.userName || !$scope.connect.password) {
                $scope.connect.dialog.open();
            }
            else {
                $scope.connect.onOK();
            }
        };
        $scope.deletePending = {};
        $scope.deleteContainer = function () {
            if ($scope.selectedContainers.all(function (c) {
                return !$scope.deletePending[c.id];
            })) {
                $scope.confirmDeleteDialog.open();
            }
        };
        $scope.mayDelete = function () {
            return $scope.selectedContainers.length > 0 && $scope.selectedContainers.all(function (c) {
                return !$scope.deletePending[c.id] && !c.root;
            });
        };
        $scope.confirmDeleteDialog = {
            dialog: new UI.Dialog(),
            onOk: function () {
                $scope.confirmDeleteDialog.dialog.close();
                if (angular.isDefined($scope.containerId)) {
                    $scope.deletePending[$scope.containerId] = true;
                    Core.unregister(jolokia, $scope);
                    $location.path('/fabric/containers');
                    ContainerHelpers.doDeleteContainer($scope, jolokia, $scope.containerId, function () {
                        delete $scope.deletePending[$scope.containerId];
                    });
                }
                else if (angular.isDefined($scope.selectedContainers)) {
                    $scope.selectedContainers.each(function (c) {
                        $scope.deletePending[c.id] = true;
                        ContainerHelpers.doDeleteContainer($scope, jolokia, c.id, function () {
                            delete $scope.deletePending[c.id];
                        });
                    });
                }
                else {
                    Fabric.log.info("Asked to delete containers but no containerId or selectedContainers attributes available");
                }
            },
            open: function () {
                $scope.confirmDeleteDialog.dialog.open();
            },
            close: function () {
                $scope.confirmDeleteDialog.dialog.close();
            }
        };
        $scope.$watch('selectedContainers', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                var num = $scope.selectedContainers.length;
                $scope.versionTitle = "Migrate " + Core.maybePlural(num, "Container") + " to:";
            }
        });
        $scope.onVersionChange = function (version) {
            var containerIds = [];
            if (angular.isDefined($scope.selectedContainers)) {
                containerIds = $scope.selectedContainers.map(function (c) { return c.id; });
            }
            else if (angular.isDefined($scope.row)) {
                containerIds = [$scope.row.id];
            }
            else {
                return;
            }
            Fabric.log.info("Setting version to " + version + " on containers: " + containerIds);
            Fabric.migrateContainers(jolokia, version, containerIds, function () {
                Core.notification('success', "Initiated container migration to version <strong>" + version + "</strong>, changes make take some time to complete");
                Core.$apply($scope);
            }, function (response) {
                Fabric.log.error("Failed to migrate containers due to ", response.error);
                Fabric.log.info("Stack trace: ", response.stacktrace);
                Core.$apply($scope);
            });
        };
        var verbose = workspace.localStorage['fabricVerboseNotifications'];
        $scope.fabricVerboseNotifications = verbose && verbose !== "false";
    }
    Fabric.initScope = initScope;
    function viewVersion(versionId, $location, $scope) {
        var defaultTarget = '/wiki/branch/' + versionId + '/view/fabric/profiles';
        var path = $location.path();
        var branch = $scope.branch || $scope.$parent.branch;
        if (!path.startsWith('/wiki/branch/') || !branch) {
            $location.path(defaultTarget);
        }
        else {
            path = path.replace('/branch/' + branch, '/branch/' + versionId);
            $location.path(path);
        }
    }
    Fabric.viewVersion = viewVersion;
    function doCreateVersion($scope, jolokia, $location, newVersionName) {
        var success = function (response) {
            var newVersion = response.value.id;
            Core.notification('success', "Created version <strong>" + newVersion + "</strong>, switching to this new version");
            var $rootScope = $scope.$root || $scope.$rootScope || $scope;
            if ($rootScope) {
                $rootScope.$broadcast('wikiBranchesUpdated');
            }
            viewVersion(newVersion, $location, $scope);
            Core.$apply($scope);
        };
        var error = function (response) {
            Fabric.log.error("Failed to create version due to :", response.error);
            Fabric.log.info("stack trace: ", response.stacktrace);
            Core.$apply($scope);
        };
        if (!Core.isBlank(newVersionName)) {
            Fabric.createVersionWithId(jolokia, newVersionName, success, error);
        }
        else {
            Fabric.createVersion(jolokia, success, error);
        }
    }
    Fabric.doCreateVersion = doCreateVersion;
    function sortVersions(versions, order) {
        return (versions || []).sortBy(function (v) {
            var answer = parseFloat(v['id']);
            if (answer === NaN) {
                answer = v['id'];
            }
            return answer;
        }, order);
    }
    Fabric.sortVersions = sortVersions;
    function pagePathToProfileId(pageId) {
        var answer = null;
        if (angular.isDefined(pageId) && pageId.has(Fabric.fabricTopLevel) && pageId !== Fabric.fabricTopLevel) {
            var profileId = pageId.remove(Fabric.fabricTopLevel);
            if ((Fabric.useDirectoriesInGit || !profileId.has("/"))) {
                var profileSeparator = profileId.indexOf(Fabric.profileSuffix + "/");
                var endsWithSuffix = profileId.endsWith(Fabric.profileSuffix);
                if (!Fabric.useDirectoriesInGit || endsWithSuffix || profileSeparator > 0) {
                    if (Fabric.useDirectoriesInGit) {
                        if (endsWithSuffix) {
                            profileId = Core.trimTrailing(profileId, Fabric.profileSuffix);
                        }
                        else if (profileSeparator > 0) {
                            profileId = profileId.substring(0, profileSeparator);
                        }
                        profileId = profileId.replace(/\//g, "-");
                    }
                    answer = profileId;
                }
            }
        }
        return answer;
    }
    Fabric.pagePathToProfileId = pagePathToProfileId;
    function profilePath(profileId) {
        if (profileId) {
            return profileId.replace(/-/g, "/") + Fabric.profileSuffix;
        }
        else {
            return null;
        }
    }
    Fabric.profilePath = profilePath;
    function profileLink(workspace, jolokia, localStorage, versionId, profileId) {
        var path;
        if (Wiki.isWikiEnabled(workspace, jolokia, localStorage)) {
            path = "/wiki/branch/" + versionId + "/view/fabric/profiles/" + Fabric.profilePath(profileId);
        }
        else {
            path = "/fabric/profile/" + versionId + "/" + profileId;
        }
        return path;
    }
    Fabric.profileLink = profileLink;
    function containerCountBadgeStyle(min, max, count) {
        if (!max || max == -1) {
            max = Number.MAX_VALUE;
        }
        if (!min) {
            min = 0;
        }
        if (!count) {
            return "badge-important";
        }
        else {
            return min <= count && count <= max ? "badge-success" : "badge-warning";
        }
        return "";
    }
    Fabric.containerCountBadgeStyle = containerCountBadgeStyle;
    function gotoProfile(workspace, jolokia, localStorage, $location, versionId, profile) {
        var path = '';
        if (angular.isString(profile)) {
            path = profileLink(workspace, jolokia, localStorage, versionId, profile);
        }
        else {
            path = profileLink(workspace, jolokia, localStorage, versionId, profile.id);
        }
        if (!Core.isBlank(path)) {
            $location.url(path);
        }
    }
    Fabric.gotoProfile = gotoProfile;
    function gotoContainer(containerId) {
        var $location = Core.injector.get('$location');
        $location.path(UrlHelpers.join('/fabric/container', containerId));
    }
    Fabric.gotoContainer = gotoContainer;
    function setSelect(selection, group) {
        if (!angular.isDefined(selection)) {
            return group[0];
        }
        var answer = group.findIndex(function (item) {
            return item.id === selection.id;
        });
        if (answer !== -1) {
            return group[answer];
        }
        else {
            return group[0];
        }
    }
    Fabric.setSelect = setSelect;
    Fabric.urlResolvers = ['http:', 'ftp:', 'mvn:'];
    function completeUri($q, $scope, workspace, jolokia, something) {
    }
    Fabric.completeUri = completeUri;
    function getActiveVersion($location) {
        return $location.search()['cv'] || "1.0";
    }
    Fabric.getActiveVersion = getActiveVersion;
    ;
    function loadRestApi(jolokia, workspace, $scope, callback) {
        if (callback === void 0) { callback = undefined; }
        if ($scope && !$scope.restApiUrl) {
            $scope.restApiUrl = Fabric.DEFAULT_REST_API;
        }
        Fabric.restApiUrl(jolokia, function (response) {
            var answer = response.value || Fabric.DEFAULT_REST_API;
            if (Fabric.isFMCContainer(workspace)) {
                try {
                    var url = new URI(answer);
                    var path = url.pathname();
                    if (path) {
                        answer = path;
                        response.value = answer;
                    }
                }
                catch (e) {
                }
                var connectionName = Core.getConnectionNameParameter(location.search);
                if (connectionName) {
                    var connectionOptions = Core.getConnectOptions(connectionName);
                    if (connectionOptions) {
                        connectionOptions.path = answer;
                        answer = Core.createServerConnectionUrl(connectionOptions);
                    }
                }
            }
            if ($scope) {
                $scope.restApiUrl = answer;
                Fabric.log.info("got REST API: " + $scope.restApiUrl);
                Core.$apply($scope);
            }
            if (callback) {
                callback(response);
            }
        });
    }
    Fabric.loadRestApi = loadRestApi;
    function toIconURL($scope, iconURL) {
        if (!iconURL) {
            return iconURL;
        }
        var connectionName = Core.getConnectionNameParameter(location.search);
        if (connectionName) {
            var connectionOptions = Core.getConnectOptions(connectionName);
            if (connectionOptions && !/^proxy\/http/.test(iconURL)) {
                connectionOptions.path = /^\//.test(iconURL) ? iconURL : Core.url("/git/") + iconURL;
                iconURL = Core.createServerConnectionUrl(connectionOptions);
            }
        }
        else {
            iconURL = /^\//.test(iconURL) ? iconURL : Core.url("/git/") + iconURL;
        }
        return iconURL;
    }
    Fabric.toIconURL = toIconURL;
    function getVersionsInUse(jolokia, callback) {
        Fabric.doAction('containers(java.util.List, java.util.List)', jolokia, [["versionId"], []], function (response) {
            var versionIds = response.value.map(function (el) {
                return el['versionId'];
            }).unique();
            callback(versionIds);
        }, function (response) {
            Fabric.log.debug("Failed to get versions in use: ", response);
            Fabric.log.debug("Stack Trace: ", response.stacktrace);
        });
    }
    Fabric.getVersionsInUse = getVersionsInUse;
    function onJolokiaUrlCreateJolokia(response, fn) {
        var jolokia = null;
        if (response) {
            var url = response.value;
            if (url) {
                url = Core.useProxyIfExternal(url);
                jolokia = Fabric.createJolokia(url);
            }
            else {
                if (response.error) {
                    Fabric.log.debug("Failed to fetch remote jolokia URL: ", response.error);
                    Fabric.log.debug("Stack trace: ", response.stacktrace);
                }
            }
            if (fn) {
                fn(jolokia);
            }
        }
        return jolokia;
    }
    function profileJolokia(jolokia, profileId, versionId, onJolokia) {
        function onJolokiaUrl(response) {
            return onJolokiaUrlCreateJolokia(response, onJolokia);
        }
        if (profileId && versionId) {
            return Fabric.profileWebAppURL(jolokia, Fabric.jolokiaWebAppGroupId, profileId, versionId, onJolokiaUrl, onJolokiaUrl);
        }
        else {
            onJolokia(null);
            return null;
        }
    }
    Fabric.profileJolokia = profileJolokia;
    function containerJolokia(jolokia, containerId, onJolokia) {
        function onJolokiaUrl(response) {
            return onJolokiaUrlCreateJolokia(response, onJolokia);
        }
        return Fabric.containerWebAppURL(jolokia, Fabric.jolokiaWebAppGroupId, containerId, onJolokiaUrl, onJolokiaUrl);
    }
    Fabric.containerJolokia = containerJolokia;
    function getServiceList(container) {
        var answer = [];
        var javaContainer = true;
        if (angular.isDefined(container) && angular.isDefined(container.jmxDomains) && angular.isArray(container.jmxDomains) && container.alive) {
            answer = Fabric.serviceIconRegistry.getIcons(container.jmxDomains);
        }
        return answer;
    }
    Fabric.getServiceList = getServiceList;
    function getTypeIcon(container) {
        var type = container.type;
        if (container.metadata && container.metadata.containerType) {
            type = container.metadata.containerType;
        }
        var answer = Fabric.containerIconRegistry.getIcon(type);
        if (!answer) {
            return Fabric.javaIcon;
        }
        else {
            return answer;
        }
    }
    Fabric.getTypeIcon = getTypeIcon;
    function usingProfile(group, targetId, action) {
        var profile = group.find(function (p) {
            return p.id === targetId;
        });
        if (profile) {
            action(profile);
        }
    }
    Fabric.usingProfile = usingProfile;
    function getDefaultVersionId(jolokia) {
        return (getDefaultVersion(jolokia) || {})["id"] || "1.0";
    }
    Fabric.getDefaultVersionId = getDefaultVersionId;
    function getDefaultVersion(jolokia) {
        return jolokia.execute(Fabric.managerMBean, "defaultVersion()");
    }
    Fabric.getDefaultVersion = getDefaultVersion;
    function setDefaultVersion(jolokia, newVersion, callback) {
        jolokia.setAttribute(Fabric.managerMBean, "DefaultVersion", newVersion, onSuccess(function (response) {
            callback();
        }));
    }
    Fabric.setDefaultVersion = setDefaultVersion;
    function defaultContainerValues(workspace, $scope, values) {
        var map = {};
        angular.forEach(values, function (row) {
            var profileIds = row["profileIds"];
            if (profileIds) {
                angular.forEach(profileIds, function (profileId) {
                    var containers = map[profileId];
                    if (!containers) {
                        containers = [];
                        map[profileId] = containers;
                    }
                    containers.push(row);
                });
            }
            $scope.profileMap = map;
            row["link"] = containerLinks(workspace, row["id"]);
            row["profileLinks"] = profileLinks(workspace, row["versionId"], profileIds);
            var versionId = row["versionId"];
            var versionHref = Core.url("#/fabric/profiles?v=" + versionId);
            var versionLink = "<a href='" + versionHref + "'>" + versionId + "</a>";
            row["versionHref"] = versionHref;
            row["versionLink"] = versionLink;
            var id = row['id'] || "";
            var title = "container " + id + " ";
            var img = "red-dot.png";
            if (row['managed'] === false) {
                img = "spacer.gif";
            }
            else if (!row['alive']) {
                img = "gray-dot.png";
            }
            else if (row['provisionPending']) {
                img = "pending.gif";
            }
            else if (row['provisionStatus'] === 'success') {
                img = "green-dot.png";
            }
            img = "img/dots/" + img;
            row["statusImageHref"] = img;
            row["link"] = "<img src='" + img + "' title='" + title + "'/> " + (row["link"] || id);
        });
        return values;
    }
    Fabric.defaultContainerValues = defaultContainerValues;
    function toCollection(values) {
        var collection = values;
        if (!angular.isArray(values)) {
            collection = [values];
        }
        return collection;
    }
    Fabric.toCollection = toCollection;
    function containerLinks(workspace, values) {
        var answer = "";
        angular.forEach(toCollection(values), function (value, key) {
            var prefix = "";
            if (answer.length > 0) {
                prefix = " ";
            }
            answer += prefix + "<a href='" + Core.url("#/fabric/container/" + value + workspace.hash()) + "'>" + value + "</a>";
        });
        return answer;
    }
    Fabric.containerLinks = containerLinks;
    function profileLinks(workspace, versionId, values) {
        var answer = "";
        angular.forEach(toCollection(values), function (value, key) {
            var prefix = "";
            if (answer.length > 0) {
                prefix = " ";
            }
            answer += prefix + "<a href='" + Core.url("#/fabric/profile/" + versionId + "/" + value + workspace.hash()) + "'>" + value + "</a>";
        });
        return answer;
    }
    Fabric.profileLinks = profileLinks;
    function defaultProfileValues(workspace, versionId, values) {
        angular.forEach(values, function (row) {
            var id = row["id"];
            row["link"] = profileLinks(workspace, versionId, id);
            row["parentLinks"] = profileLinks(workspace, versionId, row["parentIds"]);
            var containersHref = Core.url("#/fabric/containers?p=" + id);
            var containerCount = row["containerCount"];
            var containersLink = "";
            if (containerCount) {
                containersLink = "<a href='" + containersHref + "'>" + containerCount + "</a>";
            }
            row["containersCountLink"] = containersLink;
            row["containersHref"] = containersHref;
        });
        return values;
    }
    Fabric.defaultProfileValues = defaultProfileValues;
    function getZooKeeperFacadeMBean(workspace) {
        var folder = workspace.findMBeanWithProperties(Fabric.jmxDomain, { type: "ZooKeeper" });
        return Core.pathGet(folder, "objectName");
    }
    Fabric.getZooKeeperFacadeMBean = getZooKeeperFacadeMBean;
    Fabric.statusTitle = ContainerHelpers.statusTitle;
    Fabric.statusIcon = ContainerHelpers.statusIcon;
    function createJolokia(url) {
        var userDetails = Core.injector.get("userDetails");
        Fabric.log.info("Logging into remote jolokia " + url + " using user details: " + StringHelpers.toString(userDetails));
        return Core.createJolokia(url, userDetails.username, userDetails.password);
    }
    Fabric.createJolokia = createJolokia;
    function registeredProviders(jolokia) {
        var providers = jolokia.execute(Fabric.managerMBean, 'registeredValidProviders()');
        var answer = {};
        angular.forEach(providers, function (value, key) {
            answer[key] = {
                id: key,
                className: value
            };
        });
        return answer;
    }
    Fabric.registeredProviders = registeredProviders;
    function getSchema(id, className, jolokia, cb) {
        jolokia.execute(Fabric.schemaLookupMBean, 'getSchemaForClass(java.lang.String)', className, {
            method: 'POST',
            success: function (value) {
                cb(Fabric.customizeSchema(id, angular.fromJson(value)));
            }
        });
    }
    Fabric.getSchema = getSchema;
    function getDtoSchema(id, className, jolokia, cb) {
        jolokia.execute(Fabric.schemaLookupMBean, 'getSchemaForClass(java.lang.String)', className, {
            method: 'POST',
            success: function (value) {
                cb(angular.fromJson(value));
            }
        });
    }
    Fabric.getDtoSchema = getDtoSchema;
    function getCurrentContainer(jolokia, fields) {
        var name = jolokia.getAttribute(Fabric.managerMBean, 'CurrentContainerName', { method: 'POST' });
        return jolokia.execute(Fabric.managerMBean, "getContainer(java.lang.String, java.util.List)", name, fields, { method: 'POST' });
    }
    Fabric.getCurrentContainer = getCurrentContainer;
    function getContainerFields(jolokia, name, fields) {
        return jolokia.execute(Fabric.managerMBean, "getContainer(java.lang.String, java.util.List)", name, fields, { method: 'POST' });
    }
    Fabric.getContainerFields = getContainerFields;
    function getRootContainers(jolokia) {
        var fields = ["id", "root"];
        var answer = jolokia.execute(Fabric.managerMBean, "containers(java.util.List)", fields, { method: 'POST' });
        return answer.filter(function (c) {
            return c.root;
        }).map(function (v) { return v["id"]; });
    }
    Fabric.getRootContainers = getRootContainers;
    function getContainersFields(jolokia, fields, fn) {
        if (fn === void 0) { fn = null; }
        return jolokia.execute(Fabric.managerMBean, "containers(java.util.List)", fields, onSuccess(fn));
    }
    Fabric.getContainersFields = getContainersFields;
    function getOpenShiftDomains(workspace, jolokia, serverUrl, login, password, fn, onError) {
        if (fn === void 0) { fn = null; }
        if (onError === void 0) { onError = null; }
        if (hasOpenShiftFabric(workspace) && serverUrl && login && password) {
            var options = onSuccess(fn, { error: onError });
            return jolokia.execute(Fabric.openShiftFabricMBean, "getDomains", serverUrl, login, password, options);
        }
        else {
            if (fn) {
                fn([]);
            }
            return [];
        }
    }
    Fabric.getOpenShiftDomains = getOpenShiftDomains;
    function getOpenShiftGearProfiles(workspace, jolokia, serverUrl, login, password, fn) {
        if (fn === void 0) { fn = null; }
        if (hasOpenShiftFabric(workspace) && serverUrl && login && password) {
            return jolokia.execute(Fabric.openShiftFabricMBean, "getGearProfiles", serverUrl, login, password, onSuccess(fn));
        }
        else {
            if (fn) {
                fn([]);
            }
            return [];
        }
    }
    Fabric.getOpenShiftGearProfiles = getOpenShiftGearProfiles;
    function filterProfiles(jolokia, versionId, profileIds) {
        var profiles = [];
        if (versionId) {
            profiles = jolokia.execute(Fabric.managerMBean, "getProfiles(java.lang.String, java.util.List)", versionId, ['id', 'hidden', 'abstract'], { method: 'POST' });
        }
        profiles = profiles.filter(function (profile) {
            return profileIds.some(function (id) {
                return profile.id === id;
            });
        });
        profiles = profiles.filter((function (profile) {
            return !profile.abstract && !profile.hidden;
        }));
        return profiles.map(function (p) {
            return p.id;
        });
    }
    Fabric.filterProfiles = filterProfiles;
    function getProfileData(jolokia, versionId, profileId, fields) {
        return jolokia.execute(Fabric.managerMBean, "getProfile(java.lang.String, java.lang.String, java.util.List)", versionId, profileId, fields, { method: 'POST' });
    }
    Fabric.getProfileData = getProfileData;
    function getConfigFile(jolokia, versionId, profileId, fileName, fn) {
        if (fn === void 0) { fn = null; }
        function onResults(answer) {
            return answer ? answer.decodeBase64() : null;
        }
        var callback = !fn ? null : function (result) {
            fn(onResults(result));
        };
        var answer = jolokia.execute(Fabric.managerMBean, "getConfigurationFile(java.lang.String, java.lang.String, java.lang.String)", versionId, profileId, fileName, onSuccess(callback));
        return fn ? answer : onResults(answer);
    }
    Fabric.getConfigFile = getConfigFile;
    function brokerConfigLink(workspace, jolokia, localStorage, brokerVersion, brokerProfile, brokerId) {
        var path = Fabric.profileLink(workspace, jolokia, localStorage, brokerVersion, brokerProfile);
        path += "/io.fabric8.mq.fabric.server-" + brokerId + ".properties";
        return path;
    }
    Fabric.brokerConfigLink = brokerConfigLink;
    function connectToBroker($scope, container, postfix) {
        if (postfix === void 0) { postfix = null; }
        var view = "#/jmx/attributes?tab=activemq";
        if (postfix) {
            view += "&" + postfix;
        }
        $scope.doConnect(container, view);
    }
    Fabric.connectToBroker = connectToBroker;
    function sanitizeJson(json) {
        angular.forEach(json, function (value, key) {
            if (value === "") {
                delete json[key];
            }
        });
        return json;
    }
    Fabric.sanitizeJson = sanitizeJson;
})(Fabric || (Fabric = {}));
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.BrokerDiagramController", ["$scope", "$compile", "$location", "localStorage", "jolokia", "workspace", "$routeParams", function ($scope, $compile, $location, localStorage, jolokia, workspace, $routeParams) {
        Fabric.initScope($scope, $location, jolokia, workspace);
        var isFmc = Fabric.isFMCContainer(workspace);
        $scope.isFmc = isFmc;
        if (isFmc) {
            $scope.version = $routeParams['versionId'];
            if ($scope.version == 'default-version') {
                $scope.version = Fabric.getDefaultVersionId(jolokia);
            }
            $scope.selectedVersion = { id: $scope.version };
        }
        $scope.selectedNode = null;
        var defaultFlags = {
            panel: true,
            popup: false,
            label: true,
            group: false,
            profile: false,
            slave: false,
            broker: isFmc,
            network: true,
            container: false,
            queue: true,
            topic: true,
            consumer: true,
            producer: true
        };
        $scope.viewSettings = {};
        $scope.shapeSize = {
            broker: 20,
            queue: 14,
            topic: 14
        };
        var redrawGraph = Core.throttled(doRedrawGraph, 1000);
        var graphBuilder = new ForceGraph.GraphBuilder();
        Core.bindModelToSearchParam($scope, $location, "searchFilter", "q", "");
        angular.forEach(defaultFlags, function (defaultValue, key) {
            var modelName = "viewSettings." + key;
            function currentValue() {
                var answer = $location.search()[paramName] || defaultValue;
                return answer === "false" ? false : answer;
            }
            var paramName = key;
            var value = currentValue();
            Core.pathSet($scope, modelName, value);
            $scope.$watch(modelName, function () {
                var current = Core.pathGet($scope, modelName);
                var old = currentValue();
                if (current !== old) {
                    var defaultValue = defaultFlags[key];
                    if (current !== defaultValue) {
                        if (!current) {
                            current = "false";
                        }
                        $location.search(paramName, current);
                    }
                    else {
                        $location.search(paramName, null);
                    }
                }
                redrawGraph();
            });
        });
        $scope.connectToBroker = function () {
            var selectedNode = $scope.selectedNode;
            if (selectedNode) {
                var container = selectedNode["brokerContainer"] || selectedNode;
                connectToBroker(container, selectedNode["brokerName"]);
            }
        };
        function connectToBroker(container, brokerName, postfix) {
            if (postfix === void 0) { postfix = null; }
            if (isFmc && container.jolokia !== jolokia) {
                Fabric.connectToBroker($scope, container, postfix);
            }
            else {
                var view = "/jmx/attributes?tab=activemq";
                if (!postfix) {
                    if (brokerName) {
                        postfix = "nid=root-org.apache.activemq-Broker-" + brokerName;
                    }
                }
                if (postfix) {
                    view += "&" + postfix;
                }
                ActiveMQ.log.info("Opening view " + view);
                var path = Core.url("/#" + view);
                window.open(path, '_destination');
                window.focus();
            }
        }
        $scope.connectToDestination = function () {
            var selectedNode = $scope.selectedNode;
            if (selectedNode) {
                var container = selectedNode["brokerContainer"] || selectedNode;
                var brokerName = selectedNode["brokerName"];
                var destinationType = selectedNode["destinationType"] || selectedNode["typeLabel"];
                var destinationName = selectedNode["destinationName"];
                var postfix = null;
                if (brokerName && destinationType && destinationName) {
                    postfix = "nid=root-org.apache.activemq-Broker-" + brokerName + "-" + destinationType + "-" + destinationName;
                }
                connectToBroker(container, brokerName, postfix);
            }
        };
        $scope.$on('$destroy', function (event) {
            stopOldJolokia();
        });
        function stopOldJolokia() {
            var oldJolokia = $scope.selectedNodeJolokia;
            if (oldJolokia && oldJolokia !== jolokia) {
                oldJolokia.stop();
            }
        }
        $scope.$watch("selectedNode", function (newValue, oldValue) {
            if ($scope.unregisterFn) {
                $scope.unregisterFn();
                $scope.unregisterFn = null;
            }
            var node = $scope.selectedNode;
            if (node) {
                var mbean = node.objectName;
                var brokerContainer = node.brokerContainer || {};
                var nodeJolokia = node.jolokia || brokerContainer.jolokia || jolokia;
                if (nodeJolokia !== $scope.selectedNodeJolokia) {
                    stopOldJolokia();
                    $scope.selectedNodeJolokia = nodeJolokia;
                    if (nodeJolokia !== jolokia) {
                        var rate = Core.parseIntValue(localStorage['updateRate'] || "2000", "update rate");
                        if (rate) {
                            nodeJolokia.start(rate);
                        }
                    }
                }
                var dummyResponse = { value: node.panelProperties || {} };
                if (mbean && nodeJolokia) {
                    ActiveMQ.log.debug("reading ", mbean, " on remote container");
                    $scope.unregisterFn = Core.register(nodeJolokia, $scope, {
                        type: 'read',
                        mbean: mbean
                    }, onSuccess(renderNodeAttributes, {
                        error: function (response) {
                            renderNodeAttributes(dummyResponse);
                            Core.defaultJolokiaErrorHandler(response);
                        }
                    }));
                }
                else {
                    ActiveMQ.log.debug("no mbean or jolokia available, using dummy response");
                    renderNodeAttributes(dummyResponse);
                }
            }
        });
        function getDestinationTypeName(attributes) {
            var prefix = attributes["DestinationTemporary"] ? "Temporary " : "";
            return prefix + (attributes["DestinationTopic"] ? "Topic" : "Queue");
        }
        var ignoreNodeAttributes = ["Broker", "BrokerId", "BrokerName", "Connection", "DestinationName", "DestinationQueue", "DestinationTemporary", "DestinationTopic", ];
        var ignoreNodeAttributesByType = {
            producer: ["Producer", "ProducerId"],
            queue: ["Name", "MessageGroups", "MessageGroupType", "Subscriptions"],
            topic: ["Name", "Subscriptions"],
            broker: ["DataDirectory", "DurableTopicSubscriptions", "DynamicDestinationProducers", "InactiveDurableToppicSubscribers"]
        };
        var brokerShowProperties = ["AverageMessageSize", "BrokerId", "JobSchedulerStorePercentUsage", "Slave", "MemoryPercentUsage", "StorePercentUsage", "TempPercentUsage"];
        var onlyShowAttributesByType = {
            broker: brokerShowProperties,
            brokerSlave: brokerShowProperties
        };
        function renderNodeAttributes(response) {
            var properties = [];
            if (response) {
                var value = response.value || {};
                $scope.selectedNodeAttributes = value;
                var selectedNode = $scope.selectedNode || {};
                var brokerContainer = selectedNode['brokerContainer'] || {};
                var nodeType = selectedNode["type"];
                var brokerName = selectedNode["brokerName"];
                var containerId = selectedNode["container"] || brokerContainer["container"];
                var group = selectedNode["group"] || brokerContainer["group"];
                var jolokiaUrl = selectedNode["jolokiaUrl"] || brokerContainer["jolokiaUrl"];
                var profile = selectedNode["profile"] || brokerContainer["profile"];
                var version = selectedNode["version"] || brokerContainer["version"];
                var isBroker = nodeType && nodeType.startsWith("broker");
                var ignoreKeys = ignoreNodeAttributes.concat(ignoreNodeAttributesByType[nodeType] || []);
                var onlyShowKeys = onlyShowAttributesByType[nodeType];
                angular.forEach(value, function (v, k) {
                    if (onlyShowKeys ? onlyShowKeys.indexOf(k) >= 0 : ignoreKeys.indexOf(k) < 0) {
                        var formattedValue = Core.humanizeValueHtml(v);
                        properties.push({ key: Core.humanizeValue(k), value: formattedValue });
                    }
                });
                properties = properties.sortBy("key");
                var brokerProperty = null;
                if (brokerName) {
                    var brokerHtml = '<a target="broker" ng-click="connectToBroker()">' + '<img title="Apache ActiveMQ" src="img/icons/messagebroker.svg"> ' + brokerName + '</a>';
                    if (version && profile) {
                        var brokerLink = Fabric.brokerConfigLink(workspace, jolokia, localStorage, version, profile, brokerName);
                        if (brokerLink) {
                            brokerHtml += ' <a title="configuration settings" target="brokerConfig" href="' + brokerLink + '"><i class="icon-tasks"></i></a>';
                        }
                    }
                    var html = $compile(brokerHtml)($scope);
                    brokerProperty = { key: "Broker", value: html };
                    if (!isBroker) {
                        properties.splice(0, 0, brokerProperty);
                    }
                }
                if (containerId) {
                    properties.splice(0, 0, { key: "Container", value: $compile('<div fabric-container-link="' + selectedNode['container'] + '"></div>')($scope) });
                }
                var destinationName = value["DestinationName"] || selectedNode["destinationName"];
                if (destinationName && (nodeType !== "queue" && nodeType !== "topic")) {
                    var destinationTypeName = getDestinationTypeName(value);
                    var html = createDestinationLink(destinationName, destinationTypeName);
                    properties.splice(0, 0, { key: destinationTypeName, value: html });
                }
                var typeLabel = selectedNode["typeLabel"];
                var name = selectedNode["name"] || selectedNode["id"] || selectedNode['objectName'];
                if (typeLabel) {
                    var html = name;
                    if (nodeType === "queue" || nodeType === "topic") {
                        html = createDestinationLink(name, nodeType);
                    }
                    var typeProperty = { key: typeLabel, value: html };
                    if (isBroker && brokerProperty) {
                        typeProperty = brokerProperty;
                    }
                    properties.splice(0, 0, typeProperty);
                }
            }
            $scope.selectedNodeProperties = properties;
            Core.$apply($scope);
        }
        function createDestinationLink(destinationName, destinationType) {
            if (destinationType === void 0) { destinationType = "queue"; }
            return $compile('<a target="destination" title="' + destinationName + '" ng-click="connectToDestination()">' + destinationName + '</a>')($scope);
        }
        $scope.$watch("searchFilter", function (newValue, oldValue) {
            redrawGraph();
        });
        if (isFmc) {
            var unreg = null;
            $scope.$watch('selectedVersion.id', function (newValue, oldValue) {
                if (!Core.isBlank(newValue)) {
                    if (unreg) {
                        unreg();
                    }
                    unreg = Core.register(jolokia, $scope, { type: 'exec', mbean: Fabric.mqManagerMBean, operation: "loadBrokerStatus(java.lang.String)", arguments: [newValue] }, onSuccess(onBrokerData));
                }
            });
        }
        else {
            $scope.$watch('workspace.tree', function () {
                redrawGraph();
            });
            $scope.$on('jmxTreeUpdated', function () {
                redrawGraph();
            });
        }
        function onBrokerData(response) {
            if (response) {
                var responseJson = angular.toJson(response.value);
                if ($scope.responseJson === responseJson) {
                    return;
                }
                $scope.responseJson = responseJson;
                $scope.brokers = response.value;
                doRedrawGraph();
            }
        }
        function redrawFabricBrokers() {
            var containersToDelete = $scope.activeContainers || {};
            $scope.activeContainers = {};
            angular.forEach($scope.brokers, function (brokerStatus) {
                brokerStatus.validContainer = brokerStatus.alive && brokerStatus.master && brokerStatus.provisionStatus === "success";
                renameTypeProperty(brokerStatus);
                var groupId = brokerStatus.group;
                var profileId = brokerStatus.profile;
                var brokerId = brokerStatus.brokerName;
                var containerId = brokerStatus.container;
                var versionId = brokerStatus.version || "1.0";
                var group = getOrAddNode("group", groupId, brokerStatus, function () {
                    return {
                        typeLabel: "Broker Group",
                        popup: {
                            title: "Broker Group: " + groupId,
                            content: "<p>" + groupId + "</p>"
                        }
                    };
                });
                var profile = getOrAddNode("profile", profileId, brokerStatus, function () {
                    return {
                        typeLabel: "Profile",
                        popup: {
                            title: "Profile: " + profileId,
                            content: "<p>" + profileId + "</p>"
                        }
                    };
                });
                var container = null;
                if (containerId) {
                    container = getOrAddNode("container", containerId, brokerStatus, function () {
                        return {
                            containerId: containerId,
                            typeLabel: "Container",
                            popup: {
                                title: "Container: " + containerId,
                                content: "<p>" + containerId + " version: " + versionId + "</p>"
                            }
                        };
                    });
                }
                var master = brokerStatus.master;
                var broker = getOrAddBroker(master, brokerId, groupId, containerId, container, brokerStatus);
                if (container && container.validContainer) {
                    var key = container.containerId;
                    $scope.activeContainers[key] = container;
                    delete containersToDelete[key];
                }
                if ($scope.viewSettings.group) {
                    if ($scope.viewSettings.profile) {
                        addLink(group, profile, "group");
                        addLink(profile, broker, "broker");
                    }
                    else {
                        addLink(group, broker, "group");
                    }
                }
                else {
                    if ($scope.viewSettings.profile) {
                        addLink(profile, broker, "broker");
                    }
                }
                if (container) {
                    if ((master || $scope.viewSettings.slave) && $scope.viewSettings.container) {
                        addLink(broker, container, "container");
                        container.destinationLinkNode = container;
                    }
                    else {
                        container.destinationLinkNode = broker;
                    }
                }
            });
            redrawActiveContainers();
        }
        function redrawLocalBroker() {
            var container = {
                jolokia: jolokia
            };
            var containerId = "local";
            $scope.activeContainers = {
                containerId: container
            };
            if ($scope.viewSettings.broker) {
                jolokia.search("org.apache.activemq:type=Broker,brokerName=*", onSuccess(function (response) {
                    angular.forEach(response, function (objectName) {
                        var details = Core.parseMBean(objectName);
                        if (details) {
                            var properties = details['attributes'];
                            ActiveMQ.log.info("Got broker: " + objectName + " on container: " + containerId + " properties: " + angular.toJson(properties, true));
                            if (properties) {
                                var master = true;
                                var brokerId = properties["brokerName"] || "unknown";
                                var groupId = "";
                                var broker = getOrAddBroker(master, brokerId, groupId, containerId, container, properties);
                            }
                        }
                    });
                    redrawActiveContainers();
                }));
            }
            else {
                redrawActiveContainers();
            }
        }
        function redrawActiveContainers() {
            angular.forEach($scope.activeContainers, function (container, id) {
                var containerJolokia = container.jolokia;
                if (containerJolokia) {
                    onContainerJolokia(containerJolokia, container, id);
                }
                else {
                    Fabric.containerJolokia(jolokia, id, function (containerJolokia) { return onContainerJolokia(containerJolokia, container, id); });
                }
            });
            $scope.graph = graphBuilder.buildGraph();
            Core.$apply($scope);
        }
        function doRedrawGraph() {
            graphBuilder = new ForceGraph.GraphBuilder();
            if (isFmc) {
                redrawFabricBrokers();
            }
            else {
                redrawLocalBroker();
            }
        }
        function brokerNameMarkup(brokerName) {
            return brokerName ? "<p></p>broker: " + brokerName + "</p>" : "";
        }
        function matchesDestinationName(destinationName, typeName) {
            if (destinationName) {
                var selection = workspace.selection;
                if (selection && selection.domain === ActiveMQ.jmxDomain) {
                    var type = selection.entries["destinationType"];
                    if (type) {
                        if ((type === "Queue" && typeName === "topic") || (type === "Topic" && typeName === "queue")) {
                            return false;
                        }
                    }
                    var destName = selection.entries["destinationName"];
                    if (destName) {
                        if (destName !== destinationName)
                            return false;
                    }
                }
                ActiveMQ.log.info("selection: " + selection);
                return !$scope.searchFilter || destinationName.indexOf($scope.searchFilter) >= 0;
            }
            return false;
        }
        function onContainerJolokia(containerJolokia, container, id) {
            if (containerJolokia) {
                container.jolokia = containerJolokia;
                function getOrAddDestination(properties) {
                    var typeName = properties.destType;
                    var brokerName = properties.brokerName;
                    var destinationName = properties.destinationName;
                    if (!matchesDestinationName(destinationName, typeName)) {
                        return null;
                    }
                    var hideFlag = "topic" === typeName ? $scope.viewSettings.topic : $scope.viewSettings.queue;
                    if (!hideFlag) {
                        return null;
                    }
                    var destination = getOrAddNode(typeName, destinationName, properties, function () {
                        var destinationTypeName = properties.destinationType || "Queue";
                        var objectName = "";
                        if (brokerName) {
                            if (!destinationName.startsWith("ActiveMQ.Advisory.TempQueue_ActiveMQ.Advisory.TempTopic")) {
                                objectName = "org.apache.activemq:type=Broker,brokerName=" + brokerName + ",destinationType=" + destinationTypeName + ",destinationName=" + destinationName;
                            }
                        }
                        var answer = {
                            typeLabel: destinationTypeName,
                            brokerContainer: container,
                            objectName: objectName,
                            jolokia: containerJolokia,
                            popup: {
                                title: destinationTypeName + ": " + destinationName,
                                content: brokerNameMarkup(properties.brokerName)
                            }
                        };
                        if (!brokerName) {
                            containerJolokia.search("org.apache.activemq:destinationType=" + destinationTypeName + ",destinationName=" + destinationName + ",*", onSuccess(function (response) {
                                ActiveMQ.log.info("Found destination mbean: " + response);
                                if (response && response.length) {
                                    answer.objectName = response[0];
                                }
                            }));
                        }
                        return answer;
                    });
                    if (destination && $scope.viewSettings.broker && brokerName) {
                        addLinkIds(brokerNodeId(brokerName), destination["id"], "destination");
                    }
                    return destination;
                }
                var brokerId = container.brokerName;
                if (brokerId && $scope.viewSettings.network && $scope.viewSettings.broker) {
                    containerJolokia.request({ type: "read", mbean: "org.apache.activemq:connector=networkConnectors,*" }, onSuccess(function (response) {
                        angular.forEach(response.value, function (properties, objectName) {
                            var details = Core.parseMBean(objectName);
                            var attributes = details['attributes'];
                            if (properties) {
                                configureDestinationProperties(properties);
                                var remoteBrokerId = properties.RemoteBrokerName;
                                if (remoteBrokerId) {
                                    addLinkIds(brokerNodeId(brokerId), brokerNodeId(remoteBrokerId), "network");
                                }
                            }
                        });
                        graphModelUpdated();
                    }));
                }
                if ($scope.viewSettings.consumer) {
                    containerJolokia.search("org.apache.activemq:endpoint=Consumer,*", onSuccess(function (response) {
                        angular.forEach(response, function (objectName) {
                            var details = Core.parseMBean(objectName);
                            if (details) {
                                var properties = details['attributes'];
                                if (properties) {
                                    configureDestinationProperties(properties);
                                    var consumerId = properties.consumerId;
                                    if (consumerId) {
                                        var destination = getOrAddDestination(properties);
                                        if (destination) {
                                            addLink(container.destinationLinkNode, destination, "destination");
                                            var consumer = getOrAddNode("consumer", consumerId, properties, function () {
                                                return {
                                                    typeLabel: "Consumer",
                                                    brokerContainer: container,
                                                    objectName: objectName,
                                                    jolokia: containerJolokia,
                                                    popup: {
                                                        title: "Consumer: " + consumerId,
                                                        content: "<p>client: " + (properties.clientId || "") + "</p> " + brokerNameMarkup(properties.brokerName)
                                                    }
                                                };
                                            });
                                            addLink(destination, consumer, "consumer");
                                        }
                                    }
                                }
                            }
                        });
                        graphModelUpdated();
                    }));
                }
                if ($scope.viewSettings.producer) {
                    containerJolokia.search("org.apache.activemq:endpoint=Producer,*", onSuccess(function (response) {
                        angular.forEach(response, function (objectName) {
                            var details = Core.parseMBean(objectName);
                            if (details) {
                                var properties = details['attributes'];
                                if (properties) {
                                    configureDestinationProperties(properties);
                                    var producerId = properties.producerId;
                                    if (producerId) {
                                        var destination = getOrAddDestination(properties);
                                        if (destination) {
                                            addLink(container.destinationLinkNode, destination, "destination");
                                            var producer = getOrAddNode("producer", producerId, properties, function () {
                                                return {
                                                    typeLabel: "Producer",
                                                    brokerContainer: container,
                                                    objectName: objectName,
                                                    jolokia: containerJolokia,
                                                    popup: {
                                                        title: "Producer: " + producerId,
                                                        content: "<p>client: " + (properties.clientId || "") + "</p> " + brokerNameMarkup(properties.brokerName)
                                                    }
                                                };
                                            });
                                            addLink(producer, destination, "producer");
                                        }
                                        graphModelUpdated();
                                    }
                                }
                            }
                        });
                        graphModelUpdated();
                    }));
                }
                if ($scope.viewSettings.producer) {
                    containerJolokia.request({ type: "read", mbean: "org.apache.activemq:endpoint=dynamicProducer,*" }, onSuccess(function (response) {
                        angular.forEach(response.value, function (mbeanValues, objectName) {
                            var details = Core.parseMBean(objectName);
                            var attributes = details['attributes'];
                            var properties = {};
                            angular.forEach(attributes, function (value, key) {
                                properties[key] = value;
                            });
                            angular.forEach(mbeanValues, function (value, key) {
                                properties[key] = value;
                            });
                            configureDestinationProperties(properties);
                            properties['destinationName'] = properties['DestinationName'];
                            var producerId = properties["producerId"] || properties["ProducerId"];
                            if (properties["DestinationTemporary"] || properties["DestinationTopc"]) {
                                properties["destType"] = "topic";
                            }
                            var destination = getOrAddDestination(properties);
                            if (producerId && destination) {
                                addLink(container.destinationLinkNode, destination, "destination");
                                var producer = getOrAddNode("producer", producerId, properties, function () {
                                    return {
                                        typeLabel: "Producer (Dynamic)",
                                        brokerContainer: container,
                                        objectName: objectName,
                                        jolokia: containerJolokia,
                                        popup: {
                                            title: "Producer (Dynamic): " + producerId,
                                            content: "<p>client: " + (properties['ClientId'] || "") + "</p> " + brokerNameMarkup(properties['brokerName'])
                                        }
                                    };
                                });
                                addLink(producer, destination, "producer");
                            }
                        });
                        graphModelUpdated();
                    }));
                }
            }
        }
        function graphModelUpdated() {
            $scope.graph = graphBuilder.buildGraph();
            Core.$apply($scope);
        }
        function getOrAddBroker(master, brokerId, groupId, containerId, container, brokerStatus) {
            var broker = null;
            var brokerFlag = master ? $scope.viewSettings.broker : $scope.viewSettings.slave;
            if (brokerFlag) {
                broker = getOrAddNode("broker", brokerId + (master ? "" : ":slave"), brokerStatus, function () {
                    return {
                        type: master ? "broker" : "brokerSlave",
                        typeLabel: master ? "Broker" : "Slave Broker",
                        popup: {
                            title: (master ? "Master" : "Slave") + " Broker: " + brokerId,
                            content: "<p>Container: " + containerId + "</p> <p>Group: " + groupId + "</p>"
                        }
                    };
                });
                if (master) {
                    if (!broker['objectName']) {
                        broker['objectName'] = "org.apache.activemq:type=Broker,brokerName=" + brokerId;
                        ActiveMQ.log.info("Guessed broker mbean: " + broker['objectName']);
                    }
                    if (!broker['brokerContainer'] && container) {
                        broker['brokerContainer'] = container;
                    }
                }
            }
            return broker;
        }
        function getOrAddNode(typeName, id, properties, createFn) {
            var node = null;
            if (id) {
                var nodeId = typeName + ":" + id;
                node = graphBuilder.getNode(nodeId);
                if (!node) {
                    var nodeValues = createFn();
                    node = angular.copy(properties);
                    angular.forEach(nodeValues, function (value, key) { return node[key] = value; });
                    node['id'] = nodeId;
                    if (!node['type']) {
                        node['type'] = typeName;
                    }
                    if (!node['name']) {
                        node['name'] = id;
                    }
                    if (node) {
                        var size = $scope.shapeSize[typeName];
                        if (size && !node['size']) {
                            node['size'] = size;
                        }
                        if (!node['summary']) {
                            node['summary'] = node['popup'] || "";
                        }
                        if (!$scope.viewSettings.popup) {
                            delete node['popup'];
                        }
                        if (!$scope.viewSettings.label) {
                            delete node['name'];
                        }
                        var enabled = $scope.viewSettings[typeName];
                        if (enabled || !angular.isDefined(enabled)) {
                            graphBuilder.addNode(node);
                        }
                        else {
                        }
                    }
                }
            }
            return node;
        }
        function addLink(object1, object2, linkType) {
            if (object1 && object2) {
                addLinkIds(object1.id, object2.id, linkType);
            }
        }
        function addLinkIds(id1, id2, linkType) {
            if (id1 && id2) {
                graphBuilder.addLink(id1, id2, linkType);
            }
        }
        function brokerNodeId(brokerId) {
            return brokerId ? "broker:" + brokerId : null;
        }
        function renameTypeProperty(properties) {
            properties.mbeanType = properties['type'];
            delete properties['type'];
        }
        function configureDestinationProperties(properties) {
            renameTypeProperty(properties);
            var destinationType = properties.destinationType || "Queue";
            var typeName = destinationType.toLowerCase();
            properties.isQueue = !typeName.startsWith("t");
            properties['destType'] = typeName;
        }
    }]);
})(ActiveMQ || (ActiveMQ = {}));
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ.BrowseQueueController = ActiveMQ._module.controller("ActiveMQ.BrowseQueueController", ["$scope", "workspace", "jolokia", "localStorage", '$location', "activeMQMessage", "$timeout", function ($scope, workspace, jolokia, localStorage, location, activeMQMessage, $timeout) {
        $scope.searchText = '';
        $scope.allMessages = [];
        $scope.messages = [];
        $scope.headers = {};
        $scope.mode = 'text';
        $scope.deleteDialog = false;
        $scope.moveDialog = false;
        $scope.gridOptions = {
            selectedItems: [],
            data: 'messages',
            displayFooter: false,
            showFilter: false,
            showColumnMenu: true,
            enableColumnResize: true,
            enableColumnReordering: true,
            enableHighlighting: true,
            filterOptions: {
                filterText: '',
                useExternalFilter: true
            },
            selectWithCheckboxOnly: true,
            showSelectionCheckbox: true,
            maintainColumnRatios: false,
            columnDefs: [
                {
                    field: 'JMSMessageID',
                    displayName: 'Message ID',
                    cellTemplate: '<div class="ngCellText"><a ng-click="openMessageDialog(row)">{{row.entity.JMSMessageID}}</a></div>',
                    width: '34%'
                },
                {
                    field: 'JMSType',
                    displayName: 'Type',
                    width: '10%'
                },
                {
                    field: 'JMSPriority',
                    displayName: 'Priority',
                    width: '7%'
                },
                {
                    field: 'JMSTimestamp',
                    displayName: 'Timestamp',
                    width: '19%'
                },
                {
                    field: 'JMSExpiration',
                    displayName: 'Expires',
                    width: '10%'
                },
                {
                    field: 'JMSReplyTo',
                    displayName: 'Reply To',
                    width: '10%'
                },
                {
                    field: 'JMSCorrelationID',
                    displayName: 'Correlation ID',
                    width: '10%'
                }
            ]
        };
        $scope.showMessageDetails = false;
        var ignoreColumns = ["PropertiesText", "BodyPreview", "Text"];
        var flattenColumns = ["BooleanProperties", "ByteProperties", "ShortProperties", "IntProperties", "LongProperties", "FloatProperties", "DoubleProperties", "StringProperties"];
        $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid()) {
                return;
            }
            setTimeout(loadTable, 50);
        });
        $scope.$watch('gridOptions.filterOptions.filterText', function (filterText) {
            filterMessages(filterText);
        });
        $scope.openMessageDialog = function (message) {
            ActiveMQ.selectCurrentMessage(message, "JMSMessageID", $scope);
            if ($scope.row) {
                $scope.mode = CodeEditor.detectTextFormat($scope.row.Text);
                $scope.showMessageDetails = true;
            }
        };
        $scope.refresh = loadTable;
        ActiveMQ.decorate($scope);
        $scope.moveMessages = function () {
            var selection = workspace.selection;
            var mbean = selection.objectName;
            if (mbean && selection) {
                var selectedItems = $scope.gridOptions.selectedItems;
                $scope.message = "Moved " + Core.maybePlural(selectedItems.length, "message" + " to " + $scope.queueName);
                var operation = "moveMessageTo(java.lang.String, java.lang.String)";
                angular.forEach(selectedItems, function (item, idx) {
                    var id = item.JMSMessageID;
                    if (id) {
                        var callback = (idx + 1 < selectedItems.length) ? intermediateResult : moveSuccess;
                        jolokia.execute(mbean, operation, id, $scope.queueName, onSuccess(callback));
                    }
                });
            }
        };
        $scope.resendMessage = function () {
            var selection = workspace.selection;
            var mbean = selection.objectName;
            if (mbean && selection) {
                var selectedItems = $scope.gridOptions.selectedItems;
                activeMQMessage.message = selectedItems[0];
                location.path('activemq/sendMessage');
            }
        };
        $scope.deleteMessages = function () {
            var selection = workspace.selection;
            var mbean = selection.objectName;
            if (mbean && selection) {
                var selectedItems = $scope.gridOptions.selectedItems;
                $scope.message = "Deleted " + Core.maybePlural(selectedItems.length, "message");
                var operation = "removeMessage(java.lang.String)";
                angular.forEach(selectedItems, function (item, idx) {
                    var id = item.JMSMessageID;
                    if (id) {
                        var callback = (idx + 1 < selectedItems.length) ? intermediateResult : operationSuccess;
                        jolokia.execute(mbean, operation, id, onSuccess(callback));
                    }
                });
            }
        };
        $scope.retryMessages = function () {
            var selection = workspace.selection;
            var mbean = selection.objectName;
            if (mbean && selection) {
                var selectedItems = $scope.gridOptions.selectedItems;
                $scope.message = "Retry " + Core.maybePlural(selectedItems.length, "message");
                var operation = "retryMessage(java.lang.String)";
                angular.forEach(selectedItems, function (item, idx) {
                    var id = item.JMSMessageID;
                    if (id) {
                        var callback = (idx + 1 < selectedItems.length) ? intermediateResult : operationSuccess;
                        jolokia.execute(mbean, operation, id, onSuccess(callback));
                    }
                });
            }
        };
        $scope.queueNames = function (completionText) {
            var queuesFolder = ActiveMQ.getSelectionQueuesFolder(workspace);
            return (queuesFolder) ? queuesFolder.children.map(function (n) { return n.title; }) : [];
        };
        function populateTable(response) {
            var data = response.value;
            if (!angular.isArray(data)) {
                $scope.allMessages = [];
                angular.forEach(data, function (value, idx) {
                    $scope.allMessages.push(value);
                });
            }
            else {
                $scope.allMessages = data;
            }
            angular.forEach($scope.allMessages, function (message) {
                message.headerHtml = createHeaderHtml(message);
                message.bodyText = createBodyText(message);
            });
            Core.$apply($scope);
            filterMessages($scope.gridOptions.filterOptions.filterText);
        }
        function createBodyText(message) {
            if (message.Text) {
                var body = message.Text;
                var lenTxt = "" + body.length;
                message.textMode = "text (" + lenTxt + " chars)";
                return body;
            }
            else if (message.BodyPreview) {
                var code = Core.parseIntValue(localStorage["activemqBrowseBytesMessages"] || "1", "browse bytes messages");
                var body;
                message.textMode = "bytes (turned off)";
                if (code != 99) {
                    var bytesArr = [];
                    var textArr = [];
                    message.BodyPreview.forEach(function (b) {
                        if (code === 1 || code === 2) {
                            textArr.push(String.fromCharCode(b));
                        }
                        if (code === 1 || code === 4) {
                            var s = b.toString(16);
                            if (s.length === 1) {
                                s = "0" + s;
                            }
                            bytesArr.push(s);
                        }
                        else {
                            var s = b.toString(10);
                            bytesArr.push(s);
                        }
                    });
                    var bytesData = bytesArr.join(" ");
                    var textData = textArr.join("");
                    if (code === 1 || code === 2) {
                        var len = message.BodyPreview.length;
                        var lenTxt = "" + textArr.length;
                        body = "bytes:\n" + bytesData + "\n\ntext:\n" + textData;
                        message.textMode = "bytes (" + len + " bytes) and text (" + lenTxt + " chars)";
                    }
                    else {
                        var len = message.BodyPreview.length;
                        body = bytesData;
                        message.textMode = "bytes (" + len + " bytes)";
                    }
                }
                return body;
            }
            else {
                message.textMode = "unsupported";
                return "Unsupported message body type which cannot be displayed by hawtio";
            }
        }
        function createHeaderHtml(message) {
            var headers = createHeaders(message);
            var properties = createProperties(message);
            var headerKeys = Object.extended(headers).keys();
            function sort(a, b) {
                if (a > b)
                    return 1;
                if (a < b)
                    return -1;
                return 0;
            }
            var propertiesKeys = Object.extended(properties).keys().sort(sort);
            var jmsHeaders = headerKeys.filter(function (key) {
                return key.startsWith("JMS");
            }).sort(sort);
            var remaining = headerKeys.subtract(jmsHeaders, propertiesKeys).sort(sort);
            var buffer = [];
            function appendHeader(key) {
                var value = headers[key];
                if (value === null) {
                    value = '';
                }
                buffer.push('<tr><td class="propertyName"><span class="green">Header</span> - ' + key + '</td><td class="property-value">' + value + '</td></tr>');
            }
            function appendProperty(key) {
                var value = properties[key];
                if (value === null) {
                    value = '';
                }
                buffer.push('<tr><td class="propertyName">' + key + '</td><td class="property-value">' + value + '</td></tr>');
            }
            jmsHeaders.forEach(appendHeader);
            remaining.forEach(appendHeader);
            propertiesKeys.forEach(appendProperty);
            return buffer.join("\n");
        }
        function createHeaders(row) {
            ActiveMQ.log.debug("headers: ", row);
            var answer = {};
            angular.forEach(row, function (value, key) {
                if (!ignoreColumns.any(key) && !flattenColumns.any(key)) {
                    answer[Core.escapeHtml(key)] = Core.escapeHtml(value);
                }
            });
            return answer;
        }
        function createProperties(row) {
            ActiveMQ.log.debug("properties: ", row);
            var answer = {};
            angular.forEach(row, function (value, key) {
                if (!ignoreColumns.any(key) && flattenColumns.any(key)) {
                    angular.forEach(value, function (v2, k2) {
                        answer['<span class="green">' + key.replace('Properties', ' Property') + '</span> - ' + Core.escapeHtml(k2)] = Core.escapeHtml(v2);
                    });
                }
            });
            return answer;
        }
        function loadTable() {
            var objName;
            if (workspace.selection) {
                objName = workspace.selection.objectName;
            }
            else {
                var key = location.search()['nid'];
                var node = workspace.keyToNodeMap[key];
                objName = node.objectName;
            }
            if (objName) {
                $scope.dlq = false;
                jolokia.getAttribute(objName, "DLQ", onSuccess(onDlq, { silent: true }));
                jolokia.request({ type: 'exec', mbean: objName, operation: 'browse()' }, onSuccess(populateTable));
            }
        }
        function onDlq(response) {
            $scope.dlq = response;
            Core.$apply($scope);
        }
        function intermediateResult() {
        }
        function operationSuccess() {
            $scope.messageDialog = false;
            $scope.gridOptions.selectedItems.splice(0);
            Core.notification("success", $scope.message);
            setTimeout(loadTable, 50);
        }
        function moveSuccess() {
            operationSuccess();
            workspace.loadTree();
        }
        function filterMessages(filter) {
            var searchConditions = buildSearchConditions(filter);
            evalFilter(searchConditions);
        }
        function evalFilter(searchConditions) {
            if (!searchConditions || searchConditions.length === 0) {
                $scope.messages = $scope.allMessages;
            }
            else {
                ActiveMQ.log.debug("Filtering conditions:", searchConditions);
                $scope.messages = $scope.allMessages.filter(function (message) {
                    ActiveMQ.log.debug("Message:", message);
                    var matched = true;
                    $.each(searchConditions, function (index, condition) {
                        if (!condition.column) {
                            matched = matched && evalMessage(message, condition.regex);
                        }
                        else {
                            matched = matched && (message[condition.column] && condition.regex.test(message[condition.column])) || (message.StringProperties && message.StringProperties[condition.column] && condition.regex.test(message.StringProperties[condition.column]));
                        }
                    });
                    return matched;
                });
            }
        }
        function evalMessage(message, regex) {
            var jmsHeaders = ['JMSDestination', 'JMSDeliveryMode', 'JMSExpiration', 'JMSPriority', 'JMSMessageID', 'JMSTimestamp', 'JMSCorrelationID', 'JMSReplyTo', 'JMSType', 'JMSRedelivered'];
            for (var i = 0; i < jmsHeaders.length; i++) {
                var header = jmsHeaders[i];
                if (message[header] && regex.test(message[header])) {
                    return true;
                }
            }
            if (message.StringProperties) {
                for (var property in message.StringProperties) {
                    if (regex.test(message.StringProperties[property])) {
                        return true;
                    }
                }
            }
            if (message.bodyText && regex.test(message.bodyText)) {
                return true;
            }
            return false;
        }
        function getRegExp(str, modifiers) {
            try {
                return new RegExp(str, modifiers);
            }
            catch (err) {
                return new RegExp(str.replace(/(\^|\$|\(|\)|<|>|\[|\]|\{|\}|\\|\||\.|\*|\+|\?)/g, '\\$1'));
            }
        }
        function buildSearchConditions(filterText) {
            var searchConditions = [];
            var qStr;
            if (!(qStr = $.trim(filterText))) {
                return;
            }
            var columnFilters = qStr.split(";");
            for (var i = 0; i < columnFilters.length; i++) {
                var args = columnFilters[i].split(':');
                if (args.length > 1) {
                    var columnName = $.trim(args[0]);
                    var columnValue = $.trim(args[1]);
                    if (columnName && columnValue) {
                        searchConditions.push({
                            column: columnName,
                            columnDisplay: columnName.replace(/\s+/g, '').toLowerCase(),
                            regex: getRegExp(columnValue, 'i')
                        });
                    }
                }
                else {
                    var val = $.trim(args[0]);
                    if (val) {
                        searchConditions.push({
                            column: '',
                            regex: getRegExp(val, 'i')
                        });
                    }
                }
            }
            return searchConditions;
        }
    }]);
})(ActiveMQ || (ActiveMQ = {}));
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.DestinationController", ["$scope", "workspace", "jolokia", function ($scope, workspace, jolokia) {
        $scope.workspace = workspace;
        $scope.message = "";
        $scope.queueType = 'true';
        $scope.deleteDialog = false;
        $scope.purgeDialog = false;
        updateQueueType();
        function updateQueueType() {
            $scope.destinationTypeName = $scope.queueType ? "Queue" : "Topic";
        }
        $scope.$watch('queueType', function () {
            updateQueueType();
        });
        $scope.$watch('workspace.selection', function () {
            workspace.moveIfViewInvalid();
        });
        function operationSuccess() {
            $scope.destinationName = "";
            $scope.workspace.operationCounter += 1;
            Core.$apply($scope);
            Core.notification("success", $scope.message);
            $scope.workspace.loadTree();
        }
        function deleteSuccess() {
            workspace.removeAndSelectParentNode();
            $scope.workspace.operationCounter += 1;
            Core.$apply($scope);
            Core.notification("success", $scope.message);
            $scope.workspace.loadTree();
        }
        function getBrokerMBean(jolokia) {
            var mbean = null;
            var selection = workspace.selection;
            if (selection && ActiveMQ.isBroker(workspace) && selection.objectName) {
                return selection.objectName;
            }
            var folderNames = selection.folderNames;
            var parent = selection ? selection.parent : null;
            if (selection && parent && jolokia && folderNames && folderNames.length > 1) {
                mbean = parent.objectName;
                if (!mbean && parent) {
                    mbean = parent.parent.objectName;
                }
                if (!mbean) {
                    mbean = "" + folderNames[0] + ":BrokerName=" + folderNames[1] + ",Type=Broker";
                }
            }
            return mbean;
        }
        $scope.createDestination = function (name, isQueue) {
            var mbean = getBrokerMBean(jolokia);
            if (mbean) {
                var operation;
                if (isQueue) {
                    operation = "addQueue(java.lang.String)";
                    $scope.message = "Created queue " + name;
                }
                else {
                    operation = "addTopic(java.lang.String)";
                    $scope.message = "Created topic " + name;
                }
                if (mbean) {
                    jolokia.execute(mbean, operation, name, onSuccess(operationSuccess));
                }
                else {
                    Core.notification("error", "Could not find the Broker MBean!");
                }
            }
        };
        $scope.deleteDestination = function () {
            var mbean = getBrokerMBean(jolokia);
            var selection = workspace.selection;
            var entries = selection.entries;
            if (mbean && selection && jolokia && entries) {
                var domain = selection.domain;
                var name = entries["Destination"] || entries["destinationName"] || selection.title;
                name = name.unescapeHTML();
                var isQueue = "Topic" !== (entries["Type"] || entries["destinationType"]);
                var operation;
                if (isQueue) {
                    operation = "removeQueue(java.lang.String)";
                    $scope.message = "Deleted queue " + name;
                }
                else {
                    operation = "removeTopic(java.lang.String)";
                    $scope.message = "Deleted topic " + name;
                }
                jolokia.execute(mbean, operation, name, onSuccess(deleteSuccess));
            }
        };
        $scope.purgeDestination = function () {
            var mbean = workspace.getSelectedMBeanName();
            var selection = workspace.selection;
            var entries = selection.entries;
            if (mbean && selection && jolokia && entries) {
                var name = entries["Destination"] || entries["destinationName"] || selection.title;
                name = name.unescapeHTML();
                var operation = "purge()";
                $scope.message = "Purged queue " + name;
                jolokia.execute(mbean, operation, onSuccess(operationSuccess));
            }
        };
        $scope.name = function () {
            var selection = workspace.selection;
            if (selection) {
                return selection.title;
            }
            return null;
        };
    }]);
})(ActiveMQ || (ActiveMQ = {}));
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.DurableSubscriberController", ["$scope", "workspace", "jolokia", function ($scope, workspace, jolokia) {
        $scope.refresh = loadTable;
        $scope.durableSubscribers = [];
        $scope.tempData = [];
        $scope.createSubscriberDialog = new UI.Dialog();
        $scope.deleteSubscriberDialog = new UI.Dialog();
        $scope.showSubscriberDialog = new UI.Dialog();
        $scope.topicName = '';
        $scope.clientId = '';
        $scope.subscriberName = '';
        $scope.subSelector = '';
        $scope.gridOptions = {
            selectedItems: [],
            data: 'durableSubscribers',
            displayFooter: false,
            showFilter: false,
            showColumnMenu: true,
            enableCellSelection: false,
            enableColumnResize: true,
            enableColumnReordering: true,
            selectWithCheckboxOnly: false,
            showSelectionCheckbox: false,
            multiSelect: false,
            displaySelectionCheckbox: false,
            filterOptions: {
                filterText: ''
            },
            maintainColumnRatios: false,
            columnDefs: [
                {
                    field: 'destinationName',
                    displayName: 'Topic',
                    width: '30%'
                },
                {
                    field: 'clientId',
                    displayName: 'Client ID',
                    width: '30%'
                },
                {
                    field: 'consumerId',
                    displayName: 'Consumer ID',
                    cellTemplate: '<div class="ngCellText"><span ng-hide="row.entity.status != \'Offline\'">{{row.entity.consumerId}}</span><a ng-show="row.entity.status != \'Offline\'" ng-click="openSubscriberDialog(row)">{{row.entity.consumerId}}</a></div>',
                    width: '30%'
                },
                {
                    field: 'status',
                    displayName: 'Status',
                    width: '10%'
                }
            ]
        };
        $scope.doCreateSubscriber = function (clientId, subscriberName, topicName, subSelector) {
            $scope.createSubscriberDialog.close();
            $scope.clientId = clientId;
            $scope.subscriberName = subscriberName;
            $scope.topicName = topicName;
            $scope.subSelector = subSelector;
            if (Core.isBlank($scope.subSelector)) {
                $scope.subSelector = null;
            }
            var mbean = getBrokerMBean(jolokia);
            if (mbean) {
                jolokia.execute(mbean, "createDurableSubscriber(java.lang.String, java.lang.String, java.lang.String, java.lang.String)", $scope.clientId, $scope.subscriberName, $scope.topicName, $scope.subSelector, onSuccess(function () {
                    Core.notification('success', "Created durable subscriber " + clientId);
                    $scope.clientId = '';
                    $scope.subscriberName = '';
                    $scope.topicName = '';
                    $scope.subSelector = '';
                    loadTable();
                }));
            }
            else {
                Core.notification("error", "Could not find the Broker MBean!");
            }
        };
        $scope.deleteSubscribers = function () {
            var mbean = $scope.gridOptions.selectedItems[0]._id;
            jolokia.execute(mbean, "destroy()", onSuccess(function () {
                $scope.showSubscriberDialog.close();
                Core.notification('success', "Deleted durable subscriber");
                loadTable();
                $scope.gridOptions.selectedItems.splice(0, $scope.gridOptions.selectedItems.length);
            }));
        };
        $scope.openSubscriberDialog = function (subscriber) {
            jolokia.request({ type: "read", mbean: subscriber.entity._id }, onSuccess(function (response) {
                $scope.showSubscriberDialog.subscriber = response.value;
                $scope.showSubscriberDialog.subscriber.Status = subscriber.entity.status;
                console.log("Subscriber is now " + $scope.showSubscriberDialog.subscriber);
                Core.$apply($scope);
                setTimeout(function () {
                    $scope.showSubscriberDialog.open();
                    Core.$apply($scope);
                }, 100);
            }));
        };
        $scope.topicNames = function (completionText) {
            var topicsFolder = ActiveMQ.getSelectionTopicsFolder(workspace);
            return (topicsFolder) ? topicsFolder.children.map(function (n) { return n.title; }) : [];
        };
        $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid())
                return;
            setTimeout(loadTable, 50);
        });
        function loadTable() {
            var mbean = getBrokerMBean(jolokia);
            if (mbean) {
                $scope.durableSubscribers = [];
                jolokia.request({ type: "read", mbean: mbean, attribute: ["DurableTopicSubscribers"] }, onSuccess(function (response) { return populateTable(response, "DurableTopicSubscribers", "Active"); }));
                jolokia.request({ type: "read", mbean: mbean, attribute: ["InactiveDurableTopicSubscribers"] }, onSuccess(function (response) { return populateTable(response, "InactiveDurableTopicSubscribers", "Offline"); }));
            }
        }
        function populateTable(response, attr, status) {
            var data = response.value;
            ActiveMQ.log.debug("Got data: ", data);
            $scope.durableSubscribers.push.apply($scope.durableSubscribers, data[attr].map(function (o) {
                var objectName = o["objectName"];
                var entries = Core.objectNameProperties(objectName);
                if (!('objectName' in o)) {
                    if ('canonicalName' in o) {
                        objectName = o['canonicalName'];
                    }
                    entries = Object.extended(o['keyPropertyList']).clone();
                }
                entries["_id"] = objectName;
                entries["status"] = status;
                return entries;
            }));
            Core.$apply($scope);
        }
        function getBrokerMBean(jolokia) {
            var mbean = null;
            var selection = workspace.selection;
            if (selection && ActiveMQ.isBroker(workspace) && selection.objectName) {
                return selection.objectName;
            }
            var folderNames = selection.folderNames;
            var parent = selection ? selection.parent : null;
            if (selection && parent && jolokia && folderNames && folderNames.length > 1) {
                mbean = parent.objectName;
                if (!mbean && parent) {
                    mbean = parent.parent.objectName;
                }
                if (!mbean) {
                    mbean = "" + folderNames[0] + ":BrokerName=" + folderNames[1] + ",Type=Broker";
                }
            }
            return mbean;
        }
    }]);
})(ActiveMQ || (ActiveMQ = {}));
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.JobSchedulerController", ["$scope", "workspace", "jolokia", function ($scope, workspace, jolokia) {
        $scope.refresh = loadTable;
        $scope.jobs = [];
        $scope.deleteJobsDialog = new UI.Dialog();
        $scope.gridOptions = {
            selectedItems: [],
            data: 'jobs',
            displayFooter: false,
            showFilter: false,
            showColumnMenu: true,
            enableColumnResize: true,
            enableColumnReordering: true,
            filterOptions: {
                filterText: ''
            },
            selectWithCheckboxOnly: true,
            showSelectionCheckbox: true,
            maintainColumnRatios: false,
            columnDefs: [
                {
                    field: 'jobId',
                    displayName: 'Job ID',
                    width: '25%'
                },
                {
                    field: 'cronEntry',
                    displayName: 'Cron Entry',
                    width: '10%'
                },
                {
                    field: 'delay',
                    displayName: 'Delay',
                    width: '5%'
                },
                {
                    field: 'repeat',
                    displayName: 'repeat',
                    width: '5%'
                },
                {
                    field: 'period',
                    displayName: 'period',
                    width: '5%'
                },
                {
                    field: 'start',
                    displayName: 'Start',
                    width: '25%'
                },
                {
                    field: 'next',
                    displayName: 'Next',
                    width: '25%'
                }
            ]
        };
        $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid())
                return;
            setTimeout(loadTable, 50);
        });
        function loadTable() {
            var selection = workspace.selection;
            if (selection) {
                var mbean = selection.objectName;
                if (mbean) {
                    jolokia.request({ type: 'read', mbean: mbean, attribute: "AllJobs" }, onSuccess(populateTable));
                }
            }
            Core.$apply($scope);
        }
        function populateTable(response) {
            var data = response.value;
            if (!angular.isArray(data)) {
                $scope.jobs = [];
                angular.forEach(data, function (value, idx) {
                    $scope.jobs.push(value);
                });
            }
            else {
                $scope.jobs = data;
            }
            Core.$apply($scope);
        }
        $scope.deleteJobs = function () {
            var selection = workspace.selection;
            var mbean = selection.objectName;
            if (mbean && selection) {
                var selectedItems = $scope.gridOptions.selectedItems;
                $scope.message = "Deleted " + Core.maybePlural(selectedItems.length, "job");
                var operation = "removeJob(java.lang.String)";
                angular.forEach(selectedItems, function (item, idx) {
                    var id = item.jobId;
                    if (id) {
                        var callback = (idx + 1 < selectedItems.length) ? intermediateResult : operationSuccess;
                        jolokia.execute(mbean, operation, id, onSuccess(callback));
                    }
                });
            }
        };
        function intermediateResult() {
        }
        function operationSuccess() {
            $scope.gridOptions.selectedItems.splice(0);
            Core.notification("success", $scope.message);
            setTimeout(loadTable, 50);
        }
    }]);
})(ActiveMQ || (ActiveMQ = {}));
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.PreferencesController", ["$scope", "localStorage", "userDetails", "$rootScope", function ($scope, localStorage, userDetails, $rootScope) {
        Core.initPreferenceScope($scope, localStorage, {
            'activemqUserName': {
                'value': userDetails.username,
            },
            'activemqPassword': {
                'value': userDetails.password
            },
            'activemqBrowseBytesMessages': {
                'value': 1,
                'converter': parseInt,
                'formatter': function (value) {
                    return "" + value;
                }
            },
            'activemqFilterAdvisoryTopics': {
                'value': false,
                'converter': Core.parseBooleanValue,
                'post': function (newValue) {
                    $rootScope.$broadcast('jmxTreeUpdated');
                }
            }
        });
    }]);
})(ActiveMQ || (ActiveMQ = {}));
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.TreeHeaderController", ["$scope", function ($scope) {
        $scope.expandAll = function () {
            Tree.expandAll("#activemqtree");
        };
        $scope.contractAll = function () {
            Tree.contractAll("#activemqtree");
        };
    }]);
    ActiveMQ._module.controller("ActiveMQ.TreeController", ["$scope", "$location", "workspace", "localStorage", function ($scope, $location, workspace, localStorage) {
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateSelectionFromURL, 50);
        });
        $scope.$watch('workspace.tree', function () {
            reloadTree();
        });
        $scope.$on('jmxTreeUpdated', function () {
            reloadTree();
        });
        function reloadTree() {
            ActiveMQ.log.debug("workspace tree has changed, lets reload the activemq tree");
            var children = [];
            var tree = workspace.tree;
            if (tree) {
                var domainName = "org.apache.activemq";
                var folder = tree.get(domainName);
                if (folder) {
                    children = folder.children;
                }
                if (children.length) {
                    var firstChild = children[0];
                    if (!firstChild.typeName && firstChild.children.length < 4) {
                        var answer = [];
                        angular.forEach(children, function (child) {
                            answer = answer.concat(child.children);
                        });
                        children = answer;
                    }
                }
                children.forEach(function (broker) {
                    var grandChildren = broker.children;
                    if (grandChildren) {
                        Tree.sanitize(grandChildren);
                        var idx = grandChildren.findIndex(function (n) { return n.title === "Topic"; });
                        if (idx > 0) {
                            var old = grandChildren[idx];
                            var key = "ActiveMQ-allTopics-" + broker.title;
                            var allTopics = old.children.clone();
                            workspace.mapData[key] = allTopics;
                            var filter = Core.parseBooleanValue(localStorage["activemqFilterAdvisoryTopics"]);
                            if (filter) {
                                if (old && old.children) {
                                    var filteredTopics = old.children.filter(function (c) { return !c.title.startsWith("ActiveMQ.Advisory"); });
                                    old.children = filteredTopics;
                                }
                            }
                            else if (allTopics) {
                                old.children = allTopics;
                            }
                        }
                    }
                });
                var treeElement = $("#activemqtree");
                Jmx.enableTree($scope, $location, workspace, treeElement, children, true);
                setTimeout(updateSelectionFromURL, 50);
            }
        }
        function updateSelectionFromURL() {
            Jmx.updateTreeSelectionFromURLAndAutoSelect($location, $("#activemqtree"), function (first) {
                var queues = first.getChildren()[0];
                if (queues && queues.data.title === 'Queue') {
                    first = queues;
                    first.expand(true);
                    return first;
                }
                return null;
            }, true);
        }
    }]);
})(ActiveMQ || (ActiveMQ = {}));
var API;
(function (API) {
    API.log = Logger.get("API");
    API.wadlNamespace = "http://schemas.xmlsoap.org/wsdl/";
    function loadXml(url, onXml) {
        if (url) {
            API.log.info("Loading XML: " + url);
            var ajaxParams = {
                type: "GET",
                url: url,
                beforeSend: function (xhr) {
                    xhr.setRequestHeader('Authorization', null);
                },
                dataType: "xml",
                contextType: "text/xml",
                success: onXml,
                error: function (jqXHR, textStatus, errorThrow) {
                    API.log.error("Failed to query XML for: " + url + " status:" + textStatus + " error: " + errorThrow);
                }
            };
            $.ajax(ajaxParams);
        }
    }
    API.loadXml = loadXml;
    var wadlXmlToJavaConfig = {};
    function parseJson(json) {
        var answer = null;
        try {
            answer = JSON.parse(json);
        }
        catch (e) {
            API.log.info("Failed to parse JSON " + e);
            API.log.info("JSON: " + json);
        }
        return answer;
    }
    API.parseJson = parseJson;
    function initScope($scope, $location, jolokia) {
        var search = $location.search();
        $scope.container = search["container"];
        $scope.objectName = search["objectName"];
        $scope.showHide = function (resource) {
            if (resource) {
                resource.hide = resource.hide ? false : true;
            }
        };
        $scope.showOperations = function (resource) {
            showHideOperations(resource, false);
        };
        $scope.expandOperations = function (resource) {
            showHideOperations(resource, true);
        };
        function showHideOperations(resource, flag) {
            if (resource) {
                resource.hide = false;
                angular.forEach(resource.resource, function (childResource) {
                    showHideOperations(childResource, flag);
                });
                angular.forEach(resource.method || resource.operations, function (method) {
                    method.expanded = flag;
                });
            }
        }
        $scope.autoFormat = function (codeMirror) {
            if (!codeMirror) {
                codeMirror = findChildScopeValue($scope, "codeMirror");
            }
            if (codeMirror) {
                setTimeout(function () {
                    CodeEditor.autoFormatEditor(codeMirror);
                }, 50);
            }
        };
        function findChildScopeValue(scope, name) {
            var answer = scope[name];
            var childScope = scope.$$childHead;
            while (childScope && !answer) {
                answer = findChildScopeValue(childScope, name);
                childScope = childScope.$$nextSibling;
            }
            return answer;
        }
        if ($scope.container && $scope.objectName) {
            Fabric.containerJolokia(jolokia, $scope.container, function (remoteJolokia) {
                $scope.remoteJolokia = remoteJolokia;
                if (remoteJolokia) {
                    API.loadJsonSchema(remoteJolokia, $scope.objectName, function (jsonSchema) {
                        $scope.jsonSchema = jsonSchema;
                        Core.$apply($scope);
                    });
                }
                else {
                    API.log.info("No Remote Jolokia!");
                }
            });
        }
        else {
            API.log.info("No container or objectName");
        }
        API.log.info("container: " + $scope.container + " objectName: " + $scope.objectName + " url: " + $scope.url);
    }
    API.initScope = initScope;
    function loadJsonSchema(jolokia, mbean, onJsonSchemaFn) {
        function onResults(response) {
            var schema = {};
            if (response) {
                var json = response;
                if (json) {
                    schema = parseJson(json);
                }
            }
            onJsonSchemaFn(schema);
        }
        if (mbean) {
            return jolokia.execute(mbean, "getJSONSchema", onSuccess(onResults));
        }
        else {
            var schema = {};
            onJsonSchemaFn(schema);
            return schema;
        }
    }
    API.loadJsonSchema = loadJsonSchema;
    function onWadlXmlLoaded(response) {
        var root = response.documentElement;
        var output = {};
        return API.convertWadlToJson(root, output);
    }
    API.onWadlXmlLoaded = onWadlXmlLoaded;
    function convertWadlToJson(element, obj) {
        if (obj === void 0) { obj = {}; }
        return API.convertXmlToJson(element, obj, wadlXmlToJavaConfig);
    }
    API.convertWadlToJson = convertWadlToJson;
    function convertWadlJsonToSwagger(object) {
        var apis = [];
        var basePath = null;
        var resourcePath = null;
        var resources = Core.pathGet(object, ["resources", 0]);
        if (resources) {
            basePath = resources.base;
            angular.forEach(resources.resource, function (resource) {
                var path = resource.path;
                var operations = [];
                angular.forEach(resource.method, function (method) {
                    var name = method.name;
                    var responseMessages = [];
                    var parameters = [];
                    operations.push({
                        "method": method.name,
                        "summary": method.summary,
                        "notes": method.notes,
                        "nickname": method.nickname,
                        "type": method.type,
                        "parameters": parameters,
                        "produces": [
                            "application/json"
                        ],
                        "responseMessages": responseMessages
                    });
                });
                apis.push({
                    path: path,
                    operations: operations
                });
            });
        }
        return {
            "apiVersion": "1.0",
            "swaggerVersion": "1.2",
            "basePath": basePath,
            "resourcePath": resourcePath,
            "produces": [
                "application/json"
            ],
            apis: apis
        };
    }
    API.convertWadlJsonToSwagger = convertWadlJsonToSwagger;
    function nodeName(owner, node) {
        return node ? node.localName : null;
    }
    function convertXmlToJson(element, obj, config) {
        var elementProperyFn = config.elementToPropertyName || nodeName;
        var attributeProperyFn = config.attributeToPropertyName || nodeName;
        angular.forEach(element.childNodes, function (child) {
            if (child.nodeType === 1) {
                var propertyName = elementProperyFn(element, child);
                if (propertyName) {
                    var array = obj[propertyName] || [];
                    if (!angular.isArray(array)) {
                        array = [array];
                    }
                    var value = {};
                    convertXmlToJson(child, value, config);
                    array.push(value);
                    obj[propertyName] = array;
                }
            }
        });
        angular.forEach(element.attributes, function (attr) {
            var propertyName = attributeProperyFn(element, attr);
            if (propertyName) {
                var value = attr.nodeValue;
                obj[propertyName] = value;
            }
        });
        return obj;
    }
    API.convertXmlToJson = convertXmlToJson;
    function concatArrays(arrays) {
        var answer = [];
        angular.forEach(arrays, function (array) {
            if (array) {
                if (angular.isArray(array)) {
                    answer = answer.concat(array);
                }
                else {
                    answer.push(array);
                }
            }
        });
        return answer;
    }
    API.concatArrays = concatArrays;
    function addObjectNameProperties(object) {
        var objectName = object["objectName"];
        if (objectName) {
            var properties = Core.objectNameProperties(objectName);
            if (properties) {
                angular.forEach(properties, function (value, key) {
                    if (!object[key]) {
                        object[key] = value;
                    }
                });
            }
        }
        return null;
    }
    function processApiData($scope, json, podURL, path) {
        if (path === void 0) { path = ""; }
        var array = [];
        angular.forEach(json, function (value, key) {
            var childPath = path + "/" + key;
            function addParameters(href) {
                angular.forEach(["podId", "port", "objectName"], function (name) {
                    var param = value[name];
                    if (param) {
                        href += "&" + name + "=" + encodeURIComponent(param);
                    }
                });
                return href;
            }
            var path = value["path"];
            var url = value["url"];
            if (url) {
                addObjectNameProperties(value);
                value["serviceName"] = Core.trimQuotes(value["service"]) || value["containerName"];
                var podId = value["podId"];
                var prefix = "";
                if (podId) {
                    var port = value["port"] || 8080;
                    prefix = podURL + podId + "/" + port;
                }
                function addPrefix(text) {
                    return (text) ? prefix + text : null;
                }
                function maybeUseProxy(value) {
                    if (value) {
                        return Core.useProxyIfExternal(value);
                    }
                    else {
                        return value;
                    }
                }
                var apidocs = maybeUseProxy(value["swaggerUrl"]) || addPrefix(value["swaggerPath"]);
                var wadl = maybeUseProxy(value["wadlUrl"]) || addPrefix(value["wadlPath"]);
                var wsdl = maybeUseProxy(value["wsdlUrl"]) || addPrefix(value["wsdlPath"]);
                if (apidocs) {
                    value["apidocsHref"] = addParameters("/hawtio-swagger/index.html?baseUri=" + apidocs);
                }
                if (wadl) {
                    value["wadlHref"] = addParameters("#/api/wadl?wadl=" + encodeURIComponent(wadl));
                }
                if (wsdl) {
                    value["wsdlHref"] = addParameters("#/api/wsdl?wsdl=" + encodeURIComponent(wsdl));
                }
            }
            array.push(value);
        });
        $scope.apis = array;
        $scope.initDone = true;
    }
    API.processApiData = processApiData;
})(API || (API = {}));
var API;
(function (API) {
    API.pluginName = 'api';
    API.templatePath = 'app/' + API.pluginName + '/html/';
    API._module = angular.module(API.pluginName, ['bootstrap', 'hawtioCore', 'hawtio-ui']);
    API._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/api/pods', { templateUrl: 'app/api/html/apiPods.html' }).when('/api/services', { templateUrl: 'app/api/html/apiServices.html' }).when('/api/wsdl', { templateUrl: 'app/api/html/wsdl.html' }).when('/api/wadl', { templateUrl: 'app/api/html/wadl.html' });
    }]);
    API._module.run(["$location", "workspace", "viewRegistry", "layoutFull", "helpRegistry", "ServiceRegistry", function ($location, workspace, viewRegistry, layoutFull, helpRegistry, ServiceRegistry) {
        viewRegistry['api/pods'] = API.templatePath + "layoutApis.html";
        viewRegistry['api/services'] = API.templatePath + "layoutApis.html";
        viewRegistry['api'] = layoutFull;
        workspace.topLevelTabs.push({
            id: 'apis.index',
            content: 'APIs',
            title: 'View the available APIs inside this fabric',
            isValid: function (workspace) { return Service.hasService(ServiceRegistry, "api-registry") && Kubernetes.isKubernetes(workspace); },
            href: function () { return '#/api/services'; },
            isActive: function (workspace) { return workspace.isLinkActive('api/'); }
        });
    }]);
    hawtioPluginLoader.addModule(API.pluginName);
})(API || (API = {}));
var API;
(function (API) {
    API._module.controller("API.ApiPodsController", ["$scope", "localStorage", "$routeParams", "$location", "jolokia", "workspace", "$compile", "$templateCache", "$http", function ($scope, localStorage, $routeParams, $location, jolokia, workspace, $compile, $templateCache, $http) {
        $scope.path = "apis";
        $scope.apis = null;
        $scope.selectedApis = [];
        $scope.initDone = false;
        var endpointsPodsURL = Core.url("/service/api-registry/endpoints/pods");
        var podURL = Core.url("/pod/");
        $scope.apiOptions = {
            data: 'apis',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                filterText: "",
                useExternalFilter: false
            },
            selectedItems: $scope.selectedApis,
            rowHeight: 32,
            showSelectionCheckbox: false,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'serviceName',
                    displayName: 'Endpoint',
                    width: "***"
                },
                {
                    field: 'contracts',
                    displayName: 'APIs',
                    cellTemplate: $templateCache.get("apiContractLinksTemplate.html"),
                    width: "*"
                },
                {
                    field: 'url',
                    displayName: 'URL',
                    cellTemplate: $templateCache.get("apiUrlTemplate.html"),
                    width: "***"
                },
                {
                    field: 'podId',
                    displayName: 'Pod',
                    cellTemplate: $templateCache.get("apiPodLinkTemplate.html"),
                    width: "*"
                }
            ]
        };
        function matchesFilter(text) {
            var filter = $scope.searchFilter;
            return !filter || (text && text.has(filter));
        }
        function loadData() {
            var restURL = endpointsPodsURL;
            $http.get(restURL).success(function (data) {
                createFlatList(restURL, data);
            }).error(function (data) {
                API.log.debug("Error fetching image repositories:", data);
                createFlatList(restURL, null);
            });
        }
        loadData();
        function createFlatList(restURL, json, path) {
            if (path === void 0) { path = ""; }
            return API.processApiData($scope, json, podURL, path);
        }
    }]);
})(API || (API = {}));
var API;
(function (API) {
    API._module.controller("API.ApiServicesController", ["$scope", "localStorage", "$routeParams", "$location", "jolokia", "workspace", "$compile", "$templateCache", "$http", function ($scope, localStorage, $routeParams, $location, jolokia, workspace, $compile, $templateCache, $http) {
        $scope.path = "apis";
        $scope.apis = null;
        $scope.selectedApis = [];
        $scope.initDone = false;
        var endpointsPodsURL = Core.url("/service/api-registry/endpoints/services");
        var podURL = Core.url("/pod/");
        $scope.apiOptions = {
            data: 'apis',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                filterText: "",
                useExternalFilter: false
            },
            selectedItems: $scope.selectedApis,
            rowHeight: 32,
            showSelectionCheckbox: false,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'serviceName',
                    displayName: 'Service',
                    cellTemplate: $templateCache.get("apiServiceLinkTemplate.html"),
                    width: "***"
                },
                {
                    field: 'contracts',
                    displayName: 'APIs',
                    cellTemplate: $templateCache.get("apiContractLinksTemplate.html"),
                    width: "*"
                },
                {
                    field: 'url',
                    displayName: 'URL',
                    cellTemplate: $templateCache.get("apiUrlTemplate.html"),
                    width: "***"
                }
            ]
        };
        function matchesFilter(text) {
            var filter = $scope.searchFilter;
            return !filter || (text && text.has(filter));
        }
        function loadData() {
            var restURL = endpointsPodsURL;
            $http.get(restURL).success(function (data) {
                createFlatList(restURL, data);
            }).error(function (data) {
                API.log.debug("Error fetching image repositories:", data);
                createFlatList(restURL, null);
            });
        }
        loadData();
        function createFlatList(restURL, json, path) {
            if (path === void 0) { path = ""; }
            return API.processApiData($scope, json, podURL, path);
        }
    }]);
})(API || (API = {}));
var API;
(function (API) {
    API._module.controller("API.WadlViewController", ["$scope", "$location", "$http", "jolokia", function ($scope, $location, $http, jolokia) {
        API.initScope($scope, $location, jolokia);
        var search = $location.search();
        $scope.url = search["wadl"];
        $scope.podId = search["podId"];
        $scope.port = search["port"];
        $scope.$watch("apidocs", enrichApiDocsWithSchema);
        $scope.$watch("jsonSchema", enrichApiDocsWithSchema);
        API.loadXml($scope.url, onWsdl);
        $scope.tryInvoke = function (base, resource, method) {
            var useProxy = true;
            if (resource) {
                var path = resource.fullPath || base + "/" + resource.path;
                if (path) {
                    if ($scope.podId) {
                        var idx = path.indexOf("://");
                        if (idx > 0) {
                            var pathWithoutProtocol = path.substring(idx + 3);
                            var idx = pathWithoutProtocol.indexOf("/");
                            if (idx > 0) {
                                path = "/hawtio/pod/" + $scope.podId + ($scope.port ? "/" + $scope.port : "") + pathWithoutProtocol.substring(idx);
                                useProxy = false;
                            }
                        }
                    }
                    angular.forEach(resource.param, function (param) {
                        var name = param.name;
                        if (name) {
                            var value = param.value;
                            if (angular.isUndefined(value) || value === null) {
                                value = "";
                            }
                            value = value.toString();
                            API.log.debug("replacing " + name + " with '" + value + "'");
                            path = path.replace(new RegExp("{" + name + "}", "g"), value);
                        }
                    });
                    var url = useProxy ? Core.useProxyIfExternal(path) : path;
                    API.log.info("Lets invoke resource: " + url);
                    var methodName = method.name || "GET";
                    method.invoke = {
                        url: url,
                        running: true
                    };
                    var requestData = {
                        method: methodName,
                        url: url,
                        headers: {}
                    };
                    if (methodName === "POST" || methodName === "PUT") {
                        angular.forEach(method.request, function (request) {
                            if (!requestData["data"]) {
                                requestData["data"] = request.value;
                            }
                            if (!requestData.headers["Content-Type"]) {
                                requestData.headers["Content-Type"] = request.contentType;
                            }
                        });
                    }
                    API.log.info("About to make request: " + angular.toJson(requestData));
                    $http(requestData).success(function (data, status, headers, config) {
                        API.log.info("Worked!" + data);
                        method.invoke = {
                            url: url,
                            realUrl: path,
                            success: true,
                            data: data,
                            dataMode: textFormat(headers),
                            status: status,
                            headers: headers(),
                            config: config
                        };
                        Core.$apply($scope);
                    }).error(function (data, status, headers, config) {
                        API.log.info("Failed: " + status);
                        method.invoke = {
                            url: url,
                            realUrl: path,
                            data: data,
                            dataMode: textFormat(headers),
                            status: status,
                            headers: headers(),
                            config: config
                        };
                        Core.$apply($scope);
                    });
                }
            }
        };
        function textFormat(headers) {
            return contentTypeTextFormat(headers("content-type"));
        }
        function contentTypeTextFormat(contentType) {
            if (contentType) {
                if (contentType.endsWith("xml")) {
                    return "xml";
                }
                if (contentType.endsWith("html")) {
                    return "html";
                }
                if (contentType.endsWith("json")) {
                    return "json";
                }
            }
            return null;
        }
        function enrichApiDocsWithSchema() {
            var apidocs = $scope.apidocs;
            var jsonSchema = $scope.jsonSchema;
            if (apidocs) {
                enrichResources(jsonSchema, apidocs.resources, $scope.parentUri);
            }
        }
        function enrichResources(jsonSchema, resources, parentUri) {
            if (parentUri === void 0) { parentUri = null; }
            angular.forEach(resources, function (resource) {
                var base = resource.base;
                if (base) {
                    if (parentUri) {
                        if (base) {
                            var idx = base.indexOf("/");
                            if (idx > 0) {
                                base = parentUri + base.substring(idx);
                            }
                        }
                    }
                }
                else {
                    base = parentUri;
                }
                var path = resource.path;
                if (base && path) {
                    if (!base.endsWith("/") && !path.startsWith("/")) {
                        base += "/";
                    }
                    base += path;
                    resource["fullPath"] = base;
                }
                var childResources = resource.resource;
                if (childResources) {
                    enrichResources(jsonSchema, childResources, base);
                }
                angular.forEach(API.concatArrays([resource.method, resource.operation]), function (method) {
                    var request = method.request;
                    if (request) {
                        var count = request.count(function (n) { return n["representation"]; });
                        if (!count) {
                            delete method.request;
                        }
                    }
                    angular.forEach(API.concatArrays([method.request, method.response]), function (object) {
                        var element = object["element"];
                        var representations = object["representation"];
                        if (representations) {
                            var mediaTypes = representations.map(function (r) { return r["mediaType"]; });
                            object["mediaTypes"] = mediaTypes;
                            if (mediaTypes && mediaTypes.length) {
                                object["contentType"] = mediaTypes[0];
                            }
                        }
                        angular.forEach(representations, function (representation) {
                            if (!element) {
                                element = representation["element"];
                            }
                            enrichRepresentation(jsonSchema, representation);
                        });
                        if (element) {
                            object["element"] = element;
                        }
                    });
                });
            });
        }
        function enrichRepresentation(jsonSchema, representation) {
            var defs = jsonSchema ? jsonSchema["definitions"] : null;
            if (defs && representation) {
                var contentType = representation["mediaType"];
                if (contentType) {
                    representation["dataMode"] = contentTypeTextFormat(contentType);
                }
                var element = representation["element"];
                if (element) {
                    var idx = element.indexOf(':');
                    if (idx >= 0) {
                        element = element.substring(idx + 1);
                    }
                    var elementPostfix = "." + element;
                    var foundDef = null;
                    angular.forEach(defs, function (value, key) {
                        if (!foundDef && (key === element || key.endsWith(elementPostfix))) {
                            foundDef = value;
                            representation["schema"] = foundDef;
                            representation["typeName"] = element;
                            representation["javaClass"] = key;
                        }
                    });
                }
            }
        }
        function onWsdl(response) {
            $scope.apidocs = API.onWadlXmlLoaded(response);
            Core.$apply($scope);
        }
    }]);
})(API || (API = {}));
var API;
(function (API) {
    API._module.controller("API.WsdlViewController", ["$scope", "$location", "jolokia", function ($scope, $location, jolokia) {
        var log = Logger.get("API");
        API.initScope($scope, $location, jolokia);
        var wsdlNamespace = "http://schemas.xmlsoap.org/wsdl/";
        $scope.url = $location.search()["wsdl"];
        API.loadXml($scope.url, onWsdl);
        $scope.$watch("services", enrichApiDocsWithSchema);
        $scope.$watch("jsonSchema", enrichApiDocsWithSchema);
        function enrichApiDocsWithSchema() {
            var services = $scope.services;
            var jsonSchema = $scope.jsonSchema;
            if (services && jsonSchema) {
                log.info("We have services and jsonSchema!");
                enrichServices(jsonSchema, services);
            }
        }
        function enrichServices(jsonSchema, services) {
            angular.forEach(services, function (service) {
                angular.forEach(service.operations, function (method) {
                    angular.forEach(API.concatArrays([method.inputs, method.outputs]), function (object) {
                        enrichRepresentation(jsonSchema, object);
                    });
                });
            });
        }
        function enrichRepresentation(jsonSchema, representation) {
            var defs = jsonSchema ? jsonSchema["definitions"] : null;
            if (defs && representation) {
                var name = representation["name"];
                if (name) {
                    var foundDef = defs[name];
                    if (foundDef) {
                        if (angular.isArray(foundDef) && foundDef.length > 0) {
                            foundDef = foundDef[0];
                        }
                        log.info("Found def " + angular.toJson(foundDef) + " for name " + name);
                        representation["schema"] = foundDef;
                    }
                }
            }
        }
        function onWsdl(response) {
            $scope.services = [];
            var root = response.documentElement;
            var targetNamespace = root ? root.getAttribute("targetNamespace") : null;
            var name = root ? root.getAttribute("name") : null;
            var portTypes = response.getElementsByTagNameNS(wsdlNamespace, "portType");
            var services = response.getElementsByTagNameNS(wsdlNamespace, "service");
            var bindings = response.getElementsByTagNameNS(wsdlNamespace, "binding");
            angular.forEach(portTypes, function (portType) {
                var service = {
                    name: name,
                    targetNamespace: targetNamespace,
                    portName: portType.getAttribute("name") || "Unknown",
                    operations: []
                };
                $scope.services.push(service);
                var operations = portType.getElementsByTagNameNS(wsdlNamespace, "operation");
                angular.forEach(operations, function (operation) {
                    var input = operation.getElementsByTagNameNS(wsdlNamespace, "input");
                    var output = operation.getElementsByTagNameNS(wsdlNamespace, "output");
                    function createMessageData(data) {
                        var answer = [];
                        angular.forEach(data, function (item) {
                            var name = item.getAttribute("name");
                            if (name) {
                                answer.push({
                                    name: name
                                });
                            }
                        });
                        return answer;
                    }
                    var opData = {
                        name: operation.getAttribute("name") || "Unknown",
                        inputs: createMessageData(input),
                        outputs: createMessageData(output)
                    };
                    service.operations.push(opData);
                });
            });
            Core.$apply($scope);
        }
    }]);
})(API || (API = {}));
var Apm;
(function (Apm) {
    Apm.log = Logger.get("Apm");
    Apm.jmxDomain = 'io.fabric8.apmagent';
    Apm.agentMBean = Apm.jmxDomain + ':type=apmAgent';
})(Apm || (Apm = {}));
var Apm;
(function (Apm) {
    Apm.pluginName = 'apm';
    Apm._module = angular.module(Apm.pluginName, ['bootstrap', 'ui.bootstrap', 'ui.bootstrap.dialog', 'ui.bootstrap.tabs', 'ui.bootstrap.typeahead', 'ngResource', 'hawtioCore', 'hawtio-ui']);
    Apm._module.config(["$routeProvider", function ($routeProvider) {
    }]);
    Apm._module.run(["workspace", "jolokia", "viewRegistry", "layoutFull", "helpRegistry", "preferencesRegistry", function (workspace, jolokia, viewRegistry, layoutFull, helpRegistry, preferencesRegistry) {
        viewRegistry['apm'] = 'app/apm/html/layoutApmTree.html';
        helpRegistry.addUserDoc('apm', 'app/apm/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties(Apm.jmxDomain);
        });
        var attributes = workspace.attributeColumnDefs;
        attributes[Apm.jmxDomain + "/MethodMetrics/folder"] = [
            { field: 'Name', displayName: 'Name' },
            { field: 'Count', displayName: 'Count' }
        ];
        attributes[Apm.jmxDomain + "/ThreadContextMetrics/folder"] = [
            { field: 'Name', displayName: 'Name' },
            { field: 'ThreadName', displayName: 'Thread' },
            { field: 'Count', displayName: 'Count' }
        ];
        function postProcessTree(tree) {
            var apmTree = tree.get(Apm.jmxDomain);
            if (apmTree) {
                angular.forEach(apmTree.children, function (folder) {
                    if (folder.title === "ThreadContextMetrics") {
                        angular.forEach(folder.children, function (child) {
                            if (!child.typeName) {
                                child.typeName = "ThreadContextMetrics";
                            }
                        });
                    }
                });
            }
        }
        workspace.addTreePostProcessor(postProcessTree);
    }]);
    hawtioPluginLoader.addModule(Apm.pluginName);
})(Apm || (Apm = {}));
var Apollo;
(function (Apollo) {
    Apollo.pluginName = 'apollo';
    Apollo._module = angular.module(Apollo.pluginName, ['bootstrap', 'ngResource', 'hawtioCore']);
    Apollo._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/apollo', { templateUrl: 'app/apollo/html/layout-apollo.html' });
    }]);
    Apollo._module.run(["$location", "workspace", "viewRegistry", "helpRegistry", function ($location, workspace, viewRegistry, helpRegistry) {
        viewRegistry['apollo'] = "app/apollo/html/layout-apollo.html";
        helpRegistry.addUserDoc('apollo', 'app/apollo/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties("org.apache.apollo");
        });
        workspace.topLevelTabs.push({
            id: "apollo",
            content: "Apollo",
            title: "Manage your Apollo Broker",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties("org.apache.apollo"); },
            href: function () { return '#/apollo/virtual-hosts'; },
            isActive: function (workspace) { return workspace.isLinkActive("apollo"); }
        });
    }]);
    hawtioPluginLoader.addModule(Apollo.pluginName);
})(Apollo || (Apollo = {}));
var Apollo;
(function (Apollo) {
    Apollo._module.controller("Apollo.ApolloController", ["$scope", "$http", "$location", "localStorage", "workspace", function ($scope, $http, $location, localStorage, workspace) {
        var jolokia = workspace.jolokia;
        $scope.broker = {};
        $scope.online = true;
        $scope.route = function () {
            return $location.path();
        };
        $scope.apollo = {
            version: jolokia.getAttribute('org.apache.apollo:type=broker,name="default"', "Version", onSuccess(null)),
            url: jolokia.getAttribute('org.apache.apollo:type=broker,name="default"', "WebAdminUrl", onSuccess(null)),
        };
        var default_error_handler = function (data, status, headers, config) {
            if (status === 401) {
                alert("Action not authorized.");
            }
            else {
                alert("Error: " + status);
            }
        };
        $scope.ajax = function (type, path, success, error, data, binary_options) {
            if (!error) {
                error = default_error_handler;
            }
            var username = "admin";
            var password = "password";
            var ajax_options = {
                method: type,
                url: $scope.apollo.url + "/api/json" + path,
                headers: {
                    AuthPrompt: 'false',
                    Accept: "application/json",
                    ContentType: "application/json",
                    Authorization: Core.getBasicAuthHeader(username, password)
                },
                cache: false,
                data: null,
            };
            if (binary_options) {
                ajax_options.headers["Accept"] = binary_options.Accept || "application/octet-stream";
                ajax_options.headers["ContentType"] || "application/octet-stream";
                ajax_options.data = binary_options.data;
            }
            return $http(ajax_options).success(function (data, status, headers, config) {
                $scope.online = true;
                if (success) {
                    success(data, status, headers, config);
                }
            }).error(function (data, status, headers, config) {
                if (status === 0) {
                    $scope.online = false;
                }
                else {
                    $scope.online = true;
                    error(data, status, headers, config);
                }
            });
        };
        var reload = function () {
            if ($scope.apollo.url) {
                $scope.ajax("GET", "/broker", function (broker) {
                    $scope.broker = broker;
                    if ($scope.apollo.selected_virtual_host === undefined) {
                        $scope.apollo.selected_virtual_host = broker.virtual_hosts[0];
                    }
                }, function (error) {
                    alert("fail:" + error);
                });
            }
            else {
                $scope.broker = {};
            }
        };
        var schedule_refresh = function () {
        };
        schedule_refresh = function () {
            setTimeout(function () {
                reload();
                schedule_refresh();
            }, 1000);
        };
        schedule_refresh();
        $scope.$watch('apollo.url', reload);
        $scope.$watch('online', function () {
        });
    }]);
})(Apollo || (Apollo = {}));
var Apollo;
(function (Apollo) {
    Apollo._module.controller("Apollo.VirtualHostController", ["$scope", "$http", "$location", "localStorage", "workspace", function ($scope, $http, $location, localStorage, workspace) {
        $scope.virtual_host = {};
        $scope.init = function (virtual_host_name) {
            $scope.ajax("GET", "/broker/virtual-hosts/" + virtual_host_name, function (host) {
                $scope.virtual_host = host;
            });
        };
    }]);
})(Apollo || (Apollo = {}));
var Camel;
(function (Camel) {
    Camel.log = Logger.get("Camel");
    Camel.jmxDomain = 'org.apache.camel';
    Camel.defaultMaximumLabelWidth = 34;
    Camel.defaultCamelMaximumTraceOrDebugBodyLength = 5000;
    Camel.defaultCamelTraceOrDebugIncludeStreams = true;
    Camel.defaultCamelRouteMetricMaxSeconds = 10;
    Camel.defaultHideOptionDocumentation = false;
    Camel.defaultHideOptionDefaultValue = false;
    Camel.defaultHideOptionUnusedValue = false;
    function processRouteXml(workspace, jolokia, folder, onRoute) {
        var selectedRouteId = getSelectedRouteId(workspace, folder);
        var mbean = getExpandingFolderCamelContextMBean(workspace, folder) || getSelectionCamelContextMBean(workspace);
        function onRouteXml(response) {
            var route = null;
            var data = response ? response.value : null;
            if (data) {
                var doc = $.parseXML(data);
                var routes = $(doc).find("route[id='" + selectedRouteId + "']");
                if (routes && routes.length) {
                    route = routes[0];
                }
            }
            onRoute(route);
        }
        if (mbean && selectedRouteId) {
            jolokia.request({ type: 'exec', mbean: mbean, operation: 'dumpRoutesAsXml()' }, onSuccess(onRouteXml, { error: onRouteXml }));
        }
        else {
            if (!selectedRouteId) {
                console.log("No selectedRouteId when trying to lazy load the route!");
            }
            onRoute(null);
        }
    }
    Camel.processRouteXml = processRouteXml;
    function getRouteNodeUri(node) {
        var uri = null;
        if (node) {
            uri = node.getAttribute("uri");
            if (!uri) {
                var ref = node.getAttribute("ref");
                if (ref) {
                    var method = node.getAttribute("method");
                    if (method) {
                        uri = ref + "." + method + "()";
                    }
                    else {
                        uri = "ref:" + ref;
                    }
                }
            }
        }
        return uri;
    }
    Camel.getRouteNodeUri = getRouteNodeUri;
    function getRouteFolderJSON(folder, answer) {
        if (answer === void 0) { answer = {}; }
        var nodeData = folder["camelNodeData"];
        if (!nodeData) {
            var routeXmlNode = folder["routeXmlNode"];
            if (routeXmlNode) {
                nodeData = Camel.getRouteNodeJSON(routeXmlNode);
            }
            if (!nodeData) {
                nodeData = answer;
            }
            folder["camelNodeData"] = nodeData;
        }
        return nodeData;
    }
    Camel.getRouteFolderJSON = getRouteFolderJSON;
    function getRouteNodeJSON(routeXmlNode, answer) {
        if (answer === void 0) { answer = {}; }
        if (routeXmlNode) {
            angular.forEach(routeXmlNode.attributes, function (attr) {
                answer[attr.name] = attr.value;
            });
            var localName = routeXmlNode.localName;
            if (localName !== "route" && localName !== "routes" && localName !== "camelContext" && localName !== "rests") {
                $(routeXmlNode).children("*").each(function (idx, element) {
                    var nodeName = element.localName;
                    var langSettings = Camel.camelLanguageSettings(nodeName);
                    if (langSettings) {
                        answer["expression"] = {
                            language: nodeName,
                            expression: element.textContent
                        };
                    }
                    else {
                        if (!isCamelPattern(nodeName)) {
                            var nested = getRouteNodeJSON(element);
                            if (nested) {
                                if (nested["expression"]) {
                                    nested = nested["expression"];
                                }
                                if (nodeName === "completionSize") {
                                    nodeName = "completionSizeExpression";
                                }
                                else if (nodeName === "completionTimeout") {
                                    nodeName = "completionTimeoutExpression";
                                }
                                answer[nodeName] = nested;
                            }
                        }
                    }
                });
            }
        }
        return answer;
    }
    Camel.getRouteNodeJSON = getRouteNodeJSON;
    function increaseIndent(currentIndent, indentAmount) {
        if (indentAmount === void 0) { indentAmount = "  "; }
        return currentIndent + indentAmount;
    }
    Camel.increaseIndent = increaseIndent;
    function setRouteNodeJSON(routeXmlNode, newData, indent) {
        if (routeXmlNode) {
            var childIndent = increaseIndent(indent);
            function doUpdate(value, key, append) {
                if (append === void 0) { append = false; }
                if (angular.isArray(value)) {
                    $(routeXmlNode).children(key).remove();
                    angular.forEach(value, function (item) {
                        doUpdate(item, key, true);
                    });
                }
                else if (angular.isObject(value)) {
                    var textContent = null;
                    if (key === "expression") {
                        var languageName = value["language"];
                        if (languageName) {
                            key = languageName;
                            textContent = value["expression"];
                            value = angular.copy(value);
                            delete value["expression"];
                            delete value["language"];
                        }
                    }
                    var nested = $(routeXmlNode).children(key);
                    var element = null;
                    if (append || !nested || !nested.length) {
                        var doc = routeXmlNode.ownerDocument || document;
                        routeXmlNode.appendChild(doc.createTextNode("\n" + childIndent));
                        element = doc.createElementNS(routeXmlNode.namespaceURI, key);
                        if (textContent) {
                            element.appendChild(doc.createTextNode(textContent));
                        }
                        routeXmlNode.appendChild(element);
                    }
                    else {
                        element = nested[0];
                    }
                    setRouteNodeJSON(element, value, childIndent);
                    if (textContent) {
                        nested.text(textContent);
                    }
                }
                else {
                    if (value) {
                        if (key.startsWith("_")) {
                        }
                        else {
                            var text = value.toString();
                            routeXmlNode.setAttribute(key, text);
                        }
                    }
                    else {
                        routeXmlNode.removeAttribute(key);
                    }
                }
            }
            angular.forEach(newData, function (value, key) { return doUpdate(value, key, false); });
        }
    }
    Camel.setRouteNodeJSON = setRouteNodeJSON;
    function getRouteNodeIcon(nodeSettingsOrXmlNode) {
        var nodeSettings = null;
        if (nodeSettingsOrXmlNode) {
            var nodeName = nodeSettingsOrXmlNode.localName;
            if (nodeName) {
                nodeSettings = getCamelSchema(nodeName);
            }
            else {
                nodeSettings = nodeSettingsOrXmlNode;
            }
        }
        if (nodeSettings) {
            var imageName = nodeSettings["icon"] || "generic24.png";
            return Core.url("/img/icons/camel/" + imageName);
        }
        else {
            return null;
        }
    }
    Camel.getRouteNodeIcon = getRouteNodeIcon;
    function getSelectedEndpointName(workspace) {
        var selection = workspace.selection;
        if (selection && selection['objectName'] && selection['typeName'] && selection['typeName'] === 'endpoints') {
            var mbean = Core.parseMBean(selection['objectName']);
            if (!mbean) {
                return null;
            }
            var attributes = mbean['attributes'];
            if (!attributes) {
                return null;
            }
            if (!('name' in attributes)) {
                return null;
            }
            var uri = attributes['name'];
            uri = uri.replace("\\?", "?");
            if (uri.startsWith("\"")) {
                uri = uri.last(uri.length - 1);
            }
            if (uri.endsWith("\"")) {
                uri = uri.first(uri.length - 1);
            }
            return uri;
        }
        else {
            return null;
        }
    }
    Camel.getSelectedEndpointName = getSelectedEndpointName;
    function escapeEndpointUriNameForJmx(uri) {
        if (angular.isString(uri)) {
            var answer = uri.replace("?", "\\?");
            answer = answer.replace(/\:(\/[^\/])/, "://$1");
            answer = answer.replace(/\:([^\/])/, "://$1");
            return answer;
        }
        else {
            return uri;
        }
    }
    Camel.escapeEndpointUriNameForJmx = escapeEndpointUriNameForJmx;
    function getContextAndTargetEndpoint(workspace) {
        return {
            uri: Camel.getSelectedEndpointName(workspace),
            mbean: Camel.getSelectionCamelContextMBean(workspace)
        };
    }
    Camel.getContextAndTargetEndpoint = getContextAndTargetEndpoint;
    function getSelectedRouteNode(workspace) {
        var selection = workspace.selection;
        return (selection && Camel.jmxDomain === selection.domain) ? selection["routeXmlNode"] : null;
    }
    Camel.getSelectedRouteNode = getSelectedRouteNode;
    function clearSelectedRouteNode(workspace) {
        var selection = workspace.selection;
        if (selection && Camel.jmxDomain === selection.domain) {
            delete selection["routeXmlNode"];
        }
    }
    Camel.clearSelectedRouteNode = clearSelectedRouteNode;
    function getCamelSchema(nodeIdOrDefinition) {
        return (angular.isObject(nodeIdOrDefinition)) ? nodeIdOrDefinition : Forms.lookupDefinition(nodeIdOrDefinition, _apacheCamelModel);
    }
    Camel.getCamelSchema = getCamelSchema;
    function isCamelPattern(nodeId) {
        return Forms.lookupDefinition(nodeId, _apacheCamelModel) != null;
    }
    Camel.isCamelPattern = isCamelPattern;
    function isNextSiblingAddedAsChild(nodeIdOrDefinition) {
        var definition = getCamelSchema(nodeIdOrDefinition);
        if (definition) {
            return definition["nextSiblingAddedAsChild"] || false;
        }
        return null;
    }
    Camel.isNextSiblingAddedAsChild = isNextSiblingAddedAsChild;
    function acceptInput(nodeIdOrDefinition) {
        var definition = getCamelSchema(nodeIdOrDefinition);
        if (definition) {
            return definition["acceptInput"] || false;
        }
        return null;
    }
    Camel.acceptInput = acceptInput;
    function acceptOutput(nodeIdOrDefinition) {
        var definition = getCamelSchema(nodeIdOrDefinition);
        if (definition) {
            return definition["acceptOutput"] || false;
        }
        return null;
    }
    Camel.acceptOutput = acceptOutput;
    function camelLanguageSettings(nodeName) {
        return _apacheCamelModel.languages[nodeName];
    }
    Camel.camelLanguageSettings = camelLanguageSettings;
    function isCamelLanguage(nodeName) {
        return (camelLanguageSettings(nodeName) || nodeName === "expression") ? true : false;
    }
    Camel.isCamelLanguage = isCamelLanguage;
    function loadCamelTree(xml, key) {
        var doc = xml;
        if (angular.isString(xml)) {
            doc = $.parseXML(xml);
        }
        var id = "camelContext";
        var folder = new Folder(id);
        folder.addClass = "org-apache-camel-context";
        folder.domain = Camel.jmxDomain;
        folder.typeName = "context";
        folder.key = Core.toSafeDomID(key);
        var context = $(doc).find("camelContext");
        if (!context || !context.length) {
            context = $(doc).find("routes");
        }
        if (context && context.length) {
            folder["xmlDocument"] = doc;
            folder["routeXmlNode"] = context;
            $(context).children("route").each(function (idx, route) {
                var id = route.getAttribute("id");
                if (!id) {
                    id = "route" + idx;
                    route.setAttribute("id", id);
                }
                var routeFolder = new Folder(id);
                routeFolder.addClass = "org-apache-camel-route";
                routeFolder.typeName = "routes";
                routeFolder.domain = Camel.jmxDomain;
                routeFolder.key = folder.key + "_" + Core.toSafeDomID(id);
                routeFolder.parent = folder;
                var nodeSettings = getCamelSchema("route");
                if (nodeSettings) {
                    var imageUrl = getRouteNodeIcon(nodeSettings);
                    routeFolder.tooltip = nodeSettings["tooltip"] || nodeSettings["description"] || id;
                    routeFolder.icon = imageUrl;
                }
                folder.children.push(routeFolder);
                addRouteChildren(routeFolder, route);
            });
        }
        return folder;
    }
    Camel.loadCamelTree = loadCamelTree;
    function addRouteChildren(folder, route) {
        folder.children = [];
        folder["routeXmlNode"] = route;
        route.setAttribute("_cid", folder.key);
        $(route).children("*").each(function (idx, n) {
            addRouteChild(folder, n);
        });
    }
    Camel.addRouteChildren = addRouteChildren;
    function addRouteChild(folder, n) {
        var nodeName = n.localName;
        if (nodeName) {
            var nodeSettings = getCamelSchema(nodeName);
            if (nodeSettings) {
                var imageUrl = getRouteNodeIcon(nodeSettings);
                var child = new Folder(nodeName);
                child.domain = Camel.jmxDomain;
                child.typeName = "routeNode";
                updateRouteNodeLabelAndTooltip(child, n, nodeSettings);
                child.parent = folder;
                child.folderNames = folder.folderNames;
                var id = n.getAttribute("id") || nodeName;
                var key = folder.key + "_" + Core.toSafeDomID(id);
                var counter = 1;
                var notFound = true;
                while (notFound) {
                    var tmpKey = key + counter;
                    if (folder.children.some({ key: tmpKey })) {
                        counter += 1;
                    }
                    else {
                        notFound = false;
                        key = tmpKey;
                    }
                }
                child.key = key;
                child.icon = imageUrl;
                child["routeXmlNode"] = n;
                if (!folder.children) {
                    folder.children = [];
                }
                folder.children.push(child);
                addRouteChildren(child, n);
                return child;
            }
        }
        return null;
    }
    Camel.addRouteChild = addRouteChild;
    function getRootCamelFolder(workspace) {
        var tree = workspace ? workspace.tree : null;
        if (tree) {
            return tree.get(Camel.jmxDomain);
        }
        return null;
    }
    Camel.getRootCamelFolder = getRootCamelFolder;
    function getCamelContextFolder(workspace, camelContextId) {
        var answer = null;
        var root = getRootCamelFolder(workspace);
        if (root && camelContextId) {
            angular.forEach(root.children, function (contextFolder) {
                if (!answer && camelContextId === contextFolder.title) {
                    answer = contextFolder;
                }
            });
        }
        return answer;
    }
    Camel.getCamelContextFolder = getCamelContextFolder;
    function getCamelContextMBean(workspace, camelContextId) {
        var contextsFolder = getCamelContextFolder(workspace, camelContextId);
        if (contextsFolder) {
            var contextFolder = contextsFolder.navigate("context");
            if (contextFolder && contextFolder.children && contextFolder.children.length) {
                var contextItem = contextFolder.children[0];
                return contextItem.objectName;
            }
        }
        return null;
    }
    Camel.getCamelContextMBean = getCamelContextMBean;
    function linkToFullScreenView(workspace) {
        var answer = null;
        var selection = workspace.selection;
        if (selection) {
            var entries = selection.entries;
            if (entries) {
                var contextId = entries["context"];
                var name = entries["name"];
                var type = entries["type"];
                if ("endpoints" === type) {
                    return linkToBrowseEndpointFullScreen(contextId, name);
                }
                if ("routes" === type) {
                    return linkToRouteDiagramFullScreen(contextId, name);
                }
            }
        }
        return answer;
    }
    Camel.linkToFullScreenView = linkToFullScreenView;
    function linkToBrowseEndpointFullScreen(contextId, endpointPath) {
        var answer = null;
        if (contextId && endpointPath) {
            answer = "#/camel/endpoint/browse/" + contextId + "/" + endpointPath;
        }
        return answer;
    }
    Camel.linkToBrowseEndpointFullScreen = linkToBrowseEndpointFullScreen;
    function linkToRouteDiagramFullScreen(contextId, routeId) {
        var answer = null;
        if (contextId && routeId) {
            answer = "#/camel/route/diagram/" + contextId + "/" + routeId;
        }
        return answer;
    }
    Camel.linkToRouteDiagramFullScreen = linkToRouteDiagramFullScreen;
    function getFolderCamelNodeId(folder) {
        var answer = Core.pathGet(folder, ["routeXmlNode", "localName"]);
        return ("from" === answer || "to" === answer) ? "endpoint" : answer;
    }
    Camel.getFolderCamelNodeId = getFolderCamelNodeId;
    function createFolderXmlTree(treeNode, xmlNode, indent) {
        if (indent === void 0) { indent = Camel.increaseIndent(""); }
        var folder = treeNode.data || treeNode;
        var count = 0;
        var parentName = getFolderCamelNodeId(folder);
        if (folder) {
            if (!xmlNode) {
                xmlNode = document.createElement(parentName);
                var rootJson = Camel.getRouteFolderJSON(folder);
                if (rootJson) {
                    Camel.setRouteNodeJSON(xmlNode, rootJson, indent);
                }
            }
            var doc = xmlNode.ownerDocument || document;
            var namespaceURI = xmlNode.namespaceURI;
            var from = parentName !== "route";
            var childIndent = Camel.increaseIndent(indent);
            angular.forEach(treeNode.children || treeNode.getChildren(), function (childTreeNode) {
                var childFolder = childTreeNode.data || childTreeNode;
                var name = Camel.getFolderCamelNodeId(childFolder);
                var json = Camel.getRouteFolderJSON(childFolder);
                if (name && json) {
                    var language = false;
                    if (name === "endpoint") {
                        if (from) {
                            name = "to";
                        }
                        else {
                            name = "from";
                            from = true;
                        }
                    }
                    if (name === "expression") {
                        var languageName = json["language"];
                        if (languageName) {
                            name = languageName;
                            language = true;
                        }
                    }
                    xmlNode.appendChild(doc.createTextNode("\n" + childIndent));
                    var newNode = doc.createElementNS(namespaceURI, name);
                    Camel.setRouteNodeJSON(newNode, json, childIndent);
                    xmlNode.appendChild(newNode);
                    count += 1;
                    createFolderXmlTree(childTreeNode, newNode, childIndent);
                }
            });
            if (count) {
                xmlNode.appendChild(doc.createTextNode("\n" + indent));
            }
        }
        return xmlNode;
    }
    Camel.createFolderXmlTree = createFolderXmlTree;
    function updateRouteNodeLabelAndTooltip(folder, routeXmlNode, nodeSettings) {
        var localName = routeXmlNode.localName;
        var id = routeXmlNode.getAttribute("id");
        var label = nodeSettings["title"] || localName;
        var tooltip = nodeSettings["tooltip"] || nodeSettings["description"] || label;
        if (id) {
            label = id;
        }
        else {
            var uri = getRouteNodeUri(routeXmlNode);
            if (uri) {
                label = uri;
                var split = uri.split("?");
                if (split && split.length > 1) {
                    label = split[0];
                }
                tooltip += " " + uri;
            }
            else {
                var children = $(routeXmlNode).children("*");
                if (children && children.length) {
                    var child = children[0];
                    var childName = child.localName;
                    var expression = null;
                    if (Camel.isCamelLanguage(childName)) {
                        expression = child.textContent;
                        if (!expression) {
                            expression = child.getAttribute("expression");
                        }
                    }
                    if (expression) {
                        label += " " + expression;
                        tooltip += " " + childName + " expression";
                    }
                }
            }
        }
        folder.title = label;
        folder.tooltip = tooltip;
        return label;
    }
    Camel.updateRouteNodeLabelAndTooltip = updateRouteNodeLabelAndTooltip;
    function getSelectionCamelContextMBean(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, contextId, "context");
                    if (result && result.children) {
                        var contextBean = result.children.first();
                        if (contextBean.title) {
                            var contextName = contextBean.title;
                            return "" + domain + ":context=" + contextId + ',type=context,name="' + contextName + '"';
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelContextMBean = getSelectionCamelContextMBean;
    function getExpandingFolderCamelContextMBean(workspace, folder) {
        if (folder.entries && folder.entries["type"] === "routes") {
            var result = workspace.tree.navigate("org.apache.camel", folder.entries["context"], "context");
            if (result && result.children) {
                var contextBean = result.children.first();
                if (contextBean.objectName) {
                    return contextBean.objectName;
                }
            }
        }
        return null;
    }
    Camel.getExpandingFolderCamelContextMBean = getExpandingFolderCamelContextMBean;
    function getSelectionCamelContextEndpoints(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    return tree.navigate(domain, contextId, "endpoints");
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelContextEndpoints = getSelectionCamelContextEndpoints;
    function getSelectionCamelTraceMBean(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, contextId, "tracer");
                    if (result && result.children) {
                        var mbean = result.children.find(function (m) { return m.title.startsWith("BacklogTracer"); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                    var fabricResult = tree.navigate(domain, contextId, "fabric");
                    if (fabricResult && fabricResult.children) {
                        var mbean = fabricResult.children.first();
                        return mbean.objectName;
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelTraceMBean = getSelectionCamelTraceMBean;
    function getSelectionCamelDebugMBean(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, contextId, "tracer");
                    if (result && result.children) {
                        var mbean = result.children.find(function (m) { return m.title.startsWith("BacklogDebugger"); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelDebugMBean = getSelectionCamelDebugMBean;
    function getSelectionCamelTypeConverter(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, contextId, "services");
                    if (result && result.children) {
                        var mbean = result.children.find(function (m) { return m.title.startsWith("DefaultTypeConverter"); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelTypeConverter = getSelectionCamelTypeConverter;
    function getSelectionCamelRestRegistry(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, contextId, "services");
                    if (result && result.children) {
                        var mbean = result.children.find(function (m) { return m.title.startsWith("DefaultRestRegistry"); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelRestRegistry = getSelectionCamelRestRegistry;
    function getSelectionCamelRouteMetrics(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, contextId, "services");
                    if (result && result.children) {
                        var mbean = result.children.find(function (m) { return m.title.startsWith("MetricsRegistryService"); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelRouteMetrics = getSelectionCamelRouteMetrics;
    function getSelectionCamelInflightRepository(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, contextId, "services");
                    if (result && result.children) {
                        var mbean = result.children.find(function (m) { return m.title.startsWith("DefaultInflightRepository"); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelInflightRepository = getSelectionCamelInflightRepository;
    function getContextId(workspace) {
        var selection = workspace.selection;
        if (selection) {
            selection = selection.findAncestor(function (s) { return s.title === 'context' || s.parent != null && s.parent.title === 'org.apache.camel'; });
            if (selection) {
                var tree = workspace.tree;
                var folderNames = selection.folderNames;
                var entries = selection.entries;
                var contextId;
                if (tree) {
                    if (folderNames && folderNames.length > 1) {
                        contextId = folderNames[1];
                    }
                    else if (entries) {
                        contextId = entries["context"];
                    }
                }
            }
        }
        return contextId;
    }
    Camel.getContextId = getContextId;
    function isState(item, state) {
        var value = (item.State || "").toLowerCase();
        if (angular.isArray(state)) {
            return state.any(function (stateText) { return value.startsWith(stateText); });
        }
        else {
            return value.startsWith(state);
        }
    }
    Camel.isState = isState;
    function iconClass(state) {
        if (state) {
            switch (state.toLowerCase()) {
                case 'started':
                    return "green icon-play-circle";
                case 'suspended':
                    return "icon-pause";
            }
        }
        return "orange icon-off";
    }
    Camel.iconClass = iconClass;
    function getSelectedRouteId(workspace, folder) {
        if (folder === void 0) { folder = null; }
        var selection = folder || workspace.selection;
        var selectedRouteId = null;
        if (selection) {
            if (selection && selection.entries) {
                var typeName = selection.entries["type"];
                var name = selection.entries["name"];
                if ("routes" === typeName && name) {
                    selectedRouteId = Core.trimQuotes(name);
                }
            }
        }
        return selectedRouteId;
    }
    Camel.getSelectedRouteId = getSelectedRouteId;
    function getSelectionRouteMBean(workspace, routeId) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, contextId, "routes");
                    if (result && result.children) {
                        var mbean = result.children.find(function (m) { return m.title === routeId; });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionRouteMBean = getSelectionRouteMBean;
    function getCamelVersion(workspace, jolokia) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, contextId, "context");
                    if (result && result.children) {
                        var contextBean = result.children.first();
                        if (contextBean.version) {
                            return contextBean.version;
                        }
                        if (contextBean.title) {
                            var contextName = contextBean.title;
                            var mbean = "" + domain + ":context=" + contextId + ',type=context,name="' + contextName + '"';
                            var version = jolokia.getAttribute(mbean, "CamelVersion", onSuccess(null));
                            contextBean.version = version;
                            return version;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getCamelVersion = getCamelVersion;
    function createMessageFromXml(exchange) {
        var exchangeElement = $(exchange);
        var uid = exchangeElement.children("uid").text();
        var timestamp = exchangeElement.children("timestamp").text();
        var messageData = {
            headers: {},
            headerTypes: {},
            id: null,
            uid: uid,
            timestamp: timestamp,
            headerHtml: ""
        };
        var message = exchangeElement.children("message")[0];
        if (!message) {
            message = exchange;
        }
        var messageElement = $(message);
        var headers = messageElement.find("header");
        var headerHtml = "";
        headers.each(function (idx, header) {
            var key = header.getAttribute("key");
            var typeName = header.getAttribute("type");
            var value = header.textContent;
            if (key) {
                if (value)
                    messageData.headers[key] = value;
                if (typeName)
                    messageData.headerTypes[key] = typeName;
                headerHtml += "<tr><td class='property-name'>" + key + "</td>" + "<td class='property-value'>" + (humanizeJavaType(typeName)) + "</td>" + "<td class='property-value'>" + (value || "") + "</td></tr>";
            }
        });
        messageData.headerHtml = headerHtml;
        var id = messageData.headers["breadcrumbId"];
        if (!id) {
            var postFixes = ["MessageID", "ID", "Path", "Name"];
            angular.forEach(postFixes, function (postfix) {
                if (!id) {
                    angular.forEach(messageData.headers, function (value, key) {
                        if (!id && key.endsWith(postfix)) {
                            id = value;
                        }
                    });
                }
            });
            angular.forEach(messageData.headers, function (value, key) {
                if (!id)
                    id = value;
            });
        }
        messageData.id = id;
        var body = messageElement.children("body")[0];
        if (body) {
            var bodyText = body.textContent;
            var bodyType = body.getAttribute("type");
            messageData["body"] = bodyText;
            messageData["bodyType"] = humanizeJavaType(bodyType);
        }
        return messageData;
    }
    Camel.createMessageFromXml = createMessageFromXml;
    function humanizeJavaType(type) {
        if (!type) {
            return "";
        }
        if (type.startsWith("java.lang")) {
            return type.substr(10);
        }
        return type;
    }
    Camel.humanizeJavaType = humanizeJavaType;
    function createBrowseGridOptions() {
        return {
            selectedItems: [],
            data: 'messages',
            displayFooter: false,
            showFilter: false,
            showColumnMenu: true,
            enableColumnResize: true,
            enableColumnReordering: true,
            filterOptions: {
                filterText: ''
            },
            selectWithCheckboxOnly: true,
            showSelectionCheckbox: true,
            maintainColumnRatios: false,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'ID',
                    cellTemplate: '<div class="ngCellText"><a ng-click="openMessageDialog(row)">{{row.entity.id}}</a></div>'
                }
            ]
        };
    }
    Camel.createBrowseGridOptions = createBrowseGridOptions;
    function loadRouteXmlNodes($scope, doc, selectedRouteId, nodes, links, width) {
        var allRoutes = $(doc).find("route");
        var routeDelta = width / allRoutes.length;
        var rowX = 0;
        allRoutes.each(function (idx, route) {
            var routeId = route.getAttribute("id");
            if (!selectedRouteId || !routeId || selectedRouteId === routeId) {
                Camel.addRouteXmlChildren($scope, route, nodes, links, null, rowX, 0);
                rowX += routeDelta;
            }
        });
    }
    Camel.loadRouteXmlNodes = loadRouteXmlNodes;
    function addRouteXmlChildren($scope, parent, nodes, links, parentId, parentX, parentY, parentNode) {
        if (parentNode === void 0) { parentNode = null; }
        var delta = 150;
        var x = parentX;
        var y = parentY + delta;
        var rid = parent.getAttribute("id");
        var siblingNodes = [];
        var parenNodeName = parent.localName;
        $(parent).children().each(function (idx, route) {
            var id = nodes.length;
            var nodeId = route.localName;
            if (nodeId === "from" && !parentId) {
                parentId = id;
            }
            var nodeSettings = getCamelSchema(nodeId);
            var node = null;
            if (nodeSettings) {
                var label = nodeSettings["title"] || nodeId;
                var uri = getRouteNodeUri(route);
                if (uri) {
                    label += " " + uri.split("?")[0];
                }
                var tooltip = nodeSettings["tooltip"] || nodeSettings["description"] || label;
                if (uri) {
                    tooltip += " " + uri;
                }
                var elementID = route.getAttribute("id");
                var labelSummary = label;
                if (elementID) {
                    var customId = route.getAttribute("customId");
                    if ($scope.camelIgnoreIdForLabel || (!customId || customId === "false")) {
                        labelSummary = "id: " + elementID;
                    }
                    else {
                        label = elementID;
                    }
                }
                var labelLimit = $scope.camelMaximumLabelWidth || Camel.defaultMaximumLabelWidth;
                var length = label.length;
                if (length > labelLimit) {
                    labelSummary = label + "\n\n" + labelSummary;
                    label = label.substring(0, labelLimit) + "..";
                }
                var imageUrl = getRouteNodeIcon(nodeSettings);
                if ((nodeId === "from" || nodeId === "to") && uri) {
                    var uriIdx = uri.indexOf(":");
                    if (uriIdx > 0) {
                        var componentScheme = uri.substring(0, uriIdx);
                        if (componentScheme) {
                            var value = Camel.getEndpointIcon(componentScheme);
                            if (value) {
                                imageUrl = Core.url(value);
                            }
                        }
                    }
                }
                var cid = route.getAttribute("_cid") || route.getAttribute("id");
                node = { "name": name, "label": label, "labelSummary": labelSummary, "group": 1, "id": id, "elementId": elementID, "x": x, "y:": y, "imageUrl": imageUrl, "cid": cid, "tooltip": tooltip, "type": nodeId };
                if (rid) {
                    node["rid"] = rid;
                    if (!$scope.routeNodes)
                        $scope.routeNodes = {};
                    $scope.routeNodes[rid] = node;
                }
                if (!cid) {
                    cid = nodeId + (nodes.length + 1);
                }
                if (cid) {
                    node["cid"] = cid;
                    if (!$scope.nodes)
                        $scope.nodes = {};
                    $scope.nodes[cid] = node;
                }
                rid = null;
                nodes.push(node);
                if (parentId !== null && parentId !== id) {
                    if (siblingNodes.length === 0 || parenNodeName === "choice") {
                        links.push({ "source": parentId, "target": id, "value": 1 });
                    }
                    else {
                        siblingNodes.forEach(function (nodeId) {
                            links.push({ "source": nodeId, "target": id, "value": 1 });
                        });
                        siblingNodes.length = 0;
                    }
                }
            }
            else {
                var langSettings = Camel.camelLanguageSettings(nodeId);
                if (langSettings && parentNode) {
                    var name = langSettings["name"] || nodeId;
                    var text = route.textContent;
                    if (text) {
                        parentNode["tooltip"] = parentNode["label"] + " " + name + " " + text;
                        parentNode["label"] = text;
                    }
                    else {
                        parentNode["label"] = parentNode["label"] + " " + name;
                    }
                }
            }
            var siblings = addRouteXmlChildren($scope, route, nodes, links, id, x, y, node);
            if (parenNodeName === "choice") {
                siblingNodes = siblingNodes.concat(siblings);
                x += delta;
            }
            else if (nodeId === "choice") {
                siblingNodes = siblings;
                y += delta;
            }
            else {
                siblingNodes = [nodes.length - 1];
                y += delta;
            }
        });
        return siblingNodes;
    }
    Camel.addRouteXmlChildren = addRouteXmlChildren;
    function getCanvasHeight(canvasDiv) {
        var height = canvasDiv.height();
        if (height < 300) {
            console.log("browse thinks the height is only " + height + " so calculating offset from doc height");
            var offset = canvasDiv.offset();
            height = $(document).height() - 5;
            if (offset) {
                var top = offset['top'];
                if (top) {
                    height -= top;
                }
            }
        }
        return height;
    }
    Camel.getCanvasHeight = getCanvasHeight;
    function addFoldersToIndex(folder, map) {
        if (map === void 0) { map = {}; }
        if (folder) {
            var key = folder.key;
            if (key) {
                map[key] = folder;
            }
            angular.forEach(folder.children, function (child) { return addFoldersToIndex(child, map); });
        }
        return map;
    }
    Camel.addFoldersToIndex = addFoldersToIndex;
    function generateXmlFromFolder(treeNode) {
        var folder = (treeNode && treeNode.data) ? treeNode.data : treeNode;
        if (!folder)
            return null;
        var doc = folder["xmlDocument"];
        var context = folder["routeXmlNode"];
        if (context && context.length) {
            var element = context[0];
            var children = element.childNodes;
            var routeIndices = [];
            for (var i = 0; i < children.length; i++) {
                var node = children[i];
                var name = node.localName;
                if ("route" === name && parent) {
                    routeIndices.push(i);
                }
            }
            while (routeIndices.length) {
                var idx = routeIndices.pop();
                var nextIndex = idx + 1;
                while (true) {
                    var node = element.childNodes[nextIndex];
                    if (Core.isTextNode(node)) {
                        element.removeChild(node);
                    }
                    else {
                        break;
                    }
                }
                if (idx < element.childNodes.length) {
                    element.removeChild(element.childNodes[idx]);
                }
                for (var i = idx - 1; i >= 0; i--) {
                    var node = element.childNodes[i];
                    if (Core.isTextNode(node)) {
                        element.removeChild(node);
                    }
                    else {
                        break;
                    }
                }
            }
            Camel.createFolderXmlTree(treeNode, context[0]);
        }
        return doc;
    }
    Camel.generateXmlFromFolder = generateXmlFromFolder;
    function camelContextMBeansById(workspace) {
        var answer = {};
        var tree = workspace.tree;
        if (tree) {
            var camelTree = tree.navigate(Camel.jmxDomain);
            if (camelTree) {
                angular.forEach(camelTree.children, function (contextsFolder) {
                    var contextFolder = contextsFolder.navigate("context");
                    if (contextFolder && contextFolder.children && contextFolder.children.length) {
                        var contextItem = contextFolder.children[0];
                        var id = Core.pathGet(contextItem, ["entries", "name"]) || contextItem.key;
                        if (id) {
                            answer[id] = {
                                folder: contextItem,
                                mbean: contextItem.objectName
                            };
                        }
                    }
                });
            }
        }
        return answer;
    }
    Camel.camelContextMBeansById = camelContextMBeansById;
    function camelContextMBeansByComponentName(workspace) {
        return camelContextMBeansByRouteOrComponentId(workspace, "components");
    }
    Camel.camelContextMBeansByComponentName = camelContextMBeansByComponentName;
    function camelContextMBeansByRouteId(workspace) {
        return camelContextMBeansByRouteOrComponentId(workspace, "routes");
    }
    Camel.camelContextMBeansByRouteId = camelContextMBeansByRouteId;
    function camelContextMBeansByRouteOrComponentId(workspace, componentsOrRoutes) {
        var answer = {};
        var tree = workspace.tree;
        if (tree) {
            var camelTree = tree.navigate(Camel.jmxDomain);
            if (camelTree) {
                angular.forEach(camelTree.children, function (contextsFolder) {
                    var contextFolder = contextsFolder.navigate("context");
                    var componentsFolder = contextsFolder.navigate(componentsOrRoutes);
                    if (contextFolder && componentsFolder && contextFolder.children && contextFolder.children.length) {
                        var contextItem = contextFolder.children[0];
                        var mbean = contextItem.objectName;
                        if (mbean) {
                            var contextValues = {
                                folder: contextItem,
                                mbean: mbean
                            };
                            angular.forEach(componentsFolder.children, function (componentFolder) {
                                var id = componentFolder.title;
                                if (id) {
                                    answer[id] = contextValues;
                                }
                            });
                        }
                    }
                });
            }
        }
        return answer;
    }
    function camelProcessorMBeansById(workspace) {
        var answer = {};
        var tree = workspace.tree;
        if (tree) {
            var camelTree = tree.navigate(Camel.jmxDomain);
            if (camelTree) {
                angular.forEach(camelTree.children, function (contextsFolder) {
                    var processorsFolder = contextsFolder.navigate("processors");
                    if (processorsFolder && processorsFolder.children && processorsFolder.children.length) {
                        angular.forEach(processorsFolder.children, function (processorFolder) {
                            var id = processorFolder.title;
                            if (id) {
                                var processorValues = {
                                    folder: processorsFolder,
                                    key: processorFolder.key
                                };
                                answer[id] = processorValues;
                            }
                        });
                    }
                });
            }
        }
        return answer;
    }
    Camel.camelProcessorMBeansById = camelProcessorMBeansById;
    function showInflightCounter(localStorage) {
        var value = localStorage["camelShowInflightCounter"];
        return Core.parseBooleanValue(value, true);
    }
    Camel.showInflightCounter = showInflightCounter;
    function ignoreIdForLabel(localStorage) {
        var value = localStorage["camelIgnoreIdForLabel"];
        return Core.parseBooleanValue(value);
    }
    Camel.ignoreIdForLabel = ignoreIdForLabel;
    function maximumLabelWidth(localStorage) {
        var value = localStorage["camelMaximumLabelWidth"];
        if (angular.isString(value)) {
            value = parseInt(value);
        }
        if (!value) {
            value = Camel.defaultMaximumLabelWidth;
        }
        return value;
    }
    Camel.maximumLabelWidth = maximumLabelWidth;
    function maximumTraceOrDebugBodyLength(localStorage) {
        var value = localStorage["camelMaximumTraceOrDebugBodyLength"];
        if (angular.isString(value)) {
            value = parseInt(value);
        }
        if (!value) {
            value = Camel.defaultCamelMaximumTraceOrDebugBodyLength;
        }
        return value;
    }
    Camel.maximumTraceOrDebugBodyLength = maximumTraceOrDebugBodyLength;
    function traceOrDebugIncludeStreams(localStorage) {
        var value = localStorage["camelTraceOrDebugIncludeStreams"];
        return Core.parseBooleanValue(value, Camel.defaultCamelTraceOrDebugIncludeStreams);
    }
    Camel.traceOrDebugIncludeStreams = traceOrDebugIncludeStreams;
    function routeMetricMaxSeconds(localStorage) {
        var value = localStorage["camelRouteMetricMaxSeconds"];
        if (angular.isString(value)) {
            value = parseInt(value);
        }
        if (!value) {
            value = Camel.defaultCamelRouteMetricMaxSeconds;
        }
        return value;
    }
    Camel.routeMetricMaxSeconds = routeMetricMaxSeconds;
    function hideOptionDocumentation(localStorage) {
        var value = localStorage["camelHideOptionDocumentation"];
        return Core.parseBooleanValue(value, Camel.defaultHideOptionDocumentation);
    }
    Camel.hideOptionDocumentation = hideOptionDocumentation;
    function hideOptionDefaultValue(localStorage) {
        var value = localStorage["camelHideOptionDefaultValue"];
        return Core.parseBooleanValue(value, Camel.defaultHideOptionDefaultValue);
    }
    Camel.hideOptionDefaultValue = hideOptionDefaultValue;
    function hideOptionUnusedValue(localStorage) {
        var value = localStorage["camelHideOptionUnusedValue"];
        return Core.parseBooleanValue(value, Camel.defaultHideOptionUnusedValue);
    }
    Camel.hideOptionUnusedValue = hideOptionUnusedValue;
    function highlightSelectedNode(nodes, toNode) {
        nodes.attr("class", "node");
        nodes.filter(function (item) {
            if (item) {
                var cid = item["cid"];
                var rid = item["rid"];
                var type = item["type"];
                var elementId = item["elementId"];
                if ("from" === type) {
                    return toNode === rid;
                }
                if (elementId) {
                    return toNode === elementId;
                }
                if (cid) {
                    return toNode === cid;
                }
                else {
                    return toNode === rid;
                }
            }
            return null;
        }).attr("class", "node selected");
    }
    Camel.highlightSelectedNode = highlightSelectedNode;
    function isCamelVersionEQGT(major, minor, workspace, jolokia) {
        var camelVersion = getCamelVersion(workspace, jolokia);
        if (camelVersion) {
            console.log("Camel version " + camelVersion);
            camelVersion += "camel-";
            var numbers = Core.parseVersionNumbers(camelVersion);
            if (Core.compareVersionNumberArrays(numbers, [major, minor]) >= 0) {
                return true;
            }
            else {
                return false;
            }
        }
        return false;
    }
    Camel.isCamelVersionEQGT = isCamelVersionEQGT;
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    var jmxModule = Jmx;
    Camel.pluginName = 'camel';
    var routeToolBar = "app/camel/html/attributeToolBarRoutes.html";
    var contextToolBar = "app/camel/html/attributeToolBarContext.html";
    Camel._module = angular.module(Camel.pluginName, ['bootstrap', 'ui.bootstrap', 'ui.bootstrap.dialog', 'ui.bootstrap.tabs', 'ui.bootstrap.typeahead', 'ngResource', 'hawtioCore', 'hawtio-ui']);
    Camel._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/camel/browseEndpoint', { templateUrl: 'app/camel/html/browseEndpoint.html' }).when('/camel/endpoint/browse/:contextId/*endpointPath', { templateUrl: 'app/camel/html/browseEndpoint.html' }).when('/camel/propertiesEndpoint', { templateUrl: 'app/camel/html/propertiesEndpoint.html' }).when('/camel/createEndpoint', { templateUrl: 'app/camel/html/createEndpoint.html' }).when('/camel/route/diagram/:contextId/:routeId', { templateUrl: 'app/camel/html/routes.html' }).when('/camel/routes', { templateUrl: 'app/camel/html/routes.html' }).when('/camel/fabricDiagram', { templateUrl: 'app/camel/html/fabricDiagram.html', reloadOnSearch: false }).when('/camel/typeConverter', { templateUrl: 'app/camel/html/typeConverter.html', reloadOnSearch: false }).when('/camel/restRegistry', { templateUrl: 'app/camel/html/restRegistry.html', reloadOnSearch: false }).when('/camel/routeMetrics', { templateUrl: 'app/camel/html/routeMetrics.html', reloadOnSearch: false }).when('/camel/inflight', { templateUrl: 'app/camel/html/inflight.html', reloadOnSearch: false }).when('/camel/sendMessage', { templateUrl: 'app/camel/html/sendMessage.html', reloadOnSearch: false }).when('/camel/source', { templateUrl: 'app/camel/html/source.html' }).when('/camel/traceRoute', { templateUrl: 'app/camel/html/traceRoute.html' }).when('/camel/debugRoute', { templateUrl: 'app/camel/html/debug.html' }).when('/camel/profileRoute', { templateUrl: 'app/camel/html/profileRoute.html' }).when('/camel/properties', { templateUrl: 'app/camel/html/properties.html' });
    }]);
    Camel._module.factory('tracerStatus', function () {
        return {
            jhandle: null,
            messages: []
        };
    });
    Camel._module.filter('camelIconClass', function () { return Camel.iconClass; });
    Camel._module.factory('activeMQMessage', function () {
        return { 'message': null };
    });
    Camel._module.run(["workspace", "jolokia", "viewRegistry", "layoutFull", "helpRegistry", "preferencesRegistry", function (workspace, jolokia, viewRegistry, layoutFull, helpRegistry, preferencesRegistry) {
        viewRegistry['camel/endpoint/'] = layoutFull;
        viewRegistry['camel/route/'] = layoutFull;
        viewRegistry['camel/fabricDiagram'] = layoutFull;
        viewRegistry['camel'] = 'app/camel/html/layoutCamelTree.html';
        helpRegistry.addUserDoc('camel', 'app/camel/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties(Camel.jmxDomain);
        });
        preferencesRegistry.addTab('Camel', 'app/camel/html/preferences.html', function () {
            return workspace.treeContainsDomainAndProperties(Camel.jmxDomain);
        });
        Jmx.addAttributeToolBar(Camel.pluginName, Camel.jmxDomain, function (selection) {
            var typeName = selection.typeName;
            if (typeName) {
                if (typeName.startsWith("context"))
                    return contextToolBar;
                if (typeName.startsWith("route"))
                    return routeToolBar;
            }
            var folderNames = selection.folderNames;
            if (folderNames && selection.domain === Camel.jmxDomain) {
                var last = folderNames.last();
                if ("routes" === last)
                    return routeToolBar;
                if ("context" === last)
                    return contextToolBar;
            }
            return null;
        });
        var stateField = 'State';
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(\'' + stateField + '\') | camelIconClass}}"></i></div>';
        var stateColumn = { field: stateField, displayName: stateField, cellTemplate: stateTemplate, width: 56, minWidth: 56, maxWidth: 56, resizable: false, defaultSort: false };
        var attributes = workspace.attributeColumnDefs;
        attributes[Camel.jmxDomain + "/context/folder"] = [
            stateColumn,
            { field: 'CamelId', displayName: 'Context' },
            { field: 'Uptime', displayName: 'Uptime', visible: false },
            { field: 'CamelVersion', displayName: 'Version', visible: false },
            { field: 'ExchangesCompleted', displayName: 'Completed #' },
            { field: 'ExchangesFailed', displayName: 'Failed #' },
            { field: 'FailuresHandled', displayName: 'Failed Handled #' },
            { field: 'ExchangesTotal', displayName: 'Total #', visible: false },
            { field: 'InflightExchanges', displayName: 'Inflight #' },
            { field: 'MeanProcessingTime', displayName: 'Mean Time' },
            { field: 'MinProcessingTime', displayName: 'Min Time' },
            { field: 'MaxProcessingTime', displayName: 'Max Time' },
            { field: 'TotalProcessingTime', displayName: 'Total Time', visible: false },
            { field: 'LastProcessingTime', displayName: 'Last Time', visible: false },
            { field: 'LastExchangeCompletedTimestamp', displayName: 'Last completed', visible: false },
            { field: 'LastExchangeFailedTimestamp', displayName: 'Last failed', visible: false },
            { field: 'Redeliveries', displayName: 'Redelivery #', visible: false },
            { field: 'ExternalRedeliveries', displayName: 'External Redelivery #', visible: false }
        ];
        attributes[Camel.jmxDomain + "/routes/folder"] = [
            stateColumn,
            { field: 'CamelId', displayName: 'Context' },
            { field: 'RouteId', displayName: 'Route' },
            { field: 'ExchangesCompleted', displayName: 'Completed #' },
            { field: 'ExchangesFailed', displayName: 'Failed #' },
            { field: 'FailuresHandled', displayName: 'Failed Handled #' },
            { field: 'ExchangesTotal', displayName: 'Total #', visible: false },
            { field: 'InflightExchanges', displayName: 'Inflight #' },
            { field: 'MeanProcessingTime', displayName: 'Mean Time' },
            { field: 'MinProcessingTime', displayName: 'Min Time' },
            { field: 'MaxProcessingTime', displayName: 'Max Time' },
            { field: 'TotalProcessingTime', displayName: 'Total Time', visible: false },
            { field: 'DeltaProcessingTime', displayName: 'Delta Time', visible: false },
            { field: 'LastProcessingTime', displayName: 'Last Time', visible: false },
            { field: 'LastExchangeCompletedTimestamp', displayName: 'Last completed', visible: false },
            { field: 'LastExchangeFailedTimestamp', displayName: 'Last failed', visible: false },
            { field: 'Redeliveries', displayName: 'Redelivery #', visible: false },
            { field: 'ExternalRedeliveries', displayName: 'External Redelivery #', visible: false }
        ];
        attributes[Camel.jmxDomain + "/processors/folder"] = [
            stateColumn,
            { field: 'CamelId', displayName: 'Context' },
            { field: 'RouteId', displayName: 'Route' },
            { field: 'ProcessorId', displayName: 'Processor' },
            { field: 'ExchangesCompleted', displayName: 'Completed #' },
            { field: 'ExchangesFailed', displayName: 'Failed #' },
            { field: 'FailuresHandled', displayName: 'Failed Handled #' },
            { field: 'ExchangesTotal', displayName: 'Total #', visible: false },
            { field: 'InflightExchanges', displayName: 'Inflight #' },
            { field: 'MeanProcessingTime', displayName: 'Mean Time' },
            { field: 'MinProcessingTime', displayName: 'Min Time' },
            { field: 'MaxProcessingTime', displayName: 'Max Time' },
            { field: 'TotalProcessingTime', displayName: 'Total Time', visible: false },
            { field: 'LastProcessingTime', displayName: 'Last Time', visible: false },
            { field: 'LastExchangeCompletedTimestamp', displayName: 'Last completed', visible: false },
            { field: 'LastExchangeFailedTimestamp', displayName: 'Last failed', visible: false },
            { field: 'Redeliveries', displayName: 'Redelivery #', visible: false },
            { field: 'ExternalRedeliveries', displayName: 'External Redelivery #', visible: false }
        ];
        attributes[Camel.jmxDomain + "/components/folder"] = [
            stateColumn,
            { field: 'CamelId', displayName: 'Context' },
            { field: 'ComponentName', displayName: 'Name' }
        ];
        attributes[Camel.jmxDomain + "/consumers/folder"] = [
            stateColumn,
            { field: 'CamelId', displayName: 'Context' },
            { field: 'RouteId', displayName: 'Route' },
            { field: 'EndpointUri', displayName: 'Endpoint URI', width: "**" },
            { field: 'Suspended', displayName: 'Suspended', resizable: false },
            { field: 'InflightExchanges', displayName: 'Inflight #' }
        ];
        attributes[Camel.jmxDomain + "/services/folder"] = [
            stateColumn,
            { field: 'CamelId', displayName: 'Context' },
            { field: 'RouteId', displayName: 'Route' },
            { field: 'Suspended', displayName: 'Suspended', resizable: false },
            { field: 'SupportsSuspended', displayName: 'Can Suspend', resizable: false }
        ];
        attributes[Camel.jmxDomain + "/endpoints/folder"] = [
            stateColumn,
            { field: 'CamelId', displayName: 'Context' },
            { field: 'EndpointUri', displayName: 'Endpoint URI', width: "***" },
            { field: 'Singleton', displayName: 'Singleton', resizable: false }
        ];
        attributes[Camel.jmxDomain + "/threadpools/folder"] = [
            { field: 'Id', displayName: 'Id', width: "**" },
            { field: 'ActiveCount', displayName: 'Active #' },
            { field: 'PoolSize', displayName: 'Pool Size' },
            { field: 'CorePoolSize', displayName: 'Core Pool Size' },
            { field: 'TaskQueueSize', displayName: 'Task Queue Size' },
            { field: 'TaskCount', displayName: 'Task #' },
            { field: 'CompletedTaskCount', displayName: 'Completed Task #' }
        ];
        attributes[Camel.jmxDomain + "/errorhandlers/folder"] = [
            { field: 'CamelId', displayName: 'Context' },
            { field: 'DeadLetterChannel', displayName: 'Dead Letter' },
            { field: 'DeadLetterChannelEndpointUri', displayName: 'Endpoint URI', width: "**", resizable: true },
            { field: 'MaximumRedeliveries', displayName: 'Max Redeliveries' },
            { field: 'RedeliveryDelay', displayName: 'Redelivery Delay' },
            { field: 'MaximumRedeliveryDelay', displayName: 'Max Redeliveries Delay' }
        ];
        workspace.topLevelTabs.push({
            id: "camel",
            content: "Camel",
            title: "Manage your Apache Camel applications",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties(Camel.jmxDomain); },
            href: function () { return "#/jmx/attributes?tab=camel"; },
            isActive: function (workspace) { return workspace.isTopTabActive("camel"); }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-picture"></i> Route Diagram',
            title: "View a diagram of the Camel routes",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && workspace.isRoute() && workspace.hasInvokeRightsForName(Camel.getSelectionCamelContextMBean(workspace), "dumpRoutesAsXml"); },
            href: function () { return "#/camel/routes"; },
            index: -2
        });
        workspace.subLevelTabs.push({
            content: '<i class=" icon-file-alt"></i> Source',
            title: "View the source of the Camel routes",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && !workspace.isEndpointsFolder() && (workspace.isRoute() || workspace.isRoutesFolder()) && workspace.hasInvokeRightsForName(Camel.getSelectionCamelContextMBean(workspace), "dumpRoutesAsXml"); },
            href: function () { return "#/camel/source"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-bar-chart"></i> Route Metrics',
            title: "View the entire JVMs Camel route metrics",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && !workspace.isEndpointsFolder() && (workspace.isRoute() || workspace.isRoutesFolder()) && Camel.isCamelVersionEQGT(2, 14, workspace, jolokia) && workspace.hasInvokeRightsForName(Camel.getSelectionCamelRouteMetrics(workspace), "dumpStatisticsAsJson"); },
            href: function () { return "#/camel/routeMetrics"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-list"></i> Inflight Exchanges',
            title: "View the entire JVMs Camel inflight exchanges",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && !workspace.isEndpointsFolder() && (workspace.isRoute() || workspace.isRoutesFolder()) && Camel.isCamelVersionEQGT(2, 15, workspace, jolokia) && workspace.hasInvokeRightsForName(Camel.getSelectionCamelInflightRepository(workspace), "browse"); },
            href: function () { return "#/camel/inflight"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class=" icon-edit"></i> Properties',
            title: "View the pattern properties",
            isValid: function (workspace) { return Camel.getSelectedRouteNode(workspace); },
            href: function () { return "#/camel/properties"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-list"></i> Rest Services',
            title: "List all the REST services registered in the context",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && !Camel.getSelectedRouteNode(workspace) && !workspace.isEndpointsFolder() && !workspace.isRoute() && Camel.isCamelVersionEQGT(2, 14, workspace, jolokia) && workspace.hasInvokeRightsForName(Camel.getSelectionCamelRestRegistry(workspace), "listRestServices"); },
            href: function () { return "#/camel/restRegistry"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-list"></i> Type Converters',
            title: "List all the type converters registered in the context",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && !Camel.getSelectedRouteNode(workspace) && !workspace.isEndpointsFolder() && (workspace.isRoute() || workspace.isRoutesFolder() || workspace.isCamelContext()) && Camel.isCamelVersionEQGT(2, 13, workspace, jolokia) && workspace.hasInvokeRightsForName(Camel.getSelectionCamelTypeConverter(workspace), "listTypeConverters"); },
            href: function () { return "#/camel/typeConverter"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-envelope"></i> Browse',
            title: "Browse the messages on the endpoint",
            isValid: function (workspace) { return workspace.isEndpoint() && workspace.hasInvokeRights(workspace.selection, "browseAllMessagesAsXml"); },
            href: function () { return "#/camel/browseEndpoint"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-list"></i> Properties',
            title: "Show the endpoint properties",
            isValid: function (workspace) { return workspace.isEndpoint() && Camel.isCamelVersionEQGT(2, 15, workspace, jolokia) && workspace.hasInvokeRights(workspace.selection, "explainEndpointJson"); },
            href: function () { return "#/camel/propertiesEndpoint"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-stethoscope"></i> Debug',
            title: "Debug the Camel route",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && workspace.isRoute() && Camel.getSelectionCamelDebugMBean(workspace) && workspace.hasInvokeRightsForName(Camel.getSelectionCamelDebugMBean(workspace), "getBreakpoints"); },
            href: function () { return "#/camel/debugRoute"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-envelope"></i> Trace',
            title: "Trace the messages flowing through the Camel route",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && workspace.isRoute() && Camel.getSelectionCamelTraceMBean(workspace) && workspace.hasInvokeRightsForName(Camel.getSelectionCamelTraceMBean(workspace), "dumpAllTracedMessagesAsXml"); },
            href: function () { return "#/camel/traceRoute"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-bar-chart"></i> Profile',
            title: "Profile the messages flowing through the Camel route",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && workspace.isRoute() && Camel.getSelectionCamelTraceMBean(workspace) && workspace.hasInvokeRightsForName(Camel.getSelectionCamelTraceMBean(workspace), "dumpAllTracedMessagesAsXml"); },
            href: function () { return "#/camel/profileRoute"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-pencil"></i> Send',
            title: "Send a message to this endpoint",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && workspace.isEndpoint() && workspace.hasInvokeRights(workspace.selection, workspace.selection.domain === "org.apache.camel" ? "sendBodyAndHeaders" : "sendTextMessage"); },
            href: function () { return "#/camel/sendMessage"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-plus"></i> Endpoint',
            title: "Create a new endpoint",
            isValid: function (workspace) { return workspace.isTopTabActive("camel") && workspace.isEndpointsFolder() && workspace.hasInvokeRights(workspace.selection, "createEndpoint"); },
            href: function () { return "#/camel/createEndpoint"; }
        });
    }]);
    hawtioPluginLoader.addModule(Camel.pluginName);
    hawtioPluginLoader.registerPreBootstrapTask(function (task) {
        jmxModule.registerLazyLoadHandler(Camel.jmxDomain, function (folder) {
            if (Camel.jmxDomain === folder.domain && "routes" === folder.typeName) {
                return function (workspace, folder, onComplete) {
                    if ("routes" === folder.typeName) {
                        Camel.processRouteXml(workspace, workspace.jolokia, folder, function (route) {
                            if (route) {
                                Camel.addRouteChildren(folder, route);
                            }
                            onComplete();
                        });
                    }
                    else {
                        onComplete();
                    }
                };
            }
            return null;
        });
        task();
    });
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.AttributesToolBarController", ["$scope", "workspace", "jolokia", function ($scope, workspace, jolokia) {
        $scope.deleteDialog = false;
        $scope.start = function () {
            $scope.invokeSelectedMBeans(function (item) {
                return Camel.isState(item, "suspend") ? "resume()" : "start()";
            });
        };
        $scope.pause = function () {
            $scope.invokeSelectedMBeans("suspend()");
        };
        $scope.stop = function () {
            $scope.invokeSelectedMBeans("stop()", function () {
                workspace.removeAndSelectParentNode();
            });
        };
        $scope.delete = function () {
            $scope.invokeSelectedMBeans("remove()", function () {
                $scope.workspace.operationCounter += 1;
                Core.$apply($scope);
            });
        };
        $scope.anySelectionHasState = function (state) {
            var selected = $scope.selectedItems || [];
            return selected.length && selected.any(function (s) { return Camel.isState(s, state); });
        };
        $scope.everySelectionHasState = function (state) {
            var selected = $scope.selectedItems || [];
            return selected.length && selected.every(function (s) { return Camel.isState(s, state); });
        };
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.BreadcrumbBarController", ["$scope", "$routeParams", "workspace", "jolokia", function ($scope, $routeParams, workspace, jolokia) {
        $scope.workspace = workspace;
        if ($routeParams != null) {
            $scope.contextId = $routeParams["contextId"];
            $scope.endpointPath = $routeParams["endpointPath"];
            $scope.endpointName = tidyJmxName($scope.endpointPath);
            $scope.routeId = $routeParams["routeId"];
        }
        $scope.treeViewLink = linkToTreeView();
        var defaultChildEntity = $scope.endpointPath ? "endpoints" : "routes";
        var childEntityToolTips = {
            "endpoints": "Camel Endpoint",
            "routes": "Camel Route"
        };
        $scope.breadcrumbs = [
            {
                name: $scope.contextId,
                items: findContexts(),
                tooltip: "Camel Context"
            },
            {
                name: defaultChildEntity,
                items: findChildEntityTypes($scope.contextId),
                tooltip: "Entity inside a Camel Context"
            },
            {
                name: $scope.endpointName || tidyJmxName($scope.routeId),
                items: findChildEntityLinks($scope.contextId, currentChildEntity()),
                tooltip: childEntityToolTips[defaultChildEntity]
            }
        ];
        function findContexts() {
            var answer = [];
            var rootFolder = Camel.getRootCamelFolder(workspace);
            if (rootFolder) {
                angular.forEach(rootFolder.children, function (contextFolder) {
                    var id = contextFolder.title;
                    if (id && id !== $scope.contextId) {
                        var name = id;
                        var link = createLinkToFirstChildEntity(id, currentChildEntity());
                        answer.push({
                            name: name,
                            tooltip: "Camel Context",
                            link: link
                        });
                    }
                });
            }
            return answer;
        }
        function findChildEntityTypes(contextId) {
            var answer = [];
            angular.forEach(["endpoints", "routes"], function (childEntityName) {
                if (childEntityName && childEntityName !== currentChildEntity()) {
                    var link = createLinkToFirstChildEntity(contextId, childEntityName);
                    answer.push({
                        name: childEntityName,
                        tooltip: "Entity inside a Camel Context",
                        link: link
                    });
                }
            });
            return answer;
        }
        function currentChildEntity() {
            var answer = Core.pathGet($scope, ["breadcrumbs", "childEntity"]);
            return answer || defaultChildEntity;
        }
        function createLinkToFirstChildEntity(id, childEntityValue) {
            var links = findChildEntityLinks(id, childEntityValue);
            var link = links.length > 0 ? links[0].link : Camel.linkToBrowseEndpointFullScreen(id, "noEndpoints");
            return link;
        }
        function findChildEntityLinks(contextId, childEntityValue) {
            if ("endpoints" === childEntityValue) {
                return findEndpoints(contextId);
            }
            else {
                return findRoutes(contextId);
            }
        }
        function findEndpoints(contextId) {
            var answer = [];
            var contextFolder = Camel.getCamelContextFolder(workspace, contextId);
            if (contextFolder) {
                var endpoints = (contextFolder["children"] || []).find(function (n) { return "endpoints" === n.title; });
                if (endpoints) {
                    angular.forEach(endpoints.children, function (endpointFolder) {
                        var entries = endpointFolder ? endpointFolder.entries : null;
                        if (entries) {
                            var endpointPath = entries["name"];
                            if (endpointPath) {
                                var name = tidyJmxName(endpointPath);
                                var link = Camel.linkToBrowseEndpointFullScreen(contextId, endpointPath);
                                answer.push({
                                    contextId: contextId,
                                    path: endpointPath,
                                    name: name,
                                    tooltip: "Endpoint",
                                    link: link
                                });
                            }
                        }
                    });
                }
            }
            return answer;
        }
        function findRoutes(contextId) {
            var answer = [];
            var contextFolder = Camel.getCamelContextFolder(workspace, contextId);
            if (contextFolder) {
                var folders = (contextFolder["children"] || []).find(function (n) { return "routes" === n.title; });
                if (folders) {
                    angular.forEach(folders.children, function (folder) {
                        var entries = folder ? folder.entries : null;
                        if (entries) {
                            var routeId = entries["name"];
                            if (routeId) {
                                var name = tidyJmxName(routeId);
                                var link = Camel.linkToRouteDiagramFullScreen(contextId, routeId);
                                answer.push({
                                    contextId: contextId,
                                    path: routeId,
                                    name: name,
                                    tooltip: "Camel Route",
                                    link: link
                                });
                            }
                        }
                    });
                }
            }
            return answer;
        }
        function linkToTreeView() {
            var answer = null;
            if ($scope.contextId) {
                var node = null;
                var tab = null;
                if ($scope.endpointPath) {
                    tab = "browseEndpoint";
                    node = workspace.findMBeanWithProperties(Camel.jmxDomain, {
                        context: $scope.contextId,
                        type: "endpoints",
                        name: $scope.endpointPath
                    });
                }
                else if ($scope.routeId) {
                    tab = "routes";
                    node = workspace.findMBeanWithProperties(Camel.jmxDomain, {
                        context: $scope.contextId,
                        type: "routes",
                        name: $scope.routeId
                    });
                }
                var key = node ? node["key"] : null;
                if (key && tab) {
                    answer = "#/camel/" + tab + "?tab=camel&nid=" + key;
                }
            }
            return answer;
        }
        function tidyJmxName(jmxName) {
            return jmxName ? Core.trimQuotes(jmxName) : jmxName;
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel.BrowseEndpointController = Camel._module.controller("Camel.BrowseEndpointController", ["$scope", "$routeParams", "workspace", "jolokia", function ($scope, $routeParams, workspace, jolokia) {
        $scope.workspace = workspace;
        $scope.forwardDialog = new UI.Dialog();
        $scope.showMessageDetails = false;
        $scope.mode = 'text';
        $scope.gridOptions = Camel.createBrowseGridOptions();
        $scope.contextId = $routeParams["contextId"];
        $scope.endpointPath = $routeParams["endpointPath"];
        $scope.isJmxTab = !$routeParams["contextId"] || !$routeParams["endpointPath"];
        $scope.$watch('workspace.selection', function () {
            if ($scope.isJmxTab && workspace.moveIfViewInvalid())
                return;
            loadData();
        });
        $scope.openMessageDialog = function (message) {
            ActiveMQ.selectCurrentMessage(message, "id", $scope);
            if ($scope.row) {
                $scope.mode = CodeEditor.detectTextFormat($scope.row.body);
                $scope.showMessageDetails = true;
            }
        };
        ActiveMQ.decorate($scope);
        $scope.forwardMessagesAndCloseForwardDialog = function () {
            var mbean = Camel.getSelectionCamelContextMBean(workspace);
            var selectedItems = $scope.gridOptions.selectedItems;
            var uri = $scope.endpointUri;
            if (mbean && uri && selectedItems && selectedItems.length) {
                jolokia.execute(mbean, "createEndpoint(java.lang.String)", uri, onSuccess(intermediateResult));
                $scope.message = "Forwarded " + Core.maybePlural(selectedItems.length, "message" + " to " + uri);
                angular.forEach(selectedItems, function (item, idx) {
                    var callback = (idx + 1 < selectedItems.length) ? intermediateResult : operationSuccess;
                    var body = item.body;
                    var headers = item.headers;
                    jolokia.execute(mbean, "sendBodyAndHeaders(java.lang.String, java.lang.Object, java.util.Map)", uri, body, headers, onSuccess(callback));
                });
            }
            $scope.forwardDialog.close();
        };
        $scope.endpointUris = function () {
            var endpointFolder = Camel.getSelectionCamelContextEndpoints(workspace);
            return (endpointFolder) ? endpointFolder.children.map(function (n) { return n.title; }) : [];
        };
        $scope.refresh = loadData;
        function intermediateResult() {
        }
        function operationSuccess() {
            if ($scope.messageDialog) {
                $scope.messageDialog.close();
            }
            $scope.gridOptions.selectedItems.splice(0);
            Core.notification("success", $scope.message);
            setTimeout(loadData, 50);
        }
        function loadData() {
            var mbean = null;
            if ($scope.contextId && $scope.endpointPath) {
                var node = workspace.findMBeanWithProperties(Camel.jmxDomain, {
                    context: $scope.contextId,
                    type: "endpoints",
                    name: $scope.endpointPath
                });
                if (node) {
                    mbean = node.objectName;
                }
            }
            if (!mbean) {
                mbean = workspace.getSelectedMBeanName();
            }
            if (mbean) {
                Camel.log.info("MBean: " + mbean);
                var options = onSuccess(populateTable);
                jolokia.execute(mbean, 'browseAllMessagesAsXml(java.lang.Boolean)', true, options);
            }
        }
        function populateTable(response) {
            var data = [];
            if (angular.isString(response)) {
                var doc = $.parseXML(response);
                var allMessages = $(doc).find("message");
                allMessages.each(function (idx, message) {
                    var messageData = Camel.createMessageFromXml(message);
                    data.push(messageData);
                });
            }
            $scope.messages = data;
            Core.$apply($scope);
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel.camelHeaderSchema = {
        definitions: {
            headers: {
                properties: {
                    "CamelAuthentication": {
                        type: "java.lang.String"
                    },
                    "CamelAuthenticationFailurePolicyId": {
                        type: "java.lang.String"
                    },
                    "CamelAcceptContentType": {
                        type: "java.lang.String"
                    },
                    "CamelAggregatedSize": {
                        type: "java.lang.String"
                    },
                    "CamelAggregatedTimeout": {
                        type: "java.lang.String"
                    },
                    "CamelAggregatedCompletedBy": {
                        type: "java.lang.String"
                    },
                    "CamelAggregatedCorrelationKey": {
                        type: "java.lang.String"
                    },
                    "CamelAggregationStrategy": {
                        type: "java.lang.String"
                    },
                    "CamelAggregationCompleteAllGroups": {
                        type: "java.lang.String"
                    },
                    "CamelAggregationCompleteAllGroupsInclusive": {
                        type: "java.lang.String"
                    },
                    "CamelAsyncWait": {
                        type: "java.lang.String"
                    },
                    "CamelBatchIndex": {
                        type: "java.lang.String"
                    },
                    "CamelBatchSize": {
                        type: "java.lang.String"
                    },
                    "CamelBatchComplete": {
                        type: "java.lang.String"
                    },
                    "CamelBeanMethodName": {
                        type: "java.lang.String"
                    },
                    "CamelBeanMultiParameterArray": {
                        type: "java.lang.String"
                    },
                    "CamelBinding": {
                        type: "java.lang.String"
                    },
                    "breadcrumbId": {
                        type: "java.lang.String"
                    },
                    "CamelCharsetName": {
                        type: "java.lang.String"
                    },
                    "CamelCreatedTimestamp": {
                        type: "java.lang.String"
                    },
                    "Content-Encoding": {
                        type: "java.lang.String"
                    },
                    "Content-Length": {
                        type: "java.lang.String"
                    },
                    "Content-Type": {
                        type: "java.lang.String"
                    },
                    "CamelCorrelationId": {
                        type: "java.lang.String"
                    },
                    "CamelDataSetIndex": {
                        type: "java.lang.String"
                    },
                    "org.apache.camel.default.charset": {
                        type: "java.lang.String"
                    },
                    "CamelDestinationOverrideUrl": {
                        type: "java.lang.String"
                    },
                    "CamelDisableHttpStreamCache": {
                        type: "java.lang.String"
                    },
                    "CamelDuplicateMessage": {
                        type: "java.lang.String"
                    },
                    "CamelExceptionCaught": {
                        type: "java.lang.String"
                    },
                    "CamelExceptionHandled": {
                        type: "java.lang.String"
                    },
                    "CamelEvaluateExpressionResult": {
                        type: "java.lang.String"
                    },
                    "CamelErrorHandlerHandled": {
                        type: "java.lang.String"
                    },
                    "CamelExternalRedelivered": {
                        type: "java.lang.String"
                    },
                    "CamelFailureHandled": {
                        type: "java.lang.String"
                    },
                    "CamelFailureEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelFailureRouteId": {
                        type: "java.lang.String"
                    },
                    "CamelFilterNonXmlChars": {
                        type: "java.lang.String"
                    },
                    "CamelFileLocalWorkPath": {
                        type: "java.lang.String"
                    },
                    "CamelFileName": {
                        type: "java.lang.String"
                    },
                    "CamelFileNameOnly": {
                        type: "java.lang.String"
                    },
                    "CamelFileNameProduced": {
                        type: "java.lang.String"
                    },
                    "CamelFileNameConsumed": {
                        type: "java.lang.String"
                    },
                    "CamelFilePath": {
                        type: "java.lang.String"
                    },
                    "CamelFileParent": {
                        type: "java.lang.String"
                    },
                    "CamelFileLastModified": {
                        type: "java.lang.String"
                    },
                    "CamelFileLength": {
                        type: "java.lang.String"
                    },
                    "CamelFilterMatched": {
                        type: "java.lang.String"
                    },
                    "CamelFileLockFileAcquired": {
                        type: "java.lang.String"
                    },
                    "CamelFileLockFileName": {
                        type: "java.lang.String"
                    },
                    "CamelGroupedExchange": {
                        type: "java.lang.String"
                    },
                    "CamelHttpBaseUri": {
                        type: "java.lang.String"
                    },
                    "CamelHttpCharacterEncoding": {
                        type: "java.lang.String"
                    },
                    "CamelHttpMethod": {
                        type: "java.lang.String"
                    },
                    "CamelHttpPath": {
                        type: "java.lang.String"
                    },
                    "CamelHttpProtocolVersion": {
                        type: "java.lang.String"
                    },
                    "CamelHttpQuery": {
                        type: "java.lang.String"
                    },
                    "CamelHttpResponseCode": {
                        type: "java.lang.String"
                    },
                    "CamelHttpUri": {
                        type: "java.lang.String"
                    },
                    "CamelHttpUrl": {
                        type: "java.lang.String"
                    },
                    "CamelHttpChunked": {
                        type: "java.lang.String"
                    },
                    "CamelHttpServletRequest": {
                        type: "java.lang.String"
                    },
                    "CamelHttpServletResponse": {
                        type: "java.lang.String"
                    },
                    "CamelInterceptedEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelInterceptSendToEndpointWhenMatched": {
                        type: "java.lang.String"
                    },
                    "CamelLanguageScript": {
                        type: "java.lang.String"
                    },
                    "CamelLogDebugBodyMaxChars": {
                        type: "java.lang.String"
                    },
                    "CamelLogDebugStreams": {
                        type: "java.lang.String"
                    },
                    "CamelLoopIndex": {
                        type: "java.lang.String"
                    },
                    "CamelLoopSize": {
                        type: "java.lang.String"
                    },
                    "CamelMaximumCachePoolSize": {
                        type: "java.lang.String"
                    },
                    "CamelMaximumEndpointCacheSize": {
                        type: "java.lang.String"
                    },
                    "CamelMessageHistory": {
                        type: "java.lang.String"
                    },
                    "CamelMulticastIndex": {
                        type: "java.lang.String"
                    },
                    "CamelMulticastComplete": {
                        type: "java.lang.String"
                    },
                    "CamelNotifyEvent": {
                        type: "java.lang.String"
                    },
                    "CamelOnCompletion": {
                        type: "java.lang.String"
                    },
                    "CamelOverruleFileName": {
                        type: "java.lang.String"
                    },
                    "CamelParentUnitOfWork": {
                        type: "java.lang.String"
                    },
                    "CamelRecipientListEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelReceivedTimestamp": {
                        type: "java.lang.String"
                    },
                    "CamelRedelivered": {
                        type: "java.lang.String"
                    },
                    "CamelRedeliveryCounter": {
                        type: "java.lang.String"
                    },
                    "CamelRedeliveryMaxCounter": {
                        type: "java.lang.String"
                    },
                    "CamelRedeliveryExhausted": {
                        type: "java.lang.String"
                    },
                    "CamelRedeliveryDelay": {
                        type: "java.lang.String"
                    },
                    "CamelRollbackOnly": {
                        type: "java.lang.String"
                    },
                    "CamelRollbackOnlyLast": {
                        type: "java.lang.String"
                    },
                    "CamelRouteStop": {
                        type: "java.lang.String"
                    },
                    "CamelSoapAction": {
                        type: "java.lang.String"
                    },
                    "CamelSkipGzipEncoding": {
                        type: "java.lang.String"
                    },
                    "CamelSlipEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelSplitIndex": {
                        type: "java.lang.String"
                    },
                    "CamelSplitComplete": {
                        type: "java.lang.String"
                    },
                    "CamelSplitSize": {
                        type: "java.lang.String"
                    },
                    "CamelTimerCounter": {
                        type: "java.lang.String"
                    },
                    "CamelTimerFiredTime": {
                        type: "java.lang.String"
                    },
                    "CamelTimerName": {
                        type: "java.lang.String"
                    },
                    "CamelTimerPeriod": {
                        type: "java.lang.String"
                    },
                    "CamelTimerTime": {
                        type: "java.lang.String"
                    },
                    "CamelToEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelTraceEvent": {
                        type: "java.lang.String"
                    },
                    "CamelTraceEventNodeId": {
                        type: "java.lang.String"
                    },
                    "CamelTraceEventTimestamp": {
                        type: "java.lang.String"
                    },
                    "CamelTraceEventExchange": {
                        type: "java.lang.String"
                    },
                    "Transfer-Encoding": {
                        type: "java.lang.String"
                    },
                    "CamelUnitOfWorkExhausted": {
                        type: "java.lang.String"
                    },
                    "CamelUnitOfWorkProcessSync": {
                        type: "java.lang.String"
                    },
                    "CamelXsltFileName": {
                        type: "java.lang.String"
                    }
                }
            }
        }
    };
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.DebugRouteController", ["$scope", "$element", "workspace", "jolokia", "localStorage", function ($scope, $element, workspace, jolokia, localStorage) {
        $scope.ignoreRouteXmlNode = true;
        $scope.startDebugging = function () {
            setDebugging(true);
        };
        $scope.stopDebugging = function () {
            setDebugging(false);
        };
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(reloadData, 50);
        });
        $scope.$on("camel.diagram.selectedNodeId", function (event, value) {
            $scope.selectedDiagramNodeId = value;
            updateBreakpointFlag();
        });
        $scope.$on("camel.diagram.layoutComplete", function (event, value) {
            updateBreakpointIcons();
            $($element).find("g.node").dblclick(function (n) {
                var id = this.getAttribute("data-cid");
                $scope.toggleBreakpoint(id);
            });
        });
        $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid())
                return;
            reloadData();
        });
        $scope.toggleBreakpoint = function (id) {
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            if (mbean && id) {
                var method = isBreakpointSet(id) ? "removeBreakpoint" : "addBreakpoint";
                jolokia.execute(mbean, method, id, onSuccess(breakpointsChanged));
            }
        };
        $scope.addBreakpoint = function () {
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            if (mbean && $scope.selectedDiagramNodeId) {
                jolokia.execute(mbean, "addBreakpoint", $scope.selectedDiagramNodeId, onSuccess(breakpointsChanged));
            }
        };
        $scope.removeBreakpoint = function () {
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            if (mbean && $scope.selectedDiagramNodeId) {
                jolokia.execute(mbean, "removeBreakpoint", $scope.selectedDiagramNodeId, onSuccess(breakpointsChanged));
            }
        };
        $scope.resume = function () {
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            if (mbean) {
                jolokia.execute(mbean, "resumeAll", onSuccess(clearStoppedAndResume));
            }
        };
        $scope.suspend = function () {
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            if (mbean) {
                jolokia.execute(mbean, "suspendAll", onSuccess(clearStoppedAndResume));
            }
        };
        $scope.step = function () {
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            var stepNode = getStoppedBreakpointId();
            if (mbean && stepNode) {
                jolokia.execute(mbean, "stepBreakpoint(java.lang.String)", stepNode, onSuccess(clearStoppedAndResume));
            }
        };
        $scope.messages = [];
        $scope.mode = 'text';
        $scope.messageDialog = new UI.Dialog();
        $scope.gridOptions = Camel.createBrowseGridOptions();
        $scope.gridOptions.selectWithCheckboxOnly = false;
        $scope.gridOptions.showSelectionCheckbox = false;
        $scope.gridOptions.multiSelect = false;
        $scope.gridOptions.afterSelectionChange = onSelectionChanged;
        $scope.gridOptions.columnDefs.push({
            field: 'toNode',
            displayName: 'To Node'
        });
        $scope.openMessageDialog = function (message) {
            var idx = Core.pathGet(message, ["rowIndex"]);
            $scope.selectRowIndex(idx);
            if ($scope.row) {
                var body = $scope.row.body;
                $scope.mode = angular.isString(body) ? CodeEditor.detectTextFormat(body) : "text";
                $scope.messageDialog.open();
            }
        };
        $scope.selectRowIndex = function (idx) {
            $scope.rowIndex = idx;
            var selected = $scope.gridOptions.selectedItems;
            selected.splice(0, selected.length);
            if (idx >= 0 && idx < $scope.messages.length) {
                $scope.row = $scope.messages[idx];
                if ($scope.row) {
                    selected.push($scope.row);
                }
            }
            else {
                $scope.row = null;
            }
            onSelectionChanged();
        };
        function onSelectionChanged() {
            var toNode = getStoppedBreakpointId();
            if (toNode) {
                var nodes = getDiagramNodes();
                Camel.highlightSelectedNode(nodes, toNode);
            }
        }
        function reloadData() {
            $scope.debugging = false;
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            if (mbean) {
                $scope.debugging = jolokia.getAttribute(mbean, "Enabled", onSuccess(null));
                if ($scope.debugging) {
                    jolokia.execute(mbean, "getBreakpoints", onSuccess(onBreakpoints));
                    $scope.graphView = "app/camel/html/routes.html";
                    $scope.tableView = "app/camel/html/browseMessages.html";
                    Core.register(jolokia, $scope, {
                        type: 'exec',
                        mbean: mbean,
                        operation: 'getDebugCounter'
                    }, onSuccess(onBreakpointCounter));
                }
                else {
                    $scope.graphView = null;
                    $scope.tableView = null;
                }
            }
        }
        function onBreakpointCounter(response) {
            var counter = response.value;
            if (counter && counter !== $scope.breakpointCounter) {
                $scope.breakpointCounter = counter;
                loadCurrentStack();
            }
        }
        function loadCurrentStack() {
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            if (mbean) {
                console.log("getting suspended breakpoints!");
                jolokia.execute(mbean, "getSuspendedBreakpointNodeIds", onSuccess(onSuspendedBreakpointNodeIds));
            }
        }
        function onSuspendedBreakpointNodeIds(response) {
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            $scope.suspendedBreakpoints = response;
            $scope.stopped = response && response.length;
            var stopNodeId = getStoppedBreakpointId();
            if (mbean && stopNodeId) {
                jolokia.execute(mbean, 'dumpTracedMessagesAsXml', stopNodeId, onSuccess(onMessages));
                $scope.selectedDiagramNodeId = stopNodeId;
            }
            updateBreakpointIcons();
            Core.$apply($scope);
        }
        function onMessages(response) {
            console.log("onMessage! ");
            $scope.messages = [];
            if (response) {
                var xml = response;
                if (angular.isString(xml)) {
                    var doc = $.parseXML(xml);
                    var allMessages = $(doc).find("fabricTracerEventMessage");
                    if (!allMessages || !allMessages.length) {
                        allMessages = $(doc).find("backlogTracerEventMessage");
                    }
                    allMessages.each(function (idx, message) {
                        var messageData = Camel.createMessageFromXml(message);
                        var toNode = $(message).find("toNode").text();
                        if (toNode) {
                            messageData["toNode"] = toNode;
                        }
                        $scope.messages.push(messageData);
                    });
                }
            }
            else {
                console.log("WARNING: dumpTracedMessagesAsXml() returned no results!");
            }
            updateMessageSelection();
            console.log("has messages " + $scope.messages.length + " selected row " + $scope.row + " index " + $scope.rowIndex);
            Core.$apply($scope);
            updateBreakpointIcons();
        }
        function updateMessageSelection() {
            $scope.selectRowIndex($scope.rowIndex);
            if (!$scope.row && $scope.messageDialog.show) {
                $scope.row = {
                    headers: {},
                    body: ""
                };
            }
        }
        function clearStoppedAndResume() {
            $scope.messages = [];
            $scope.suspendedBreakpoints = [];
            $scope.stopped = false;
            updateMessageSelection();
            Core.$apply($scope);
            updateBreakpointIcons();
        }
        function getStoppedBreakpointId() {
            var stepNode = null;
            var stepNodes = $scope.suspendedBreakpoints;
            if (stepNodes && stepNodes.length) {
                stepNode = stepNodes[0];
                if (stepNodes.length > 1 && isSuspendedAt($scope.selectedDiagramNodeId)) {
                    stepNode = $scope.selectedDiagramNodeId;
                }
            }
            return stepNode;
        }
        function isSuspendedAt(nodeId) {
            return containsNodeId($scope.suspendedBreakpoints, nodeId);
        }
        function onBreakpoints(response) {
            $scope.breakpoints = response;
            updateBreakpointFlag();
            var nodes = getDiagramNodes();
            if (nodes.length) {
                updateBreakpointIcons(nodes);
            }
            Core.$apply($scope);
        }
        function isBreakpointSet(nodeId) {
            return containsNodeId($scope.breakpoints, nodeId);
        }
        function updateBreakpointFlag() {
            $scope.hasBreakpoint = isBreakpointSet($scope.selectedDiagramNodeId);
        }
        function containsNodeId(breakpoints, nodeId) {
            return nodeId && breakpoints && breakpoints.some(nodeId);
        }
        function getDiagramNodes() {
            var svg = d3.select("svg");
            return svg.selectAll("g .node");
        }
        var breakpointImage = Core.url("/app/camel/doc/img/debug/breakpoint.gif");
        var suspendedBreakpointImage = Core.url("/app/camel/doc/img/debug/breakpoint-suspended.gif");
        function updateBreakpointIcons(nodes) {
            if (nodes === void 0) { nodes = getDiagramNodes(); }
            nodes.each(function (object) {
                var nodeId = object.cid;
                var thisNode = d3.select(this);
                var icons = thisNode.selectAll("image.breakpoint");
                var isSuspended = isSuspendedAt(nodeId);
                var isBreakpoint = isBreakpointSet(nodeId);
                if (isBreakpoint || isSuspended) {
                    var imageUrl = isSuspended ? suspendedBreakpointImage : breakpointImage;
                    if (!icons.length || !icons[0].length) {
                        thisNode.append("image").attr("xlink:href", function (d) {
                            return imageUrl;
                        }).attr("class", "breakpoint").attr("x", -12).attr("y", -20).attr("height", 24).attr("width", 24);
                    }
                    else {
                        icons.attr("xlink:href", function (d) {
                            return imageUrl;
                        });
                    }
                }
                else {
                    icons.remove();
                }
            });
        }
        function breakpointsChanged(response) {
            reloadData();
            Core.$apply($scope);
        }
        function setDebugging(flag) {
            var mbean = Camel.getSelectionCamelDebugMBean(workspace);
            if (mbean) {
                var method = flag ? "enableDebugger" : "disableDebugger";
                var max = Camel.maximumTraceOrDebugBodyLength(localStorage);
                var streams = Camel.traceOrDebugIncludeStreams(localStorage);
                jolokia.setAttribute(mbean, "BodyMaxChars", max);
                jolokia.setAttribute(mbean, "BodyIncludeStreams", streams);
                jolokia.setAttribute(mbean, "BodyIncludeFiles", streams);
                jolokia.execute(mbean, method, onSuccess(breakpointsChanged));
            }
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.EndpointController", ["$scope", "$location", "localStorage", "workspace", "jolokia", function ($scope, $location, localStorage, workspace, jolokia) {
        Camel.initEndpointChooserScope($scope, $location, localStorage, workspace, jolokia);
        $scope.workspace = workspace;
        $scope.message = "";
        $scope.createEndpoint = function (name) {
            var jolokia = workspace.jolokia;
            if (jolokia) {
                var mbean = Camel.getSelectionCamelContextMBean(workspace);
                if (mbean) {
                    $scope.message = "Creating endpoint " + name;
                    var operation = "createEndpoint(java.lang.String)";
                    jolokia.execute(mbean, operation, name, onSuccess(operationSuccess));
                }
                else {
                    Core.notification("error", "Could not find the CamelContext MBean!");
                }
            }
        };
        $scope.createEndpointFromData = function () {
            if ($scope.selectedComponentName && $scope.endpointPath) {
                var name = $scope.selectedComponentName + "://" + $scope.endpointPath;
                console.log("Have endpoint data " + JSON.stringify($scope.endpointParameters));
                var params = "";
                angular.forEach($scope.endpointParameters, function (value, key) {
                    var prefix = params ? "&" : "";
                    params += prefix + key + "=" + value;
                });
                if (params) {
                    name += "?" + params;
                }
                $scope.createEndpoint(name);
            }
        };
        $scope.deleteEndpoint = function () {
            var jolokia = workspace.jolokia;
            var selection = workspace.selection;
            var entries = selection.entries;
            if (selection && jolokia && entries) {
                var domain = selection.domain;
                var brokerName = entries["BrokerName"];
                var name = entries["Destination"];
                var isQueue = "Topic" !== entries["Type"];
                if (domain && brokerName) {
                    var mbean = "" + domain + ":BrokerName=" + brokerName + ",Type=Broker";
                    $scope.message = "Deleting " + (isQueue ? "queue" : "topic") + " " + name;
                    var operation = "removeEndpoint(java.lang.String)";
                    jolokia.execute(mbean, operation, name, onSuccess(deleteSuccess));
                }
            }
        };
        function operationSuccess() {
            $scope.endpointName = "";
            $scope.workspace.operationCounter += 1;
            Core.$apply($scope);
            Core.notification("success", $scope.message);
        }
        function deleteSuccess() {
            if (workspace.selection) {
                var parent = Core.pathGet(workspace, ["selection", "parent"]);
                if (parent) {
                    $scope.workspace.updateSelectionNode(parent);
                }
            }
            $scope.workspace.operationCounter += 1;
            Core.$apply($scope);
            Core.notification("success", $scope.message);
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel.endpointCategories = {
        bigdata: {
            label: "Big Data",
            endpoints: ["hdfs", "hbase", "lucene", "solr"],
            endpointIcon: "/img/icons/camel/endpointRepository24.png"
        },
        database: {
            label: "Database",
            endpoints: ["couchdb", "elasticsearch", "hbase", "jdbc", "jpa", "hibernate", "mongodb", "mybatis", "sql"],
            endpointIcon: "/img/icons/camel/endpointRepository24.png"
        },
        cloud: {
            label: "Cloud",
            endpoints: [
                "aws-cw",
                "aws-ddb",
                "aws-sdb",
                "aws-ses",
                "aws-sns",
                "aws-sqs",
                "aws-s3",
                "gauth",
                "ghhtp",
                "glogin",
                "gtask",
                "jclouds"
            ]
        },
        core: {
            label: "Core",
            endpoints: ["bean", "direct", "seda"]
        },
        messaging: {
            label: "Messaging",
            endpoints: ["jms", "activemq", "amqp", "cometd", "cometds", "mqtt", "netty", "vertx", "websocket"],
            endpointIcon: "/img/icons/camel/endpointQueue24.png"
        },
        mobile: {
            label: "Mobile",
            endpoints: ["apns"]
        },
        sass: {
            label: "SaaS",
            endpoints: ["salesforce", "sap-netweaver"]
        },
        social: {
            label: "Social",
            endpoints: ["atom", "facebook", "irc", "ircs", "rss", "smpp", "twitter", "weather"]
        },
        storage: {
            label: "Storage",
            endpointIcon: "/img/icons/camel/endpointFolder24.png",
            endpoints: ["file", "ftp", "sftp", "scp", "jsch"]
        },
        template: {
            label: "Templating",
            endpoints: ["freemarker", "velocity", "xquery", "xslt", "scalate", "string-template"]
        }
    };
    Camel.endpointToCategory = {};
    Camel.endpointIcon = "/img/icons/camel/endpoint24.png";
    Camel.endpointConfigurations = {
        drools: {
            icon: "/img/icons/camel/endpointQueue24.png"
        },
        quartz: {
            icon: "/img/icons/camel/endpointTimer24.png"
        },
        facebook: {
            icon: "/img/icons/camel/endpoints/facebook24.jpg"
        },
        salesforce: {
            icon: "/img/icons/camel/endpoints/salesForce24.png"
        },
        sap: {
            icon: "/img/icons/camel/endpoints/SAPe24.png"
        },
        "sap-netweaver": {
            icon: "/img/icons/camel/endpoints/SAPNetweaver24.jpg"
        },
        timer: {
            icon: "/img/icons/camel/endpointTimer24.png"
        },
        twitter: {
            icon: "/img/icons/camel/endpoints/twitter24.png"
        },
        weather: {
            icon: "/img/icons/camel/endpoints/weather24.jpg"
        }
    };
    Camel.endpointForms = {
        file: {
            tabs: {
                'Options': ['*']
            }
        },
        activemq: {
            tabs: {
                'Connection': ['clientId', 'transacted', 'transactedInOut', 'transactionName', 'transactionTimeout'],
                'Producer': ['timeToLive', 'priority', 'allowNullBody', 'pubSubNoLocal', 'preserveMessageQos'],
                'Consumer': ['concurrentConsumers', 'acknowledgementModeName', 'selector', 'receiveTimeout'],
                'Reply': ['replyToDestination', 'replyToDeliveryPersistent', 'replyToCacheLevelName', 'replyToDestinationSelectorName'],
                'Options': ['*']
            }
        }
    };
    Camel.endpointForms["jms"] = Camel.endpointForms.activemq;
    angular.forEach(Camel.endpointCategories, function (category, catKey) {
        category.id = catKey;
        angular.forEach(category.endpoints, function (endpoint) {
            Camel.endpointToCategory[endpoint] = category;
        });
    });
    var camelModelTabExtensions = {
        route: {
            'Overview': ['id', 'description'],
            'Advanced': ['*']
        }
    };
    function getEndpointIcon(endpointName) {
        var value = Camel.getEndpointConfig(endpointName, null);
        var answer = Core.pathGet(value, ["icon"]);
        if (!answer) {
            var category = getEndpointCategory(endpointName);
            answer = Core.pathGet(category, ["endpointIcon"]);
        }
        return answer || Camel.endpointIcon;
    }
    Camel.getEndpointIcon = getEndpointIcon;
    function getEndpointConfig(endpointName, category) {
        var answer = Camel.endpointConfigurations[endpointName];
        if (!answer) {
            answer = {};
            Camel.endpointConfigurations[endpointName] = answer;
        }
        if (!answer.label) {
            answer.label = endpointName;
        }
        if (!answer.icon) {
            answer.icon = Core.pathGet(category, ["endpointIcon"]) || Camel.endpointIcon;
        }
        if (!answer.category) {
            answer.category = category;
        }
        return answer;
    }
    Camel.getEndpointConfig = getEndpointConfig;
    function getEndpointCategory(endpointName) {
        return Camel.endpointToCategory[endpointName] || Camel.endpointCategories.core;
    }
    Camel.getEndpointCategory = getEndpointCategory;
    function getConfiguredCamelModel() {
        var schema = _apacheCamelModel;
        var definitions = schema["definitions"];
        if (definitions) {
            angular.forEach(camelModelTabExtensions, function (tabs, name) {
                var model = definitions[name];
                if (model) {
                    if (!model["tabs"]) {
                        model["tabs"] = tabs;
                    }
                }
            });
        }
        return schema;
    }
    Camel.getConfiguredCamelModel = getConfiguredCamelModel;
    function initEndpointChooserScope($scope, $location, localStorage, workspace, jolokia) {
        $scope.selectedComponentName = null;
        $scope.endpointParameters = {};
        $scope.endpointPath = "";
        $scope.schema = {
            definitions: {}
        };
        $scope.jolokia = jolokia;
        var versionId = $scope.branch;
        var profileId = Fabric.pagePathToProfileId($scope.pageId);
        if (profileId && versionId) {
            Fabric.profileJolokia(jolokia, profileId, versionId, function (profileJolokia) {
                if (!profileJolokia) {
                    Camel.log.info("No container is running for profile " + profileId + " and version " + versionId + " so using current container for endpoint completion");
                    profileJolokia = jolokia;
                }
                $scope.jolokia = profileJolokia;
                $scope.profileWorkspace = null;
                $scope.loadEndpointNames();
            });
        }
        var silentOptions = { silent: true };
        $scope.$watch('workspace.selection', function () {
            $scope.loadEndpointNames();
        });
        $scope.$watch('selectedComponentName', function () {
            if ($scope.selectedComponentName !== $scope.loadedComponentName) {
                $scope.endpointParameters = {};
                $scope.loadEndpointSchema($scope.selectedComponentName);
                $scope.loadedComponentName = $scope.selectedComponentName;
            }
        });
        $scope.endpointCompletions = function (completionText) {
            var answer = null;
            var mbean = findCamelContextMBean();
            var componentName = $scope.selectedComponentName;
            var endpointParameters = {};
            if (mbean && componentName && completionText) {
                answer = $scope.jolokia.execute(mbean, 'completeEndpointPath', componentName, endpointParameters, completionText, onSuccess(null, silentOptions));
            }
            return answer || [];
        };
        $scope.loadEndpointNames = function () {
            $scope.componentNames = null;
            var mbean = findCamelContextMBean();
            if (mbean) {
                $scope.jolokia.execute(mbean, 'findComponentNames', onSuccess(onComponents, { silent: true }));
            }
            else {
                console.log("WARNING: No camel context mbean so cannot load component names");
            }
        };
        $scope.loadEndpointSchema = function (componentName) {
            var mbean = findCamelContextMBean();
            if (mbean && componentName && componentName !== $scope.loadedEndpointSchema) {
                $scope.selectedComponentName = componentName;
                $scope.jolokia.execute(mbean, 'componentParameterJsonSchema', componentName, onSuccess(onEndpointSchema, silentOptions));
            }
        };
        function onComponents(response) {
            $scope.componentNames = response;
            Camel.log.info("onComponents: " + response);
            $scope.hasComponentNames = $scope.componentNames ? true : false;
            Core.$apply($scope);
        }
        function onEndpointSchema(response) {
            if (response) {
                try {
                    var json = JSON.parse(response);
                    var endpointName = $scope.selectedComponentName;
                    configureEndpointSchema(endpointName, json);
                    $scope.endpointSchema = json;
                    $scope.schema.definitions[endpointName] = json;
                    $scope.loadedEndpointSchema = endpointName;
                    Core.$apply($scope);
                }
                catch (e) {
                    console.log("Failed to parse JSON " + e);
                    console.log("JSON: " + response);
                }
            }
        }
        function configureEndpointSchema(endpointName, json) {
            console.log("======== configuring schema for " + endpointName);
            var config = Camel.endpointForms[endpointName];
            if (config && json) {
                if (config.tabs) {
                    json.tabs = config.tabs;
                }
            }
        }
        function findCamelContextMBean() {
            var profileWorkspace = $scope.profileWorkspace;
            if (!profileWorkspace) {
                var removeJolokia = $scope.jolokia;
                if (removeJolokia) {
                    profileWorkspace = Core.createRemoteWorkspace(removeJolokia, $location, localStorage);
                    $scope.profileWorkspace = profileWorkspace;
                }
            }
            if (!profileWorkspace) {
                Camel.log.info("No profileWorkspace found so defaulting it to workspace for now");
                profileWorkspace = workspace;
            }
            var componentName = $scope.selectedComponentName;
            var selectedCamelContextId;
            var selectedRouteId;
            if (angular.isDefined($scope.camelSelectionDetails)) {
                selectedCamelContextId = $scope.camelSelectionDetails.selectedCamelContextId;
                selectedRouteId = $scope.camelSelectionDetails.selectedRouteId;
            }
            console.log("==== componentName " + componentName + " selectedCamelContextId: " + selectedCamelContextId + " selectedRouteId: " + selectedRouteId);
            var contextsById = Camel.camelContextMBeansById(profileWorkspace);
            if (selectedCamelContextId) {
                var mbean = Core.pathGet(contextsById, [selectedCamelContextId, "mbean"]);
                if (mbean) {
                    return mbean;
                }
            }
            if (selectedRouteId) {
                var map = Camel.camelContextMBeansByRouteId(profileWorkspace);
                var mbean = Core.pathGet(map, [selectedRouteId, "mbean"]);
                if (mbean) {
                    return mbean;
                }
            }
            if (componentName) {
                var map = Camel.camelContextMBeansByComponentName(profileWorkspace);
                var mbean = Core.pathGet(map, [componentName, "mbean"]);
                if (mbean) {
                    return mbean;
                }
            }
            var answer = null;
            angular.forEach(contextsById, function (details, id) {
                var mbean = details.mbean;
                if (!answer && mbean)
                    answer = mbean;
            });
            return answer;
        }
    }
    Camel.initEndpointChooserScope = initEndpointChooserScope;
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.FabricDiagramController", ["$scope", "$compile", "$location", "localStorage", "jolokia", "workspace", function ($scope, $compile, $location, localStorage, jolokia, workspace) {
        Fabric.initScope($scope, $location, jolokia, workspace);
        var isFmc = Fabric.isFMCContainer(workspace);
        $scope.isFmc = isFmc;
        $scope.selectedNode = null;
        var defaultFlags = {
            panel: true,
            popup: false,
            label: true,
            container: false,
            endpoint: true,
            route: true,
            context: false,
            consumer: true,
            producer: true
        };
        $scope.viewSettings = {};
        $scope.shapeSize = {
            context: 12,
            route: 10,
            endpoint: 7
        };
        var graphBuilder = new ForceGraph.GraphBuilder();
        Core.bindModelToSearchParam($scope, $location, "searchFilter", "q", "");
        angular.forEach(defaultFlags, function (defaultValue, key) {
            var modelName = "viewSettings." + key;
            function currentValue() {
                var answer = $location.search()[paramName] || defaultValue;
                return answer === "false" ? false : answer;
            }
            var paramName = key;
            var value = currentValue();
            Core.pathSet($scope, modelName, value);
            $scope.$watch(modelName, function () {
                var current = Core.pathGet($scope, modelName);
                var old = currentValue();
                if (current !== old) {
                    var defaultValue = defaultFlags[key];
                    if (current !== defaultValue) {
                        if (!current) {
                            current = "false";
                        }
                        $location.search(paramName, current);
                    }
                    else {
                        $location.search(paramName, null);
                    }
                }
                redrawGraph();
            });
        });
        $scope.connectToContext = function () {
            var selectedNode = $scope.selectedNode;
            if (selectedNode) {
                var container = selectedNode["container"] || selectedNode;
                var postfix = null;
                connectToContainer(container, postfix);
            }
        };
        $scope.connectToEndpoint = function () {
            var selectedNode = $scope.selectedNode;
            if (selectedNode) {
                var container = selectedNode["container"] || selectedNode;
                var postfix = null;
                connectToContainer(container, postfix);
            }
        };
        function connectToContainer(container, postfix, viewPrefix) {
            if (viewPrefix === void 0) { viewPrefix = "#/jmx/attributes?tab=camel"; }
            var view = viewPrefix;
            if (postfix) {
                view += postfix;
            }
            $scope.doConnect(container, view);
        }
        $scope.$on('$destroy', function (event) {
            stopOldJolokia();
        });
        function stopOldJolokia() {
            var oldJolokia = $scope.selectedNodeJolokia;
            if (oldJolokia && oldJolokia !== jolokia) {
                oldJolokia.stop();
            }
        }
        $scope.$watch("selectedNode", function (newValue, oldValue) {
            if ($scope.unregisterFn) {
                $scope.unregisterFn();
                $scope.unregisterFn = null;
            }
            var node = $scope.selectedNode;
            if (node) {
                var mbean = node.objectName;
                var container = node.container || {};
                var nodeJolokia = node.jolokia || container.jolokia || jolokia;
                if (nodeJolokia !== $scope.selectedNodeJolokia) {
                    stopOldJolokia();
                    $scope.selectedNodeJolokia = nodeJolokia;
                    if (nodeJolokia !== jolokia) {
                        var rate = Core.parseIntValue(localStorage['updateRate'] || "2000", "update rate");
                        if (rate) {
                            nodeJolokia.start(rate);
                        }
                    }
                }
                var dummyResponse = { value: node.panelProperties || {} };
                if (mbean && nodeJolokia) {
                    $scope.unregisterFn = Core.register(nodeJolokia, $scope, {
                        type: 'read',
                        mbean: mbean
                    }, onSuccess(renderNodeAttributes, { error: function (response) {
                        renderNodeAttributes(dummyResponse);
                        Core.defaultJolokiaErrorHandler(response);
                    } }));
                }
                else {
                    renderNodeAttributes(dummyResponse);
                }
            }
        });
        var ignoreNodeAttributes = [
            "CamelId",
            "CamelManagementName"
        ];
        var ignoreNodeAttributesByType = {
            context: ["ApplicationContextClassName", "CamelId", "ClassResolver", "ManagementName", "PackageScanClassResolver", "Properties"],
            endpoint: ["Camel", "Endpoint"],
            route: ["Description"]
        };
        var onlyShowAttributesByType = {
            broker: []
        };
        function renderNodeAttributes(response) {
            var properties = [];
            if (response) {
                var value = response.value || {};
                $scope.selectedNodeAttributes = value;
                var selectedNode = $scope.selectedNode || {};
                var container = selectedNode['container'] || {};
                var nodeType = selectedNode["type"];
                var brokerName = selectedNode["brokerName"];
                var containerId = container["id"];
                var group = selectedNode["group"] || container["group"];
                var jolokiaUrl = selectedNode["jolokiaUrl"] || container["jolokiaUrl"];
                var profile = selectedNode["profile"] || container["profile"];
                var version = selectedNode["version"] || container["version"];
                var isBroker = nodeType && nodeType.startsWith("broker");
                var ignoreKeys = ignoreNodeAttributes.concat(ignoreNodeAttributesByType[nodeType] || []);
                var onlyShowKeys = onlyShowAttributesByType[nodeType];
                angular.forEach(value, function (v, k) {
                    if (onlyShowKeys ? onlyShowKeys.indexOf(k) >= 0 : ignoreKeys.indexOf(k) < 0) {
                        var formattedValue = Core.humanizeValueHtml(v);
                        properties.push({ key: Core.humanizeValue(k), value: formattedValue });
                    }
                });
                properties = properties.sortBy("key");
                if (containerId && isFmc) {
                    properties.splice(0, 0, { key: "Container", value: $compile('<div fabric-container-link="' + selectedNode['container']['id'] + '"></div>')($scope) });
                }
                var typeLabel = selectedNode["typeLabel"];
                var name = selectedNode["name"] || selectedNode["id"] || selectedNode['objectName'];
                if (typeLabel) {
                    var html = name;
                    if (nodeType === "queue" || nodeType === "topic") {
                        html = createDestinationLink(name, nodeType);
                    }
                    var typeProperty = { key: typeLabel, value: html };
                    properties.splice(0, 0, typeProperty);
                }
            }
            $scope.selectedNodeProperties = properties;
            Core.$apply($scope);
        }
        function createDestinationLink(destinationName, destinationType) {
            if (destinationType === void 0) { destinationType = "queue"; }
            return $compile('<a target="destination" title="' + destinationName + '" ng-click="connectToEndpoint()">' + destinationName + '</a>')($scope);
        }
        $scope.$watch("searchFilter", function (newValue, oldValue) {
            redrawGraph();
        });
        if (isFmc) {
            $scope.versionId = Fabric.getDefaultVersionId(jolokia);
            var fields = ["id", "alive", "parentId", "profileIds", "versionId", "provisionResult", "jolokiaUrl", "jmxDomains"];
            Fabric.getContainersFields(jolokia, fields, onFabricContainerData);
        }
        else {
            $scope.$watch('workspace.tree', function () {
                reloadLocalJmxTree();
            });
            $scope.$on('jmxTreeUpdated', function () {
                reloadLocalJmxTree();
            });
        }
        function reloadLocalJmxTree() {
            var localContainer = {
                jolokia: jolokia
            };
            $scope.activeContainers = {
                "local": localContainer
            };
            redrawGraph();
            $scope.containerCount = 1;
        }
        function onFabricContainerData(response) {
            if (response) {
                var responseJson = angular.toJson(response);
                if ($scope.responseJson === responseJson) {
                    return;
                }
                $scope.responseJson = responseJson;
                var containersToDelete = $scope.activeContainers || {};
                $scope.activeContainers = (response || {}).filter(function (c) { return c.jmxDomains.any(Camel.jmxDomain); });
                $scope.containerCount = $scope.activeContainers.length;
                redrawGraph();
            }
            else {
                $scope.containerCount = 0;
            }
        }
        function redrawGraph() {
            graphBuilder = new ForceGraph.GraphBuilder();
            angular.forEach($scope.activeContainers, function (container, id) {
                var containerJolokia = container.jolokia;
                if (!containerJolokia) {
                    var jolokiaUrl = container["jolokiaUrl"];
                    if (jolokiaUrl) {
                        var url = Core.useProxyIfExternal(jolokiaUrl);
                        containerJolokia = Fabric.createJolokia(url);
                    }
                }
                if (containerJolokia) {
                    onContainerJolokia(containerJolokia, container);
                }
                else {
                    Fabric.containerJolokia(jolokia, id, function (containerJolokia) { return onContainerJolokia(containerJolokia, container); });
                }
            });
            Core.$apply($scope);
        }
        function matchesContextId(contextId) {
            if (contextId) {
                return !$scope.searchFilter || contextId.indexOf($scope.searchFilter) >= 0;
            }
            return false;
        }
        function onContainerJolokia(containerJolokia, container) {
            if (containerJolokia) {
                container.jolokia = containerJolokia;
                var containerId = container.id || "local";
                var idPrefix = containerId + ":";
                var endpointUriToObject = {};
                var startedLoadMetaDataFromEndpointMBeans = false;
                function getOrCreateRoute(objectName, properties, addEndpointLink, routeId, contextId, camelContext) {
                    if (routeId === void 0) { routeId = null; }
                    if (contextId === void 0) { contextId = null; }
                    if (camelContext === void 0) { camelContext = null; }
                    if (!objectName) {
                        objectName = Camel.jmxDomain + ':context=' + contextId + ',type=routes,name="' + routeId + '"';
                    }
                    var details = Core.parseMBean(objectName);
                    var attributes = details['attributes'];
                    var contextId = attributes["context"];
                    if (!routeId) {
                        routeId = Core.trimQuotes(attributes["name"]);
                    }
                    attributes["routeId"] = routeId;
                    attributes["mbean"] = objectName;
                    attributes["container"] = container;
                    attributes["type"] = "route";
                    var route = null;
                    if (routeId && matchesContextId(contextId)) {
                        route = getOrAddNode("route", idPrefix + routeId, attributes, function () {
                            return {
                                name: routeId,
                                typeLabel: "Route",
                                container: container,
                                objectName: objectName,
                                jolokia: containerJolokia,
                                popup: {
                                    title: "Route: " + routeId,
                                    content: "<p>context: " + contextId + "</p>"
                                }
                            };
                        });
                        if (addEndpointLink) {
                            var uri = properties["EndpointUri"];
                            if (uri && route) {
                                var endpoint = null;
                                var escaledUrl = Camel.escapeEndpointUriNameForJmx(uri);
                                var urlsToTry = [uri, escaledUrl];
                                angular.forEach(urlsToTry, function (key) {
                                    if (!endpoint) {
                                        endpoint = endpointUriToObject[key];
                                    }
                                });
                                if (!endpoint) {
                                    angular.forEach(urlsToTry, function (key) {
                                        if (!endpoint) {
                                            var idx = key.lastIndexOf("?");
                                            if (idx > 0) {
                                                var prefix = key.substring(0, idx);
                                                endpoint = endpointUriToObject[prefix];
                                            }
                                        }
                                    });
                                }
                                addLink(route, endpoint, "consumer");
                            }
                        }
                        if ($scope.viewSettings.route && $scope.viewSettings.context) {
                            if (!camelContext) {
                                camelContext = getOrCreateCamelContext(contextId);
                            }
                            addLink(camelContext, route, "route");
                        }
                    }
                    return route;
                }
                function getOrCreateEndpoint(objectName, uri, contextId) {
                    if (uri === void 0) { uri = null; }
                    if (contextId === void 0) { contextId = null; }
                    if (!objectName) {
                        objectName = Camel.jmxDomain + ':context=' + contextId + ',type=endpoints,name="' + Camel.escapeEndpointUriNameForJmx(uri) + '"';
                    }
                    var details = Core.parseMBean(objectName);
                    var attributes = details['attributes'];
                    var contextId = attributes["context"];
                    if (!uri) {
                        uri = Core.trimQuotes(attributes["name"]);
                    }
                    attributes["uri"] = uri;
                    attributes["mbean"] = objectName;
                    attributes["container"] = container;
                    attributes["contextId"] = contextId;
                    var endpoint = null;
                    if (uri && matchesContextId(contextId)) {
                        endpoint = getOrAddNode("endpoint", idPrefix + uri, attributes, function () {
                            return {
                                name: uri,
                                typeLabel: "Endpoint",
                                container: container,
                                objectName: objectName,
                                jolokia: containerJolokia,
                                popup: {
                                    title: "Endpoint: " + uri,
                                    content: "<p>context: " + contextId + "</p>"
                                }
                            };
                        });
                        if (endpoint) {
                            endpointUriToObject[uri] = endpoint;
                        }
                    }
                    return endpoint;
                }
                function loadMetaDataFromEndpointMBeans() {
                    if ($scope.viewSettings.route) {
                        containerJolokia.request({ type: "read", mbean: "org.apache.camel:type=routes,*", attribute: ["EndpointUri"] }, onSuccess(function (response) {
                            angular.forEach(response.value, function (properties, objectName) {
                                getOrCreateRoute(objectName, properties, true);
                            });
                            graphModelUpdated();
                        }));
                    }
                    if ($scope.viewSettings.endpoint) {
                        containerJolokia.search("org.apache.camel:type=endpoints,*", onSuccess(function (response) {
                            angular.forEach(response, function (objectName) {
                                var endpoint = getOrCreateEndpoint(objectName);
                                var camelContext = getOrCreateCamelContext(null, objectName);
                                addLink(camelContext, endpoint, "endpoint");
                            });
                            graphModelUpdated();
                        }));
                    }
                }
                function getOrCreateCamelContext(contextId, contextMBean) {
                    if (contextMBean === void 0) { contextMBean = null; }
                    var answer = null;
                    if (matchesContextId(contextId)) {
                        if (!contextMBean) {
                            contextMBean = Camel.jmxDomain + ':context=' + contextId + ',type=context,name="' + contextId + '"';
                        }
                        if (!contextId && contextMBean) {
                            var details = Core.parseMBean(contextMBean);
                            var attributes = details['attributes'];
                            contextId = attributes["context"];
                        }
                        var contextAttributes = {
                            contextId: contextId
                        };
                        if ($scope.viewSettings.context) {
                            answer = getOrAddNode("context", idPrefix + contextId, contextAttributes, function () {
                                return {
                                    name: contextId,
                                    typeLabel: "CamelContext",
                                    container: container,
                                    objectName: contextMBean,
                                    jolokia: containerJolokia,
                                    popup: {
                                        title: "CamelContext: " + contextId,
                                        content: ""
                                    }
                                };
                            });
                        }
                        containerJolokia.execute(contextMBean, "createRouteStaticEndpointJson", onSuccess(function (response) {
                            if (angular.isString(response)) {
                                var text = response;
                                var data = null;
                                try {
                                    data = JSON.parse(text);
                                }
                                catch (e) {
                                    text = Core.trimTrailing(text.trim(), "}");
                                    try {
                                        data = JSON.parse(text);
                                    }
                                    catch (e2) {
                                        Camel.log.debug("Ignored invalid json: " + e + " from text: " + response);
                                    }
                                }
                            }
                            if (data) {
                                angular.forEach(data["routes"], function (routeData, routeId) {
                                    angular.forEach(routeData["inputs"], function (inputEndpoint) {
                                        var inputUri = inputEndpoint["uri"];
                                        if (inputUri) {
                                            var route = getOrCreateRoute(null, {}, false, routeId, contextId, answer);
                                            var input = getOrCreateEndpoint(null, inputUri, contextId);
                                            var nextStep = route;
                                            addLink(input, route, "endpoint");
                                            angular.forEach(routeData["outputs"], function (outputEndpoint) {
                                                var outputUri = outputEndpoint["uri"];
                                                if (outputUri) {
                                                    var output = getOrCreateEndpoint(null, outputUri, contextId);
                                                    addLink(nextStep, output, "endpoint");
                                                    nextStep = output;
                                                }
                                            });
                                        }
                                    });
                                });
                                Camel.log.info("Updating graph model!");
                                graphModelUpdated();
                            }
                        }, {
                            error: function (response) {
                                if (!startedLoadMetaDataFromEndpointMBeans) {
                                    startedLoadMetaDataFromEndpointMBeans = true;
                                    loadMetaDataFromEndpointMBeans();
                                }
                            }
                        }));
                    }
                    return answer;
                }
                containerJolokia.search("org.apache.camel:type=context,*", onSuccess(function (response) {
                    angular.forEach(response, function (objectName) {
                        var details = Core.parseMBean(objectName);
                        var attributes = details['attributes'];
                        var contextId = attributes["context"];
                        var uri = Core.trimQuotes(attributes["name"]);
                        getOrCreateCamelContext(contextId, objectName);
                    });
                }));
            }
        }
        function graphModelUpdated() {
            $scope.graph = graphBuilder.buildGraph();
            Core.$apply($scope);
        }
        function getOrAddNode(typeName, id, properties, createFn) {
            var node = null;
            if (id) {
                var nodeId = typeName + ":" + id;
                node = graphBuilder.getNode(nodeId);
                if (!node) {
                    var nodeValues = createFn();
                    node = angular.copy(properties);
                    angular.forEach(nodeValues, function (value, key) { return node[key] = value; });
                    node['id'] = nodeId;
                    if (!node['type']) {
                        node['type'] = typeName;
                    }
                    if (!node['name']) {
                        node['name'] = id;
                    }
                    if (node) {
                        var size = $scope.shapeSize[typeName];
                        if (size && !node['size']) {
                            node['size'] = size;
                        }
                        if (!node['summary']) {
                            node['summary'] = node['popup'] || "";
                        }
                        if (!$scope.viewSettings.popup) {
                            delete node['popup'];
                        }
                        if (!$scope.viewSettings.label) {
                            delete node['name'];
                        }
                        var enabled = $scope.viewSettings[typeName];
                        if (enabled || !angular.isDefined(enabled)) {
                            graphBuilder.addNode(node);
                        }
                        else {
                        }
                    }
                }
            }
            return node;
        }
        function addLink(object1, object2, linkType) {
            if (object1 && object2) {
                addLinkIds(object1.id, object2.id, linkType);
            }
        }
        function addLinkIds(id1, id2, linkType) {
            if (id1 && id2) {
                graphBuilder.addLink(id1, id2, linkType);
            }
        }
        function renameTypeProperty(properties) {
            properties.mbeanType = properties['type'];
            delete properties['type'];
        }
        function configureEndpointProperties(properties) {
            renameTypeProperty(properties);
            var destinationType = properties.destinationType || "Queue";
            var typeName = destinationType.toLowerCase();
            properties.isQueue = !typeName.startsWith("t");
            properties['destType'] = typeName;
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.InflightController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.data = [];
        $scope.initDone = false;
        $scope.mbeanAttributes = {};
        var columnDefs = [
            {
                field: 'exchangeId',
                displayName: 'Exchange Id',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'routeId',
                displayName: 'Route Id',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'nodeId',
                displayName: 'Node Id',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'duration',
                displayName: 'Duration (ms)',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'elapsed',
                displayName: 'Elapsed (ms)',
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        $scope.gridOptions = {
            data: 'data',
            displayFooter: true,
            displaySelectionCheckbox: false,
            canSelectRows: false,
            enableSorting: true,
            columnDefs: columnDefs,
            selectedItems: [],
            filterOptions: {
                filterText: ''
            }
        };
        function onInflight(response) {
            var obj = response.value;
            if (obj) {
                var arr = [];
                for (var key in obj) {
                    var entry = obj[key];
                    arr.push({
                        exchangeId: entry.exchangeId,
                        routeId: entry.routeId,
                        nodeId: entry.nodeId,
                        duration: entry.duration,
                        elapsed: entry.elapsed
                    });
                }
                arr = arr.sortBy("exchangeId");
                $scope.data = arr;
                $scope.selectedMBean = response.request.mbean;
            }
            else {
                $scope.data = [];
            }
            $scope.initDone = "true";
            Core.$apply($scope);
        }
        $scope.renderIcon = function (state) {
            return Camel.iconClass(state);
        };
        function loadRestRegistry() {
            console.log("Loading inflight data...");
            var routeId = Camel.getSelectedRouteId(workspace);
            if (routeId != null) {
                $scope.gridOptions.filterOptions.filterText = routeId;
            }
            var mbean = Camel.getSelectionCamelInflightRepository(workspace);
            if (mbean) {
                var query = { type: "exec", mbean: mbean, operation: 'browse()' };
                jolokia.request(query, onSuccess(onInflight));
                scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(onSuccess(onInflight), query));
            }
        }
        loadRestRegistry();
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel.jmsHeaderSchema = {
        definitions: {
            headers: {
                properties: {
                    JMSCorrelationID: {
                        type: "java.lang.String"
                    },
                    JMSDeliveryMode: {
                        "type": "string",
                        "enum": [
                            "PERSISTENT",
                            "NON_PERSISTENT"
                        ]
                    },
                    JMSDestination: {
                        type: "javax.jms.Destination"
                    },
                    JMSExpiration: {
                        type: "long"
                    },
                    JMSPriority: {
                        type: "int"
                    },
                    JMSReplyTo: {
                        type: "javax.jms.Destination"
                    },
                    JMSType: {
                        type: "java.lang.String"
                    },
                    JMSXGroupId: {
                        type: "java.lang.String"
                    },
                    AMQ_SCHEDULED_CRON: {
                        type: "java.lang.String"
                    },
                    AMQ_SCHEDULED_DELAY: {
                        type: "java.lang.String"
                    },
                    AMQ_SCHEDULED_PERIOD: {
                        type: "java.lang.String"
                    },
                    AMQ_SCHEDULED_REPEAT: {
                        type: "java.lang.String"
                    }
                }
            },
            "javax.jms.Destination": {
                type: "java.lang.String"
            }
        }
    };
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.PreferencesController", ["$scope", "localStorage", function ($scope, localStorage) {
        Core.initPreferenceScope($scope, localStorage, {
            'camelIgnoreIdForLabel': {
                'value': false,
                'converter': Core.parseBooleanValue
            },
            'camelShowInflightCounter': {
                'value': true,
                'converter': Core.parseBooleanValue
            },
            'camelMaximumLabelWidth': {
                'value': Camel.defaultMaximumLabelWidth,
                'converter': parseInt
            },
            'camelMaximumTraceOrDebugBodyLength': {
                'value': Camel.defaultCamelMaximumTraceOrDebugBodyLength,
                'converter': parseInt
            },
            'camelTraceOrDebugIncludeStreams': {
                'value': Camel.defaultCamelTraceOrDebugIncludeStreams,
                'converter': Core.parseBooleanValue
            },
            'camelRouteMetricMaxSeconds': {
                'value': Camel.defaultCamelRouteMetricMaxSeconds,
                'converter': parseInt
            },
            'camelHideOptionDocumentation': {
                'value': Camel.defaultHideOptionDocumentation,
                'converter': Core.parseBooleanValue
            },
            'camelHideOptionDefaultValue': {
                'value': Camel.defaultHideOptionDefaultValue,
                'converter': Core.parseBooleanValue
            },
            'camelHideOptionUnusedValue': {
                'value': Camel.defaultHideOptionUnusedValue,
                'converter': Core.parseBooleanValue
            }
        });
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.ProfileRouteController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.data = [];
        $scope.icons = {};
        $scope.selectedRouteId = "";
        var columnDefs = [
            {
                field: 'id',
                displayName: 'Id',
                cellTemplate: '<div class="ngCellText" ng-bind-html-unsafe="rowIcon(row.entity.id)"></div>',
                cellFilter: null,
                width: "**",
                resizable: true
            },
            {
                field: 'count',
                displayName: 'Count',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'last',
                displayName: 'Last',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'delta',
                displayName: 'Delta',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'mean',
                displayName: 'Mean',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'min',
                displayName: 'Min',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'max',
                displayName: 'Max',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'total',
                displayName: 'Total',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'self',
                displayName: 'Self',
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        $scope.rowIcon = function (id) {
            var entry = $scope.icons[id];
            if (entry) {
                return entry.img + " " + id;
            }
            else {
                return id;
            }
        };
        $scope.gridOptions = {
            data: 'data',
            displayFooter: true,
            displaySelectionCheckbox: false,
            canSelectRows: false,
            enableSorting: false,
            columnDefs: columnDefs,
            filterOptions: {
                filterText: ''
            }
        };
        var populateProfileMessages = function (response) {
            var updatedData = [];
            var xml = response.value;
            if (angular.isString(xml)) {
                var doc = $.parseXML(xml);
                var routeMessages = $(doc).find("routeStat");
                routeMessages.each(function (idx, message) {
                    var messageData = {
                        id: {},
                        count: {},
                        last: {},
                        delta: {},
                        mean: {},
                        min: {},
                        max: {},
                        total: {},
                        self: {}
                    };
                    messageData.id = message.getAttribute("id");
                    var total = 0;
                    total += +message.getAttribute("exchangesCompleted");
                    total += +message.getAttribute("exchangesFailed");
                    messageData.count = total;
                    messageData.last = message.getAttribute("lastProcessingTime");
                    var delta = message.getAttribute("deltaProcessingTime");
                    if (delta) {
                        messageData.delta = delta;
                    }
                    else {
                        messageData.delta = 0;
                    }
                    messageData.mean = message.getAttribute("meanProcessingTime");
                    messageData.min = message.getAttribute("minProcessingTime");
                    messageData.max = message.getAttribute("maxProcessingTime");
                    messageData.total = message.getAttribute("totalProcessingTime");
                    messageData.self = message.getAttribute("selfProcessingTime");
                    updatedData.push(messageData);
                });
                var processorMessages = $(doc).find("processorStat");
                processorMessages.each(function (idx, message) {
                    var messageData = {
                        id: {},
                        count: {},
                        last: {},
                        delta: {},
                        mean: {},
                        min: {},
                        max: {},
                        total: {},
                        self: {}
                    };
                    messageData.id = message.getAttribute("id");
                    var total = 0;
                    total += +message.getAttribute("exchangesCompleted");
                    total += +message.getAttribute("exchangesFailed");
                    messageData.count = total;
                    messageData.last = message.getAttribute("lastProcessingTime");
                    var delta = message.getAttribute("deltaProcessingTime");
                    if (delta) {
                        messageData.delta = delta;
                    }
                    else {
                        messageData.delta = 0;
                    }
                    messageData.mean = message.getAttribute("meanProcessingTime");
                    messageData.min = message.getAttribute("minProcessingTime");
                    messageData.max = message.getAttribute("maxProcessingTime");
                    var apt = message.getAttribute("accumulatedProcessingTime");
                    if (apt) {
                        messageData.total = apt;
                    }
                    else {
                        messageData.total = "0";
                    }
                    messageData.self = message.getAttribute("totalProcessingTime");
                    updatedData.push(messageData);
                });
            }
            $scope.data = updatedData;
            Core.$apply($scope);
        };
        $scope.onResponse = function (response) {
            loadData();
        };
        $scope.$watch('workspace.tree', function () {
            setTimeout(loadData, 50);
        });
        function initIdToIcon() {
            console.log("initializing id and icons");
            $scope.icons = {};
            var routeXml = Core.pathGet(workspace.selection, ["routeXmlNode"]);
            if (routeXml) {
                var entry = {
                    img: "",
                    index: 0
                };
                entry.index = -1;
                entry.img = "<img src='img/icons/camel/camel_route.png'>";
                $scope.icons[$scope.selectedRouteId] = entry;
                $(routeXml).find('*').each(function (idx, element) {
                    var id = element.getAttribute("id");
                    if (id) {
                        var entry = {
                            img: "",
                            index: 0
                        };
                        entry.index = idx;
                        var icon = Camel.getRouteNodeIcon(element);
                        if (icon) {
                            entry.img = "<img src='" + icon + "'>";
                        }
                        else {
                            entry.img = "";
                        }
                        $scope.icons[id] = entry;
                    }
                });
            }
        }
        function loadData() {
            console.log("Loading Camel route profile data...");
            $scope.selectedRouteId = Camel.getSelectedRouteId(workspace);
            var routeMBean = Camel.getSelectionRouteMBean(workspace, $scope.selectedRouteId);
            console.log("Selected route is " + $scope.selectedRouteId);
            initIdToIcon();
            console.log("Initialized icons, with " + $scope.icons.length + " icons");
            var query = { type: 'exec', mbean: routeMBean, operation: 'dumpRouteStatsAsXml(boolean,boolean)', arguments: [false, true] };
            scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(populateProfileMessages, query));
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.PropertiesController", ["$scope", "workspace", "localStorage", function ($scope, workspace, localStorage) {
        var log = Logger.get("Camel");
        $scope.hideHelp = Camel.hideOptionDocumentation(localStorage);
        $scope.hideUnused = Camel.hideOptionUnusedValue(localStorage);
        $scope.hideDefault = Camel.hideOptionDefaultValue(localStorage);
        $scope.viewTemplate = null;
        $scope.schema = _apacheCamelModel;
        $scope.model = null;
        $scope.labels = [];
        $scope.nodeData = null;
        $scope.icon = null;
        $scope.$watch('hideHelp', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateData();
            }
        });
        $scope.$watch('hideUnused', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateData();
            }
        });
        $scope.$watch('hideDefault', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateData();
            }
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateData, 50);
        });
        $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid())
                return;
            updateData();
        });
        $scope.showEntity = function (id) {
            if ($scope.hideDefault) {
                if (isDefaultValue(id)) {
                    return false;
                }
            }
            if ($scope.hideUnused) {
                if (!hasValue(id)) {
                    return false;
                }
            }
            return true;
        };
        function isDefaultValue(id) {
            var defaultValue = Core.pathGet($scope.model, ["properties", id, "defaultValue"]);
            if (angular.isDefined(defaultValue)) {
                var value = Core.pathGet($scope.nodeData, id);
                if (angular.isDefined(value)) {
                    var str = value.toString();
                    return str.localeCompare(defaultValue) === 0;
                }
            }
            return false;
        }
        function hasValue(id) {
            var value = Core.pathGet($scope.nodeData, id);
            if (angular.isUndefined(value) || Core.isBlank(value)) {
                return false;
            }
            if (angular.isString(value)) {
                return !Core.isBlank(value);
            }
            return true;
        }
        function updateData() {
            var routeXmlNode = Camel.getSelectedRouteNode(workspace);
            if (routeXmlNode != null) {
                $scope.model = Camel.getCamelSchema(routeXmlNode.nodeName);
                if ($scope.model) {
                    if (log.enabledFor(Logger.DEBUG)) {
                        log.debug("Properties - data: " + JSON.stringify($scope.nodeData, null, "  "));
                        log.debug("Properties - schema: " + JSON.stringify($scope.model, null, "  "));
                    }
                    var labels = [];
                    if ($scope.model.group) {
                        labels = $scope.model.group.split(",");
                    }
                    $scope.labels = labels;
                    $scope.nodeData = Camel.getRouteNodeJSON(routeXmlNode);
                    $scope.icon = Camel.getRouteNodeIcon(routeXmlNode);
                    $scope.viewTemplate = "app/camel/html/nodePropertiesView.html";
                    Core.$apply($scope);
                }
            }
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.PropertiesEndpointController", ["$scope", "workspace", "localStorage", "jolokia", function ($scope, workspace, localStorage, jolokia) {
        var log = Logger.get("Camel");
        $scope.hideHelp = Camel.hideOptionDocumentation(localStorage);
        $scope.hideUnused = Camel.hideOptionUnusedValue(localStorage);
        $scope.hideDefault = Camel.hideOptionDefaultValue(localStorage);
        $scope.viewTemplate = null;
        $scope.schema = null;
        $scope.model = null;
        $scope.labels = [];
        $scope.nodeData = null;
        $scope.icon = null;
        $scope.endpointUrl = null;
        $scope.$watch('hideHelp', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateData();
            }
        });
        $scope.$watch('hideUnused', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateData();
            }
        });
        $scope.$watch('hideDefault', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateData();
            }
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateData, 50);
        });
        $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid())
                return;
            updateData();
        });
        $scope.showEntity = function (id) {
            if ($scope.hideDefault) {
                if (isDefaultValue(id)) {
                    return false;
                }
            }
            if ($scope.hideUnused) {
                if (!hasValue(id)) {
                    return false;
                }
            }
            return true;
        };
        function isDefaultValue(id) {
            var defaultValue = Core.pathGet($scope.model, ["properties", id, "defaultValue"]);
            if (angular.isDefined(defaultValue)) {
                var value = Core.pathGet($scope.nodeData, id);
                if (angular.isDefined(value)) {
                    var str = value.toString();
                    return str.localeCompare(defaultValue) === 0;
                }
            }
            return false;
        }
        function hasValue(id) {
            var value = Core.pathGet($scope.nodeData, id);
            if (angular.isUndefined(value) || Core.isBlank(value)) {
                return false;
            }
            if (angular.isString(value)) {
                return !Core.isBlank(value);
            }
            return true;
        }
        function updateData() {
            var contextMBean = Camel.getSelectionCamelContextMBean(workspace);
            var endpointMBean = null;
            if ($scope.contextId && $scope.endpointPath) {
                var node = workspace.findMBeanWithProperties(Camel.jmxDomain, {
                    context: $scope.contextId,
                    type: "endpoints",
                    name: $scope.endpointPath
                });
                if (node) {
                    endpointMBean = node.objectName;
                }
            }
            if (!endpointMBean) {
                endpointMBean = workspace.getSelectedMBeanName();
            }
            if (endpointMBean && contextMBean) {
                var reply = jolokia.request({ type: "read", mbean: endpointMBean, attribute: ["EndpointUri"] });
                var url = reply.value["EndpointUri"];
                if (url) {
                    $scope.endpointUrl = url;
                    log.info("Calling explainEndpointJson for url: " + url);
                    var query = { type: 'exec', mbean: contextMBean, operation: 'explainEndpointJson(java.lang.String,boolean)', arguments: [url, true] };
                    jolokia.request(query, onSuccess(populateData));
                }
            }
        }
        function populateData(response) {
            log.debug("Populate data " + response);
            var data = response.value;
            if (data) {
                $scope.model = JSON.parse(data);
                $scope.model.title = $scope.endpointUrl;
                $scope.model.description = $scope.model.component.description;
                $scope.icon = Core.url("/img/icons/camel/endpoint24.png");
                $scope.nodeData = {};
                angular.forEach($scope.model.properties, function (property, key) {
                    var value = property["value"] || property["defaultValue"];
                    if (angular.isDefined(value) && value !== null) {
                        $scope.nodeData[key] = value;
                    }
                    delete property["label"];
                });
                var labels = [];
                if ($scope.model.component.label) {
                    labels = $scope.model.component.label.split(",");
                }
                $scope.labels = labels;
                $scope.viewTemplate = "app/camel/html/nodePropertiesView.html";
                Core.$apply($scope);
            }
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.RestServiceController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.data = [];
        $scope.selectedMBean = null;
        $scope.mbeanAttributes = {};
        var columnDefs = [
            {
                field: 'url',
                displayName: 'Absolute Url',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'baseUrl',
                displayName: 'Base Url',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'basePath',
                displayName: 'Base Path',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'uriTemplate',
                displayName: 'Uri Template',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'method',
                displayName: 'Method',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'consumes',
                displayName: 'Consumes',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'produces',
                displayName: 'Produces',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'inType',
                displayName: 'Input Type',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'outType',
                displayName: 'Output Type',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'state',
                displayName: 'State',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'routeId',
                displayName: 'Route Id',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'description',
                displayName: 'Description',
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        $scope.gridOptions = {
            data: 'data',
            displayFooter: true,
            displaySelectionCheckbox: false,
            canSelectRows: false,
            enableSorting: true,
            columnDefs: columnDefs,
            selectedItems: [],
            filterOptions: {
                filterText: ''
            }
        };
        function onRestRegistry(response) {
            var obj = response.value;
            if (obj) {
                var arr = [];
                for (var key in obj) {
                    var values = obj[key];
                    for (var v in values) {
                        var entry = values[v];
                        arr.push({
                            url: entry.url,
                            baseUrl: entry.baseUrl,
                            basePath: entry.basePath,
                            uriTemplate: entry.uriTemplate,
                            method: entry.method,
                            consumes: entry.consumes,
                            produces: entry.produces,
                            inType: entry.inType,
                            outType: entry.outType,
                            state: entry.state,
                            routeId: entry.routeId,
                            description: entry.description
                        });
                    }
                }
                arr = arr.sortBy("url");
                $scope.data = arr;
                $scope.selectedMBean = response.request.mbean;
            }
            else {
                $scope.selectedMBean = "true";
            }
            Core.$apply($scope);
        }
        $scope.renderIcon = function (state) {
            return Camel.iconClass(state);
        };
        function loadRestRegistry() {
            console.log("Loading RestRegistry data...");
            var mbean = Camel.getSelectionCamelRestRegistry(workspace);
            if (mbean) {
                jolokia.request({ type: 'exec', mbean: mbean, operation: 'listRestServices' }, onSuccess(onRestRegistry));
            }
        }
        loadRestRegistry();
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.RouteMetricsController", ["$scope", "$location", "workspace", "jolokia", "metricsWatcher", "localStorage", function ($scope, $location, workspace, jolokia, metricsWatcher, localStorage) {
        var log = Logger.get("Camel");
        $scope.maxSeconds = Camel.routeMetricMaxSeconds(localStorage);
        $scope.filterText = null;
        $scope.initDone = false;
        $scope.metricDivs = [];
        $scope.filterByRoute = function (div) {
            log.debug("Filter by route " + div);
            var match = Core.matchFilterIgnoreCase(div.routeId, $scope.filterText);
            if (!match) {
                return "display: none;";
            }
            else {
                return "";
            }
        };
        function populateRouteStatistics(response) {
            var obj = response.value;
            if (obj) {
                var json = JSON.parse(obj);
                if (!$scope.initDone) {
                    var meters = json['timers'];
                    var counter = 0;
                    if (meters != null) {
                        for (var v in meters) {
                            var key = v;
                            var lastDot = key.lastIndexOf(".");
                            var className = key.substr(0, lastDot);
                            var metricsName = key.substr(lastDot + 1);
                            var firstColon = key.indexOf(":");
                            var routeId = key.substr(firstColon + 1);
                            lastDot = routeId.lastIndexOf(".");
                            if (lastDot > 0) {
                                routeId = routeId.substr(0, lastDot);
                            }
                            var entry = meters[v];
                            var div = "timer-" + counter;
                            $scope.metricDivs.push({
                                id: div,
                                routeId: routeId
                            });
                            counter++;
                            log.info("Added timer: " + div + " (" + className + "." + metricsName + ") for route: " + routeId + " with max seconds: " + $scope.maxSeconds);
                            metricsWatcher.addTimer(div, className, metricsName, $scope.maxSeconds, routeId, "Histogram", $scope.maxSeconds * 1000);
                        }
                        log.info("Pre-init graphs");
                        Core.$apply($scope);
                    }
                    log.info("Init graphs");
                    metricsWatcher.initGraphs();
                }
                $scope.initDone = true;
                log.debug("Updating graphs: " + json);
                metricsWatcher.updateGraphs(json);
            }
            $scope.initDone = true;
            Core.$apply($scope);
        }
        $scope.onResponse = function (response) {
            loadData();
        };
        $scope.$watch('workspace.tree', function () {
            setTimeout(loadData, 50);
        });
        function loadData() {
            log.info("Loading RouteMetrics data...");
            var routeId = Camel.getSelectedRouteId(workspace);
            if (routeId != null) {
                $scope.filterText = routeId;
            }
            var mbean = Camel.getSelectionCamelRouteMetrics(workspace);
            if (mbean) {
                var query = { type: 'exec', mbean: mbean, operation: 'dumpStatisticsAsJson' };
                scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(populateRouteStatistics, query));
            }
            else {
                $scope.initDone = true;
                Core.$apply($scope);
            }
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.RouteController", ["$scope", "$routeParams", "$element", "$timeout", "workspace", "$location", "jolokia", "localStorage", function ($scope, $routeParams, $element, $timeout, workspace, $location, jolokia, localStorage) {
        var log = Logger.get("Camel");
        $scope.routes = [];
        $scope.routeNodes = {};
        if ($routeParams != null) {
            $scope.contextId = $routeParams["contextId"];
            $scope.routeId = Core.trimQuotes($routeParams["routeId"]);
            $scope.isJmxTab = !$routeParams["contextId"] || !$routeParams["routeId"];
        }
        $scope.camelIgnoreIdForLabel = Camel.ignoreIdForLabel(localStorage);
        $scope.camelMaximumLabelWidth = Camel.maximumLabelWidth(localStorage);
        $scope.camelShowInflightCounter = Camel.showInflightCounter(localStorage);
        var updateRoutes = Core.throttled(doUpdateRoutes, 1000);
        var delayUpdatingRoutes = 300;
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            $timeout(updateRoutes, delayUpdatingRoutes);
        });
        $scope.$watch('workspace.selection', function () {
            if ($scope.isJmxTab && workspace.moveIfViewInvalid())
                return;
            $timeout(updateRoutes, delayUpdatingRoutes);
        });
        $scope.$on('jmxTreeUpdated', function () {
            $timeout(updateRoutes, delayUpdatingRoutes);
        });
        $scope.$watch('nodeXmlNode', function () {
            if ($scope.isJmxTab && workspace.moveIfViewInvalid())
                return;
            $timeout(updateRoutes, delayUpdatingRoutes);
        });
        function doUpdateRoutes() {
            var routeXmlNode = null;
            if (!$scope.ignoreRouteXmlNode) {
                routeXmlNode = Camel.getSelectedRouteNode(workspace);
                if (!routeXmlNode) {
                    routeXmlNode = $scope.nodeXmlNode;
                }
                if (routeXmlNode && routeXmlNode.localName !== "route") {
                    var wrapper = document.createElement("route");
                    wrapper.appendChild(routeXmlNode.cloneNode(true));
                    routeXmlNode = wrapper;
                }
            }
            $scope.mbean = Camel.getSelectionCamelContextMBean(workspace);
            if (!$scope.mbean && $scope.contextId) {
                $scope.mbean = Camel.getCamelContextMBean(workspace, $scope.contextId);
            }
            if (routeXmlNode) {
                $scope.nodes = {};
                var nodes = [];
                var links = [];
                $scope.processorTree = Camel.camelProcessorMBeansById(workspace);
                Camel.addRouteXmlChildren($scope, routeXmlNode, nodes, links, null, 0, 0);
                showGraph(nodes, links);
            }
            else if ($scope.mbean) {
                jolokia.request({ type: 'exec', mbean: $scope.mbean, operation: 'dumpRoutesAsXml()' }, onSuccess(populateTable));
            }
            else {
                log.info("No camel context bean! Selection: " + workspace.selection);
            }
        }
        var populateTable = function (response) {
            var data = response.value;
            $scope.routes = data;
            $scope.nodes = {};
            $scope.routeNodes = {};
            var nodes = [];
            var links = [];
            var selectedRouteId = $scope.routeId;
            if (!selectedRouteId) {
                selectedRouteId = Camel.getSelectedRouteId(workspace);
            }
            if (data) {
                var doc = $.parseXML(data);
                $scope.processorTree = Camel.camelProcessorMBeansById(workspace);
                Camel.loadRouteXmlNodes($scope, doc, selectedRouteId, nodes, links, getWidth());
                showGraph(nodes, links);
            }
            else {
                console.log("No data from route XML!");
            }
            Core.$apply($scope);
        };
        var postfix = " selected";
        function isSelected(node) {
            if (node) {
                var className = node.getAttribute("class");
                return className && className.endsWith(postfix);
            }
            return false;
        }
        function setSelected(node, flag) {
            var answer = false;
            if (node) {
                var className = node.getAttribute("class");
                var selected = className && className.endsWith(postfix);
                if (selected) {
                    className = className.substring(0, className.length - postfix.length);
                }
                else {
                    if (!flag) {
                        return answer;
                    }
                    className = className + postfix;
                    answer = true;
                }
                node.setAttribute("class", className);
            }
            return answer;
        }
        var onClickGraphNode = function (node) {
            log.debug("Clicked on Camel Route Diagram node: " + node.cid);
            $location.path('/camel/properties').search({ "tab": "camel", "nid": node.cid });
        };
        function showGraph(nodes, links) {
            var canvasDiv = $($element);
            var width = getWidth();
            var height = getHeight();
            var svg = canvasDiv.children("svg")[0];
            var onClick;
            var path = $location.path();
            if (path.startsWith("/camel/debugRoute") || path.startsWith("/camel/traceRoute")) {
                onClick = null;
            }
            else {
                onClick = onClickGraphNode;
            }
            $scope.graphData = Core.dagreLayoutGraph(nodes, links, width, height, svg, false, onClick);
            var gNodes = canvasDiv.find("g.node");
            gNodes.click(function () {
                var selected = isSelected(this);
                gNodes.each(function (idx, element) {
                    setSelected(element, false);
                });
                var cid = null;
                if (!selected) {
                    cid = this.getAttribute("data-cid");
                    setSelected(this, true);
                }
                $scope.$emit("camel.diagram.selectedNodeId", cid);
                Core.$apply($scope);
            });
            if ($scope.mbean) {
                Core.register(jolokia, $scope, {
                    type: 'exec',
                    mbean: $scope.mbean,
                    operation: 'dumpRoutesStatsAsXml',
                    arguments: [true, true]
                }, onSuccess(statsCallback, { silent: true, error: false }));
            }
            $scope.$emit("camel.diagram.layoutComplete");
            return width;
        }
        function getWidth() {
            var canvasDiv = $($element);
            return canvasDiv.width();
        }
        function getHeight() {
            var canvasDiv = $($element);
            return Camel.getCanvasHeight(canvasDiv);
        }
        function statsCallback(response) {
            var data = response.value;
            if (data) {
                var doc = $.parseXML(data);
                var allStats = $(doc).find("routeStat");
                allStats.each(function (idx, stat) {
                    addTooltipToNode(true, stat);
                });
                var allStats = $(doc).find("processorStat");
                allStats.each(function (idx, stat) {
                    addTooltipToNode(false, stat);
                });
                Core.dagreUpdateGraphData($scope.graphData);
            }
            function addTooltipToNode(isRoute, stat) {
                var id = stat.getAttribute("id");
                var completed = stat.getAttribute("exchangesCompleted");
                var inflight = stat.hasAttribute("exchangesInflight") ? stat.getAttribute("exchangesInflight") : 0;
                var tooltip = "";
                if (id && completed) {
                    var container = isRoute ? $scope.routeNodes : $scope.nodes;
                    var node = container[id];
                    if (!node) {
                        angular.forEach(container, function (value, key) {
                            if (!node && id === value.elementId) {
                                node = value;
                            }
                        });
                    }
                    if (node) {
                        var total = 0 + parseInt(completed);
                        var failed = stat.getAttribute("exchangesFailed");
                        if (failed) {
                            total += parseInt(failed);
                        }
                        var last = stat.getAttribute("lastProcessingTime");
                        var mean = stat.getAttribute("meanProcessingTime");
                        var min = stat.getAttribute("minProcessingTime");
                        var max = stat.getAttribute("maxProcessingTime");
                        tooltip = "totoal: " + total + "\ninflight:" + inflight + "\nlast: " + last + " (ms)\nmean: " + mean + " (ms)\nmin: " + min + " (ms)\nmax: " + max + " (ms)";
                        node["counter"] = total;
                        if ($scope.camelShowInflightCounter) {
                            node["inflight"] = inflight;
                        }
                        var labelSummary = node["labelSummary"];
                        if (labelSummary) {
                            tooltip = labelSummary + "\n\n" + tooltip;
                        }
                        node["tooltip"] = tooltip;
                    }
                    else {
                    }
                }
            }
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    var DELIVERY_PERSISTENT = "2";
    Camel._module.controller("Camel.SendMessageController", ["$route", "$scope", "$element", "$timeout", "workspace", "jolokia", "localStorage", "$location", "activeMQMessage", function ($route, $scope, $element, $timeout, workspace, jolokia, localStorage, $location, activeMQMessage) {
        var log = Logger.get("Camel");
        $scope.noCredentials = false;
        $scope.showChoose = false;
        $scope.profileFileNames = [];
        $scope.profileFileNameToProfileId = {};
        $scope.selectedFiles = {};
        $scope.container = {};
        $scope.message = "\n\n\n\n";
        $scope.headers = [];
        Core.bindModelToSearchParam($scope, $location, "tab", "subtab", "compose");
        Core.bindModelToSearchParam($scope, $location, "searchText", "q", "");
        Core.reloadWhenParametersChange($route, $scope, $location);
        $scope.checkCredentials = function () {
            $scope.noCredentials = (Core.isBlank(localStorage['activemqUserName']) || Core.isBlank(localStorage['activemqPassword']));
        };
        if ($location.path().has('activemq')) {
            $scope.localStorage = localStorage;
            $scope.$watch('localStorage.activemqUserName', $scope.checkCredentials);
            $scope.$watch('localStorage.activemqPassword', $scope.checkCredentials);
            if (activeMQMessage.message !== null) {
                $scope.message = activeMQMessage.message.bodyText;
                if (activeMQMessage.message.PropertiesText !== null) {
                    for (var p in activeMQMessage.message.StringProperties) {
                        $scope.headers.push({ name: p, value: activeMQMessage.message.StringProperties[p] });
                    }
                }
            }
            activeMQMessage.message = null;
        }
        $scope.openPrefs = function () {
            $location.search('pref', 'ActiveMQ');
            $scope.$emit("hawtioOpenPrefs");
        };
        var LANGUAGE_FORMAT_PREFERENCE = "defaultLanguageFormat";
        var sourceFormat = workspace.getLocalStorage(LANGUAGE_FORMAT_PREFERENCE) || "javascript";
        $scope.codeMirror = undefined;
        var options = {
            mode: {
                name: sourceFormat
            },
            onChange: function (codeMirror) {
                if (!$scope.codeMirror) {
                    $scope.codeMirror = codeMirror;
                }
            }
        };
        $scope.codeMirrorOptions = CodeEditor.createEditorSettings(options);
        $scope.addHeader = function () {
            $scope.headers.push({ name: "", value: "" });
            if ($element) {
                $timeout(function () {
                    var lastHeader = $element.find("input.headerName").last();
                    lastHeader.focus();
                }, 100);
            }
        };
        $scope.removeHeader = function (header) {
            $scope.headers = $scope.headers.remove(header);
        };
        $scope.defaultHeaderNames = function () {
            var answer = [];
            function addHeaderSchema(schema) {
                angular.forEach(schema.definitions.headers.properties, function (value, name) {
                    answer.push(name);
                });
            }
            if (isJmsEndpoint()) {
                addHeaderSchema(Camel.jmsHeaderSchema);
            }
            if (isCamelEndpoint()) {
                addHeaderSchema(Camel.camelHeaderSchema);
            }
            return answer;
        };
        $scope.$watch('workspace.selection', function () {
            workspace.moveIfViewInvalid();
            if (Fabric.fabricCreated(workspace)) {
                loadProfileConfigurationFiles();
            }
        });
        $scope.$watch('codeMirrorOptions.mode.name', function (newValue, oldValue) {
            workspace.setLocalStorage(LANGUAGE_FORMAT_PREFERENCE, newValue);
        });
        var sendWorked = function () {
            $scope.message = "";
            Core.notification("success", "Message sent!");
        };
        $scope.autoFormat = function () {
            setTimeout(function () {
                CodeEditor.autoFormatEditor($scope.codeMirror);
            }, 50);
        };
        $scope.sendMessage = function () {
            var body = $scope.message;
            doSendMessage(body, sendWorked);
        };
        function doSendMessage(body, onSendCompleteFn) {
            var selection = workspace.selection;
            if (selection) {
                var mbean = selection.objectName;
                if (mbean) {
                    var headers = null;
                    if ($scope.headers.length) {
                        headers = {};
                        angular.forEach($scope.headers, function (object) {
                            var key = object.name;
                            if (key) {
                                headers[key] = object.value;
                            }
                        });
                        log.info("About to send headers: " + JSON.stringify(headers));
                    }
                    var callback = onSuccess(onSendCompleteFn);
                    if (selection.domain === "org.apache.camel") {
                        var target = Camel.getContextAndTargetEndpoint(workspace);
                        var uri = target['uri'];
                        mbean = target['mbean'];
                        if (mbean && uri) {
                            var ok = true;
                            if (Camel.isCamelVersionEQGT(2, 14, workspace, jolokia)) {
                                var reply = jolokia.execute(mbean, "canSendToEndpoint(java.lang.String)", uri);
                                if (!reply) {
                                    Core.notification("warning", "Camel does not support sending to this endpoint.");
                                    ok = false;
                                }
                            }
                            if (ok) {
                                if (headers) {
                                    jolokia.execute(mbean, "sendBodyAndHeaders(java.lang.String, java.lang.Object, java.util.Map)", uri, body, headers, callback);
                                }
                                else {
                                    jolokia.execute(mbean, "sendStringBody(java.lang.String, java.lang.String)", uri, body, callback);
                                }
                            }
                        }
                        else {
                            if (!mbean) {
                                Core.notification("error", "Could not find CamelContext MBean!");
                            }
                            else {
                                Core.notification("error", "Failed to determine endpoint name!");
                            }
                            log.debug("Parsed context and endpoint: ", target);
                        }
                    }
                    else {
                        var user = localStorage["activemqUserName"];
                        var pwd = localStorage["activemqPassword"];
                        if (!headers) {
                            headers = {};
                        }
                        if (!headers["JMSDeliveryMode"]) {
                            headers["JMSDeliveryMode"] = DELIVERY_PERSISTENT;
                        }
                        jolokia.execute(mbean, "sendTextMessage(java.util.Map, java.lang.String, java.lang.String, java.lang.String)", headers, body, user, pwd, callback);
                    }
                }
            }
        }
        $scope.fileSelection = function () {
            var answer = [];
            angular.forEach($scope.selectedFiles, function (value, key) {
                if (value) {
                    answer.push(key);
                }
            });
            return answer;
        };
        $scope.sendSelectedFiles = function () {
            var filesToSend = $scope.fileSelection();
            var fileCount = filesToSend.length;
            var version = $scope.container.versionId || "1.0";
            function onSendFileCompleted(response) {
                if (filesToSend.length) {
                    var fileName = filesToSend.pop();
                    if (fileName) {
                        var profile = $scope.profileFileNameToProfileId[fileName];
                        if (profile) {
                            var body = Fabric.getConfigFile(jolokia, version, profile, fileName);
                            if (!body) {
                                log.warn("No body for message " + fileName);
                                body = "";
                            }
                            doSendMessage(body, onSendFileCompleted);
                        }
                    }
                }
                else {
                    var text = Core.maybePlural(fileCount, "Message") + " sent!";
                    Core.notification("success", text);
                }
            }
            onSendFileCompleted(null);
        };
        function isCamelEndpoint() {
            return true;
        }
        function isJmsEndpoint() {
            return true;
        }
        function loadProfileConfigurationFiles() {
            if (Fabric.fabricCreated(workspace)) {
                $scope.container = Fabric.getCurrentContainer(jolokia, ['versionId', 'profileIds']);
                jolokia.execute(Fabric.managerMBean, "currentContainerConfigurationFiles", onSuccess(onFabricConfigFiles));
            }
        }
        function onFabricConfigFiles(response) {
            $scope.profileFileNameToProfileId = response;
            $scope.profileFileNames = Object.keys(response).filter(function (key) {
                return key.toLowerCase().startsWith('data/');
            }).sort();
            $scope.showChoose = $scope.profileFileNames.length ? true : false;
            $scope.selectedFiles = {};
            Core.$apply($scope);
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.SourceController", ["$scope", "workspace", function ($scope, workspace) {
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateRoutes, 50);
        });
        $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid())
                return;
            updateRoutes();
        });
        $scope.mode = 'xml';
        function getSource(routeXmlNode) {
            function removeCrappyHeaders(idx, e) {
                var answer = e.getAttribute("customId");
                if (e.nodeName === 'route') {
                    answer = "true";
                }
                if (!answer || answer !== "true") {
                    e.removeAttribute("id");
                }
                e.removeAttribute("customId");
                e.removeAttribute("_cid");
                e.removeAttribute("group");
            }
            var copy = $(routeXmlNode).clone();
            copy.each(removeCrappyHeaders);
            copy.find("*").each(removeCrappyHeaders);
            var newNode = (copy && copy.length) ? copy[0] : routeXmlNode;
            return Core.xmlNodeToString(newNode);
        }
        function updateRoutes() {
            var routeXmlNode = Camel.getSelectedRouteNode(workspace);
            if (routeXmlNode) {
                $scope.source = getSource(routeXmlNode);
                Core.$apply($scope);
            }
            else {
                $scope.mbean = Camel.getSelectionCamelContextMBean(workspace);
                if (!$scope.mbean) {
                    var parent = Core.pathGet(workspace, ["selection", "parent"]);
                    if (parent && parent.title === "context") {
                        $scope.mbean = parent.children[0].objectName;
                    }
                }
                if ($scope.mbean) {
                    var jolokia = workspace.jolokia;
                    jolokia.request({ type: 'exec', mbean: $scope.mbean, operation: 'dumpRoutesAsXml()' }, onSuccess(populateTable));
                }
            }
        }
        var populateTable = function (response) {
            var data = response.value;
            var selectedRouteId = Camel.getSelectedRouteId(workspace);
            if (data && selectedRouteId) {
                var doc = $.parseXML(data);
                var routes = $(doc).find('route[id="' + selectedRouteId + '"]');
                if (routes && routes.length) {
                    var selectedRoute = routes[0];
                    var routeXml = getSource(selectedRoute);
                    if (routeXml) {
                        data = routeXml;
                    }
                }
            }
            $scope.source = data;
            Core.$apply($scope);
        };
        var saveWorked = function () {
            Core.notification("success", "Route updated!");
            Camel.clearSelectedRouteNode(workspace);
            updateRoutes();
        };
        $scope.saveRouteXml = function () {
            var routeXml = $scope.source;
            if (routeXml) {
                var decoded = decodeURIComponent(routeXml);
                Camel.log.debug("addOrUpdateRoutesFromXml xml decoded: " + decoded);
                var jolokia = workspace.jolokia;
                var mbean = Camel.getSelectionCamelContextMBean(workspace);
                if (mbean) {
                    jolokia.execute(mbean, "addOrUpdateRoutesFromXml(java.lang.String)", decoded, onSuccess(saveWorked));
                }
                else {
                    Core.notification("error", "Could not find CamelContext MBean!");
                }
            }
        };
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.TraceRouteController", ["$scope", "workspace", "jolokia", "localStorage", "tracerStatus", function ($scope, workspace, jolokia, localStorage, tracerStatus) {
        var log = Logger.get("CamelTracer");
        $scope.tracing = false;
        $scope.messages = [];
        $scope.graphView = null;
        $scope.tableView = null;
        $scope.mode = 'text';
        $scope.messageDialog = new UI.Dialog();
        $scope.gridOptions = Camel.createBrowseGridOptions();
        $scope.gridOptions.selectWithCheckboxOnly = false;
        $scope.gridOptions.showSelectionCheckbox = false;
        $scope.gridOptions.multiSelect = false;
        $scope.gridOptions.afterSelectionChange = onSelectionChanged;
        $scope.gridOptions.columnDefs.push({
            field: 'toNode',
            displayName: 'To Node'
        });
        $scope.startTracing = function () {
            log.info("Start tracing");
            setTracing(true);
        };
        $scope.stopTracing = function () {
            log.info("Stop tracing");
            setTracing(false);
        };
        $scope.clear = function () {
            log.debug("Clear messages");
            tracerStatus.messages = [];
            $scope.messages = [];
            Core.$apply($scope);
        };
        $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid()) {
                return;
            }
            $scope.messages = tracerStatus.messages;
            reloadTracingFlag();
        });
        $scope.openMessageDialog = function (message) {
            var idx = Core.pathGet(message, ["rowIndex"]);
            $scope.selectRowIndex(idx);
            if ($scope.row) {
                $scope.mode = CodeEditor.detectTextFormat($scope.row.body);
                $scope.messageDialog.open();
            }
        };
        $scope.selectRowIndex = function (idx) {
            $scope.rowIndex = idx;
            var selected = $scope.gridOptions.selectedItems;
            selected.splice(0, selected.length);
            if (idx >= 0 && idx < $scope.messages.length) {
                $scope.row = $scope.messages[idx];
                if ($scope.row) {
                    selected.push($scope.row);
                }
            }
            else {
                $scope.row = null;
            }
            onSelectionChanged();
        };
        function reloadTracingFlag() {
            $scope.tracing = false;
            if (tracerStatus.jhandle != null) {
                log.debug("Unregistering jolokia handle");
                jolokia.unregister(tracerStatus.jhandle);
                tracerStatus.jhandle = null;
            }
            var mbean = Camel.getSelectionCamelTraceMBean(workspace);
            if (mbean) {
                $scope.tracing = jolokia.getAttribute(mbean, "Enabled", onSuccess(null));
                if ($scope.tracing) {
                    var traceMBean = mbean;
                    if (traceMBean) {
                        if (tracerStatus.jhandle === null) {
                            log.debug("Registering jolokia handle");
                            tracerStatus.jhandle = jolokia.register(populateRouteMessages, {
                                type: 'exec',
                                mbean: traceMBean,
                                operation: 'dumpAllTracedMessagesAsXml()',
                                ignoreErrors: true,
                                arguments: []
                            });
                        }
                    }
                    $scope.graphView = "app/camel/html/routes.html";
                    $scope.tableView = "app/camel/html/browseMessages.html";
                }
                else {
                    tracerStatus.messages = [];
                    $scope.messages = [];
                    $scope.graphView = null;
                    $scope.tableView = null;
                }
            }
        }
        function populateRouteMessages(response) {
            log.debug("Populating response " + response);
            var selectedRouteId = Camel.getSelectedRouteId(workspace);
            var xml = response.value;
            if (angular.isString(xml)) {
                var doc = $.parseXML(xml);
                var allMessages = $(doc).find("fabricTracerEventMessage");
                if (!allMessages || !allMessages.length) {
                    allMessages = $(doc).find("backlogTracerEventMessage");
                }
                allMessages.each(function (idx, message) {
                    var routeId = $(message).find("routeId").text();
                    if (routeId === selectedRouteId) {
                        var messageData = Camel.createMessageFromXml(message);
                        var toNode = $(message).find("toNode").text();
                        if (toNode) {
                            messageData["toNode"] = toNode;
                        }
                        log.debug("Adding new message to trace table with id " + messageData["id"]);
                        $scope.messages.push(messageData);
                    }
                });
                tracerStatus.messages = $scope.messages;
                Core.$apply($scope);
            }
        }
        function onSelectionChanged() {
            angular.forEach($scope.gridOptions.selectedItems, function (selected) {
                if (selected) {
                    var toNode = selected["toNode"];
                    if (toNode) {
                        var nodes = d3.select("svg").selectAll("g .node");
                        Camel.highlightSelectedNode(nodes, toNode);
                    }
                }
            });
        }
        function tracingChanged(response) {
            reloadTracingFlag();
            Core.$apply($scope);
        }
        function setTracing(flag) {
            var mbean = Camel.getSelectionCamelTraceMBean(workspace);
            if (mbean) {
                if (mbean.toString().endsWith("BacklogTracer")) {
                    var max = Camel.maximumTraceOrDebugBodyLength(localStorage);
                    var streams = Camel.traceOrDebugIncludeStreams(localStorage);
                    jolokia.setAttribute(mbean, "BodyMaxChars", max);
                    jolokia.setAttribute(mbean, "BodyIncludeStreams", streams);
                    jolokia.setAttribute(mbean, "BodyIncludeFiles", streams);
                }
                jolokia.setAttribute(mbean, "Enabled", flag, onSuccess(tracingChanged));
            }
        }
        log.info("Re-activating tracer with " + tracerStatus.messages.length + " existing messages");
        $scope.messages = tracerStatus.messages;
        $scope.tracing = tracerStatus.jhandle != null;
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.TreeHeaderController", ["$scope", "$location", function ($scope, $location) {
        $scope.contextFilterText = '';
        $scope.$watch('contextFilterText', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.$emit("camel-contextFilterText", newValue);
            }
        });
        $scope.expandAll = function () {
            Tree.expandAll("#cameltree");
        };
        $scope.contractAll = function () {
            Tree.contractAll("#cameltree");
        };
    }]);
    Camel._module.controller("Camel.TreeController", ["$scope", "$location", "$timeout", "workspace", "$rootScope", function ($scope, $location, $timeout, workspace, $rootScope) {
        $scope.contextFilterText = $location.search()["cq"];
        $scope.fullScreenViewLink = Camel.linkToFullScreenView(workspace);
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateSelectionFromURL, 50);
        });
        var reloadThrottled = Core.throttled(reloadFunction, 500);
        $scope.$watch('workspace.tree', function () {
            reloadThrottled();
        });
        var reloadOnContextFilterThrottled = Core.throttled(function () {
            reloadFunction(function () {
                $("#camelContextIdFilter").focus();
            });
        }, 500);
        $scope.$watch('contextFilterText', function () {
            if ($scope.contextFilterText != $scope.lastContextFilterText) {
                $timeout(reloadOnContextFilterThrottled, 250);
            }
        });
        $rootScope.$on('camel-contextFilterText', function (event, value) {
            $scope.contextFilterText = value;
        });
        $scope.$on('jmxTreeUpdated', function () {
            reloadThrottled();
        });
        function reloadFunction(afterSelectionFn) {
            if (afterSelectionFn === void 0) { afterSelectionFn = null; }
            $scope.fullScreenViewLink = Camel.linkToFullScreenView(workspace);
            var children = [];
            var domainName = Camel.jmxDomain;
            var tree = workspace.tree;
            if (tree) {
                var rootFolder = new Folder("Camel Contexts");
                rootFolder.addClass = "org-apache-camel-context-folder";
                rootFolder.children = children;
                rootFolder.typeName = "context";
                rootFolder.key = "camelContexts";
                rootFolder.domain = domainName;
                var contextFilterText = $scope.contextFilterText;
                $scope.lastContextFilterText = contextFilterText;
                Camel.log.debug("Reloading the tree for filter: " + contextFilterText);
                var folder = tree.get(domainName);
                if (folder) {
                    angular.forEach(folder.children, function (value, key) {
                        var entries = value.map;
                        if (entries) {
                            var contextsFolder = entries["context"];
                            var routesNode = entries["routes"];
                            var endpointsNode = entries["endpoints"];
                            if (contextsFolder) {
                                var contextNode = contextsFolder.children[0];
                                if (contextNode) {
                                    var title = contextNode.title;
                                    var match = Core.matchFilterIgnoreCase(title, contextFilterText);
                                    if (match) {
                                        var folder = new Folder(title);
                                        folder.addClass = "org-apache-camel-context";
                                        folder.domain = domainName;
                                        folder.objectName = contextNode.objectName;
                                        folder.entries = contextNode.entries;
                                        folder.typeName = contextNode.typeName;
                                        folder.key = contextNode.key;
                                        folder.version = contextNode.version;
                                        if (routesNode) {
                                            var routesFolder = new Folder("Routes");
                                            routesFolder.addClass = "org-apache-camel-routes-folder";
                                            routesFolder.parent = contextsFolder;
                                            routesFolder.children = routesNode.children;
                                            angular.forEach(routesFolder.children, function (n) { return n.addClass = "org-apache-camel-routes"; });
                                            folder.children.push(routesFolder);
                                            routesFolder.typeName = "routes";
                                            routesFolder.key = routesNode.key;
                                            routesFolder.domain = routesNode.domain;
                                        }
                                        if (endpointsNode) {
                                            var endpointsFolder = new Folder("Endpoints");
                                            endpointsFolder.addClass = "org-apache-camel-endpoints-folder";
                                            endpointsFolder.parent = contextsFolder;
                                            endpointsFolder.children = endpointsNode.children;
                                            angular.forEach(endpointsFolder.children, function (n) {
                                                n.addClass = "org-apache-camel-endpoints";
                                                if (!Camel.getContextId(n)) {
                                                    n.entries["context"] = contextNode.entries["context"];
                                                }
                                            });
                                            folder.children.push(endpointsFolder);
                                            endpointsFolder.entries = contextNode.entries;
                                            endpointsFolder.typeName = "endpoints";
                                            endpointsFolder.key = endpointsNode.key;
                                            endpointsFolder.domain = endpointsNode.domain;
                                        }
                                        var jmxNode = new Folder("MBeans");
                                        angular.forEach(entries, function (jmxChild, name) {
                                            if (name !== "context" && name !== "routes" && name !== "endpoints") {
                                                jmxNode.children.push(jmxChild);
                                            }
                                        });
                                        if (jmxNode.children.length > 0) {
                                            jmxNode.sortChildren(false);
                                            folder.children.push(jmxNode);
                                        }
                                        folder.parent = rootFolder;
                                        children.push(folder);
                                    }
                                }
                            }
                        }
                    });
                }
                var treeElement = $("#cameltree");
                Jmx.enableTree($scope, $location, workspace, treeElement, [rootFolder], true);
                setTimeout(function () {
                    updateSelectionFromURL();
                    if (angular.isFunction(afterSelectionFn)) {
                        afterSelectionFn();
                    }
                }, 50);
            }
        }
        function updateSelectionFromURL() {
            Jmx.updateTreeSelectionFromURLAndAutoSelect($location, $("#cameltree"), function (first) {
                var contexts = first.getChildren();
                if (contexts && contexts.length === 1) {
                    first = contexts[0];
                    first.expand(true);
                    var children = first.getChildren();
                    if (children && children.length) {
                        var routes = children[0];
                        if (routes.data.typeName === 'routes') {
                            first = routes;
                            return first;
                        }
                    }
                }
                return null;
            }, true);
            $scope.fullScreenViewLink = Camel.linkToFullScreenView(workspace);
        }
    }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.TypeConverterController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.data = [];
        $scope.selectedMBean = null;
        $scope.mbeanAttributes = {};
        var columnDefs = [
            {
                field: 'from',
                displayName: 'From',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'to',
                displayName: 'To',
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        $scope.gridOptions = {
            data: 'data',
            displayFooter: true,
            displaySelectionCheckbox: false,
            canSelectRows: false,
            enableSorting: true,
            columnDefs: columnDefs,
            selectedItems: [],
            filterOptions: {
                filterText: ''
            }
        };
        function onAttributes(response) {
            var obj = response.value;
            if (obj) {
                $scope.mbeanAttributes = obj;
                Core.$apply($scope);
            }
        }
        function onConverters(response) {
            var obj = response.value;
            if (obj) {
                var arr = [];
                for (var key in obj) {
                    var values = obj[key];
                    for (var v in values) {
                        arr.push({ from: key, to: v });
                    }
                }
                arr = arr.sortBy("from");
                $scope.data = arr;
                $scope.selectedMBean = response.request.mbean;
                Core.$apply($scope);
            }
        }
        $scope.renderIcon = function (state) {
            return Camel.iconClass(state);
        };
        $scope.disableStatistics = function () {
            if ($scope.selectedMBean) {
                jolokia.setAttribute($scope.selectedMBean, "StatisticsEnabled", false);
            }
        };
        $scope.enableStatistics = function () {
            if ($scope.selectedMBean) {
                jolokia.setAttribute($scope.selectedMBean, "StatisticsEnabled", true);
            }
        };
        $scope.resetStatistics = function () {
            if ($scope.selectedMBean) {
                jolokia.request({ type: 'exec', mbean: $scope.selectedMBean, operation: 'resetTypeConversionCounters' }, onSuccess(null, { silent: true }));
            }
        };
        function loadConverters() {
            console.log("Loading TypeConverter data...");
            var mbean = Camel.getSelectionCamelTypeConverter(workspace);
            if (mbean) {
                var query = { type: "read", mbean: mbean, attribute: ["AttemptCounter", "FailedCounter", "HitCounter", "MissCounter", "NumberOfTypeConverters", "StatisticsEnabled"] };
                jolokia.request(query, onSuccess(onAttributes));
                scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(onAttributes, query));
                jolokia.request({ type: 'exec', mbean: mbean, operation: 'listTypeConverters' }, onSuccess(onConverters));
            }
        }
        loadConverters();
    }]);
})(Camel || (Camel = {}));
var Camin;
(function (Camin) {
    var pluginName = 'camin';
    Camin._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ngGrid', 'hawtioCore', 'elasticjs.service']);
    Camin._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/camin', { templateUrl: 'app/camin/html/camin.html' }).when('/camin/:exchangeId', { templateUrl: 'app/camin/html/camin.html' });
    }]);
    Camin._module.run(["workspace", "viewRegistry", "helpRegistry", function (workspace, viewRegistry, helpRegistry) {
        viewRegistry["camin"] = "app/camin/html/layoutCamin.html";
        helpRegistry.addUserDoc('camin', 'app/camin/doc/help.md', function () {
            return Fabric.hasFabric(workspace);
        });
        workspace.topLevelTabs.push({
            id: "camin",
            content: "Camel",
            title: "Insight into Camel",
            isValid: function (workspace) { return Fabric.hasFabric(workspace); },
            href: function () { return "#/camin"; },
            isActive: function (workspace) { return workspace.isLinkActive("camin"); }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Camin || (Camin = {}));
var Camin;
(function (Camin) {
    Camin._module.controller("Camin.Controller", ["$scope", "jolokia", "localStorage", "$routeParams", "ejsResource", function ($scope, jolokia, localStorage, $routeParams, ejsResource) {
        $scope.query = "";
        $scope.breadcrumbs = [];
        $scope.onQueryChange = function () {
            $scope.breadcrumbs = [$scope.query];
            searchRequest();
        };
        var log = Logger.get("Camin");
        var esUrl = new Jolokia(Core.getJolokiaUrl()).execute("io.fabric8.insight:type=Elasticsearch", "getRestUrl", "insight");
        var esClient = ejsResource(esUrl);
        var searchRequest = function () {
            var queryStr = "exchange.id:\"" + $scope.breadcrumbs.join("\" OR exchange.id:\"") + "\" OR " + "exchange.in.headers.ExtendedBreadcrumb:\"" + $scope.breadcrumbs.join("\" OR exchange.in.headers.ExtendedBreadcrumb:\"") + "\" OR " + "exchange.out.headers.ExtendedBreadcrumb:\"" + $scope.breadcrumbs.join("\" OR exchange.out.headers.ExtendedBreadcrumb:\"") + "\"";
            var request = ejs.Request().types('camel');
            var searchPromise = request.from(0).size(1000).query(ejs.QueryStringQuery(queryStr)).doSearch();
            searchPromise.then(function (data) {
                if (!(angular.isUndefined(data.error))) {
                    log.error(data.error);
                    return;
                }
                log.debug("Results", data);
                var oldsize = $scope.breadcrumbs.length;
                for (var i = 0; i < data.hits.hits.length; i++) {
                    var concat = function (breadcrumbs) {
                        if (breadcrumbs) {
                            if (typeof breadcrumbs === 'string') {
                                breadcrumbs = [breadcrumbs];
                            }
                            for (var j = 0; j < breadcrumbs.length; j++) {
                                var id = breadcrumbs[j];
                                if ($scope.breadcrumbs.indexOf(id) < 0) {
                                    $scope.breadcrumbs.push(id);
                                }
                            }
                        }
                    };
                    if (angular.isDefined(data.hits.hits[i]._source.exchange.in)) {
                        concat(data.hits.hits[i]._source.exchange.in.headers.ExtendedBreadcrumb);
                    }
                    if (angular.isDefined(data.hits.hits[i]._source.exchange.out)) {
                        concat(data.hits.hits[i]._source.exchange.out.headers.ExtendedBreadcrumb);
                    }
                }
                log.debug("Found " + data.hits.total + " ids");
                if (oldsize != $scope.breadcrumbs.length) {
                    searchRequest();
                }
                else {
                    var ids = [];
                    for (var i = 0; i < data.hits.hits.length; i++) {
                        var id = data.hits.hits[i]._id;
                        if (ids.indexOf(id) < 0) {
                            ids.push(id);
                        }
                    }
                    var idSearchRequest = ejs.Request().types('camel');
                    var idSearchPromise = idSearchRequest.from(0).size(1000).query(ejs.MatchAllQuery()).filter(ejs.IdsFilter(ids)).sort('@timestamp').doSearch();
                    idSearchPromise.then(function (data) {
                        if (!(angular.isUndefined(data.error))) {
                            log.error(data.error);
                            return;
                        }
                        log.debug("Found " + data.hits.total + " exchanges");
                        var events = [];
                        for (var i = 0; i < data.hits.hits.length; i++) {
                            var e = data.hits.hits[i]._source;
                            events.push(e);
                        }
                        draw(events);
                    });
                }
            });
        };
        var isoDate = function (date) {
            var timestamp, struct, minutesOffset = 0;
            var numericKeys = [1, 4, 5, 6, 7, 10, 11];
            if ((struct = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/.exec(date))) {
                for (var i = 0, k; (k = numericKeys[i]); ++i) {
                    struct[k] = +struct[k] || 0;
                }
                struct[2] = (+struct[2] || 1) - 1;
                struct[3] = +struct[3] || 1;
                if (struct[8] !== 'Z' && struct[9] !== undefined) {
                    minutesOffset = struct[10] * 60 + struct[11];
                    if (struct[9] === '+') {
                        minutesOffset = 0 - minutesOffset;
                    }
                }
                timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
            }
            else {
                timestamp = Date.parse(date);
            }
            return timestamp;
        };
        var buildSequence = function (events) {
            var sequence = new Camin.Sequence();
            var exchangeToExec = {};
            events = events.sort(function (a, b) {
                return isoDate(a['@timestamp']) - isoDate(b['@timestamp']);
            });
            for (var i = 0; i < events.length; i++) {
                if (events[i].event === 'Created') {
                    var evtCreated = events[i];
                    var evtCompleted = _.find(events, function (value, index) {
                        return value.event === 'Completed' && evtCreated.exchange.id === value.exchange.id;
                    });
                    if (evtCompleted === null) {
                        log.debug('Could not find matching Completed exchange for ' + evtCreated.exchange.id);
                        continue;
                    }
                    var endpoint = sequence.endpoint(evtCompleted.exchange.fromEndpoint, evtCompleted.exchange.routeId, evtCompleted.exchange.contextId, evtCompleted.host);
                    var exec = sequence.exec(evtCreated.exchange.id, endpoint, isoDate(evtCreated['@timestamp']), isoDate(evtCompleted['@timestamp']));
                    exchangeToExec[evtCreated.exchange.id] = exec;
                }
            }
            var calls = {};
            for (var i = 0; i < events.length; i++) {
                if (events[i].event === 'Sending' && events[i].exchange.in && events[i].exchange.in.headers) {
                    var callId = events[i].exchange.in.headers.AuditCallId;
                    if (callId && calls[callId] === undefined) {
                        var evtSending = events[i];
                        var evtSent = _.find(events, function (value, index) {
                            return value.event === 'Sent' && evtSending.exchange.id === value.exchange.id && value.exchange.in.headers.AuditCallId === callId;
                        });
                        var evtCreated = _.find(events, function (value, index) {
                            return value.event === 'Created' && evtSending.exchange.id !== value.exchange.id && value.exchange.in.headers.AuditCallId === callId;
                        });
                        var execA = exchangeToExec[evtSending.exchange.id];
                        var execB = evtCreated ? exchangeToExec[evtCreated.exchange.id] : null;
                        if (evtSent !== null && evtCreated !== null && execA !== null && execB != null) {
                            var call = sequence.call(callId, execA, execB, isoDate(evtSending['@timestamp']), isoDate(evtSent['@timestamp']));
                            calls[callId] = call;
                        }
                        else {
                            log.debug("Could not find Execution for exchange " + evtSending.exchange.id);
                        }
                    }
                }
            }
            return sequence;
        };
        var buildDiagram = function (sequence) {
            var diagram = new Camin.Diagram();
            var actors = {};
            var signals = [];
            var base = sequence.start();
            for (var i = 0; i < sequence.endpoints.length; i++) {
                var actor = diagram.actor("ep" + i);
                var ep = sequence.endpoints[i];
                var key = ep.url + "|" + ep.routeId + "|" + ep.contextId + "|" + ep.host;
                actors[key] = actor;
            }
            for (var i = 0; i < sequence.calls.length; i++) {
                var call = sequence.calls[i];
                if (call.execB) {
                    var epA = call.execA.endpoint;
                    var keyA = epA.url + "|" + epA.routeId + "|" + epA.contextId + "|" + epA.host;
                    var epB = call.execB.endpoint;
                    var keyB = epB.url + "|" + epB.routeId + "|" + epB.contextId + "|" + epB.host;
                    var actorA = actors[keyA];
                    var actorB = actors[keyB];
                    var start1 = call.start - base;
                    var stop1 = call.execB.start - base;
                    var start2 = call.execB.stop - base;
                    var stop2 = call.stop - base;
                    signals.push({ actorA: actorA, actorB: actorB, message: start1 + "ms - " + stop1 + "ms", timestamp: start1 });
                    signals.push({ actorA: actorB, actorB: actorA, message: start2 + "ms - " + stop2 + "ms", timestamp: start2 });
                }
            }
            signals = signals.sort(function (a, b) {
                return a['@timestamp'] - b['@timestamp'];
            });
            for (var i = 0; i < signals.length; i++) {
                diagram.signal(signals[i].actorA, signals[i].actorB, signals[i].message);
            }
            return diagram;
        };
        var buildGantt = function (sequence) {
            var gantt = new Camin.Gantt();
            for (var i = 0; i < sequence.endpoints.length; i++) {
                var endpoint = sequence.endpoints[i];
                var resource = gantt.resource(endpoint);
                for (var j = 0; j < sequence.execs.length; j++) {
                    var exec = sequence.execs[j];
                    if (exec.endpoint === endpoint) {
                        gantt.task(resource, exec.start, exec.stop, exec);
                    }
                }
            }
            for (var i = 0; i < sequence.calls.length; i++) {
                var call = sequence.calls[i];
                if (call.execB) {
                    var taskA = gantt.taskByData(call.execA);
                    var taskB = gantt.taskByData(call.execB);
                    gantt.link(call.start, taskA, call.stop, taskB, call);
                }
            }
            gantt.layout();
            return gantt;
        };
        var eventTypeValue = { "Created": 0, "Sending": 1, "Sent": 2, "Completed": 3 };
        var draw = function (events) {
            $scope.definition = "";
            events = events.sort(function (a, b) {
                return isoDate(a['@timestamp']) - isoDate(b['@timestamp']);
            });
            log.debug("Events", events);
            var sequence = buildSequence(events);
            log.debug("Sequence", sequence);
            var gantt = buildGantt(sequence);
            log.debug("Gantt", gantt);
            $('#gantt').html('');
            drawGantt('#gantt', gantt);
            var diagram = buildDiagram(sequence);
            log.debug("Diagram", diagram);
            $('#diagram').html('');
            drawDiagram('#diagram', diagram);
        };
        var drawDiagram = function (container, diagram) {
            var arrow_size = 10;
            var margin = 10;
            var actor_width = 100;
            var actor_margin = 30;
            var actor_height = 40;
            var signal_height = 30;
            var actor_font = 20;
            var signal_font = 14;
            var width = diagram.actors.length * (actor_width + actor_margin * 2);
            var height = (diagram.signals.length + 1) * signal_height + actor_height * 2 + margin * 2;
            var svg = d3.select(container).append('svg').attr('width', width + 2 * margin).attr('height', height + 2 * margin);
            var g = svg.append('g').attr('text-anchor', 'middle');
            for (var i = 0; i < diagram.actors.length; i++) {
                var actor = diagram.actors[i];
                var gu = g.append('g').attr('transform', 'translate(' + (i * (actor_width + actor_margin * 2) + actor_margin) + ',' + actor_height + ')');
                gu.append('rect').attr('width', actor_width).attr('height', actor_height).attr('stroke', '#000').attr('stroke-width', '2').attr('fill', '#FFFFFF');
                gu.append('text').attr('x', actor_width / 2).attr('y', actor_height / 2).attr('stroke-width', '0').attr('dominant-baseline', 'middle').attr('font-size', actor_font).text(actor.name);
                g.append('line').attr('x1', i * (actor_width + actor_margin * 2) + actor_width / 2 + actor_margin).attr('y1', actor_height * 2).attr('x2', i * (actor_width + actor_margin * 2) + actor_width / 2 + actor_margin).attr('y2', height - actor_height).attr('stroke', '#000').attr('stroke-width', '2');
                var gu = g.append('g').attr('transform', 'translate(' + (i * (actor_width + actor_margin * 2) + actor_margin) + ',' + (height - actor_height) + ')');
                gu.append('rect').attr('width', actor_width).attr('height', actor_height).attr('stroke', '#000').attr('stroke-width', '2').attr('fill', 'white');
                gu.append('text').attr('x', actor_width / 2).attr('y', actor_height / 2).attr('stroke-width', '0').attr('dominant-baseline', 'middle').attr('font-size', actor_font).text(actor.name);
            }
            for (var i = 0; i < diagram.signals.length; i++) {
                var x;
                var y;
                var length;
                var direction;
                var text;
                x = diagram.signals[i].actorA.index * (actor_width + actor_margin * 2) + actor_width / 2 + actor_margin;
                y = (i + 1) * signal_height + actor_height * 2;
                length = Math.abs(diagram.signals[i].actorA.index - diagram.signals[i].actorB.index) * (actor_width + actor_margin * 2);
                direction = diagram.signals[i].actorB.index > diagram.signals[i].actorA.index ? +1 : -1;
                text = diagram.signals[i].message;
                var gu = g.append('g').attr('transform', 'translate(' + x + ',' + y + ')').attr('stroke-width', '2');
                gu.append('rect').attr('x', Math.min(3, length * direction + 3)).attr('y', '-16').attr('width', Math.abs((length - 6) * direction)).attr('height', '19').attr('stroke', 'white').attr('stroke-width', '0').attr('fill', 'white');
                gu.append('line').attr('x1', 0).attr('y1', 0).attr('x2', length * direction).attr('y2', 0).attr('stroke', '#000').attr('stroke-width', '2');
                gu.append('line').attr('x1', length * direction - arrow_size * direction).attr('y1', -arrow_size).attr('x2', length * direction).attr('y2', 0).attr('stroke', '#000').attr('stroke-width', '2');
                gu.append('line').attr('x1', length * direction).attr('y1', 0).attr('x2', length * direction - arrow_size * direction).attr('y2', arrow_size).attr('stroke', '#000').attr('stroke-width', '2');
                gu.append('text').attr('x', length * direction / 2).attr('y', -8).attr('stroke-width', '0').attr('dominant-baseline', 'middle').attr('font-size', signal_font).text(text);
            }
        };
        var drawGantt = function (container, gantt) {
            var lineHeight = 35;
            var lineMargin = 3;
            var arrowWidth = 4;
            var width = 800;
            var height = lineHeight * gantt.resources.length;
            var margin = {
                top: 20,
                right: 40,
                bottom: 20,
                left: 250
            };
            var begin = gantt.start;
            var end = gantt.stop;
            var x = d3.scale.linear().domain([begin - (end - begin) * 0.1, end + (end - begin) * 0.1]).range([0, width]);
            var yt = function (t) {
                return t.resource.index * lineHeight + lineMargin + t.index * (lineHeight - 2 * lineMargin) / (t.max + 1);
            };
            var ht = function (t) {
                return 2 * (lineHeight - 2 * lineMargin) / (t.max + 1);
            };
            var svg = d3.select(container).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom);
            var text = svg.append('g').attr('width', width).attr('height', height).attr('transform', 'translate(0,' + margin.top + ')').selectAll('text').data(gantt.resources).enter();
            text.append('text').attr('x', 0).attr('y', function (r) {
                return r.index * lineHeight + lineHeight / 2;
            }).attr('dy', '-0.2em').attr('text-anchor', 'start').text(function (r) {
                var endpoint = r.data;
                var text = endpoint.url;
                if (text.indexOf("Endpoint[") == 0) {
                    text = text.substring(9, text.length - 1);
                }
                return text;
            });
            text.append('text').attr('x', 0).attr('y', function (r) {
                return r.index * lineHeight + lineHeight / 2;
            }).attr('dy', '0.8em').attr('text-anchor', 'start').text(function (r) {
                var endpoint = r.data;
                return endpoint.host + "/" + endpoint.contextId + "/" + endpoint.routeId;
            });
            var g = svg.append('g').attr('width', width).attr('height', height).attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            g.append('g').attr('width', width).attr('height', height).selectAll('rect').data(gantt.tasks).enter().append('rect').attr('rx', lineMargin * 2).attr('ry', lineMargin * 2).attr('x', function (t) {
                return x(t.start);
            }).attr('y', yt).attr('height', ht).attr('width', function (t) {
                return x(t.stop) - x(t.start);
            }).attr('stroke', '#000000').attr('stroke-width', '2').attr('fill', function (t) {
                return d3.hsl(Math.random() * 360, 0.8, 0.8).toString();
            });
            var lines = g.append('g').attr('width', width).attr('height', height).attr('stroke', '#404040').attr('stroke-width', '2').selectAll('line').data(gantt.links).enter();
            lines.append('line').attr('x1', function (l) {
                return x(l.start);
            }).attr('y1', function (l) {
                return yt(l.taskA) + ht(l.taskA);
            }).attr('x2', function (l) {
                return x(l.start);
            }).attr('y2', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2;
            });
            lines.append('line').attr('x1', function (l) {
                return x(l.start);
            }).attr('y1', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2;
            }).attr('x2', function (l) {
                return x(l.taskB.start);
            }).attr('y2', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2;
            });
            lines.append('line').attr('x1', function (l) {
                return x(l.taskB.start);
            }).attr('y1', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2;
            }).attr('x2', function (l) {
                return x(l.taskB.start) - arrowWidth;
            }).attr('y2', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2 - arrowWidth;
            });
            lines.append('line').attr('x1', function (l) {
                return x(l.taskB.start);
            }).attr('y1', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2;
            }).attr('x2', function (l) {
                return x(l.taskB.start) - arrowWidth;
            }).attr('y2', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2 + arrowWidth;
            });
            lines.append('line').attr('x1', function (l) {
                return x(l.taskB.stop);
            }).attr('y1', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2;
            }).attr('x2', function (l) {
                return x(l.stop);
            }).attr('y2', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2;
            });
            lines.append('line').attr('x1', function (l) {
                return x(l.stop);
            }).attr('y1', function (l) {
                return yt(l.taskB) + ht(l.taskB) / 2;
            }).attr('x2', function (l) {
                return x(l.stop);
            }).attr('y2', function (l) {
                return yt(l.taskA) + ht(l.taskA);
            });
            lines.append('line').attr('x1', function (l) {
                return x(l.stop);
            }).attr('y1', function (l) {
                return yt(l.taskA) + ht(l.taskA);
            }).attr('x2', function (l) {
                return x(l.stop) - arrowWidth;
            }).attr('y2', function (l) {
                return yt(l.taskA) + ht(l.taskA) + arrowWidth;
            });
            lines.append('line').attr('x1', function (l) {
                return x(l.stop);
            }).attr('y1', function (l) {
                return yt(l.taskA) + ht(l.taskA);
            }).attr('x2', function (l) {
                return x(l.stop) + arrowWidth;
            }).attr('y2', function (l) {
                return yt(l.taskA) + ht(l.taskA) + arrowWidth;
            });
        };
        if ($routeParams["exchangeId"]) {
            $scope.query = $routeParams["exchangeId"];
            $scope.onQueryChange();
        }
    }]);
})(Camin || (Camin = {}));
var Camin;
(function (Camin) {
    var Diagram = (function () {
        function Diagram() {
            this.actors = [];
            this.signals = [];
        }
        Diagram.prototype.actor = function (name) {
            for (var i = 0; i < this.actors.length; i++) {
                if (this.actors[i].name === name) {
                    return this.actors[i];
                }
            }
            var actor = new Actor(name, this.actors.length);
            this.actors.push(actor);
            return actor;
        };
        Diagram.prototype.signal = function (actorA, actorB, message) {
            var signal = new Signal(actorA, actorB, message);
            this.signals.push(signal);
            return signal;
        };
        return Diagram;
    })();
    Camin.Diagram = Diagram;
    var Actor = (function () {
        function Actor(name, index) {
            this.name = name;
            this.index = index;
        }
        return Actor;
    })();
    Camin.Actor = Actor;
    var Signal = (function () {
        function Signal(actorA, actorB, message) {
            this.actorA = actorA;
            this.actorB = actorB;
            this.message = message;
        }
        Signal.prototype.isSelf = function () {
            return this.actorA.index === this.actorB.index;
        };
        return Signal;
    })();
    Camin.Signal = Signal;
})(Camin || (Camin = {}));
var Camin;
(function (Camin) {
    var Gantt = (function () {
        function Gantt() {
            this.resources = [];
            this.tasks = [];
            this.links = [];
        }
        Gantt.prototype.resource = function (data) {
            var resource = new Resource(data, this.resources.length);
            this.resources.push(resource);
            return resource;
        };
        Gantt.prototype.task = function (resource, start, stop, data) {
            var task = resource.task(start, stop, data);
            this.tasks.push(task);
            return task;
        };
        Gantt.prototype.link = function (start, taskA, stop, taskB, data) {
            var link = new Link(start, taskA, stop, taskB, data);
            this.links.push(link);
            return link;
        };
        Gantt.prototype.layout = function () {
            for (var i = 0; i < this.resources.length; i++) {
                this.resources[i].layout();
                this.start = this.start ? Math.min(this.start, this.resources[i].start) : this.resources[i].start;
                this.stop = this.stop ? Math.max(this.stop, this.resources[i].stop) : this.resources[i].stop;
            }
            for (var i = 0; i < this.links.length; i++) {
                this.start = this.start ? Math.min(this.start, this.links[i].start) : this.links[i].start;
                this.stop = this.stop ? Math.max(this.stop, this.links[i].stop) : this.links[i].stop;
            }
        };
        Gantt.prototype.taskByData = function (data) {
            for (var i = 0; i < this.tasks.length; i++) {
                if (this.tasks[i].data === data) {
                    return this.tasks[i];
                }
            }
            return undefined;
        };
        return Gantt;
    })();
    Camin.Gantt = Gantt;
    var Resource = (function () {
        function Resource(data, index) {
            this.tasks = [];
            this.index = index;
            this.data = data;
        }
        Resource.prototype.task = function (start, stop, data) {
            var task = new Task(start, stop, data, this);
            this.tasks.push(task);
            return task;
        };
        Resource.prototype.layout = function () {
            this.tasks.sort(function (ta, tb) {
                return ta.start - tb.start;
            });
            var bands = [];
            for (var i = 0; i < this.tasks.length; i++) {
                this.start = this.start ? Math.min(this.start, this.tasks[i].start) : this.tasks[i].start;
                this.stop = this.stop ? Math.max(this.stop, this.tasks[i].stop) : this.tasks[i].stop;
                for (var j = 0; j < bands.length; j++) {
                    if (bands[j] < this.tasks[i].start) {
                        bands[j] = this.tasks[i].stop;
                        this.tasks[i].index = j;
                        break;
                    }
                }
                if (!this.tasks[i].index) {
                    var index = bands.length;
                    this.tasks[i].index = index;
                    bands[index] = this.tasks[i].stop;
                }
            }
            for (var i = 0; i < this.tasks.length; i++) {
                this.tasks[i].max = bands.length;
            }
        };
        return Resource;
    })();
    Camin.Resource = Resource;
    var Task = (function () {
        function Task(start, stop, data, resource) {
            this.start = start;
            this.stop = stop;
            this.data = data;
            this.resource = resource;
        }
        return Task;
    })();
    Camin.Task = Task;
    var Link = (function () {
        function Link(start, taskA, stop, taskB, data) {
            this.start = start;
            this.stop = stop;
            this.taskA = taskA;
            this.taskB = taskB;
            this.data = data;
        }
        return Link;
    })();
    Camin.Link = Link;
})(Camin || (Camin = {}));
var Camin;
(function (Camin) {
    var Sequence = (function () {
        function Sequence() {
            this.endpoints = [];
            this.execs = [];
            this.calls = [];
        }
        Sequence.prototype.endpoint = function (url, routeId, contextId, host) {
            for (var i = 0; i < this.endpoints.length; i++) {
                if (this.endpoints[i].url === url && this.endpoints[i].routeId === routeId && this.endpoints[i].contextId === contextId && this.endpoints[i].host === host) {
                    return this.endpoints[i];
                }
            }
            var endpoint = new Endpoint(url, routeId, contextId, host);
            this.endpoints.push(endpoint);
            return endpoint;
        };
        Sequence.prototype.exec = function (exchangeId, endpoint, start, stop) {
            var exec = new Execution(exchangeId, endpoint, start, stop);
            this.execs.push(exec);
            return exec;
        };
        Sequence.prototype.call = function (callId, execA, execB, start, stop) {
            var call = new Call(callId, execA, execB, start, stop);
            this.calls.push(call);
            return call;
        };
        Sequence.prototype.start = function () {
            var start;
            for (var i = 0; i < this.execs.length; i++) {
                start = start ? Math.min(start, this.execs[i].start) : this.execs[i].start;
            }
            for (var i = 0; i < this.calls.length; i++) {
                start = start ? Math.min(start, this.calls[i].start) : this.calls[i].start;
            }
            return start;
        };
        Sequence.prototype.stop = function () {
            var stop;
            for (var i = 0; i < this.execs.length; i++) {
                stop = stop ? Math.max(stop, this.execs[i].stop) : this.execs[i].stop;
            }
            for (var i = 0; i < this.calls.length; i++) {
                stop = stop ? Math.max(stop, this.calls[i].stop) : this.calls[i].stop;
            }
            return stop;
        };
        return Sequence;
    })();
    Camin.Sequence = Sequence;
    var Endpoint = (function () {
        function Endpoint(url, routeId, contextId, host) {
            this.url = url;
            this.routeId = routeId;
            this.contextId = contextId;
            this.host = host;
        }
        return Endpoint;
    })();
    Camin.Endpoint = Endpoint;
    var Execution = (function () {
        function Execution(exchangeId, endpoint, start, stop) {
            this.exchangeId = exchangeId;
            this.endpoint = endpoint;
            this.start = start;
            this.stop = stop;
        }
        return Execution;
    })();
    Camin.Execution = Execution;
    var Call = (function () {
        function Call(callId, execA, execB, start, stop) {
            this.callId = callId;
            this.execA = execA;
            this.execB = execB;
            this.start = start;
            this.stop = stop;
        }
        return Call;
    })();
    Camin.Call = Call;
})(Camin || (Camin = {}));
var Core;
(function (Core) {
    Core._module.controller("Core.AboutController", ["$scope", "$location", "jolokia", "branding", "localStorage", function ($scope, $location, jolokia, branding, localStorage) {
        var log = Logger.get("About");
        $.ajax({
            url: "app/core/doc/about.md",
            dataType: 'html',
            cache: false,
            success: function (data, textStatus, jqXHR) {
                $scope.html = "Unable to download about.md";
                if (angular.isDefined(data)) {
                    $scope.html = marked(data);
                    $scope.branding = branding;
                    $scope.customBranding = branding.enabled;
                    try {
                        $scope.hawtioVersion = jolokia.request({
                            type: "read",
                            mbean: "hawtio:type=About",
                            attribute: "HawtioVersion"
                        }).value;
                    }
                    catch (Error) {
                        $scope.hawtioVersion = "N/A";
                    }
                    $scope.jolokiaVersion = jolokia.version().agent;
                    $scope.serverProduct = jolokia.version().info.product;
                    $scope.serverVendor = jolokia.version().info.vendor;
                    $scope.serverVersion = jolokia.version().info.version;
                }
                Core.$apply($scope);
            },
            error: function (jqXHR, textStatus, errorThrown) {
                $scope.html = "Unable to download about.md";
                Core.$apply($scope);
            }
        });
    }]);
})(Core || (Core = {}));
var Kubernetes;
(function (Kubernetes) {
    Kubernetes.context = '/kubernetes';
    Kubernetes.hash = '#' + Kubernetes.context;
    Kubernetes.defaultRoute = Kubernetes.hash + '/apps';
    Kubernetes.pluginName = 'Kubernetes';
    Kubernetes.templatePath = 'app/kubernetes/html/';
    Kubernetes.log = Logger.get(Kubernetes.pluginName);
    Kubernetes.defaultApiVersion = "v1beta2";
    Kubernetes.appSuffix = ".app";
    Kubernetes.mbean = Fabric.jmxDomain + ":type=Kubernetes";
    Kubernetes.managerMBean = Fabric.jmxDomain + ":type=KubernetesManager";
    Kubernetes.appViewMBean = Fabric.jmxDomain + ":type=AppView";
    function isKubernetes(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "Kubernetes" });
    }
    Kubernetes.isKubernetes = isKubernetes;
    function isKubernetesTemplateManager(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "KubernetesTemplateManager" });
    }
    Kubernetes.isKubernetesTemplateManager = isKubernetesTemplateManager;
    function isAppView(workspace) {
        return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "AppView" });
    }
    Kubernetes.isAppView = isAppView;
    function updateNamespaces(kubernetes, pods, replicationControllers, services) {
        if (pods === void 0) { pods = []; }
        if (replicationControllers === void 0) { replicationControllers = []; }
        if (services === void 0) { services = []; }
        var byNamespace = function (thing) {
            return thing.namespace;
        };
        function pushIfNotExists(array, items) {
            angular.forEach(items, function (value) {
                if ($.inArray(value, array) < 0) {
                    array.push(value);
                }
            });
        }
        var namespaces = [];
        pushIfNotExists(namespaces, pods.map(byNamespace));
        pushIfNotExists(namespaces, services.map(byNamespace));
        pushIfNotExists(namespaces, replicationControllers.map(byNamespace));
        namespaces = namespaces.sort();
        kubernetes.namespaces = namespaces;
        kubernetes.selectedNamespace = kubernetes.selectedNamespace || namespaces[0];
    }
    Kubernetes.updateNamespaces = updateNamespaces;
    function setJson($scope, id, collection) {
        $scope.id = id;
        if (!$scope.fetched) {
            return;
        }
        if (!id) {
            $scope.json = '';
            return;
        }
        if (!collection) {
            return;
        }
        var item = collection.find(function (item) {
            return item.id === id;
        });
        if (item) {
            $scope.json = angular.toJson(item, true);
            $scope.item = item;
        }
        else {
            $scope.id = undefined;
            $scope.json = '';
            $scope.item = undefined;
        }
    }
    Kubernetes.setJson = setJson;
    function labelsToString(labels, seperatorText) {
        if (seperatorText === void 0) { seperatorText = ","; }
        var answer = "";
        angular.forEach(labels, function (value, key) {
            var separator = answer ? seperatorText : "";
            answer += separator + key + "=" + value;
        });
        return answer;
    }
    Kubernetes.labelsToString = labelsToString;
    function initShared($scope, $location) {
        $scope.$watch("tableConfig.filterOptions.filterText", function (text) {
            $location.search("q", text);
        });
        $scope.$on("labelFilterUpdate", function ($event, text) {
            var currentFilter = $scope.tableConfig.filterOptions.filterText;
            if (Core.isBlank(currentFilter)) {
                $scope.tableConfig.filterOptions.filterText = text;
            }
            else {
                var expressions = currentFilter.split(/\s+/);
                if (expressions.any(text)) {
                    expressions = expressions.remove(text);
                    $scope.tableConfig.filterOptions.filterText = expressions.join(" ");
                }
                else {
                    $scope.tableConfig.filterOptions.filterText = currentFilter + " " + text;
                }
            }
            $scope.id = undefined;
        });
    }
    Kubernetes.initShared = initShared;
    function createPodCounters(selector, pods) {
        var answer = {
            podsLink: "",
            valid: 0,
            waiting: 0,
            error: 0
        };
        if (selector) {
            answer.podsLink = Core.url("/kubernetes/pods?q=" + encodeURIComponent(Kubernetes.labelsToString(selector, " ")));
            angular.forEach(pods, function (pod) {
                if (selectorMatches(selector, pod.labels)) {
                    var status = (pod.currentState || {}).status;
                    if (status) {
                        var lower = status.toLowerCase();
                        if (lower.startsWith("run")) {
                            answer.valid += 1;
                        }
                        else if (lower.startsWith("wait")) {
                            answer.waiting += 1;
                        }
                        else if (lower.startsWith("term") || lower.startsWith("error") || lower.startsWith("fail")) {
                            answer.error += 1;
                        }
                    }
                    else {
                        answer.error += 1;
                    }
                }
            });
        }
        return answer;
    }
    Kubernetes.createPodCounters = createPodCounters;
    function runApp($location, jolokia, $scope, json, name, onSuccessFn, namespace) {
        if (name === void 0) { name = "App"; }
        if (onSuccessFn === void 0) { onSuccessFn = null; }
        if (namespace === void 0) { namespace = null; }
        if (json) {
            name = name || "App";
            var postfix = namespace ? " in namespace " + namespace : "";
            Core.notification('info', "Running " + name + postfix);
            var callback = onSuccess(function (response) {
                Kubernetes.log.debug("Got response: ", response);
                if (angular.isFunction(onSuccessFn)) {
                    onSuccessFn();
                }
                Core.$apply($scope);
            });
            if (namespace) {
                jolokia.execute(Kubernetes.managerMBean, "applyInNamespace", json, namespace, callback);
            }
            else {
                jolokia.execute(Kubernetes.managerMBean, "apply", json, callback);
            }
        }
    }
    Kubernetes.runApp = runApp;
    function isRunning(podCurrentState) {
        var status = (podCurrentState || {}).status;
        if (status) {
            var lower = status.toLowerCase();
            return lower.startsWith("run");
        }
        else {
            return false;
        }
    }
    Kubernetes.isRunning = isRunning;
    function selectorMatches(selector, labels) {
        if (angular.isObject(labels)) {
            var answer = true;
            angular.forEach(selector, function (value, key) {
                if (answer && labels[key] !== value) {
                    answer = false;
                }
            });
            return answer;
        }
        else {
            return false;
        }
    }
    Kubernetes.selectorMatches = selectorMatches;
    function kibanaLogsLink(ServiceRegistry) {
        var link = Service.serviceLink(ServiceRegistry, "kibana-service");
        if (link) {
            if (!link.endsWith("/")) {
                link += "/";
            }
            return link + "#/discover/Fabric8";
        }
        else {
            return null;
        }
    }
    Kubernetes.kibanaLogsLink = kibanaLogsLink;
    function openLogsForPods(ServiceRegistry, $window, pods) {
        function encodePodIdInSearch(id) {
            if (id) {
                var idx = id.indexOf("-");
                if (idx > 0) {
                    id = id.substring(0, idx);
                }
            }
            var quoteText = "";
            return quoteText + id + quoteText;
        }
        var link = kibanaLogsLink(ServiceRegistry);
        if (link) {
            var query = "";
            var count = 0;
            angular.forEach(pods, function (item) {
                var id = item.id;
                if (id) {
                    var space = query ? " || " : "";
                    count++;
                    query += space + encodePodIdInSearch(id);
                }
            });
            if (query) {
                if (count > 1) {
                    query = "(" + query + ")";
                }
                link += "?_a=(query:'k8s_pod:" + query + "')";
            }
            var newWindow = $window.open(link, "viewLogs");
        }
    }
    Kubernetes.openLogsForPods = openLogsForPods;
    function resizeController($http, KubernetesApiURL, id, newReplicas, onCompleteFn) {
        if (onCompleteFn === void 0) { onCompleteFn = null; }
        KubernetesApiURL.then(function (KubernetesApiURL) {
            var url = UrlHelpers.join(KubernetesApiURL, "/kubernetes/api/v1beta2/replicationControllers/" + id);
            $http.get(url).success(function (data, status, headers, config) {
                if (data) {
                    var desiredState = data.desiredState;
                    if (!desiredState) {
                        desiredState = {};
                        data.desiredState = desiredState;
                    }
                    desiredState.replicas = newReplicas;
                    $http.put(url, data).success(function (data, status, headers, config) {
                        Kubernetes.log.debug("updated controller " + url);
                        if (angular.isFunction(onCompleteFn)) {
                            onCompleteFn();
                        }
                    }).error(function (data, status, headers, config) {
                        Kubernetes.log.warn("Failed to save " + url + " " + data + " " + status);
                    });
                }
            }).error(function (data, status, headers, config) {
                Kubernetes.log.warn("Failed to load " + url + " " + data + " " + status);
            });
        }, function (response) {
            Kubernetes.log.debug("Failed to get rest API URL, can't resize controller " + id + " resource: ", response);
        });
    }
    Kubernetes.resizeController = resizeController;
    function statusTextToCssClass(text) {
        if (text) {
            var lower = text.toLowerCase();
            if (lower.startsWith("run") || lower.startsWith("ok")) {
                return 'icon-play-circle green';
            }
            else if (lower.startsWith("wait")) {
                return 'icon-download';
            }
            else if (lower.startsWith("term") || lower.startsWith("error") || lower.startsWith("fail")) {
                return 'icon-off orange';
            }
        }
        return 'icon-question red';
    }
    Kubernetes.statusTextToCssClass = statusTextToCssClass;
})(Kubernetes || (Kubernetes = {}));
var Core;
(function (Core) {
    function parsePreferencesJson(value, key) {
        var answer = null;
        if (angular.isDefined(value)) {
            answer = Core.parseJsonText(value, "localStorage for " + key);
        }
        return answer;
    }
    Core.parsePreferencesJson = parsePreferencesJson;
    function configuredPluginsForPerspectiveId(perspectiveId, workspace, jolokia, localStorage) {
        var topLevelTabs = Perspective.topLevelTabsForPerspectiveId(workspace, perspectiveId);
        if (topLevelTabs && topLevelTabs.length > 0) {
            topLevelTabs = topLevelTabs.filter(function (tab) {
                var href = undefined;
                if (angular.isFunction(tab.href)) {
                    href = tab.href();
                }
                else if (angular.isString(tab.href)) {
                    href = tab.href;
                }
                return href && isValidFunction(workspace, tab.isValid, perspectiveId);
            });
            var id = "plugins-" + perspectiveId;
            var initPlugins = parsePreferencesJson(localStorage[id], id);
            if (initPlugins) {
                initPlugins = initPlugins.filter(function (p) {
                    return topLevelTabs.some(function (tab) { return tab.id === p.id; });
                });
                topLevelTabs.forEach(function (tab) {
                    var knownPlugin = initPlugins.some(function (p) { return p.id === tab.id; });
                    if (!knownPlugin) {
                        Core.log.info("Discovered new plugin in JVM since loading configuration: " + tab.id);
                        initPlugins.push({ id: tab.id, index: -1, displayName: tab.content, enabled: true, isDefault: false });
                    }
                });
            }
            else {
                initPlugins = topLevelTabs;
            }
        }
        var answer = safeTabsToPlugins(initPlugins);
        return answer;
    }
    Core.configuredPluginsForPerspectiveId = configuredPluginsForPerspectiveId;
    function safeTabsToPlugins(tabs) {
        var answer = [];
        if (tabs) {
            tabs.forEach(function (tab, idx) {
                var name;
                if (angular.isUndefined(tab.displayName)) {
                    name = tab.content;
                }
                else {
                    name = tab.displayName;
                }
                var enabled;
                if (angular.isUndefined(tab.enabled)) {
                    enabled = true;
                }
                else {
                    enabled = tab.enabled;
                }
                var isDefault;
                if (angular.isUndefined(tab.isDefault)) {
                    isDefault = false;
                }
                else {
                    isDefault = tab.isDefault;
                }
                answer.push({ id: tab.id, index: idx, displayName: name, enabled: enabled, isDefault: isDefault });
            });
        }
        return answer;
    }
    Core.safeTabsToPlugins = safeTabsToPlugins;
    function filterTopLevelTabs(perspective, workspace, configuredPlugins) {
        var topLevelTabs = Perspective.topLevelTabsForPerspectiveId(workspace, perspective);
        if (perspective === "website")
            return topLevelTabs;
        var result = [];
        configuredPlugins.forEach(function (p) {
            if (p.enabled) {
                var pid = p.id;
                var tab = null;
                if (pid) {
                    tab = topLevelTabs.find(function (t) { return t.id === pid; });
                }
                if (tab) {
                    result.push(tab);
                }
            }
        });
        return result;
    }
    Core.filterTopLevelTabs = filterTopLevelTabs;
    function initPreferenceScope($scope, localStorage, defaults) {
        angular.forEach(defaults, function (_default, key) {
            $scope[key] = _default['value'];
            var converter = _default['converter'];
            var formatter = _default['formatter'];
            if (!formatter) {
                formatter = function (value) {
                    return value;
                };
            }
            if (!converter) {
                converter = function (value) {
                    return value;
                };
            }
            if (key in localStorage) {
                var value = converter(localStorage[key]);
                Core.log.debug("from local storage, setting ", key, " to ", value);
                $scope[key] = value;
            }
            else {
                var value = _default['value'];
                Core.log.debug("from default, setting ", key, " to ", value);
                localStorage[key] = value;
            }
            var watchFunc = _default['override'];
            if (!watchFunc) {
                watchFunc = function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        if (angular.isFunction(_default['pre'])) {
                            _default.pre(newValue);
                        }
                        var value = formatter(newValue);
                        Core.log.debug("to local storage, setting ", key, " to ", value);
                        localStorage[key] = value;
                        if (angular.isFunction(_default['post'])) {
                            _default.post(newValue);
                        }
                    }
                };
            }
            if (_default['compareAsObject']) {
                $scope.$watch(key, watchFunc, true);
            }
            else {
                $scope.$watch(key, watchFunc);
            }
        });
    }
    Core.initPreferenceScope = initPreferenceScope;
    function isValidFunction(workspace, validFn, perspectiveId) {
        return !validFn || validFn(workspace, perspectiveId);
    }
    Core.isValidFunction = isValidFunction;
    function getDefaultPlugin(perspectiveId, workspace, jolokia, localStorage) {
        var plugins = Core.configuredPluginsForPerspectiveId(perspectiveId, workspace, jolokia, localStorage);
        var defaultPlugin = null;
        plugins.forEach(function (p) {
            if (p.isDefault) {
                defaultPlugin = p;
            }
        });
        return defaultPlugin;
    }
    Core.getDefaultPlugin = getDefaultPlugin;
})(Core || (Core = {}));
var Insight;
(function (Insight) {
    Insight.managerMBean = "io.fabric8:type=Fabric";
    Insight.allContainers = { id: '-- all --' };
    function hasInsight(workspace) {
        return workspace.treeContainsDomainAndProperties('io.fabric8.insight', { type: 'Elasticsearch' });
    }
    Insight.hasInsight = hasInsight;
    function hasKibana(workspace) {
        return workspace.treeContainsDomainAndProperties('hawtio', { type: 'plugin', name: 'hawtio-kibana' });
    }
    Insight.hasKibana = hasKibana;
    function hasEsHead(workspace) {
        return workspace.treeContainsDomainAndProperties('hawtio', { type: 'plugin', name: 'hawtio-eshead' });
    }
    Insight.hasEsHead = hasEsHead;
    function getInsightMetricsCollectorMBean(workspace) {
        var node = workspace.findMBeanWithProperties('io.fabric8.insight', { type: 'MetricsCollector' });
        if (!node) {
            node = workspace.findMBeanWithProperties('org.fusesource.insight', { type: 'MetricsCollector' });
        }
        return node ? node.objectName : null;
    }
    Insight.getInsightMetricsCollectorMBean = getInsightMetricsCollectorMBean;
    function getChildren(node, type, field, hasHost) {
        var children = [];
        for (var p in node["properties"]) {
            var obj = node["properties"][p];
            if (obj["type"] === 'long' || obj["type"] === 'double') {
                children.push({ title: p, field: field + p, type: type, hasHost: hasHost });
            }
            else if (obj["properties"]) {
                children.push({ title: p, isFolder: true, children: getChildren(obj, type, field + p + ".", hasHost) });
            }
        }
        return children;
    }
    Insight.getChildren = getChildren;
    function createCharts($scope, chartsDef, element, jolokia) {
        var chartsDiv = $(element);
        var width = chartsDiv.width() - 80;
        var context = cubism.context().serverDelay(interval_to_seconds('1m') * 1000).clientDelay($scope.updateRate).step(interval_to_seconds($scope.timespan) * 1000).size(width);
        var d3Selection = d3.select(chartsDiv[0]);
        d3Selection.html("");
        d3Selection.selectAll(".axis").data(["top", "bottom"]).enter().append("div").attr("class", function (d) {
            return d + " axis";
        }).each(function (d) {
            d3.select(this).call(context.axis().ticks(12).orient(d));
        });
        d3Selection.append("div").attr("class", "rule").call(context.rule());
        context.on("focus", function (i) {
            d3Selection.selectAll(".value").style("right", i === null ? null : context.size() - i + "px");
        });
        chartsDef.forEach(function (chartDef) {
            d3Selection.call(function (div) {
                div.append("div").data([chart(context, chartDef, jolokia)]).attr("class", "horizon").call(context.horizon());
            });
        });
    }
    Insight.createCharts = createCharts;
    function chart(context, chartDef, jolokia) {
        return context.metric(function (start, stop, step, callback) {
            var values = [], value = 0, start = +start, stop = +stop;
            var range = {
                range: {
                    timestamp: {
                        from: new Date(start).toISOString(),
                        to: new Date(stop).toISOString()
                    }
                }
            };
            var filter;
            if (chartDef.query) {
                filter = {
                    fquery: {
                        query: {
                            filtered: {
                                query: {
                                    query_string: {
                                        query: chartDef.query
                                    }
                                },
                                filter: range
                            }
                        }
                    }
                };
            }
            else {
                filter = range;
            }
            var request = {
                size: 0,
                facets: {
                    histo: {
                        date_histogram: {
                            value_field: chartDef.field,
                            key_field: "timestamp",
                            interval: step + "ms"
                        },
                        facet_filter: filter
                    }
                }
            };
            var jreq = { type: 'exec', mbean: 'org.elasticsearch:service=restjmx', operation: 'exec', arguments: ['POST', '/_all/' + chartDef.type + '/_search', JSON.stringify(request)] };
            jolokia.request(jreq, { success: function (response) {
                var map = {};
                var data = jQuery.parseJSON(response.value)["facets"]["histo"]["entries"];
                data.forEach(function (entry) {
                    map[entry.time] = entry.max;
                });
                var delta = 0;
                if (chartDef.meta !== undefined) {
                    if (chartDef.meta['type'] === 'trends-up' || chartDef.meta['type'] === 'peak') {
                        delta = +1;
                    }
                    else if (chartDef.meta['type'] === 'trends-down') {
                        delta = -1;
                    }
                }
                while (start < stop) {
                    var v = 0;
                    if (delta !== 0) {
                        if (map[start - step] !== undefined) {
                            var d = (map[start] - map[start - step]) * delta;
                            v = d > 0 ? d : 0;
                        }
                    }
                    else {
                        if (map[start] !== undefined) {
                            v = map[start];
                        }
                    }
                    values.push(v);
                    start += step;
                }
                callback(null, values);
            } });
        }, chartDef.name);
    }
    function interval_to_seconds(string) {
        var matches = string.match(/(\d+)([Mwdhms])/);
        switch (matches[2]) {
            case 'M':
                return matches[1] * 2592000;
                ;
            case 'w':
                return matches[1] * 604800;
                ;
            case 'd':
                return matches[1] * 86400;
                ;
            case 'h':
                return matches[1] * 3600;
                ;
            case 'm':
                return matches[1] * 60;
                ;
            case 's':
                return matches[1];
        }
    }
    function time_ago(string) {
        return new Date(new Date().getTime() - (interval_to_seconds(string) * 1000));
    }
})(Insight || (Insight = {}));
var Site;
(function (Site) {
    Site.sitePluginEnabled = false;
    function isSiteNavBarValid() {
        return Site.sitePluginEnabled;
    }
    Site.isSiteNavBarValid = isSiteNavBarValid;
})(Site || (Site = {}));
var Perspective;
(function (Perspective) {
    Perspective.containerPerspectiveEnabled = true;
    Perspective.metadata = {
        kubernetes: {
            icon: {
                title: "Fabric8",
                type: "img",
                src: "img/icons/fabric8_icon.svg"
            },
            label: "Fabric8",
            isValid: function (workspace) { return !Fabric.isFMCContainer(workspace) && Kubernetes.isKubernetes(workspace); },
            lastPage: "#/kubernetes/apps",
            topLevelTabs: {
                includes: [
                    {
                        content: "Runtime",
                        id: "kubernetes"
                    },
                    {
                        content: "Library",
                        href: "#/wiki"
                    },
                    {
                        href: "#/docker"
                    },
                    {
                        id: "apis.index"
                    },
                    {
                        id: "kibana"
                    },
                    {
                        id: "grafana"
                    },
                    {
                        href: "#/dashboard"
                    },
                    {
                        href: "#/health"
                    }
                ]
            }
        },
        fabric: {
            icon: {
                title: "Fabric8",
                type: "img",
                src: "img/icons/fabric8_icon.svg"
            },
            label: "Fabric",
            isValid: function (workspace) { return Fabric.isFMCContainer(workspace); },
            lastPage: "#/fabric/containers",
            topLevelTabs: {
                includes: [
                    {
                        id: "kubernetes"
                    },
                    {
                        id: "fabric.containers"
                    },
                    {
                        id: "fabric.profiles"
                    },
                    {
                        href: "#/wiki/branch/"
                    },
                    {
                        href: "#/fabric"
                    },
                    {
                        id: "fabric.requirements"
                    },
                    {
                        href: "#/wiki/profile"
                    },
                    {
                        href: "#/docker"
                    },
                    {
                        href: "#/dashboard"
                    },
                    {
                        href: "#/health"
                    }
                ]
            }
        },
        container: {
            icon: {
                title: "Java",
                type: "img",
                src: "img/icons/java.svg"
            },
            label: "Container",
            lastPage: "#/logs",
            isValid: function (workspace) { return workspace && workspace.tree && workspace.tree.children && workspace.tree.children.length; },
            topLevelTabs: {
                excludes: [
                    {
                        href: "#/fabric"
                    },
                    {
                        href: "#/kubernetes"
                    },
                    {
                        id: "fabric.profiles"
                    },
                    {
                        id: "fabric.containers"
                    },
                    {
                        id: "fabric.requirements"
                    },
                    {
                        id: "fabric.kubernetes"
                    },
                    {
                        href: "#/insight"
                    },
                    {
                        href: "#/camin"
                    },
                    {
                        id: "insight-camel"
                    },
                    {
                        id: "insight-logs"
                    },
                    {
                        id: "docker-registry"
                    },
                    {
                        id: "wiki"
                    },
                    {
                        id: "dashboard",
                        onCondition: function (workspace) {
                            if (Fabric.isFMCContainer(workspace)) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                    },
                    {
                        id: "health",
                        onCondition: function (workspace) {
                            if (Fabric.isFMCContainer(workspace)) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                ]
            }
        },
        limited: {
            label: "Limited",
            lastPage: "#/logs",
            isValid: function (workspace) { return false; },
            topLevelTabs: {
                includes: [
                    {
                        href: "#/jmx"
                    },
                    {
                        href: "#/camel"
                    },
                    {
                        href: "#/activemq"
                    },
                    {
                        href: "#/jetty"
                    },
                    {
                        href: "#/logs"
                    }
                ]
            }
        },
        website: {
            label: "WebSite",
            isValid: function (workspace) { return Site.sitePluginEnabled && Site.isSiteNavBarValid(); },
            lastPage: "#/site/doc/index.md",
            topLevelTabs: {
                includes: [
                    {
                        content: "Get Started",
                        title: "How to get started using hawtio",
                        href: function () { return "#/site/doc/GetStarted.md"; },
                        isValid: function () { return Site.isSiteNavBarValid(); }
                    },
                    {
                        content: "FAQ",
                        title: "Frequently Asked Questions",
                        href: function () { return "#/site/FAQ.md"; },
                        isValid: function () { return Site.isSiteNavBarValid(); }
                    },
                    {
                        content: "User Guide",
                        title: "All the docs on using hawtio",
                        href: function () { return "#/site/book/doc/index.md"; },
                        isValid: function () { return Site.isSiteNavBarValid(); }
                    },
                    {
                        content: "Community",
                        title: "Come on in and join our community!",
                        href: function () { return "#/site/doc/Community.html"; },
                        isValid: function () { return Site.isSiteNavBarValid(); }
                    },
                    {
                        content: "Developers",
                        title: "Resources for developers if you want to hack on hawtio or provide your own plugins",
                        href: function () { return "#/site/doc/developers/index.md"; },
                        isValid: function () { return Site.isSiteNavBarValid(); }
                    },
                    {
                        content: "github",
                        title: "Hawtio's source code and issue tracker",
                        href: function () { return "https://github.com/hawtio/hawtio"; },
                        isValid: function () { return Site.isSiteNavBarValid(); }
                    }
                ]
            }
        }
    };
})(Perspective || (Perspective = {}));
var Perspective;
(function (Perspective) {
    Perspective.log = Logger.get("Perspective");
    Perspective.perspectiveSearchId = "p";
    Perspective.defaultPerspective = null;
    Perspective.defaultPageLocation = null;
    function currentPerspectiveId($location, workspace, jolokia, localStorage) {
        var perspective = $location.search()[Perspective.perspectiveSearchId];
        if (!perspective) {
            perspective = Perspective.choosePerspective($location, workspace, jolokia, localStorage);
        }
        return perspective;
    }
    Perspective.currentPerspectiveId = currentPerspectiveId;
    function getPerspectives($location, workspace, jolokia, localStorage) {
        var perspectives = [];
        angular.forEach(Perspective.metadata, function (perspective, key) {
            if (isValidFunction(workspace, perspective.isValid)) {
                if (!perspective.label) {
                    perspective.label = key;
                }
                if (!perspective.title) {
                    perspective.title = perspective.label;
                }
                perspective.id = key;
                perspectives.push(perspective);
            }
        });
        return perspectives;
    }
    Perspective.getPerspectives = getPerspectives;
    function getPerspectiveById(id) {
        var answer;
        angular.forEach(Perspective.metadata, function (perspective, key) {
            if (key === id) {
                answer = perspective;
            }
        });
        return answer;
    }
    Perspective.getPerspectiveById = getPerspectiveById;
    function topLevelTabsForPerspectiveId(workspace, perspective) {
        var sortedTopLevelTabs = workspace.topLevelTabs.sortBy(function (f) { return f.content; });
        var data = perspective ? Perspective.metadata[perspective] : null;
        var metaData = data;
        var answer = [];
        if (!data) {
            answer = sortedTopLevelTabs;
        }
        else {
            var topLevelTabs = data.topLevelTabs;
            var includes = filterTabs(topLevelTabs.includes, workspace);
            var excludes = filterTabs(topLevelTabs.excludes, workspace);
            if (metaData) {
                excludes = excludes.filter(function (t) {
                    var metaTab = metaData.topLevelTabs.excludes.find(function (et) {
                        var etid = et.id;
                        return etid && etid === t.id;
                    });
                    if (metaTab != null && angular.isFunction(metaTab.onCondition)) {
                        var answer = metaTab.onCondition(workspace);
                        if (answer) {
                            Perspective.log.debug("Plugin " + t.id + " excluded in perspective " + perspective);
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    return true;
                });
            }
            if (!topLevelTabs.includes) {
                answer = sortedTopLevelTabs;
            }
            else {
                answer = includes;
            }
            answer = answer.subtract(excludes);
        }
        return answer;
    }
    Perspective.topLevelTabsForPerspectiveId = topLevelTabsForPerspectiveId;
    function filterTabs(tabs, workspace) {
        var matched = [];
        function pushMatchedTab(tabSpec, tab) {
            if (tab) {
                var content = tabSpec.content;
                if (content) {
                    tab = angular.copy(tab);
                    tab.content = content;
                }
                matched.push(tab);
            }
        }
        angular.forEach(tabs, function (tabSpec) {
            var href = tabSpec.href;
            var id = tabSpec.id;
            var rhref = tabSpec.rhref;
            if (href) {
                var hrefValue = href;
                if (angular.isFunction(href)) {
                    hrefValue = href();
                }
                var tab = workspace.topLevelTabs.find(function (t) {
                    var thref = t.href();
                    return thref && thref.startsWith(hrefValue);
                });
                if (!tab && !id && tabSpec.content) {
                    tab = tabSpec;
                }
                pushMatchedTab(tabSpec, tab);
            }
            else if (id) {
                var tab = workspace.topLevelTabs.find(function (t) {
                    var tid = t.id;
                    return tid && tid === id;
                });
                pushMatchedTab(tabSpec, tab);
            }
            else if (rhref) {
                var tab = workspace.topLevelTabs.find(function (t) {
                    var thref = t.href();
                    return thref && thref.match(rhref);
                });
                pushMatchedTab(tabSpec, tab);
            }
        });
        return matched;
    }
    function filterOnlyValidTopLevelTabs(workspace, topLevelTabs) {
        var answer = topLevelTabs.filter(function (tab) {
            var href = tab.href();
            return href && isValidFunction(workspace, tab.isValid);
        });
        return answer;
    }
    Perspective.filterOnlyValidTopLevelTabs = filterOnlyValidTopLevelTabs;
    function filterOnlyActiveTopLevelTabs(workspace, topLevelTabs) {
        var answer = topLevelTabs.filter(function (tab) {
            var href = tab.href();
            return href && isValidFunction(workspace, tab.isActive);
        });
        return answer;
    }
    Perspective.filterOnlyActiveTopLevelTabs = filterOnlyActiveTopLevelTabs;
    function getTopLevelTabsForPerspective($location, workspace, jolokia, localStorage) {
        var perspective = currentPerspectiveId($location, workspace, jolokia, localStorage);
        var plugins = Core.configuredPluginsForPerspectiveId(perspective, workspace, jolokia, localStorage);
        var tabs = Core.filterTopLevelTabs(perspective, workspace, plugins);
        tabs = Perspective.filterOnlyValidTopLevelTabs(workspace, tabs);
        return tabs;
    }
    Perspective.getTopLevelTabsForPerspective = getTopLevelTabsForPerspective;
    function choosePerspective($location, workspace, jolokia, localStorage) {
        var answer;
        var url = $location.url();
        var inFMC = Fabric.isFMCContainer(workspace);
        if (inFMC) {
            if (url.startsWith("/perspective/defaultPage") || url.startsWith("/login") || url.startsWith("/welcome") || url.startsWith("/index") || url.startsWith("/fabric") || url.startsWith("/kubernetes") || url.startsWith("/profiles") || url.startsWith("/dashboard") || url.startsWith("/health") || (url.startsWith("/wiki") && url.has("/fabric/profiles")) || (url.startsWith("/wiki") && url.has("/editFeatures"))) {
                answer = "fabric";
            }
        }
        else if (Kubernetes.isKubernetes(workspace)) {
            answer = "kubernetes";
        }
        answer = answer || Perspective.defaultPerspective || "container";
        return answer;
    }
    Perspective.choosePerspective = choosePerspective;
    function defaultPage($location, workspace, jolokia, localStorage) {
        var isProxy = Core.isProxyUrl($location);
        var isChomeApp = Core.isChromeApp();
        if (!isProxy && !isChomeApp && shouldShowWelcomePage(localStorage)) {
            return "/welcome/";
        }
        var answer = Perspective.defaultPageLocation;
        if (!answer && $location && workspace) {
            var perspectiveId = currentPerspectiveId($location, workspace, jolokia, localStorage);
            var defaultPlugin = Core.getDefaultPlugin(perspectiveId, workspace, jolokia, localStorage);
            var tabs = Perspective.topLevelTabsForPerspectiveId(workspace, perspectiveId);
            tabs = Perspective.filterOnlyValidTopLevelTabs(workspace, tabs);
            var defaultTab;
            if (defaultPlugin) {
                tabs.forEach(function (tab) {
                    if (tab.id === defaultPlugin.id) {
                        defaultTab = tab;
                    }
                });
            }
            else {
                defaultTab = tabs[0];
            }
            if (defaultTab) {
                answer = Core.trimLeading(defaultTab.href(), "#");
            }
        }
        return answer || '/help/index';
    }
    Perspective.defaultPage = defaultPage;
    function shouldShowWelcomePage(localStorage) {
        var value = localStorage["showWelcomePage"];
        if (angular.isString(value)) {
            return "true" === value;
        }
        return true;
    }
    Perspective.shouldShowWelcomePage = shouldShowWelcomePage;
    function isValidFunction(workspace, validFn) {
        return !validFn || validFn(workspace);
    }
})(Perspective || (Perspective = {}));
var Core;
(function (Core) {
    Core.ConsoleController = Core._module.controller("Core.ConsoleController", ["$scope", "$element", "$templateCache", function ($scope, $element, $templateCache) {
        $scope.setHandler = function (clip) {
            clip.addEventListener('mouseDown', function (client, args) {
                var icon = $element.find('.icon-copy');
                var icon2 = $element.find('.icon-trash');
                if (this !== icon.get(0) && this !== icon2.get(0)) {
                    return;
                }
                if (this == icon.get(0)) {
                    copyToClipboard();
                }
                else {
                    clearLogs();
                    Core.notification('info', "Cleared logging console");
                }
                Core.$apply($scope);
            });
            function copyToClipboard() {
                var text = $templateCache.get("logClipboardTemplate").lines();
                text.removeAt(0);
                text.removeAt(text.length - 1);
                text.push('<ul>');
                $element.find('#log-panel-statements').children().each(function (index, child) {
                    text.push('  <li>' + child.innerHTML + '</li>');
                });
                text.push('</ul>');
                clip.setText(text.join('\n'));
            }
            function clearLogs() {
                $element.find('#log-panel-statements').children().remove();
            }
        };
    }]);
    Core.AppController = Core._module.controller("Core.AppController", ["$scope", "$location", "$window", "workspace", "jolokia", "jolokiaStatus", "$document", "pageTitle", "localStorage", "userDetails", "lastLocation", "jolokiaUrl", "branding", "ConnectOptions", "$timeout", "locationChangeStartTasks", "$route", "keycloakContext", function ($scope, $location, $window, workspace, jolokia, jolokiaStatus, $document, pageTitle, localStorage, userDetails, lastLocation, jolokiaUrl, branding, ConnectOptions, $timeout, locationChangeStartTasks, $route, keycloakContext) {
        $scope.collapse = '';
        $scope.match = null;
        $scope.pageTitle = [];
        $scope.userDetails = userDetails;
        $scope.confirmLogout = false;
        $scope.connectionFailed = false;
        $scope.connectFailure = {};
        $scope.showPrefs = false;
        $scope.keycloakEnabled = keycloakContext.enabled;
        $scope.logoClass = function () {
            if (branding.logoOnly) {
                return "without-text";
            }
            else {
                return "with-text";
            }
        };
        $scope.branding = branding;
        $scope.hasMBeans = function () { return workspace.hasMBeans(); };
        $scope.$watch('jolokiaStatus.xhr', function () {
            var failure = jolokiaStatus.xhr;
            $scope.connectionFailed = failure ? true : false;
            $scope.connectFailure.summaryMessage = null;
            if ($scope.connectionFailed) {
                $scope.connectFailure.status = failure.status;
                $scope.connectFailure.statusText = failure.statusText;
                var text = failure.responseText;
                if (text) {
                    try {
                        var html = $(text);
                        var markup = html.find("body");
                        if (markup && markup.length) {
                            html = markup;
                        }
                        html.each(function (idx, e) {
                            var name = e.localName;
                            if (name && name.startsWith("h")) {
                                $(e).addClass("ajaxError");
                            }
                        });
                        var container = $("<div></div>");
                        container.append(html);
                        $scope.connectFailure.summaryMessage = container.html();
                        console.log("Found HTML: " + $scope.connectFailure.summaryMessage);
                    }
                    catch (e) {
                        if (text.indexOf('<') < 0) {
                            $scope.connectFailure.summaryMessage = "<p>" + text + "</p>";
                        }
                    }
                }
            }
        });
        $scope.showPreferences = function () {
            $scope.showPrefs = true;
        };
        $scope.closePreferences = function () {
            $scope.showPrefs = false;
        };
        $scope.confirmConnectionFailed = function () {
            window.close();
        };
        $scope.setPageTitle = function () {
            $scope.pageTitle = pageTitle.getTitleArrayExcluding([branding.appName]);
            var tab = workspace.getActiveTab();
            if (tab && tab.content) {
                Core.setPageTitleWithTab($document, pageTitle, tab.content);
            }
            else {
                Core.setPageTitle($document, pageTitle);
            }
        };
        $scope.setRegexIndicator = function () {
            try {
                var regexs = angular.fromJson(localStorage['regexs']);
                if (regexs) {
                    regexs.reverse().each(function (regex) {
                        var r = new RegExp(regex.regex, 'g');
                        if (r.test($location.absUrl())) {
                            $scope.match = {
                                name: regex.name,
                                color: regex.color
                            };
                        }
                    });
                }
            }
            catch (e) {
            }
        };
        $scope.loggedIn = function () {
            return userDetails.username !== null && userDetails.username !== 'public';
        };
        $scope.showLogout = function () {
            return $scope.loggedIn();
        };
        $scope.logout = function () {
            $scope.confirmLogout = true;
        };
        $scope.getUsername = function () {
            if (userDetails.username && !userDetails.username.isBlank()) {
                return userDetails.username;
            }
            else {
                return 'user';
            }
        };
        $scope.doLogout = function () {
            $scope.confirmLogout = false;
            Core.logout(jolokiaUrl, userDetails, localStorage, $scope);
        };
        $scope.$watch(function () {
            return localStorage['regexs'];
        }, $scope.setRegexIndicator);
        $scope.reloaded = false;
        $scope.maybeRedirect = function () {
            if (userDetails.username === null) {
                var currentUrl = $location.url();
                if (!currentUrl.startsWith('/login')) {
                    lastLocation.url = currentUrl;
                    $location.url('/login');
                }
                else {
                    if (!$scope.reloaded) {
                        $route.reload();
                        $scope.reloaded = true;
                    }
                }
            }
            else {
                if ($location.url().startsWith('/login')) {
                    var url = defaultPage();
                    if (angular.isDefined(lastLocation.url)) {
                        url = lastLocation.url;
                    }
                    $location.url(url);
                }
            }
        };
        $scope.$watch('userDetails', function (newValue, oldValue) {
            $scope.maybeRedirect();
        }, true);
        $scope.$on('hawtioOpenPrefs', function () {
            $scope.showPrefs = true;
        });
        $scope.$on('hawtioClosePrefs', function () {
            $scope.showPrefs = false;
        });
        $scope.$on('$routeChangeStart', function (event, args) {
            if ((!args || !args.params || !args.params.pref) && $scope.showPrefs) {
                $scope.showPrefs = false;
            }
            $scope.maybeRedirect();
        });
        $scope.$on('$routeChangeSuccess', function () {
            $scope.setPageTitle($document, Core.PageTitle);
            $scope.maybeRedirect();
        });
        $scope.fullScreen = function () {
            if ($location.path().startsWith("/login")) {
                return branding.fullscreenLogin;
            }
            var tab = $location.search()['tab'];
            if (tab) {
                return tab === "fullscreen";
            }
            return false;
        };
        $scope.login = function () {
            return $location.path().startsWith("/login");
        };
        function defaultPage() {
            return Perspective.defaultPage($location, workspace, jolokia, localStorage);
        }
        $scope.redirectToKeycloakAccountMgmt = function () {
            keycloakContext.keycloak.accountManagement();
        };
        $scope.redirectToKeycloakAdminConsole = function () {
            var realm = encodeURIComponent(keycloakContext.keycloak.realm);
            var redirectURI = keycloakContext.keycloak.authServerUrl + '/admin/' + realm + '/console/index.html';
            $window.location.href = redirectURI;
        };
    }]);
})(Core || (Core = {}));
$(function () {
    hawtioPluginLoader.loadPlugins(function () {
        var doc = angular.element(document);
        var docEl = angular.element(document.documentElement);
        Core.injector = angular.bootstrap(docEl, hawtioPluginLoader.getModules());
        Logger.get("Core").debug("Bootstrapped application, injector: ", Core.injector);
        docEl.attr('xmlns:ng', "http://angularjs.org");
        docEl.attr('ng-app', 'hawtioCore');
    });
});
var Core;
(function (Core) {
    Core._module.directive('noClick', function () {
        return function ($scope, $element, $attrs) {
            $element.click(function (event) {
                event.preventDefault();
            });
        };
    });
    Core._module.directive('logToggler', ["localStorage", function (localStorage) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attr) {
                $($element).click(function () {
                    var log = $("#log-panel");
                    var body = $('body');
                    if (log.height() !== 0) {
                        localStorage['showLog'] = 'false';
                        log.css({ 'bottom': '110%' });
                        body.css({
                            'overflow-y': 'auto'
                        });
                    }
                    else {
                        localStorage['showLog'] = 'true';
                        log.css({ 'bottom': '50%' });
                        body.css({
                            'overflow-y': 'hidden'
                        });
                    }
                    return false;
                });
            }
        };
    }]);
    Core._module.directive('autofill', ['$timeout', function ($timeout) {
        return {
            restrict: "A",
            require: 'ngModel',
            link: function (scope, elem, attrs, ctrl) {
                var ngModel = attrs["ngModel"];
                if (ngModel) {
                    var log = Logger.get("Core");
                    function checkForDifference() {
                        var modelValue = scope.$eval(ngModel);
                        var value = elem.val();
                        if (value && !modelValue) {
                            Core.pathSet(scope, ngModel, value);
                        }
                        else {
                            elem.trigger('input');
                            elem.trigger('change');
                            if (elem.length) {
                                var firstElem = $(elem[0]);
                                firstElem.trigger('input');
                                firstElem.trigger('change');
                            }
                        }
                    }
                    $timeout(checkForDifference, 200);
                    $timeout(checkForDifference, 800);
                    $timeout(checkForDifference, 1500);
                }
            }
        };
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core._module.controller("Core.CorePreferences", ["$scope", "localStorage", function ($scope, localStorage) {
        Core.initPreferenceScope($scope, localStorage, {
            'updateRate': {
                'value': 5000,
                'post': function (newValue) {
                    $scope.$emit('UpdateRate', newValue);
                }
            },
            'showWelcomePage': {
                'value': true,
                'converter': Core.parseBooleanValue,
            },
            'regexs': {
                'value': "",
                'converter': function (value) {
                    if (angular.isArray(value)) {
                        return value;
                    }
                    else if (Core.isBlank(value)) {
                        return [];
                    }
                    return angular.fromJson(value);
                },
                'formatter': function (value) {
                    return angular.toJson(value);
                },
                'compareAsObject': true
            }
        });
        $scope.newHost = {};
        $scope.forms = {};
        $scope.addRegexDialog = new UI.Dialog();
        $scope.onOk = function (json, form) {
            $scope.addRegexDialog.close();
            json['color'] = UI.colors.sample();
            if (!angular.isArray($scope.regexs)) {
                $scope.regexs = [json];
            }
            else {
                $scope.regexs.push(json);
            }
            $scope.newHost = {};
            Core.$apply($scope);
        };
        $scope.hostSchema = {
            properties: {
                'name': {
                    description: 'Indicator name',
                    type: 'string',
                    required: true
                },
                'regex': {
                    description: 'Indicator regex',
                    type: 'string',
                    required: true
                }
            }
        };
        $scope.delete = function (index) {
            $scope.regexs.removeAt(index);
        };
        $scope.moveUp = function (index) {
            var tmp = $scope.regexs[index];
            $scope.regexs[index] = $scope.regexs[index - 1];
            $scope.regexs[index - 1] = tmp;
        };
        $scope.moveDown = function (index) {
            var tmp = $scope.regexs[index];
            $scope.regexs[index] = $scope.regexs[index + 1];
            $scope.regexs[index + 1] = tmp;
        };
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    var HelpRegistry = (function () {
        function HelpRegistry($rootScope) {
            this.$rootScope = $rootScope;
            this.discoverableDocTypes = {
                user: 'help.md'
            };
            this.topicNameMappings = {
                activemq: 'ActiveMQ',
                camel: 'Camel',
                jboss: 'JBoss',
                jclouds: 'jclouds',
                jmx: 'JMX',
                jvm: 'Connect',
                log: 'Logs',
                openejb: 'OpenEJB'
            };
            this.subTopicNameMappings = {
                user: 'For Users',
                developer: 'For Developers',
                faq: 'FAQ'
            };
            this.pluginNameMappings = {
                hawtioCore: 'core',
                'hawtio-branding': 'branding',
                forceGraph: 'forcegraph',
                'hawtio-ui': 'ui',
                'hawtio-forms': 'forms',
                elasticjs: 'elasticsearch'
            };
            this.ignoredPlugins = [
                'core',
                'branding',
                'datatable',
                'forcegraph',
                'forms',
                'perspective',
                'tree',
                'ui'
            ];
            this.topics = {};
        }
        HelpRegistry.prototype.addUserDoc = function (topic, path, isValid) {
            if (isValid === void 0) { isValid = null; }
            this.addSubTopic(topic, 'user', path, isValid);
        };
        HelpRegistry.prototype.addDevDoc = function (topic, path, isValid) {
            if (isValid === void 0) { isValid = null; }
            this.addSubTopic(topic, 'developer', path, isValid);
        };
        HelpRegistry.prototype.addSubTopic = function (topic, subtopic, path, isValid) {
            if (isValid === void 0) { isValid = null; }
            this.getOrCreateTopic(topic, isValid)[subtopic] = path;
        };
        HelpRegistry.prototype.getOrCreateTopic = function (topic, isValid) {
            if (isValid === void 0) { isValid = null; }
            if (!angular.isDefined(this.topics[topic])) {
                if (isValid === null) {
                    isValid = function () {
                        return true;
                    };
                }
                this.topics[topic] = {
                    isValid: isValid
                };
                this.$rootScope.$broadcast('hawtioNewHelpTopic');
            }
            return this.topics[topic];
        };
        HelpRegistry.prototype.mapTopicName = function (name) {
            if (angular.isDefined(this.topicNameMappings[name])) {
                return this.topicNameMappings[name];
            }
            return name.capitalize();
        };
        HelpRegistry.prototype.mapSubTopicName = function (name) {
            if (angular.isDefined(this.subTopicNameMappings[name])) {
                return this.subTopicNameMappings[name];
            }
            return name.capitalize();
        };
        HelpRegistry.prototype.getTopics = function () {
            var answer = {};
            angular.forEach(this.topics, function (value, key) {
                if (value.isValid()) {
                    Core.log.debug(key, " is available");
                    answer[key] = angular.fromJson(angular.toJson(value));
                }
                else {
                    Core.log.debug(key, " is not available");
                }
            });
            return answer;
        };
        HelpRegistry.prototype.disableAutodiscover = function (name) {
            this.ignoredPlugins.push(name);
        };
        HelpRegistry.prototype.discoverHelpFiles = function (plugins) {
            var self = this;
            console.log("Ignored plugins: ", self.ignoredPlugins);
            plugins.forEach(function (plugin) {
                var pluginName = self.pluginNameMappings[plugin];
                if (!angular.isDefined(pluginName)) {
                    pluginName = plugin;
                }
                if (!self.ignoredPlugins.any(function (p) {
                    return p === pluginName;
                })) {
                    angular.forEach(self.discoverableDocTypes, function (value, key) {
                        if (!angular.isDefined(self[pluginName]) || !angular.isDefined(self[pluginName][key])) {
                            var target = 'app/' + pluginName + '/doc/' + value;
                            console.log("checking: ", target);
                            $.ajax(target, {
                                type: 'HEAD',
                                statusCode: {
                                    200: function () {
                                        self.getOrCreateTopic(plugin)[key] = target;
                                    }
                                }
                            });
                        }
                    });
                }
            });
        };
        return HelpRegistry;
    })();
    Core.HelpRegistry = HelpRegistry;
})(Core || (Core = {}));
var Core;
(function (Core) {
    var PreferencesRegistry = (function () {
        function PreferencesRegistry() {
            this.tabs = {};
        }
        PreferencesRegistry.prototype.addTab = function (name, template, isValid) {
            if (isValid === void 0) { isValid = undefined; }
            if (!isValid) {
                isValid = function () {
                    return true;
                };
            }
            this.tabs[name] = {
                template: template,
                isValid: isValid
            };
        };
        PreferencesRegistry.prototype.getTab = function (name) {
            return this.tabs[name];
        };
        PreferencesRegistry.prototype.getTabs = function () {
            var answer = {};
            angular.forEach(this.tabs, function (value, key) {
                if (value.isValid()) {
                    answer[key] = value;
                }
            });
            return answer;
        };
        return PreferencesRegistry;
    })();
    Core.PreferencesRegistry = PreferencesRegistry;
    ;
})(Core || (Core = {}));
var Themes;
(function (Themes) {
    Themes.defaultLoginBg = 'app/themes/img/default/hawtio-nologo.jpg';
    Themes.definitions = {
        'Default': {
            label: 'Default',
            file: 'app/themes/css/default.css',
            loginBg: Themes.defaultLoginBg
        },
        'Dark': {
            label: 'Dark',
            file: 'app/themes/css/dark.css',
            loginBg: Themes.defaultLoginBg
        },
        '3270': {
            label: 'Dark',
            file: 'app/themes/css/3270.css',
            loginBg: Themes.defaultLoginBg
        }
    };
    Themes.brandings = {
        'hawtio': {
            label: 'hawtio',
            setFunc: function (branding) {
                branding.appName = 'hawtio';
                branding.appLogo = 'img/hawtio_logo.svg';
                branding.css = 'css/site-branding.css';
                branding.logoOnly = true;
                branding.fullscreenLogin = false;
                branding.favicon = 'favicon.ico';
                branding.welcomePageUrl = 'app/core/doc/welcome.md';
                branding.onWelcomePage = function (data) {
                    return marked(data);
                };
                return branding;
            }
        },
        'Example': {
            label: 'Example',
            setFunc: function (branding) {
                branding.appName = 'Example';
                branding.appLogo = '';
                branding.logoOnly = false;
                branding.welcomePageUrl = 'app/themes/doc/welcome_example.md';
                return branding;
            }
        }
    };
    Themes.currentTheme = 'Default';
    Themes.currentBranding = 'hawtio';
    function getAvailableThemes() {
        return Object.extended(Themes.definitions).keys();
    }
    Themes.getAvailableThemes = getAvailableThemes;
    function getAvailableBrandings() {
        return Object.extended(Themes.brandings).keys();
    }
    Themes.getAvailableBrandings = getAvailableBrandings;
    function getBranding(name) {
        var b = Themes.brandings[name];
        if (!b || !b['setFunc']) {
            b = Themes.brandings['hawtio'];
        }
        return b;
    }
    function setCSS(el, file) {
        var cssEL = $(el);
        cssEL.prop("disabled", true);
        cssEL.attr({ href: file });
        cssEL.prop("disabled", false);
    }
    function setFavicon(file) {
        $('#favicon').remove();
        $('head').append('<link id="favicon" rel="icon" type="image/ico" href="' + file + '">"');
    }
    function applyTheme(theme, branding) {
        if (!theme || !theme['file'] || !theme['label']) {
            Themes.log.info("invalid theme, setting theme to Default");
            setCSS("#theme", Themes.definitions['Default']['file']);
            branding.loginBg = Themes.definitions['Default']['loginBg'];
        }
        else {
            Themes.log.debug("Setting theme to ", theme['label']);
            setCSS("#theme", theme['file']);
            if (theme['loginBg']) {
                branding.loginBg = theme['loginBg'];
            }
        }
    }
    function setBranding(name, branding) {
        var b = getBranding(name);
        branding = b.setFunc(branding);
        Themes.log.debug("Set branding to: ", branding);
        if (branding.favicon) {
            setFavicon(branding.favicon);
        }
        if (branding.css) {
            setCSS("#branding", branding.css);
        }
        Themes.currentBranding = b['label'];
        localStorage['branding'] = Themes.currentBranding;
    }
    Themes.setBranding = setBranding;
    function setTheme(name, branding) {
        if (!(name in Themes.definitions)) {
            name = 'Default';
            Themes.log.info("unknown theme name, using default theme");
        }
        var theme = Core.pathGet(Themes.definitions, [name]);
        applyTheme(theme, branding);
        Themes.currentTheme = name;
        localStorage['theme'] = Themes.currentTheme;
    }
    Themes.setTheme = setTheme;
    Themes.pluginName = "themes";
    Themes.log = Logger.get("Themes");
    Themes._module = angular.module(Themes.pluginName, ["hawtioCore"]);
    Themes._module.run(["localStorage", "branding", "preferencesRegistry", function (localStorage, branding, preferencesRegistry) {
        var themeName = localStorage['theme'];
        Themes.setTheme(themeName, branding);
        var brandingName = localStorage['branding'];
        Themes.setBranding(brandingName, branding);
        preferencesRegistry.addTab("Theme", "app/themes/html/preferences.html");
        Themes.log.debug("Loaded");
    }]);
    hawtioPluginLoader.addModule(Themes.pluginName);
})(Themes || (Themes = {}));
var Core;
(function (Core) {
    Core._module.factory('workspace', ["$location", "jmxTreeLazyLoadRegistry", "$compile", "$templateCache", "localStorage", "jolokia", "jolokiaStatus", "$rootScope", "userDetails", function ($location, jmxTreeLazyLoadRegistry, $compile, $templateCache, localStorage, jolokia, jolokiaStatus, $rootScope, userDetails) {
        var answer = new Core.Workspace(jolokia, jolokiaStatus, jmxTreeLazyLoadRegistry, $location, $compile, $templateCache, localStorage, $rootScope, userDetails);
        answer.loadTree();
        return answer;
    }]);
    Core._module.service('ConnectOptions', ['$location', function ($location) {
        var connectionName = Core.ConnectionName;
        if (!Core.isBlank(connectionName)) {
            var answer = Core.getConnectOptions(connectionName);
            Core.log.debug("ConnectOptions: ", answer);
            return answer;
        }
        Core.log.debug("No connection options, connected to local JVM");
        return null;
    }]);
    Core._module.service('localStorage', function () {
        return Core.getLocalStorage();
    });
    Core._module.factory('pageTitle', function () {
        var answer = new Core.PageTitle();
        return answer;
    });
    Core._module.factory('viewRegistry', function () {
        return {};
    });
    Core._module.factory('lastLocation', function () {
        return {};
    });
    Core._module.factory('locationChangeStartTasks', function () {
        return new Core.ParameterizedTasksImpl();
    });
    Core._module.factory('postLoginTasks', function () {
        return Core.postLoginTasks;
    });
    Core._module.factory('preLogoutTasks', function () {
        return Core.preLogoutTasks;
    });
    Core._module.factory('postLogoutTasks', function () {
        return Core.postLogoutTasks;
    });
    Core._module.factory('helpRegistry', ["$rootScope", function ($rootScope) {
        return new Core.HelpRegistry($rootScope);
    }]);
    Core._module.factory('preferencesRegistry', function () {
        return new Core.PreferencesRegistry();
    });
    Core._module.factory('toastr', ["$window", function ($window) {
        var answer = $window.toastr;
        if (!answer) {
            answer = {};
            $window.toaster = answer;
        }
        return answer;
    }]);
    Core._module.factory('metricsWatcher', ["$window", function ($window) {
        var answer = $window.metricsWatcher;
        if (!answer) {
            answer = {};
            $window.metricsWatcher = metricsWatcher;
        }
        return answer;
    }]);
    Core._module.factory('xml2json', function () {
        var jquery = $;
        return jquery.xml2json;
    });
    Core._module.factory('jolokiaUrl', function () {
        return Core.jolokiaUrl;
    });
    Core._module.factory('jolokiaStatus', function () {
        return {
            xhr: null
        };
    });
    Core.DEFAULT_MAX_DEPTH = 7;
    Core.DEFAULT_MAX_COLLECTION_SIZE = 500;
    Core._module.factory('jolokiaParams', ["jolokiaUrl", "localStorage", function (jolokiaUrl, localStorage) {
        var answer = {
            canonicalNaming: false,
            ignoreErrors: true,
            mimeType: 'application/json',
            maxDepth: Core.DEFAULT_MAX_DEPTH,
            maxCollectionSize: Core.DEFAULT_MAX_COLLECTION_SIZE
        };
        if ('jolokiaParams' in localStorage) {
            answer = angular.fromJson(localStorage['jolokiaParams']);
        }
        else {
            localStorage['jolokiaParams'] = angular.toJson(answer);
        }
        answer['url'] = jolokiaUrl;
        return answer;
    }]);
    Core._module.factory('branding', function () {
        var branding = Themes.brandings['hawtio'].setFunc({});
        branding.logoClass = function () {
            if (branding.logoOnly) {
                return "without-text";
            }
            else {
                return "with-text";
            }
        };
        return branding;
    });
    Core._module.factory('ResponseHistory', function () {
        var answer = Core.getResponseHistory();
        return answer;
    });
    Core._module.factory('userDetails', ["ConnectOptions", "localStorage", "$window", "$rootScope", function (ConnectOptions, localStorage, $window, $rootScope) {
        var answer = {
            username: null,
            password: null
        };
        if ('userDetails' in $window) {
            answer = $window['userDetails'];
            Core.log.debug("User details loaded from parent window: ", StringHelpers.toString(answer));
            Core.executePostLoginTasks();
        }
        else if ('userDetails' in localStorage) {
            answer = angular.fromJson(localStorage['userDetails']);
            Core.log.debug("User details loaded from local storage: ", StringHelpers.toString(answer));
            Core.executePostLoginTasks();
        }
        else if (Core.isChromeApp()) {
            answer = {
                username: 'user',
                password: ''
            };
            Core.log.debug("Running as a Chrome app, using fake UserDetails: ");
            Core.executePostLoginTasks();
        }
        else {
            Core.log.debug("No username set, checking if we have a session");
            var userUrl = "user";
            $.ajax(userUrl, {
                type: "GET",
                success: function (response) {
                    Core.log.debug("Got user response: ", response);
                    if (response === null) {
                        answer.username = null;
                        answer.password = null;
                        Core.log.debug("user response was null, no session available");
                        Core.$apply($rootScope);
                        return;
                    }
                    answer.username = response;
                    if (response === 'user') {
                        Core.log.debug("Authentication disabled, using dummy credentials");
                        answer.loginDetails = {};
                    }
                    else {
                        Core.log.debug("User details loaded from existing session: ", StringHelpers.toString(answer));
                    }
                    Core.executePostLoginTasks();
                    Core.$apply($rootScope);
                },
                error: function (xhr, textStatus, error) {
                    answer.username = null;
                    answer.password = null;
                    Core.log.debug("Failed to get session username: ", error);
                    Core.$apply($rootScope);
                }
            });
            Core.log.debug("Created empty user details to be filled in: ", StringHelpers.toString(answer));
        }
        return answer;
    }]);
    Core._module.factory('jmxTreeLazyLoadRegistry', function () {
        return Core.lazyLoaders;
    });
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core.fileUploadMBean = "hawtio:type=UploadManager";
    var FileUpload = (function () {
        function FileUpload() {
            this.restrict = 'A';
            this.replace = true;
            this.templateUrl = Core.templatePath + "fileUpload.html";
            this.scope = {
                files: '=hawtioFileUpload',
                target: '@',
                showFiles: '@'
            };
            this.controller = ["$scope", "$element", "$attrs", "jolokia", function ($scope, $element, $attrs, jolokia) {
                $scope.target = '';
                $scope.response = '';
                $scope.percentComplete = 0;
                UI.observe($scope, $attrs, 'target', '');
                UI.observe($scope, $attrs, 'showFiles', true);
                $scope.update = function (response) {
                    var responseJson = angular.toJson(response.value);
                    if ($scope.responseJson !== responseJson) {
                        $scope.responseJson = responseJson;
                        $scope.files = response.value;
                        Core.$applyNowOrLater($scope);
                    }
                };
                $scope.delete = function (fileName) {
                    jolokia.request({
                        type: 'exec',
                        mbean: Core.fileUploadMBean,
                        operation: 'delete(java.lang.String, java.lang.String)',
                        arguments: [$scope.target, fileName]
                    }, {
                        success: function () {
                            Core.$apply($scope);
                        },
                        error: function (response) {
                            Core.notification('error', "Failed to delete " + fileName + " due to: " + response.error);
                            Core.$apply($scope);
                        }
                    });
                };
                $scope.$watch('target', function (newValue, oldValue) {
                    if (oldValue !== newValue) {
                        Core.unregister(jolokia, $scope);
                    }
                    Core.register(jolokia, $scope, {
                        type: 'exec',
                        mbean: Core.fileUploadMBean,
                        operation: 'list(java.lang.String)',
                        arguments: [$scope.target]
                    }, onSuccess($scope.update));
                });
            }];
            this.link = function ($scope, $element, $attrs) {
                var fileInput = $element.find('input[type=file]');
                var form = $element.find('form[name=file-upload]');
                var button = $element.find('input[type=button]');
                var onFileChange = function () {
                    button.prop('disabled', true);
                    var files = fileInput.get(0).files;
                    var fileName = files.length + " files";
                    if (files.length === 1) {
                        fileName = files[0].name;
                    }
                    form.ajaxSubmit({
                        beforeSubmit: function (arr, $form, options) {
                            Core.notification('info', "Uploading " + fileName);
                            $scope.percentComplete = 0;
                            Core.$apply($scope);
                        },
                        success: function (response, statusText, xhr, $form) {
                            Core.notification('success', "Uploaded " + fileName);
                            setTimeout(function () {
                                button.prop('disabled', false);
                                $scope.percentComplete = 0;
                                Core.$apply($scope);
                            }, 1000);
                            Core.$apply($scope);
                        },
                        error: function (response, statusText, xhr, $form) {
                            Core.notification('error', "Failed to upload " + fileName + " due to " + statusText);
                            setTimeout(function () {
                                button.prop('disabled', false);
                                $scope.percentComplete = 0;
                                Core.$apply($scope);
                            }, 1000);
                            Core.$apply($scope);
                        },
                        uploadProgress: function (event, position, total, percentComplete) {
                            $scope.percentComplete = percentComplete;
                            Core.$apply($scope);
                        }
                    });
                    return false;
                };
                button.click(function () {
                    if (!button.prop('disabled')) {
                        fileInput.click();
                    }
                    return false;
                });
                form.submit(function () {
                    return false;
                });
                if ($.browser.msie) {
                    fileInput.click(function (event) {
                        setTimeout(function () {
                            if (fileInput.val().length > 0) {
                                onFileChange();
                            }
                        }, 0);
                    });
                }
                else {
                    fileInput.change(onFileChange);
                }
            };
        }
        return FileUpload;
    })();
    Core.FileUpload = FileUpload;
    Core._module.directive('hawtioFileUpload', function () {
        return new Core.FileUpload();
    });
})(Core || (Core = {}));
var Core;
(function (Core) {
    function d3ForceGraph(scope, nodes, links, canvasElement) {
        if (scope.graphForce) {
            scope.graphForce.stop();
        }
        if (!canvasElement) {
            canvasElement = $("#canvas")[0];
        }
        var canvasDiv = $(canvasElement);
        canvasDiv.children("svg").remove();
        if (nodes.length) {
            var width = canvasDiv.parent().width();
            var height = canvasDiv.parent().height();
            if (height < 100) {
                var offset = canvasDiv.offset();
                height = $(document).height() - 5;
                if (offset) {
                    height -= offset['top'];
                }
            }
            var svg = d3.select(canvasDiv[0]).append("svg").attr("width", width).attr("height", height);
            var force = d3.layout.force().distance(100).charge(-120 * 10).linkDistance(50).size([width, height]);
            scope.graphForce = force;
            svg.append("svg:defs").selectAll("marker").data(["from"]).enter().append("svg:marker").attr("id", String).attr("viewBox", "0 -5 10 10").attr("refX", 25).attr("refY", -1.5).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").append("svg:path").attr("d", "M0,-5L10,0L0,5");
            force.nodes(nodes).links(links).start();
            var link = svg.selectAll(".link").data(links).enter().append("line").attr("class", "link");
            link.attr("class", "link from");
            link.attr("marker-end", "url(#from)");
            var node = svg.selectAll(".node").data(nodes).enter().append("g").attr("class", "node").call(force.drag);
            node.append("image").attr("xlink:href", function (d) {
                return d.imageUrl;
            }).attr("x", -15).attr("y", -15).attr("width", 30).attr("height", 30);
            node.append("text").attr("dx", 20).attr("dy", ".35em").text(function (d) {
                return d.label;
            });
            force.on("tick", function () {
                link.attr("x1", function (d) {
                    return d.source.x;
                }).attr("y1", function (d) {
                    return d.source.y;
                }).attr("x2", function (d) {
                    return d.target.x;
                }).attr("y2", function (d) {
                    return d.target.y;
                });
                node.attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
            });
        }
    }
    Core.d3ForceGraph = d3ForceGraph;
    function createGraphStates(nodes, links, transitions) {
        var stateKeys = {};
        nodes.forEach(function (node) {
            var idx = node.id;
            if (idx === undefined) {
                console.log("No node found for node " + JSON.stringify(node));
            }
            else {
                if (node.edges === undefined)
                    node.edges = [];
                if (!node.label)
                    node.label = "node " + idx;
                stateKeys[idx] = node;
            }
        });
        var states = d3.values(stateKeys);
        links.forEach(function (d) {
            var source = stateKeys[d.source];
            var target = stateKeys[d.target];
            if (source === undefined || target === undefined) {
                console.log("Bad link!  " + source + " target " + target + " for " + d);
            }
            else {
                var edge = { source: source, target: target };
                transitions.push(edge);
                source.edges.push(edge);
                target.edges.push(edge);
            }
        });
        return states;
    }
    Core.createGraphStates = createGraphStates;
    function dagreLayoutGraph(nodes, links, width, height, svgElement, allowDrag, onClick) {
        if (allowDrag === void 0) { allowDrag = false; }
        if (onClick === void 0) { onClick = null; }
        var nodePadding = 10;
        var transitions = [];
        var states = Core.createGraphStates(nodes, links, transitions);
        function spline(e) {
            var points = e.dagre.points.slice(0);
            var source = dagre.util.intersectRect(e.source.dagre, points.length > 0 ? points[0] : e.source.dagre);
            var target = dagre.util.intersectRect(e.target.dagre, points.length > 0 ? points[points.length - 1] : e.source.dagre);
            points.unshift(source);
            points.push(target);
            return d3.svg.line().x(function (d) {
                return d.x;
            }).y(function (d) {
                return d.y;
            }).interpolate("linear")(points);
        }
        function translateEdge(e, dx, dy) {
            e.dagre.points.forEach(function (p) {
                p.x = Math.max(0, Math.min(svgBBox.width, p.x + dx));
                p.y = Math.max(0, Math.min(svgBBox.height, p.y + dy));
            });
        }
        var svg = svgElement ? d3.select(svgElement) : d3.select("svg");
        if (svgElement) {
            $(svgElement).children("g").remove();
        }
        $(svg).children("g").remove();
        var svgGroup = svg.append("g").attr("transform", "translate(5, 5)");
        var nodes = svgGroup.selectAll("g .node").data(states).enter().append("g").attr("class", "node").attr("data-cid", function (d) {
            return d.cid;
        }).attr("id", function (d) {
            return "node-" + d.label;
        });
        nodes.append("title").text(function (d) {
            return d.tooltip || "";
        });
        var edges = svgGroup.selectAll("path .edge").data(transitions).enter().append("path").attr("class", "edge").attr("marker-end", "url(#arrowhead)");
        var rects = nodes.append("rect").attr("rx", "4").attr("ry", "4").attr("class", function (d) {
            return d.type;
        });
        var images = nodes.append("image").attr("xlink:href", function (d) {
            return d.imageUrl;
        }).attr("x", -12).attr("y", -20).attr("height", 24).attr("width", 24);
        var counters = nodes.append("text").attr("text-anchor", "end").attr("class", "counter").attr("x", 0).attr("dy", 0).text(_counterFunction);
        var inflights = nodes.append("text").attr("text-anchor", "middle").attr("class", "inflight").attr("x", 10).attr("dy", -32).text(_inflightFunction);
        var labels = nodes.append("text").attr("text-anchor", "middle").attr("x", 0);
        labels.append("tspan").attr("x", 0).attr("dy", 28).text(function (d) {
            return d.label;
        });
        var labelPadding = 12;
        var minLabelwidth = 80;
        labels.each(function (d) {
            var bbox = this.getBBox();
            d.bbox = bbox;
            if (bbox.width < minLabelwidth) {
                bbox.width = minLabelwidth;
            }
            d.width = bbox.width + 2 * nodePadding;
            d.height = bbox.height + 2 * nodePadding + labelPadding;
        });
        rects.attr("x", function (d) {
            return -(d.bbox.width / 2 + nodePadding);
        }).attr("y", function (d) {
            return -(d.bbox.height / 2 + nodePadding + (labelPadding / 2));
        }).attr("width", function (d) {
            return d.width;
        }).attr("height", function (d) {
            return d.height;
        });
        if (onClick != null) {
            rects.on("click", onClick);
        }
        images.attr("x", function (d) {
            return -(d.bbox.width) / 2;
        });
        labels.attr("x", function (d) {
            return -d.bbox.width / 2;
        }).attr("y", function (d) {
            return -d.bbox.height / 2;
        });
        counters.attr("x", function (d) {
            var w = d.bbox.width;
            return w / 2;
        });
        dagre.layout().nodeSep(50).edgeSep(10).rankSep(50).nodes(states).edges(transitions).debugLevel(1).run();
        nodes.attr("transform", function (d) {
            return 'translate(' + d.dagre.x + ',' + d.dagre.y + ')';
        });
        edges.attr('id', function (e) {
            return e.dagre.id;
        }).attr("d", function (e) {
            return spline(e);
        });
        var svgNode = svg.node();
        if (svgNode) {
            var svgBBox = svgNode.getBBox();
            if (svgBBox) {
                svg.attr("width", svgBBox.width + 10);
                svg.attr("height", svgBBox.height + 10);
            }
        }
        if (allowDrag) {
            var nodeDrag = d3.behavior.drag().origin(function (d) {
                return d.pos ? { x: d.pos.x, y: d.pos.y } : { x: d.dagre.x, y: d.dagre.y };
            }).on('drag', function (d, i) {
                var prevX = d.dagre.x, prevY = d.dagre.y;
                d.dagre.x = Math.max(d.width / 2, Math.min(svgBBox.width - d.width / 2, d3.event.x));
                d.dagre.y = Math.max(d.height / 2, Math.min(svgBBox.height - d.height / 2, d3.event.y));
                d3.select(this).attr('transform', 'translate(' + d.dagre.x + ',' + d.dagre.y + ')');
                var dx = d.dagre.x - prevX, dy = d.dagre.y - prevY;
                d.edges.forEach(function (e) {
                    translateEdge(e, dx, dy);
                    d3.select('#' + e.dagre.id).attr('d', spline(e));
                });
            });
            var edgeDrag = d3.behavior.drag().on('drag', function (d, i) {
                translateEdge(d, d3.event.dx, d3.event.dy);
                d3.select(this).attr('d', spline(d));
            });
            nodes.call(nodeDrag);
            edges.call(edgeDrag);
        }
        return states;
    }
    Core.dagreLayoutGraph = dagreLayoutGraph;
    function dagreUpdateGraphData(data) {
        var svg = d3.select("svg");
        svg.selectAll("text.counter").text(_counterFunction);
        svg.selectAll("text.inflight").text(_inflightFunction);
        svg.selectAll("g .node title").text(function (d) {
            return d.tooltip || "";
        });
    }
    Core.dagreUpdateGraphData = dagreUpdateGraphData;
    function _counterFunction(d) {
        return d.counter || "";
    }
    function _inflightFunction(d) {
        return d.inflight || "";
    }
})(Core || (Core = {}));
var Core;
(function (Core) {
    var GridStyle = (function () {
        function GridStyle($window) {
            var _this = this;
            this.$window = $window;
            this.restrict = 'C';
            this.link = function (scope, element, attrs) {
                return _this.doLink(scope, element, attrs);
            };
        }
        GridStyle.prototype.doLink = function (scope, element, attrs) {
            var lastHeight = 0;
            var resizeFunc = angular.bind(this, function (scope) {
                var top = element.position().top;
                var windowHeight = $(this.$window).height();
                var height = windowHeight - top - 15;
                var heightStr = height + 'px';
                element.css({
                    'min-height': heightStr,
                    'height': heightStr
                });
                if (lastHeight !== height) {
                    lastHeight = height;
                    element.trigger('resize');
                }
            });
            resizeFunc();
            scope.$watch(resizeFunc);
            $(this.$window).resize(function () {
                resizeFunc();
                Core.$apply(scope);
                return false;
            });
        };
        return GridStyle;
    })();
    Core.GridStyle = GridStyle;
    Core._module.directive('gridStyle', ["$window", function ($window) {
        return new Core.GridStyle($window);
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core._module.controller("Core.HelpController", ["$scope", "$routeParams", "marked", "helpRegistry", "branding", function ($scope, $routeParams, marked, helpRegistry, branding) {
        $scope.branding = branding;
        $scope.topics = helpRegistry.getTopics();
        if ('topic' in $routeParams) {
            $scope.topic = $routeParams['topic'];
        }
        else {
            $scope.topic = 'index';
        }
        if ('subtopic' in $routeParams) {
            $scope.subTopic = $routeParams['subtopic'];
        }
        else {
            $scope.subTopic = Object.extended($scope.topics[$scope.topic]).keys().first();
        }
        Core.log.debug("topic: ", $scope.topic, " subtopic: ", $scope.subTopic);
        var isIndex = $scope.topic === "index";
        var filterSubTopic = $scope.subTopic;
        if (isIndex && filterSubTopic !== "developer") {
            filterSubTopic = "user";
        }
        $scope.breadcrumbs = [
            {
                topic: "index",
                subTopic: "user",
                label: "User Guide"
            },
            {
                topic: "index",
                subTopic: "faq",
                label: "FAQ"
            },
            {
                topic: "index",
                subTopic: "changes",
                label: "Changes"
            },
            {
                topic: "index",
                subTopic: "developer",
                label: "Developers"
            }
        ];
        $scope.sectionLink = function (section) {
            var topic = section.topic || "";
            var subTopic = section.subTopic || "";
            var link = Core.pathGet(helpRegistry.topics, [topic, subTopic]);
            if (link && link.indexOf("#") >= 0) {
                return link;
            }
            else {
                return "#/help/" + topic + "/" + subTopic;
            }
        };
        var activeBreadcrumb = $scope.breadcrumbs.find(function (b) { return b.topic === $scope.topic && b.subTopic === $scope.subTopic; });
        if (activeBreadcrumb)
            activeBreadcrumb.active = true;
        $scope.sections = [];
        angular.forEach($scope.topics, function (details, topic) {
            if (topic !== "index" && details[filterSubTopic]) {
                $scope.sections.push({
                    topic: topic,
                    subTopic: filterSubTopic,
                    label: helpRegistry.mapTopicName(topic),
                    active: topic === $scope.topic
                });
            }
        });
        $scope.sections = $scope.sections.sortBy("label");
        $scope.$on('hawtioNewHelpTopic', function () {
            $scope.topics = helpRegistry.getTopics();
        });
        $scope.$watch('topics', function (newValue, oldValue) {
            Core.log.debug("Topics: ", $scope.topics);
        });
        if (!angular.isDefined($scope.topics[$scope.topic])) {
            $scope.html = "Unable to download help data for " + $scope.topic;
        }
        else {
            $.ajax({
                url: $scope.topics[$scope.topic][$scope.subTopic],
                dataType: 'html',
                cache: false,
                success: function (data, textStatus, jqXHR) {
                    $scope.html = "Unable to download help data for " + $scope.topic;
                    if (angular.isDefined(data)) {
                        $scope.html = marked(data);
                    }
                    Core.$apply($scope);
                },
                error: function (jqXHR, textStatus, errorThrown) {
                    $scope.html = "Unable to download help data for " + $scope.topic;
                    Core.$apply($scope);
                }
            });
        }
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core._module.controller("Core.JolokiaPreferences", ["$scope", "localStorage", "jolokiaParams", "$window", function ($scope, localStorage, jolokiaParams, $window) {
        Core.initPreferenceScope($scope, localStorage, {
            'maxDepth': {
                'value': Core.DEFAULT_MAX_DEPTH,
                'converter': parseInt,
                'formatter': parseInt,
                'post': function (newValue) {
                    jolokiaParams.maxDepth = newValue;
                    localStorage['jolokiaParams'] = angular.toJson(jolokiaParams);
                }
            },
            'maxCollectionSize': {
                'value': Core.DEFAULT_MAX_COLLECTION_SIZE,
                'converter': parseInt,
                'formatter': parseInt,
                'post': function (newValue) {
                    jolokiaParams.maxCollectionSize = newValue;
                    localStorage['jolokiaParams'] = angular.toJson(jolokiaParams);
                }
            }
        });
        $scope.reboot = function () {
            $window.location.reload();
        };
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core._module.factory('jolokia', ["$location", "localStorage", "jolokiaStatus", "$rootScope", "userDetails", "jolokiaParams", "jolokiaUrl", function ($location, localStorage, jolokiaStatus, $rootScope, userDetails, jolokiaParams, jolokiaUrl) {
        Core.log.debug("Jolokia URL is " + jolokiaUrl);
        if (jolokiaUrl) {
            var connectionName = Core.getConnectionNameParameter($location.search());
            var connectionOptions = Core.getConnectOptions(connectionName);
            var username = null;
            var password = null;
            var found = false;
            try {
                if (window.opener && "passUserDetails" in window.opener) {
                    username = window.opener["passUserDetails"].username;
                    password = window.opener["passUserDetails"].password;
                    found = true;
                }
            }
            catch (securityException) {
            }
            if (!found) {
                if (connectionOptions && connectionOptions.userName && connectionOptions.password) {
                    username = connectionOptions.userName;
                    password = connectionOptions.password;
                }
                else if (angular.isDefined(userDetails) && angular.isDefined(userDetails.username) && angular.isDefined(userDetails.password)) {
                    username = userDetails.username;
                    password = userDetails.password;
                }
                else {
                    var search = hawtioPluginLoader.parseQueryString();
                    username = search["_user"];
                    password = search["_pwd"];
                    if (angular.isArray(username))
                        username = username[0];
                    if (angular.isArray(password))
                        password = password[0];
                }
            }
            else {
                userDetails.remoteJolokiaUserDetails = {
                    username: username,
                    password: password
                };
            }
            if (username && password) {
                userDetails.username = username;
                userDetails.password = password;
                $.ajaxSetup({
                    beforeSend: function (xhr) {
                        xhr.setRequestHeader('Authorization', Core.getBasicAuthHeader(username, password));
                    }
                });
                var loginUrl = jolokiaUrl.replace("jolokia", "auth/login/");
                $.ajax(loginUrl, {
                    type: "POST",
                    async: false,
                    success: function (response) {
                        jolokiaStatus.xhr = null;
                        if (response['credentials'] || response['principals']) {
                            userDetails.loginDetails = {
                                'credentials': response['credentials'],
                                'principals': response['principals']
                            };
                        }
                        else {
                            var doc = Core.pathGet(response, ['children', 0, 'innerHTML']);
                            if (doc) {
                                Core.log.debug("Response is a document (ignoring this): ", doc);
                            }
                        }
                        Core.executePostLoginTasks();
                    },
                    error: function (xhr, textStatus, error) {
                        jolokiaStatus.xhr = xhr;
                        Core.executePostLoginTasks();
                    }
                });
            }
            jolokiaParams['ajaxError'] = function (xhr, textStatus, error) {
                if (xhr.status === 401 || xhr.status === 403) {
                    Core.executePreLogoutTasks(function () {
                        if (localStorage['jvmConnect'] && localStorage['jvmConnect'] != "undefined") {
                            var jvmConnect = angular.fromJson(localStorage['jvmConnect']);
                            _.each(jvmConnect, function (value) {
                                delete value['userName'];
                                delete value['password'];
                            });
                            localStorage.setItem('jvmConnect', angular.toJson(jvmConnect));
                        }
                        localStorage.removeItem('activemqUserName');
                        localStorage.removeItem('activemqPassword');
                        Core.executePostLogoutTasks(function () {
                            Core.log.debug("Executing logout callback after successfully executed postLogoutTasks");
                            userDetails.username = null;
                            userDetails.password = null;
                            userDetails.loginDetails = null;
                            userDetails.remoteJolokiaUserDetails = null;
                            delete localStorage['userDetails'];
                        });
                    });
                }
                else {
                    jolokiaStatus.xhr = xhr;
                    if (!xhr.responseText && error) {
                        xhr.responseText = error.stack;
                    }
                }
                Core.$apply($rootScope);
            };
            var jolokia = new Jolokia(jolokiaParams);
            localStorage['url'] = jolokiaUrl;
            jolokia.stop();
            return jolokia;
        }
        else {
            var answer = {
                running: false,
                request: function (req, opts) { return null; },
                register: function (req, opts) { return null; },
                list: function (path, opts) { return null; },
                search: function (mBeanPatter, opts) { return null; },
                getAttribute: function (mbean, attribute, path, opts) { return null; },
                setAttribute: function (mbean, attribute, value, path, opts) {
                },
                version: function (opts) { return null; },
                execute: function (mbean, operation) {
                    var args = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        args[_i - 2] = arguments[_i];
                    }
                    return null;
                },
                start: function (period) {
                    answer.running = true;
                },
                stop: function () {
                    answer.running = false;
                },
                isRunning: function () { return answer.running; },
                jobs: function () { return []; }
            };
            return answer;
        }
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core._module.controller("Core.LoggingPreferences", ["$scope", function ($scope) {
        Core.initPreferenceScope($scope, localStorage, {
            'logBuffer': {
                'value': 100,
                'converter': parseInt,
                'formatter': parseInt,
                'post': function (newValue) {
                    window['LogBuffer'] = newValue;
                }
            },
            'logLevel': {
                'value': '{"value": 2, "name": "INFO"}',
                'post': function (value) {
                    var level = angular.fromJson(value);
                    Logger.setLevel(level);
                }
            }
        });
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core.NavBarController = Core._module.controller("Core.NavBarController", ["$scope", "$location", "workspace", "$route", "jolokia", "localStorage", "NavBarViewCustomLinks", function ($scope, $location, workspace, $route, jolokia, localStorage, NavBarViewCustomLinks) {
        $scope.hash = workspace.hash();
        $scope.topLevelTabs = [];
        $scope.subLevelTabs = workspace.subLevelTabs;
        $scope.currentPerspective = null;
        $scope.localStorage = localStorage;
        $scope.recentConnections = [];
        $scope.goTo = function (destination) {
            $location.url(destination);
        };
        $scope.$watch('localStorage.recentConnections', function (newValue, oldValue) {
            $scope.recentConnections = Core.getRecentConnections(localStorage);
        });
        $scope.openConnection = function (connection) {
            var connectOptions = Core.getConnectOptions(connection);
            if (connectOptions) {
                Core.connectToServer(localStorage, connectOptions);
            }
        };
        $scope.goHome = function () {
            window.open(".");
        };
        $scope.clearConnections = Core.clearConnections;
        $scope.perspectiveDetails = {
            perspective: null
        };
        $scope.topLevelTabs = function () {
            reloadPerspective();
            return workspace.topLevelTabs;
        };
        $scope.$on('jmxTreeUpdated', function () {
            reloadPerspective();
        });
        $scope.$watch('workspace.topLevelTabs', function () {
            reloadPerspective();
        });
        $scope.validSelection = function (uri) { return workspace.validSelection(uri); };
        $scope.isValid = function (nav) { return nav && nav.isValid(workspace); };
        $scope.switchPerspective = function (perspective) {
            if (perspective.onSelect && angular.isFunction(perspective.onSelect)) {
                perspective.onSelect.apply();
                return;
            }
            var searchPerspectiveId = $location.search()[Perspective.perspectiveSearchId];
            if (perspective && ($scope.currentPerspective !== perspective || perspective.id !== searchPerspectiveId)) {
                Logger.debug("Changed the perspective to " + JSON.stringify(perspective) + " from search id " + searchPerspectiveId);
                if ($scope.currentPerspective) {
                    $scope.currentPerspective.lastPage = $location.url();
                }
                var pid = perspective.id;
                $location.search(Perspective.perspectiveSearchId, pid);
                Logger.debug("Setting perspective to " + pid);
                $scope.currentPerspective = perspective;
                reloadPerspective();
                $scope.topLevelTabs = Perspective.getTopLevelTabsForPerspective($location, workspace, jolokia, localStorage);
                var defaultPlugin = Core.getDefaultPlugin(pid, workspace, jolokia, localStorage);
                var defaultTab;
                var path;
                if (defaultPlugin) {
                    $scope.topLevelTabs.forEach(function (tab) {
                        if (tab.id === defaultPlugin.id) {
                            defaultTab = tab;
                        }
                    });
                    if (defaultTab) {
                        path = Core.trimLeading(defaultTab.href(), "#");
                    }
                }
                else {
                    if (perspective.lastPage) {
                        path = Core.trimLeading(perspective.lastPage, "#");
                    }
                }
                if (path) {
                    var idx = path.indexOf("?p=") || path.indexOf("&p=");
                    if (idx > 0) {
                        path = path.substring(0, idx);
                    }
                    var sep = (path.indexOf("?") >= 0) ? "&" : "?";
                    path += sep + "p=" + pid;
                    $location.url(path);
                }
            }
        };
        $scope.$watch('hash', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                Core.log.debug("hash changed from ", oldValue, " to ", newValue);
            }
        });
        $scope.$on('$routeChangeSuccess', function () {
            $scope.hash = workspace.hash();
            reloadPerspective();
        });
        $scope.link = function (nav, includePerspective) {
            if (includePerspective === void 0) { includePerspective = false; }
            var href;
            if (angular.isString(nav)) {
                href = nav;
            }
            else {
                href = angular.isObject(nav) ? nav.href() : null;
            }
            href = href || "";
            var removeParams = ['tab', 'nid', 'chapter', 'pref', 'q'];
            if (!includePerspective && href) {
                if (href.indexOf("?p=") >= 0 || href.indexOf("&p=") >= 0) {
                    removeParams.push("p");
                }
            }
            return Core.createHref($location, href, removeParams);
        };
        $scope.fullScreenLink = function () {
            var href = "#" + $location.path() + "?tab=notree";
            return Core.createHref($location, href, ['tab']);
        };
        $scope.addToDashboardLink = function () {
            var href = "#" + $location.path() + workspace.hash();
            var answer = "#/dashboard/add?tab=dashboard&href=" + encodeURIComponent(href);
            if ($location.url().has("/jmx/charts")) {
                var size = {
                    size_x: 4,
                    size_y: 3
                };
                answer += "&size=" + encodeURIComponent(angular.toJson(size));
            }
            return answer;
        };
        $scope.isActive = function (nav) {
            if (angular.isString(nav))
                return workspace.isLinkActive(nav);
            var fn = nav.isActive;
            if (fn) {
                return fn(workspace);
            }
            return workspace.isLinkActive(nav.href());
        };
        $scope.isTopTabActive = function (nav) {
            if (angular.isString(nav))
                return workspace.isTopTabActive(nav);
            var fn = nav.isActive;
            if (fn) {
                return fn(workspace);
            }
            return workspace.isTopTabActive(nav.href());
        };
        $scope.activeLink = function () {
            var tabs = $scope.topLevelTabs();
            if (!tabs) {
                return "Loading...";
            }
            var tab = tabs.find(function (nav) {
                return $scope.isActive(nav);
            });
            return tab ? tab['content'] : "";
        };
        $scope.navBarViewCustomLinks = NavBarViewCustomLinks;
        $scope.isCustomLinkSet = function () {
            return $scope.navBarViewCustomLinks.list.length;
        };
        function reloadPerspective() {
            var perspectives = Perspective.getPerspectives($location, workspace, jolokia, localStorage);
            var currentId = Perspective.currentPerspectiveId($location, workspace, jolokia, localStorage);
            var newTopLevelTabs = Perspective.getTopLevelTabsForPerspective($location, workspace, jolokia, localStorage);
            var diff = newTopLevelTabs.subtract($scope.topLevelTabs);
            if (diff && diff.length > 0) {
                $scope.topLevelTabs = newTopLevelTabs;
                $scope.perspectiveId = currentId;
                $scope.perspectives = perspectives;
                $scope.perspectiveDetails.perspective = $scope.perspectives.find(function (p) {
                    return p['id'] === currentId;
                });
                Core.$apply($scope);
            }
        }
    }]);
    Core._module.service("NavBarViewCustomLinks", ['$location', '$rootScope', function ($location, $rootScope) {
        return {
            list: [],
            dropDownLabel: "Extra"
        };
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core.PluginPreferences = Core._module.controller("Core.PluginPreferences", ["$scope", "localStorage", "$location", "workspace", "jolokia", function ($scope, localStorage, $location, workspace, jolokia) {
        Core.initPreferenceScope($scope, localStorage, {
            'autoRefresh': {
                'value': true,
                'converter': Core.parseBooleanValue
            }
        });
        $scope.perspectiveId = null;
        $scope.perspectives = [];
        $scope.plugins = [];
        $scope.pluginDirty = false;
        $scope.pluginMoveUp = function (index) {
            $scope.pluginDirty = true;
            var tmp = $scope.plugins[index];
            $scope.plugins[index] = $scope.plugins[index - 1];
            $scope.plugins[index - 1] = tmp;
        };
        $scope.pluginMoveDown = function (index) {
            $scope.pluginDirty = true;
            var tmp = $scope.plugins[index];
            $scope.plugins[index] = $scope.plugins[index + 1];
            $scope.plugins[index + 1] = tmp;
        };
        $scope.pluginDisable = function (index) {
            $scope.pluginDirty = true;
            var atLeastOneEnabled = false;
            $scope.plugins.forEach(function (p, idx) {
                if (idx != index && p.enabled) {
                    atLeastOneEnabled = true;
                }
            });
            if (atLeastOneEnabled) {
                $scope.plugins[index].enabled = false;
                $scope.plugins[index].isDefault = false;
            }
        };
        $scope.pluginEnable = function (index) {
            $scope.pluginDirty = true;
            $scope.plugins[index].enabled = true;
        };
        $scope.pluginDefault = function (index) {
            $scope.pluginDirty = true;
            $scope.plugins.forEach(function (p) {
                p.isDefault = false;
            });
            $scope.plugins[index].isDefault = true;
            $scope.plugins[index].enabled = true;
        };
        $scope.pluginApply = function () {
            $scope.pluginDirty = false;
            var noDefault = true;
            $scope.plugins.forEach(function (p, idx) {
                if (p.isDefault) {
                    noDefault = false;
                }
                p.index = idx;
            });
            if (noDefault) {
                $scope.plugins.find(function (p) {
                    return p.enabled == true;
                }).isDefault = true;
            }
            var json = angular.toJson($scope.plugins);
            if (json) {
                Core.log.debug("Saving plugin settings for perspective " + $scope.perspectiveId + " -> " + json);
                var id = "plugins-" + $scope.perspectiveId;
                localStorage[id] = json;
            }
            setTimeout(function () {
                window.location.hash = "#";
            }, 10);
        };
        $scope.$watch('perspectiveId', function (newValue, oldValue) {
            if (newValue === oldValue) {
                return;
            }
            var perspective = Perspective.getPerspectiveById(newValue);
            if (perspective) {
                updateToPerspective(perspective);
                Core.$apply($scope);
            }
        });
        function updateToPerspective(perspective) {
            var plugins = Core.configuredPluginsForPerspectiveId(perspective.id, workspace, jolokia, localStorage);
            $scope.plugins = plugins;
            $scope.perspectiveId = perspective.id;
            Core.log.debug("Updated to perspective " + $scope.perspectiveId + " with " + plugins.length + " plugins");
        }
        $scope.perspectives = Perspective.getPerspectives($location, workspace, jolokia, localStorage);
        Core.log.debug("There are " + $scope.perspectives.length + " perspectives");
        var selectPerspective;
        var perspectiveId = Perspective.currentPerspectiveId($location, workspace, jolokia, localStorage);
        if (perspectiveId) {
            selectPerspective = $scope.perspectives.find(function (p) { return p.id === perspectiveId; });
        }
        if (!selectPerspective) {
            selectPerspective = $scope.perspectives[0];
        }
        updateToPerspective(selectPerspective);
        Core.$apply($scope);
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core._module.controller("Core.PreferencesController", ["$scope", "$location", "workspace", "preferencesRegistry", "$element", function ($scope, $location, workspace, preferencesRegistry, $element) {
        Core.bindModelToSearchParam($scope, $location, "pref", "pref", "Core");
        $scope.panels = {};
        $scope.$watch(function () {
            return $element.is(':visible');
        }, function (newValue, oldValue) {
            if (newValue) {
                setTimeout(function () {
                    $scope.panels = preferencesRegistry.getTabs();
                    Core.log.debug("Panels: ", $scope.panels);
                    Core.$apply($scope);
                }, 50);
            }
        });
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core._module.controller("Core.ResetPreferences", ["$scope", "userDetails", "jolokiaUrl", "localStorage", function ($scope, userDetails, jolokiaUrl, localStorage) {
        $scope.doReset = function () {
            Core.log.info("Resetting");
            var doReset = function () {
                localStorage.clear();
                setTimeout(function () {
                    window.location.reload();
                }, 10);
            };
            if (Core.isBlank(userDetails.username) && Core.isBlank(userDetails.password)) {
                doReset();
            }
            else {
                Core.logout(jolokiaUrl, userDetails, localStorage, $scope, doReset);
            }
        };
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core.ViewController = Core._module.controller("Core.ViewController", ["$scope", "$route", "$location", "layoutTree", "layoutFull", "viewRegistry", function ($scope, $route, $location, layoutTree, layoutFull, viewRegistry) {
        findViewPartial();
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            findViewPartial();
        });
        function searchRegistry(path) {
            var answer = undefined;
            Object.extended(viewRegistry).keys(function (key, value) {
                if (!answer) {
                    if (key.startsWith("/") && key.endsWith("/")) {
                        var text = key.substring(1, key.length - 1);
                        try {
                            var reg = new RegExp(text, "");
                            if (reg.exec(path)) {
                                answer = value;
                            }
                        }
                        catch (e) {
                            Core.log.debug("Invalid RegExp " + text + " for viewRegistry value: " + value);
                        }
                    }
                    else {
                        if (path.startsWith(key)) {
                            answer = value;
                        }
                    }
                }
            });
            return answer;
        }
        function findViewPartial() {
            var answer = null;
            var hash = $location.search();
            var tab = hash['tab'];
            if (angular.isString(tab)) {
                answer = searchRegistry(tab);
            }
            if (!answer) {
                var path = $location.path();
                if (path) {
                    if (path.startsWith("/")) {
                        path = path.substring(1);
                    }
                    answer = searchRegistry(path);
                }
            }
            if (!answer) {
                answer = layoutTree;
            }
            $scope.viewPartial = answer;
            Core.log.debug("Using view partial: " + answer);
            return answer;
        }
    }]);
})(Core || (Core = {}));
var Core;
(function (Core) {
    Core._module.controller("Core.WelcomeController", ["$scope", "$location", "branding", "localStorage", function ($scope, $location, branding, localStorage) {
        $scope.branding = branding;
        var log = Logger.get("Welcome");
        $scope.stopShowingWelcomePage = function () {
            log.debug("Stop showing welcome page");
            localStorage['showWelcomePage'] = false;
            $location.path("/");
        };
        $scope.$watch('branding.welcomePageUrl', function (newValue, oldValue) {
            $.ajax({
                url: branding.welcomePageUrl,
                dataType: 'html',
                cache: false,
                success: function (data, textStatus, jqXHR) {
                    $scope.html = "Unable to download welcome.md";
                    if (angular.isDefined(data)) {
                        $scope.html = branding.onWelcomePage(data);
                    }
                    Core.$apply($scope);
                },
                error: function (jqXHR, textStatus, errorThrown) {
                    $scope.html = "Unable to download welcome.md";
                    Core.$apply($scope);
                }
            });
        });
    }]);
})(Core || (Core = {}));
var Dashboard;
(function (Dashboard) {
    Dashboard.log = Logger.get('Dashboard');
    function cleanDashboardData(item) {
        var cleanItem = {};
        angular.forEach(item, function (value, key) {
            if (!angular.isString(key) || (!key.startsWith("$") && !key.startsWith("_"))) {
                cleanItem[key] = value;
            }
        });
        return cleanItem;
    }
    Dashboard.cleanDashboardData = cleanDashboardData;
    function decodeURIComponentProperties(hash) {
        if (!hash) {
            return hash;
        }
        var decodeHash = {};
        angular.forEach(hash, function (value, key) {
            decodeHash[key] = value ? decodeURIComponent(value) : value;
        });
        return decodeHash;
    }
    Dashboard.decodeURIComponentProperties = decodeURIComponentProperties;
    function onOperationComplete(result) {
        console.log("Completed adding the dashboard with response " + JSON.stringify(result));
    }
    Dashboard.onOperationComplete = onOperationComplete;
})(Dashboard || (Dashboard = {}));
var Dashboard;
(function (Dashboard) {
    Dashboard.templatePath = 'app/dashboard/html/';
    Dashboard.pluginName = 'dashboard';
    Dashboard._module = angular.module(Dashboard.pluginName, ['bootstrap', 'ngResource', 'hawtioCore', 'hawtio-ui']);
    Dashboard._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/dashboard/add', { templateUrl: Dashboard.templatePath + 'addToDashboard.html' }).when('/dashboard/edit', { templateUrl: Dashboard.templatePath + 'editDashboards.html' }).when('/dashboard/idx/:dashboardIndex', { templateUrl: Dashboard.templatePath + 'dashboard.html' }).when('/dashboard/id/:dashboardId', { templateUrl: Dashboard.templatePath + 'dashboard.html' }).when('/dashboard/id/:dashboardId/share', { templateUrl: Dashboard.templatePath + 'share.html' }).when('/dashboard/import', { templateUrl: Dashboard.templatePath + 'import.html' });
    }]);
    Dashboard._module.value('ui.config', {
        jq: {
            gridster: {
                widget_margins: [10, 10],
                widget_base_dimensions: [140, 140]
            }
        }
    });
    Dashboard._module.factory('dashboardRepository', ["workspace", "jolokia", "localStorage", function (workspace, jolokia, localStorage) {
        return new Dashboard.DefaultDashboardRepository(workspace, jolokia, localStorage);
    }]);
    Dashboard._module.directive('hawtioDashboard', function () {
        return new Dashboard.GridsterDirective();
    });
    Dashboard._module.run(["$location", "workspace", "viewRegistry", "helpRegistry", function ($location, workspace, viewRegistry, helpRegistry) {
        viewRegistry['dashboard'] = 'app/dashboard/html/layoutDashboard.html';
        helpRegistry.addUserDoc('dashboard', 'app/dashboard/doc/help.md');
        workspace.topLevelTabs.push({
            id: "dashboard",
            content: "Dashboard",
            title: "View and edit your own custom dashboards",
            isValid: function (workspace) { return workspace.hasMBeans(); },
            href: function () { return "#/dashboard/idx/0?tab=dashboard"; },
            isActive: function (workspace) { return workspace.isTopTabActive("dashboard"); }
        });
    }]);
    hawtioPluginLoader.addModule(Dashboard.pluginName);
})(Dashboard || (Dashboard = {}));
var Dashboard;
(function (Dashboard) {
    var defaultDashboards = [
        {
            "title": "Monitor",
            "group": "Personal",
            "widgets": [
                {
                    "id": "w1",
                    "title": "Operating System",
                    "row": 1,
                    "col": 1,
                    "size_x": 3,
                    "size_y": 4,
                    "path": "jmx/attributes",
                    "include": "app/jmx/html/attributes.html",
                    "search": {
                        "nid": "root-java.lang-OperatingSystem"
                    },
                    "hash": ""
                },
                {
                    "id": "w3",
                    "title": "Java Heap Memory",
                    "row": 1,
                    "col": 6,
                    "size_x": 2,
                    "size_y": 2,
                    "path": "jmx/widget/donut",
                    "include": "app/jmx/html/donutChart.html",
                    "search": {},
                    "hash": "",
                    "routeParams": "{\"type\":\"donut\",\"title\":\"Java Heap Memory\",\"mbean\":\"java.lang:type=Memory\",\"attribute\":\"HeapMemoryUsage\",\"total\":\"Max\",\"terms\":\"Used\",\"remaining\":\"Free\"}"
                },
                {
                    "id": "w4",
                    "title": "Java Non Heap Memory",
                    "row": 1,
                    "col": 8,
                    "size_x": 2,
                    "size_y": 2,
                    "path": "jmx/widget/donut",
                    "include": "app/jmx/html/donutChart.html",
                    "search": {},
                    "hash": "",
                    "routeParams": "{\"type\":\"donut\",\"title\":\"Java Non Heap Memory\",\"mbean\":\"java.lang:type=Memory\",\"attribute\":\"NonHeapMemoryUsage\",\"total\":\"Max\",\"terms\":\"Used\",\"remaining\":\"Free\"}"
                },
                {
                    "id": "w5",
                    "title": "",
                    "row": 3,
                    "col": 4,
                    "size_x": 6,
                    "size_y": 2,
                    "path": "jmx/charts",
                    "include": "app/jmx/html/charts.html",
                    "search": {
                        "size": "%7B%22size_x%22%3A2%2C%22size_y%22%3A2%7D",
                        "title": "Java%20Non%20Heap%20Memory",
                        "routeParams": "%7B%22type%22%3A%22donut%22%2C%22title%22%3A%22Java%20Non%20Heap%20Memory%22%2C%22mbean%22%3A%22java.lang%3Atype",
                        "nid": "root-java.lang-Threading"
                    },
                    "hash": ""
                },
                {
                    "id": "w6",
                    "title": "System CPU Load",
                    "row": 1,
                    "col": 4,
                    "size_x": 2,
                    "size_y": 2,
                    "path": "jmx/widget/area",
                    "include": "app/jmx/html/areaChart.html",
                    "search": {},
                    "hash": "",
                    "routeParams": "{\"type\":\"area\",\"title\":\"System CPU Load\",\"mbean\":\"java.lang:type=OperatingSystem\",\"attribute\":\"SystemCpuLoad\"}"
                }
            ],
            "id": "4e9d116173ca41767e"
        }
    ];
    var DefaultDashboardRepository = (function () {
        function DefaultDashboardRepository(workspace, jolokia, localStorage) {
            this.workspace = workspace;
            this.jolokia = jolokia;
            this.localStorage = localStorage;
            this.repository = null;
        }
        DefaultDashboardRepository.prototype.putDashboards = function (array, commitMessage, fn) {
            this.getRepository().putDashboards(array, commitMessage, fn);
        };
        DefaultDashboardRepository.prototype.deleteDashboards = function (array, fn) {
            this.getRepository().deleteDashboards(array, fn);
        };
        DefaultDashboardRepository.prototype.getDashboards = function (fn) {
            this.getRepository().getDashboards(function (values) {
                fn(values);
            });
        };
        DefaultDashboardRepository.prototype.getDashboard = function (id, onLoad) {
            this.getRepository().getDashboard(id, onLoad);
        };
        DefaultDashboardRepository.prototype.createDashboard = function (options) {
            return this.getRepository().createDashboard(options);
        };
        DefaultDashboardRepository.prototype.cloneDashboard = function (dashboard) {
            return this.getRepository().cloneDashboard(dashboard);
        };
        DefaultDashboardRepository.prototype.getType = function () {
            return this.getRepository().getType();
        };
        DefaultDashboardRepository.prototype.isValid = function () {
            return this.getRepository().isValid();
        };
        DefaultDashboardRepository.prototype.getRepository = function () {
            if (this.repository && this.repository.isValid()) {
                return this.repository;
            }
            if (Fabric.hasFabric(this.workspace)) {
                this.repository = new Dashboard.FabricDashboardRepository(this.workspace, this.jolokia, this.localStorage);
                return this.repository;
            }
            var git = Git.createGitRepository(this.workspace, this.jolokia, this.localStorage);
            if (git) {
                this.repository = new GitDashboardRepository(this.workspace, git);
                return this.repository;
            }
            this.repository = new LocalDashboardRepository(this.workspace);
            return this.repository;
        };
        return DefaultDashboardRepository;
    })();
    Dashboard.DefaultDashboardRepository = DefaultDashboardRepository;
    var LocalDashboardRepository = (function () {
        function LocalDashboardRepository(workspace) {
            this.workspace = workspace;
            this.localStorage = null;
            this.localStorage = workspace.localStorage;
            if ('userDashboards' in this.localStorage) {
            }
            else {
                this.storeDashboards(defaultDashboards);
            }
        }
        LocalDashboardRepository.prototype.loadDashboards = function () {
            var answer = angular.fromJson(localStorage['userDashboards']);
            if (answer.length === 0) {
                answer.push(this.createDashboard({}));
            }
            Dashboard.log.debug("returning dashboards: ", answer);
            return answer;
        };
        LocalDashboardRepository.prototype.storeDashboards = function (dashboards) {
            Dashboard.log.debug("storing dashboards: ", dashboards);
            localStorage['userDashboards'] = angular.toJson(dashboards);
            return this.loadDashboards();
        };
        LocalDashboardRepository.prototype.putDashboards = function (array, commitMessage, fn) {
            var dashboards = this.loadDashboards();
            array.forEach(function (dash) {
                var existing = dashboards.findIndex(function (d) {
                    return d.id === dash.id;
                });
                if (existing >= 0) {
                    dashboards[existing] = dash;
                }
                else {
                    dashboards.push(dash);
                }
            });
            fn(this.storeDashboards(dashboards));
        };
        LocalDashboardRepository.prototype.deleteDashboards = function (array, fn) {
            var dashboards = this.loadDashboards();
            angular.forEach(array, function (item) {
                dashboards.remove(function (i) {
                    return i.id === item.id;
                });
            });
            fn(this.storeDashboards(dashboards));
        };
        LocalDashboardRepository.prototype.getDashboards = function (fn) {
            fn(this.loadDashboards());
        };
        LocalDashboardRepository.prototype.getDashboard = function (id, fn) {
            var dashboards = this.loadDashboards();
            var dashboard = dashboards.find(function (dashboard) {
                return dashboard.id === id;
            });
            fn(dashboard);
        };
        LocalDashboardRepository.prototype.createDashboard = function (options) {
            var answer = {
                title: "New Dashboard",
                group: "Personal",
                widgets: []
            };
            answer = angular.extend(answer, options);
            answer['id'] = Core.getUUID();
            return answer;
        };
        LocalDashboardRepository.prototype.cloneDashboard = function (dashboard) {
            var newDashboard = Object.clone(dashboard);
            newDashboard['id'] = Core.getUUID();
            newDashboard['title'] = "Copy of " + dashboard.title;
            return newDashboard;
        };
        LocalDashboardRepository.prototype.getType = function () {
            return 'container';
        };
        LocalDashboardRepository.prototype.isValid = function () {
            return !Fabric.hasFabric(this.workspace) && !Git.hasGit(this.workspace);
        };
        return LocalDashboardRepository;
    })();
    Dashboard.LocalDashboardRepository = LocalDashboardRepository;
    var GitDashboardRepository = (function () {
        function GitDashboardRepository(workspace, git) {
            this.workspace = workspace;
            this.git = git;
            this.branch = null;
        }
        GitDashboardRepository.prototype.putDashboards = function (array, commitMessage, fn) {
            var _this = this;
            var toPut = array.length;
            var maybeCallback = function () {
                toPut = toPut - 1;
                if (toPut === 0) {
                    _this.getDashboards(fn);
                }
            };
            angular.forEach(array, function (dash) {
                var path = _this.getDashboardPath(dash);
                var contents = JSON.stringify(dash, null, "  ");
                _this.git.write(_this.branch, path, commitMessage, contents, function () {
                    maybeCallback();
                });
            });
        };
        GitDashboardRepository.prototype.deleteDashboards = function (array, fn) {
            var _this = this;
            var toDelete = array.length;
            var maybeCallback = function () {
                toDelete = toDelete - 1;
                if (toDelete === 0) {
                    _this.getDashboards(fn);
                }
            };
            angular.forEach(array, function (dash) {
                var path = _this.getDashboardPath(dash);
                var commitMessage = "Removing dashboard " + path;
                _this.git.remove(_this.branch, path, commitMessage, function () {
                    maybeCallback();
                });
            });
        };
        GitDashboardRepository.prototype.createDashboard = function (options) {
            var answer = {
                title: "New Dashboard",
                group: "Personal",
                widgets: []
            };
            answer = angular.extend(answer, options);
            answer['id'] = Core.getUUID();
            return answer;
        };
        GitDashboardRepository.prototype.cloneDashboard = function (dashboard) {
            var newDashboard = Object.clone(dashboard);
            newDashboard['id'] = Core.getUUID();
            newDashboard['title'] = "Copy of " + dashboard.title;
            return newDashboard;
        };
        GitDashboardRepository.prototype.getType = function () {
            return 'git';
        };
        GitDashboardRepository.prototype.isValid = function () {
            return Git.hasGit(this.workspace);
        };
        GitDashboardRepository.prototype.getDashboardPath = function (dash) {
            var id = dash.id || Core.getUUID();
            var path = this.getUserDashboardPath(id);
            return path;
        };
        GitDashboardRepository.prototype.getDashboards = function (fn) {
            var _this = this;
            var path = this.getUserDashboardDirectory();
            var dashboards = [];
            this.git.read(this.branch, path, function (details) {
                var files = details.children;
                var toRead = files.length;
                var maybeCallback = function () {
                    toRead = toRead - 1;
                    if (toRead === 0) {
                        dashboards = dashboards.sort(function (d1, d2) {
                            var title1 = d1.title;
                            var title2 = d2.title;
                            return title1.localeCompare(title2);
                        });
                        fn(dashboards);
                    }
                };
                if (files.length === 0) {
                    dashboards.push(_this.createDashboard({}));
                    fn(dashboards);
                    return;
                }
                angular.forEach(files, function (file, idx) {
                    var path = file.path;
                    if (!file.directory && path.endsWith(".json")) {
                        _this.git.read(_this.branch, path, function (details) {
                            var content = details.text;
                            if (content) {
                                try {
                                    var json = JSON.parse(content);
                                    json.uri = path;
                                    dashboards.push(json);
                                }
                                catch (e) {
                                    console.log("Failed to parse: " + content + " due to: " + e);
                                }
                            }
                            Dashboard.log.debug("git - read ", idx, " files, total: ", files.length);
                            maybeCallback();
                        });
                    }
                });
            });
        };
        GitDashboardRepository.prototype.getDashboard = function (id, fn) {
            var path = this.getUserDashboardPath(id);
            this.git.read(this.branch, path, function (details) {
                var dashboard = null;
                var content = details.text;
                if (content) {
                    try {
                        dashboard = JSON.parse(content);
                    }
                    catch (e) {
                        console.log("Failed to parse: " + content + " due to: " + e);
                    }
                }
                fn(dashboard);
            });
        };
        GitDashboardRepository.prototype.getUserDashboardDirectory = function () {
            return "/dashboards/team/all";
        };
        GitDashboardRepository.prototype.getUserDashboardPath = function (id) {
            return this.getUserDashboardDirectory() + "/" + id + ".json";
        };
        return GitDashboardRepository;
    })();
    Dashboard.GitDashboardRepository = GitDashboardRepository;
})(Dashboard || (Dashboard = {}));
var Dashboard;
(function (Dashboard) {
    Dashboard._module.controller("Dashboard.EditDashboardsController", ["$scope", "$routeParams", "$route", "$location", "$rootScope", "dashboardRepository", "jolokia", "workspace", "$timeout", function ($scope, $routeParams, $route, $location, $rootScope, dashboardRepository, jolokia, workspace, $timeout) {
        $scope.hash = workspace.hash();
        $scope.selectedItems = [];
        $scope.repository = dashboardRepository;
        $scope.duplicateDashboards = new UI.Dialog();
        $scope.selectedProfilesDialog = [];
        $scope._dashboards = [];
        $scope.edit = false;
        $rootScope.$on('dashboardsUpdated', dashboardLoaded);
        $scope.hasUrl = function () {
            return ($scope.url) ? true : false;
        };
        $scope.navigateTo = function (url) {
            if (!$scope.edit) {
                $location.url(url);
            }
        };
        $scope.$on('editablePropertyEdit', function (ev, edit) {
            $timeout(function () {
                $scope.edit = edit;
            }, 0, false);
        });
        $scope.hasSelection = function () {
            return $scope.selectedItems.length !== 0;
        };
        $scope.gridOptions = {
            selectedItems: $scope.selectedItems,
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                filterText: ''
            },
            data: '_dashboards',
            selectWithCheckboxOnly: true,
            showSelectionCheckbox: true,
            columnDefs: [
                {
                    field: 'title',
                    displayName: 'Dashboard',
                    cellTemplate: '<div class="ngCellText"><span class="a" ng-click="navigateTo(\'/dashboard/id/{{row.getProperty(\'id\')}}{{hash}}\')"><editable-property class="inline-block" on-save="onDashRenamed(row.entity)" property="title" ng-model="row.entity"></editable-property></span></div>'
                },
                {
                    field: 'group',
                    displayName: 'Group'
                }
            ],
            afterSelectionChange: afterSelectionChange
        };
        $scope.onDashRenamed = function (dash) {
            dashboardRepository.putDashboards([dash], "Renamed dashboard", function (dashboards) {
                dashboardLoaded(null, dashboards);
            });
        };
        $scope.usingGit = function () {
            return dashboardRepository.getType() === 'git';
        };
        $scope.usingFabric = function () {
            return dashboardRepository.getType() === 'fabric';
        };
        $scope.usingLocal = function () {
            return dashboardRepository.getType() === 'container';
        };
        if ($scope.usingFabric()) {
            $scope.container = Fabric.getCurrentContainer(jolokia, ['versionId', 'profileIds']);
            $scope.gridOptions.columnDefs.add([{
                field: 'versionId',
                displayName: 'Version'
            }, {
                field: 'profileId',
                displayName: 'Profile'
            }, {
                field: 'fileName',
                displayName: 'File Name'
            }]);
        }
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateData, 100);
        });
        $scope.goBack = function () {
            var href = Core.trimLeading($scope.url, "#");
            if (href) {
                $location.url(href);
            }
        };
        $scope.duplicateToProfiles = function () {
            if ($scope.hasSelection()) {
                $scope.duplicateDashboards.open();
            }
        };
        $scope.doDuplicateToProfiles = function () {
            $scope.duplicateDashboards.close();
            var newDashboards = [];
            $scope.selectedItems.forEach(function (dashboard) {
                $scope.selectedProfilesDialog.forEach(function (profile) {
                    var newDash = dashboardRepository.cloneDashboard(dashboard);
                    newDash['profileId'] = profile.id;
                    newDash['title'] = dashboard.title;
                    newDashboards.push(newDash);
                });
            });
            var commitMessage = "Duplicating " + $scope.selectedItems.length + " dashboards to " + $scope.selectedProfilesDialog.length + " profiles";
            dashboardRepository.putDashboards(newDashboards, commitMessage, function (dashboards) {
                deselectAll();
                dashboardLoaded(null, dashboards);
            });
        };
        $scope.addViewToDashboard = function () {
            var nextHref = null;
            angular.forEach($scope.selectedItems, function (selectedItem) {
                var text = $scope.url;
                var query = null;
                if (text) {
                    var idx = text.indexOf('?');
                    if (idx && idx > 0) {
                        query = text.substring(idx + 1);
                        text = text.substring(0, idx);
                    }
                    text = Core.trimLeading(text, "#");
                }
                var search = {};
                if (query) {
                    var expressions = query.split("&");
                    angular.forEach(expressions, function (expression) {
                        if (expression) {
                            var names = expression.split("=");
                            var key = names[0];
                            var value = names.length > 1 ? names[1] : null;
                            if (value) {
                                value = encodeURIComponent(value);
                            }
                            var old = search[key];
                            if (old) {
                                if (!angular.isArray(old)) {
                                    old = [old];
                                    search[key] = old;
                                }
                                old.push(value);
                            }
                            else {
                                search[key] = value;
                            }
                        }
                    });
                }
                if ($route && $route.routes) {
                    var value = $route.routes[text];
                    if (value) {
                        var templateUrl = value["templateUrl"];
                        if (templateUrl) {
                            if (!selectedItem.widgets) {
                                selectedItem.widgets = [];
                            }
                            var nextNumber = selectedItem.widgets.length + 1;
                            var widget = {
                                id: "w" + nextNumber,
                                title: "",
                                row: 1,
                                col: 1,
                                size_x: 1,
                                size_y: 1,
                                path: Core.trimLeading(text, "/"),
                                include: templateUrl,
                                search: search,
                                hash: ""
                            };
                            if ($scope.widgetTitle) {
                                widget.title = $scope.widgetTitle;
                            }
                            var gridWidth = 0;
                            selectedItem.widgets.forEach(function (w) {
                                var rightSide = w.col + w.size_x;
                                if (rightSide > gridWidth) {
                                    gridWidth = rightSide;
                                }
                            });
                            if ($scope.preferredSize) {
                                widget.size_x = parseInt($scope.preferredSize['size_x']);
                                widget.size_y = parseInt($scope.preferredSize['size_y']);
                            }
                            var found = false;
                            var left = function (w) {
                                return w.col;
                            };
                            var right = function (w) {
                                return w.col + w.size_x - 1;
                            };
                            var top = function (w) {
                                return w.row;
                            };
                            var bottom = function (w) {
                                return w.row + w.size_y - 1;
                            };
                            var collision = function (w1, w2) {
                                return !(left(w2) > right(w1) || right(w2) < left(w1) || top(w2) > bottom(w1) || bottom(w2) < top(w1));
                            };
                            if (selectedItem.widgets.isEmpty()) {
                                found = true;
                            }
                            while (!found) {
                                widget.col = 1;
                                if (widget.col + widget.size_x > gridWidth) {
                                    selectedItem.widgets.forEach(function (w, idx) {
                                        if (widget.row <= w.row) {
                                            widget.row++;
                                        }
                                    });
                                    found = true;
                                }
                                for (; (widget.col + widget.size_x) <= gridWidth; widget.col++) {
                                    if (!selectedItem.widgets.any(function (w) {
                                        var c = collision(w, widget);
                                        return c;
                                    })) {
                                        found = true;
                                        break;
                                    }
                                }
                                if (!found) {
                                    widget.row = widget.row + 1;
                                }
                                if (widget.row > 50) {
                                    found = true;
                                }
                            }
                            if ($scope.routeParams) {
                                widget['routeParams'] = $scope.routeParams;
                            }
                            selectedItem.widgets.push(widget);
                            if (!nextHref && selectedItem.id) {
                                nextHref = "/dashboard/id/" + selectedItem.id;
                            }
                        }
                    }
                    else {
                    }
                }
            });
            var commitMessage = "Add widget";
            dashboardRepository.putDashboards($scope.selectedItems, commitMessage, function (dashboards) {
                if (nextHref) {
                    delete $location.search()["href"];
                    $location.path(nextHref);
                    Core.$apply($scope);
                }
            });
        };
        $scope.create = function () {
            var counter = dashboards().length + 1;
            var title = "Untitled" + counter;
            var newDash = dashboardRepository.createDashboard({ title: title });
            dashboardRepository.putDashboards([newDash], "Created new dashboard: " + title, function (dashboards) {
                deselectAll();
                dashboardLoaded(null, dashboards);
            });
        };
        $scope.duplicate = function () {
            var newDashboards = [];
            var commitMessage = "Duplicated dashboard(s) ";
            angular.forEach($scope.selectedItems, function (item, idx) {
                var commitMessage = "Duplicated dashboard " + item.title;
                var newDash = dashboardRepository.cloneDashboard(item);
                newDashboards.push(newDash);
            });
            deselectAll();
            commitMessage = commitMessage + newDashboards.map(function (d) {
                return d.title;
            }).join(',');
            dashboardRepository.putDashboards(newDashboards, commitMessage, function (dashboards) {
                dashboardLoaded(null, dashboards);
            });
        };
        $scope.deleteDashboard = function () {
            if ($scope.hasSelection()) {
                dashboardRepository.deleteDashboards($scope.selectedItems, function (dashboards) {
                    deselectAll();
                    dashboardLoaded(null, dashboards);
                });
            }
        };
        $scope.gist = function () {
            if ($scope.selectedItems.length > 0) {
                var id = $scope.selectedItems[0].id;
                $location.path("/dashboard/id/" + id + "/share");
            }
        };
        function updateData() {
            var url = $routeParams["href"];
            if (url) {
                $scope.url = decodeURIComponent(url);
            }
            var routeParams = $routeParams["routeParams"];
            if (routeParams) {
                $scope.routeParams = decodeURIComponent(routeParams);
            }
            var size = $routeParams["size"];
            if (size) {
                size = decodeURIComponent(size);
                $scope.preferredSize = angular.fromJson(size);
            }
            var title = $routeParams["title"];
            if (title) {
                title = decodeURIComponent(title);
                $scope.widgetTitle = title;
            }
            dashboardRepository.getDashboards(function (dashboards) {
                dashboardLoaded(null, dashboards);
            });
        }
        function dashboardLoaded(event, dashboards) {
            $scope._dashboards = dashboards;
            if (event === null) {
                $scope.$emit('dashboardsUpdated', dashboards);
            }
            Core.$apply($scope);
        }
        function dashboards() {
            return $scope._dashboards;
        }
        function afterSelectionChange(rowItem, checkAll) {
            if (checkAll === void 0) {
                $scope.gridOptions['$gridScope'].allSelected = rowItem.config.selectedItems.length == $scope._dashboards.length;
            }
            else {
                $scope.gridOptions['$gridScope'].allSelected = checkAll;
            }
        }
        function deselectAll() {
            $scope.selectedItems.splice(0);
            $scope.gridOptions['$gridScope'].allSelected = false;
        }
        updateData();
    }]);
})(Dashboard || (Dashboard = {}));
var Dashboard;
(function (Dashboard) {
    var FabricDashboardRepository = (function () {
        function FabricDashboardRepository(workspace, jolokia, localStorage) {
            this.workspace = workspace;
            this.jolokia = jolokia;
            this.localStorage = localStorage;
            this.details = this.getBranchAndProfiles();
        }
        FabricDashboardRepository.prototype.getBranchAndProfiles = function () {
            if (Fabric.fabricCreated(this.workspace)) {
                var container = Fabric.getCurrentContainer(this.jolokia, ['id', 'versionId', 'profiles']);
                var profiles = [];
                if (container.profiles) {
                    profiles = container.profiles.unique();
                    profiles = Fabric.filterProfiles(this.jolokia, container.versionId, profiles);
                }
                return {
                    branch: container.versionId,
                    profiles: profiles
                };
            }
            else {
                return {
                    branch: "1.0",
                    profiles: []
                };
            }
        };
        FabricDashboardRepository.prototype.putDashboards = function (array, commitMessage, fn) {
            var _this = this;
            var jolokia = this.jolokia;
            var details = this.details;
            var toPut = array.length;
            var maybeCallback = function () {
                toPut = toPut - 1;
                if (toPut === 0) {
                    _this.getDashboards(fn);
                }
            };
            array.forEach(function (dashboard) {
                var data = angular.toJson(dashboard, true);
                var profileId = dashboard.profileId;
                if (!profileId) {
                    profileId = details.profiles.first();
                }
                var fileName = dashboard.fileName;
                if (!fileName) {
                    fileName = Core.getUUID() + ".dashboard";
                }
                Fabric.saveConfigFile(jolokia, details.branch, profileId, fileName, data.encodeBase64(), function () {
                    maybeCallback();
                }, function (response) {
                    Dashboard.log.error("Failed to store dashboard: ", dashboard.title, " due to: ", response.error, " stack trace: ", response.stacktrace);
                    maybeCallback();
                });
            });
        };
        FabricDashboardRepository.prototype.deleteDashboards = function (array, fn) {
            var _this = this;
            var jolokia = this.jolokia;
            var details = this.details;
            var profileIds = [];
            var fileNames = [];
            array.forEach(function (dashboard) {
                profileIds.push(dashboard.profileId);
                fileNames.push(dashboard.fileName);
            });
            Fabric.deleteConfigFiles(jolokia, details.branch, profileIds, fileNames, function () {
                _this.getDashboards(fn);
            }, function (response) {
                Dashboard.log.error("Failed to delete selected dashboards due to: ", response.error, " stack trace: ", response.stacktrace);
                _this.getDashboards(fn);
            });
        };
        FabricDashboardRepository.prototype.createDashboard = function (options) {
            var answer = {
                title: "New Dashboard",
                group: "Fabric",
                versionId: this.details.branch,
                profileId: this.details.profiles.first(),
                widgets: []
            };
            answer = angular.extend(answer, options);
            var uuid = Core.getUUID();
            answer['id'] = uuid;
            answer['fileName'] = uuid + ".dashboard";
            return answer;
        };
        FabricDashboardRepository.prototype.cloneDashboard = function (dashboard) {
            var newDashboard = Object.clone(dashboard);
            var uuid = Core.getUUID();
            newDashboard['id'] = uuid;
            newDashboard['fileName'] = uuid + ".dashboard";
            newDashboard['title'] = "Copy of " + dashboard.title;
            return newDashboard;
        };
        FabricDashboardRepository.prototype.getType = function () {
            return 'fabric';
        };
        FabricDashboardRepository.prototype.isValid = function () {
            return Fabric.hasFabric(this.workspace);
        };
        FabricDashboardRepository.prototype.getDashboards = function (fn) {
            var _this = this;
            var jolokia = this.jolokia;
            var details = this.details;
            var dashboards = [];
            jolokia.request({
                type: 'exec',
                mbean: Fabric.managerMBean,
                operation: 'getConfigurationFiles',
                arguments: [details.branch, details.profiles, ".*dashboard"]
            }, {
                method: 'POST',
                success: function (response) {
                    angular.forEach(response.value, function (value, profile) {
                        angular.forEach(value, function (value, fileName) {
                            var dashboard = angular.fromJson(value.decodeBase64());
                            dashboard['versionId'] = details.branch;
                            dashboard['profileId'] = profile;
                            dashboard['fileName'] = fileName;
                            dashboards.push(dashboard);
                        });
                    });
                    if (dashboards.isEmpty()) {
                        dashboards.push(_this.createDashboard({}));
                    }
                    dashboards = dashboards.sort(function (d1, d2) {
                        var title1 = d1.title;
                        var title2 = d2.title;
                        return title1.localeCompare(title2);
                    });
                    fn(dashboards);
                },
                error: function (response) {
                    Dashboard.log.error("Failed to load dashboard data: error: ", response.error, " stack trace: ", response.stacktrace);
                    fn([]);
                }
            });
        };
        FabricDashboardRepository.prototype.getDashboard = function (id, fn) {
            this.getDashboards(function (dashboards) {
                var dashboard = dashboards.find(function (dashboard) {
                    return dashboard.id === id;
                });
                fn(dashboard);
            });
        };
        return FabricDashboardRepository;
    })();
    Dashboard.FabricDashboardRepository = FabricDashboardRepository;
})(Dashboard || (Dashboard = {}));
var Dashboard;
(function (Dashboard) {
    var GridsterDirective = (function () {
        function GridsterDirective() {
            this.restrict = 'A';
            this.replace = true;
            this.controller = ["$scope", "$element", "$attrs", "$location", "$routeParams", "$injector", "$route", "$templateCache", "workspace", "dashboardRepository", "$compile", function ($scope, $element, $attrs, $location, $routeParams, $injector, $route, $templateCache, workspace, dashboardRepository, $compile) {
                $scope.route = $route;
                $scope.injector = $injector;
                var gridSize = 150;
                var gridMargin = 6;
                var gridHeight;
                $scope.gridX = gridSize;
                $scope.gridY = gridSize;
                $scope.widgetMap = {};
                $scope.$on('$destroy', function () {
                    angular.forEach($scope.widgetMap, function (value, key) {
                        if ('scope' in value) {
                            var scope = value['scope'];
                            scope.$destroy();
                        }
                    });
                });
                updateWidgets();
                $scope.removeWidget = function (widget) {
                    var gridster = getGridster();
                    var widgetElem = null;
                    var widgetData = $scope.widgetMap[widget.id];
                    if (widgetData) {
                        delete $scope.widgetMap[widget.id];
                        var scope = widgetData.scope;
                        widgetElem = widgetData.widget;
                        if (scope) {
                            scope.$destroy();
                        }
                    }
                    if (!widgetElem) {
                        widgetElem = $("div").find("[data-widgetId='" + widget.id + "']").parent();
                    }
                    if (gridster && widgetElem) {
                        gridster.remove_widget(widgetElem);
                    }
                    if ($scope.dashboard) {
                        var widgets = $scope.dashboard.widgets;
                        if (widgets) {
                            widgets.remove(widget);
                        }
                    }
                    updateDashboardRepository("Removed widget " + widget.title);
                };
                function changeWidgetSize(widget, sizefunc, savefunc) {
                    var gridster = getGridster();
                    var entry = $scope.widgetMap[widget.id];
                    var w = entry.widget;
                    var scope = entry.scope;
                    sizefunc(entry);
                    gridster.resize_widget(w, entry.size_x, entry.size_y);
                    gridster.set_dom_grid_height();
                    setTimeout(function () {
                        var template = $templateCache.get("widgetTemplate");
                        var div = $('<div></div>');
                        div.html(template);
                        w.html($compile(div.contents())(scope));
                        makeResizable();
                        Core.$apply($scope);
                        setTimeout(function () {
                            savefunc(widget);
                        }, 50);
                    }, 30);
                }
                $scope.onWidgetRenamed = function (widget) {
                    updateDashboardRepository("Renamed widget to " + widget.title);
                };
                function updateWidgets() {
                    $scope.id = $routeParams["dashboardId"];
                    $scope.idx = $routeParams["dashboardIndex"];
                    if ($scope.id) {
                        $scope.$emit('loadDashboards');
                        dashboardRepository.getDashboard($scope.id, onDashboardLoad);
                    }
                    else {
                        dashboardRepository.getDashboards(function (dashboards) {
                            $scope.$emit('dashboardsUpdated', dashboards);
                            var idx = $scope.idx ? parseInt($scope.idx) : 0;
                            var id = null;
                            if (dashboards.length > 0) {
                                var dashboard = dashboards.length > idx ? dashboards[idx] : dashboard[0];
                                id = dashboard.id;
                            }
                            if (id) {
                                $location.path("/dashboard/id/" + id);
                            }
                            else {
                                $location.path("/dashboard/edit?tab=dashboard");
                            }
                            Core.$apply($scope);
                        });
                    }
                }
                function onDashboardLoad(dashboard) {
                    $scope.dashboard = dashboard;
                    var widgets = ((dashboard) ? dashboard.widgets : null) || [];
                    var minHeight = 10;
                    var minWidth = 6;
                    angular.forEach(widgets, function (widget) {
                        if (angular.isDefined(widget.row) && minHeight < widget.row) {
                            minHeight = widget.row + 1;
                        }
                        if (angular.isDefined(widget.size_x && angular.isDefined(widget.col))) {
                            var rightEdge = widget.col + widget.size_x;
                            if (rightEdge > minWidth) {
                                minWidth = rightEdge + 1;
                            }
                        }
                    });
                    var gridster = $element.gridster({
                        widget_margins: [gridMargin, gridMargin],
                        widget_base_dimensions: [$scope.gridX, $scope.gridY],
                        extra_rows: minHeight,
                        extra_cols: minWidth,
                        max_size_x: minWidth,
                        max_size_y: minHeight,
                        draggable: {
                            stop: function (event, ui) {
                                if (serializeDashboard()) {
                                    updateDashboardRepository("Changing dashboard layout");
                                }
                            }
                        }
                    }).data('gridster');
                    var template = $templateCache.get("widgetTemplate");
                    angular.forEach(widgets, function (widget) {
                        var childScope = $scope.$new(false);
                        childScope.widget = widget;
                        var path = widget.path;
                        var search = null;
                        if (widget.search) {
                            search = Dashboard.decodeURIComponentProperties(widget.search);
                        }
                        var hash = widget.hash;
                        var location = new Dashboard.RectangleLocation($location, path, search, hash);
                        var routeParams = null;
                        if (widget.routeParams) {
                            routeParams = angular.fromJson(widget.routeParams);
                        }
                        var childWorkspace = workspace.createChildWorkspace(location);
                        childWorkspace.$location = location;
                        if (search) {
                            var key = location.search()['nid'];
                            if (key && workspace.tree) {
                                childWorkspace.selection = workspace.keyToNodeMap[key];
                                if (!childWorkspace.selection) {
                                    var decodedKey = decodeURIComponent(key);
                                    childWorkspace.selection = workspace.keyToNodeMap[decodedKey];
                                }
                            }
                        }
                        var $$scopeInjections = {
                            workspace: childWorkspace,
                            location: location,
                            $location: location,
                            $routeParams: routeParams
                        };
                        childScope.$$scopeInjections = $$scopeInjections;
                        childScope.inDashboard = true;
                        if (!widget.size_x || widget.size_x < 1) {
                            widget.size_x = 1;
                        }
                        if (!widget.size_y || widget.size_y < 1) {
                            widget.size_y = 1;
                        }
                        var div = $('<div></div>');
                        div.html(template);
                        var outerDiv = $('<li class="grid-block" style="display: list-item; position: absolute"></li>');
                        outerDiv.html($compile(div.contents())(childScope));
                        var w = gridster.add_widget(outerDiv, widget.size_x, widget.size_y, widget.col, widget.row);
                        $scope.widgetMap[widget.id] = {
                            widget: w,
                            scope: childScope
                        };
                    });
                    makeResizable();
                    getGridster().enable();
                    Core.$apply($scope);
                }
                function serializeDashboard() {
                    var gridster = getGridster();
                    if (gridster) {
                        var data = gridster.serialize();
                        var widgets = $scope.dashboard.widgets || [];
                        angular.forEach(widgets, function (widget, idx) {
                            var value = data[idx];
                            if (value && widget) {
                                angular.forEach(value, function (attr, key) { return widget[key] = attr; });
                            }
                        });
                        return true;
                    }
                    return false;
                }
                function makeResizable() {
                    var blocks = $('.grid-block');
                    blocks.resizable('destroy');
                    blocks.resizable({
                        grid: [gridSize + (gridMargin * 2), gridSize + (gridMargin * 2)],
                        animate: false,
                        minWidth: gridSize,
                        minHeight: gridSize,
                        autoHide: false,
                        start: function (event, ui) {
                            gridHeight = getGridster().$el.height();
                        },
                        resize: function (event, ui) {
                            var g = getGridster();
                            var delta = gridSize + gridMargin * 2;
                            if (event.offsetY > g.$el.height()) {
                                var extra = Math.floor((event.offsetY - gridHeight) / delta + 1);
                                var newHeight = gridHeight + extra * delta;
                                g.$el.css('height', newHeight);
                            }
                        },
                        stop: function (event, ui) {
                            var resized = $(this);
                            setTimeout(function () {
                                resizeBlock(resized);
                            }, 300);
                        }
                    });
                    $('.ui-resizable-handle').hover(function () {
                        getGridster().disable();
                    }, function () {
                        getGridster().enable();
                    });
                }
                function resizeBlock(elmObj) {
                    var area = elmObj.find('.widget-area');
                    var w = elmObj.width() - gridSize;
                    var h = elmObj.height() - gridSize;
                    for (var grid_w = 1; w > 0; w -= (gridSize + (gridMargin * 2))) {
                        grid_w++;
                    }
                    for (var grid_h = 1; h > 0; h -= (gridSize + (gridMargin * 2))) {
                        grid_h++;
                    }
                    var widget = {
                        id: area.attr('data-widgetId')
                    };
                    changeWidgetSize(widget, function (widget) {
                        widget.size_x = grid_w;
                        widget.size_y = grid_h;
                    }, function (widget) {
                        if (serializeDashboard()) {
                            updateDashboardRepository("Changed size of widget: " + widget.id);
                        }
                    });
                }
                function updateDashboardRepository(message) {
                    if ($scope.dashboard) {
                        var commitMessage = message;
                        if ($scope.dashboard && $scope.dashboard.title) {
                            commitMessage += " on dashboard " + $scope.dashboard.title;
                        }
                        dashboardRepository.putDashboards([$scope.dashboard], commitMessage, Dashboard.onOperationComplete);
                    }
                }
                function getGridster() {
                    return $element.gridster().data('gridster');
                }
            }];
        }
        return GridsterDirective;
    })();
    Dashboard.GridsterDirective = GridsterDirective;
})(Dashboard || (Dashboard = {}));
var Dashboard;
(function (Dashboard) {
    Dashboard._module.controller("Dashboard.ImportController", ["$scope", "$location", "$routeParams", "workspace", "dashboardRepository", function ($scope, $location, $routeParams, workspace, dashboardRepository) {
        $scope.placeholder = "Paste the JSON here for the dashboard configuration to import...";
        $scope.source = $scope.placeholder;
        var options = {
            mode: {
                name: "javascript"
            }
        };
        $scope.codeMirrorOptions = CodeEditor.createEditorSettings(options);
        $scope.isValid = function () { return $scope.source && $scope.source !== $scope.placeholder; };
        $scope.importJSON = function () {
            var json = [];
            try {
                json = JSON.parse($scope.source);
            }
            catch (e) {
                Core.notification("error", "Could not parse the JSON\n" + e);
                json = [];
            }
            var array = [];
            if (angular.isArray(json)) {
                array = json;
            }
            else if (angular.isObject(json)) {
                array.push(json);
            }
            if (array.length) {
                angular.forEach(array, function (dash, index) {
                    angular.copy(dash, dashboardRepository.createDashboard(dash));
                });
                dashboardRepository.putDashboards(array, "Imported dashboard JSON", Dashboard.onOperationComplete);
                $location.path("/dashboard/edit");
            }
        };
    }]);
})(Dashboard || (Dashboard = {}));
var Dashboard;
(function (Dashboard) {
    Dashboard._module.controller("Dashboard.NavBarController", ["$scope", "$routeParams", "$rootScope", "workspace", "dashboardRepository", "$location", "$timeout", function ($scope, $routeParams, $rootScope, workspace, dashboardRepository, $location, $timeout) {
        $scope.hash = workspace.hash();
        $scope._dashboards = [];
        $scope.edit = false;
        $scope.activeDashboard = $routeParams['dashboardId'];
        $rootScope.$on('loadDashboards', loadDashboards);
        $rootScope.$on('dashboardsUpdated', dashboardLoaded);
        $scope.navigateTo = function (url) {
            if (!$scope.edit) {
                $location.url(url);
            }
        };
        $scope.$on('editablePropertyEdit', function (ev, edit) {
            $timeout(function () {
                $scope.edit = edit;
            }, 0, false);
        });
        $scope.dashboards = function () {
            return $scope._dashboards;
        };
        $scope.isActive = function (dash) {
            return workspace.isLinkActive("#/dashboard/id/" + dash.id);
        };
        $scope.isEditing = function () {
            return workspace.isLinkActive("#/dashboard/edit");
        };
        $scope.onTabRenamed = function (dash) {
            dashboardRepository.putDashboards([dash], "Renamed dashboard", function (dashboards) {
                dashboardLoaded(null, dashboards);
            });
        };
        function dashboardLoaded(event, dashboards) {
            Dashboard.log.debug("navbar dashboardLoaded: ", dashboards);
            $scope._dashboards = dashboards;
            if (event === null) {
                $rootScope.$broadcast('dashboardsUpdated', dashboards);
                Core.$apply($scope);
            }
        }
        function loadDashboards(event) {
            dashboardRepository.getDashboards(function (dashboards) {
                dashboardLoaded(event, dashboards);
                Core.$apply($scope);
            });
        }
    }]);
})(Dashboard || (Dashboard = {}));
var Dashboard;
(function (Dashboard) {
    var RectangleLocation = (function () {
        function RectangleLocation(delegate, path, search, hash) {
            this.delegate = delegate;
            this._path = path;
            this._search = search;
            this._hash = hash;
        }
        RectangleLocation.prototype.absUrl = function () {
            return this.protocol() + this.host() + ":" + this.port() + this.path() + this.search();
        };
        RectangleLocation.prototype.hash = function (newHash) {
            if (newHash === void 0) { newHash = null; }
            if (newHash) {
                return this.delegate.hash(newHash).search('tab', null);
            }
            return this._hash;
        };
        RectangleLocation.prototype.host = function () {
            return this.delegate.host();
        };
        RectangleLocation.prototype.path = function (newPath) {
            if (newPath === void 0) { newPath = null; }
            if (newPath) {
                return this.delegate.path(newPath).search('tab', null);
            }
            return this._path;
        };
        RectangleLocation.prototype.port = function () {
            return this.delegate.port();
        };
        RectangleLocation.prototype.protocol = function () {
            return this.delegate.port();
        };
        RectangleLocation.prototype.replace = function () {
            return this;
        };
        RectangleLocation.prototype.search = function (parametersMap) {
            if (parametersMap === void 0) { parametersMap = null; }
            if (parametersMap) {
                return this.delegate.search(parametersMap);
            }
            return this._search;
        };
        RectangleLocation.prototype.url = function (newValue) {
            if (newValue === void 0) { newValue = null; }
            if (newValue) {
                return this.delegate.url(newValue).search('tab', null);
            }
            return this.absUrl();
        };
        return RectangleLocation;
    })();
    Dashboard.RectangleLocation = RectangleLocation;
})(Dashboard || (Dashboard = {}));
var Dashboard;
(function (Dashboard) {
    Dashboard.ShareController = Dashboard._module.controller("Dashboard.ShareController", ["$scope", "$location", "$routeParams", "workspace", "dashboardRepository", function ($scope, $location, $routeParams, workspace, dashboardRepository) {
        var id = $routeParams["dashboardId"];
        dashboardRepository.getDashboard(id, onDashboardLoad);
        var options = {
            mode: {
                name: "javascript"
            }
        };
        $scope.codeMirrorOptions = CodeEditor.createEditorSettings(options);
        function onDashboardLoad(dashboard) {
            $scope.dashboard = Dashboard.cleanDashboardData(dashboard);
            $scope.json = {
                "description": "hawtio dashboards",
                "public": true,
                "files": {
                    "dashboards.json": {
                        "content": JSON.stringify($scope.dashboard, null, "  ")
                    }
                }
            };
            $scope.source = JSON.stringify($scope.dashboard, null, "  ");
            Core.$applyNowOrLater($scope);
        }
    }]);
})(Dashboard || (Dashboard = {}));
var DataTable;
(function (DataTable) {
    var TableWidget = (function () {
        function TableWidget(scope, $templateCache, $compile, dataTableColumns, config) {
            var _this = this;
            if (config === void 0) { config = {}; }
            this.scope = scope;
            this.$templateCache = $templateCache;
            this.$compile = $compile;
            this.dataTableColumns = dataTableColumns;
            this.config = config;
            this.ignoreColumnHash = {};
            this.flattenColumnHash = {};
            this.detailTemplate = null;
            this.openMessages = [];
            this.addedExpandNodes = false;
            this.tableElement = null;
            this.sortColumns = null;
            this.dataTableConfig = {
                bPaginate: false,
                sDom: 'Rlfrtip',
                bDestroy: true,
                bAutoWidth: true
            };
            this.dataTable = null;
            angular.forEach(config.ignoreColumns, function (name) {
                _this.ignoreColumnHash[name] = true;
            });
            angular.forEach(config.flattenColumns, function (name) {
                _this.flattenColumnHash[name] = true;
            });
            var templateId = config.rowDetailTemplateId;
            if (templateId) {
                this.detailTemplate = this.$templateCache.get(templateId);
            }
        }
        TableWidget.prototype.addData = function (newData) {
            var dataTable = this.dataTable;
            dataTable.fnAddData(newData);
        };
        TableWidget.prototype.populateTable = function (data) {
            var _this = this;
            var $scope = this.scope;
            if (!data) {
                $scope.messages = [];
            }
            else {
                $scope.messages = data;
                var formatMessageDetails = function (dataTable, parentRow) {
                    var oData = dataTable.fnGetData(parentRow);
                    var div = $('<div>');
                    div.addClass('innerDetails');
                    _this.populateDetailDiv(oData, div);
                    return div;
                };
                var array = data;
                if (angular.isArray(data)) {
                }
                else if (angular.isObject(data)) {
                    array = [];
                    angular.forEach(data, function (object) { return array.push(object); });
                }
                var tableElement = this.tableElement;
                if (!tableElement) {
                    tableElement = $('#grid');
                }
                var tableTr = Core.getOrCreateElements(tableElement, ["thead", "tr"]);
                var tableBody = Core.getOrCreateElements(tableElement, ["tbody"]);
                var ths = $(tableTr).find("th");
                var columns = [];
                angular.forEach(this.dataTableColumns, function (value) { return columns.push(value); });
                var addColumn = function (key, title) {
                    columns.push({
                        "sDefaultContent": "",
                        "mData": null,
                        mDataProp: key
                    });
                    if (tableTr) {
                        $("<th>" + title + "</th>").appendTo(tableTr);
                    }
                };
                var checkForNewColumn = function (value, key, prefix) {
                    var found = _this.ignoreColumnHash[key] || columns.any(function (k, v) { return "mDataProp" === k && v === key; });
                    if (!found) {
                        if (_this.flattenColumnHash[key]) {
                            if (angular.isObject(value)) {
                                var childPrefix = prefix + key + ".";
                                angular.forEach(value, function (value, key) { return checkForNewColumn(value, key, childPrefix); });
                            }
                        }
                        else {
                            addColumn(prefix + key, Core.humanizeValue(key));
                        }
                    }
                };
                if (!this.config.disableAddColumns && angular.isArray(array) && array.length > 0) {
                    var first = array[0];
                    if (angular.isObject(first)) {
                        angular.forEach(first, function (value, key) { return checkForNewColumn(value, key, ""); });
                    }
                }
                if (columns.length > 1) {
                    var col0 = columns[0];
                    if (!this.sortColumns && !col0["mDataProp"] && !col0["mData"]) {
                        var sortOrder = [[1, "asc"]];
                        this.sortColumns = sortOrder;
                    }
                }
                if (array.length && !angular.isArray(array[0])) {
                    this.dataTableConfig["aaData"] = array;
                }
                else {
                    this.dataTableConfig["aaData"] = array;
                }
                this.dataTableConfig["aoColumns"] = columns;
                if (this.sortColumns) {
                    this.dataTableConfig["aaSorting"] = this.sortColumns;
                }
                this.dataTableConfig["oLanguage"] = {
                    "sSearch": "Filter:"
                };
                if (this.dataTable) {
                    this.dataTable.fnClearTable(false);
                    this.dataTable.fnAddData(array);
                    this.dataTable.fnDraw();
                }
                else {
                    this.dataTable = tableElement.dataTable(this.dataTableConfig);
                }
                var widget = this;
                if (this.dataTable) {
                    var keys = new KeyTable({
                        "table": tableElement[0],
                        "datatable": this.dataTable
                    });
                    keys.fnSetPosition(0, 0);
                    if (angular.isArray(data) && data.length) {
                        var selected = data[0];
                        var selectHandler = widget.config.selectHandler;
                        if (selected && selectHandler) {
                            selectHandler(selected);
                        }
                    }
                }
                $(tableElement).focus();
                var widget = this;
                var expandCollapseNode = function () {
                    var dataTable = widget.dataTable;
                    var parentRow = this.parentNode;
                    var openMessages = widget.openMessages;
                    var i = $.inArray(parentRow, openMessages);
                    var element = $('i', this);
                    if (i === -1) {
                        element.removeClass('icon-plus');
                        element.addClass('icon-minus');
                        var dataDiv = formatMessageDetails(dataTable, parentRow);
                        var detailsRow = $(dataTable.fnOpen(parentRow, dataDiv, 'details'));
                        detailsRow.css("padding", "0");
                        setTimeout(function () {
                            detailsRow.find(".innerDetails").slideDown(400, function () {
                                $(parentRow).addClass('opened');
                                openMessages.push(parentRow);
                            });
                        }, 20);
                    }
                    else {
                        $(parentRow.nextSibling).find(".innerDetails").slideUp(400, function () {
                            $(parentRow).removeClass('opened');
                            element.removeClass('icon-minus');
                            element.addClass('icon-plus');
                            dataTable.fnClose(parentRow);
                            openMessages.splice(i, 1);
                        });
                    }
                    Core.$apply($scope);
                };
                if (!this.addedExpandNodes) {
                    this.addedExpandNodes = true;
                    $(tableElement).on("click", "td.control", expandCollapseNode);
                    keys.event.action(0, null, function (node) {
                        expandCollapseNode.call(node);
                    });
                }
                keys.event.focus(null, null, function (node) {
                    var dataTable = widget.dataTable;
                    var row = node;
                    if (node) {
                        var nodeName = node.nodeName;
                        if (nodeName) {
                            if (nodeName.toLowerCase() === "td") {
                                row = $(node).parents("tr")[0];
                            }
                            var selected = dataTable.fnGetData(row);
                            var selectHandler = widget.config.selectHandler;
                            if (selected && selectHandler) {
                                selectHandler(selected);
                            }
                        }
                    }
                });
                $(tableElement).find("td.control").on("click", function (event) {
                    var dataTable = widget.dataTable;
                    if ($(this).hasClass('selected')) {
                        $(this).removeClass('focus selected');
                    }
                    else {
                        if (!widget.config.multiSelect) {
                            dataTable.$('td.selected').removeClass('focus selected');
                        }
                        $(this).addClass('focus selected');
                        var row = $(this).parents("tr")[0];
                        var selected = dataTable.fnGetData(row);
                        var selectHandler = widget.config.selectHandler;
                        if (selected && selectHandler) {
                            selectHandler(selected);
                        }
                    }
                });
            }
            Core.$apply($scope);
        };
        TableWidget.prototype.populateDetailDiv = function (row, div) {
            delete row["0"];
            var scope = this.scope.$new();
            scope.row = row;
            scope.templateDiv = div;
            var template = this.detailTemplate;
            if (!template) {
                var templateId = this.config.rowDetailTemplateId;
                if (templateId) {
                    this.detailTemplate = this.$templateCache.get(templateId);
                    template = this.detailTemplate;
                }
            }
            if (template) {
                div.html(template);
                this.$compile(div.contents())(scope);
            }
        };
        return TableWidget;
    })();
    DataTable.TableWidget = TableWidget;
})(DataTable || (DataTable = {}));
var DataTable;
(function (DataTable) {
    DataTable.pluginName = 'datatable';
    DataTable.log = Logger.get("DataTable");
    DataTable._module = angular.module(DataTable.pluginName, ['bootstrap', 'ngResource']);
    DataTable._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/datatable/test', { templateUrl: 'app/datatable/html/test.html' });
    }]);
    DataTable._module.directive('hawtioDatatable', ["$templateCache", "$compile", "$timeout", "$filter", function ($templateCache, $compile, $timeout, $filter) {
        return function (scope, element, attrs) {
            var gridOptions = null;
            var data = null;
            var widget = null;
            var timeoutId = null;
            var initialised = false;
            var childScopes = [];
            var rowDetailTemplate = null;
            var rowDetailTemplateId = null;
            var selectedItems = null;
            function updateGrid() {
                Core.$applyNowOrLater(scope);
            }
            function convertToDataTableColumn(columnDef) {
                var data = {
                    mData: columnDef.field,
                    sDefaultContent: ""
                };
                var name = columnDef.displayName;
                if (name) {
                    data["sTitle"] = name;
                }
                var width = columnDef.width;
                if (angular.isNumber(width)) {
                    data["sWidth"] = "" + width + "px";
                }
                else if (angular.isString(width) && !width.startsWith("*")) {
                    data["sWidth"] = width;
                }
                var template = columnDef.cellTemplate;
                if (template) {
                    data["fnCreatedCell"] = function (nTd, sData, oData, iRow, iCol) {
                        var childScope = childScopes[iRow];
                        if (!childScope) {
                            childScope = scope.$new(false);
                            childScopes[iRow] = childScope;
                        }
                        var entity = oData;
                        childScope["row"] = {
                            entity: entity,
                            getProperty: function (name) {
                                return entity[name];
                            }
                        };
                        var elem = $(nTd);
                        elem.html(template);
                        var contents = elem.contents();
                        contents.removeClass("ngCellText");
                        $compile(contents)(childScope);
                    };
                }
                else {
                    var cellFilter = columnDef.cellFilter;
                    var render = columnDef.render;
                    if (cellFilter && !render) {
                        var filter = $filter(cellFilter);
                        if (filter) {
                            render = function (data, type, full) {
                                return filter(data);
                            };
                        }
                    }
                    if (render) {
                        data["mRender"] = render;
                    }
                }
                return data;
            }
            function destroyChildScopes() {
                angular.forEach(childScopes, function (childScope) {
                    childScope.$destroy();
                });
                childScopes = [];
            }
            function selectHandler(selection) {
                if (selection && selectedItems) {
                    selectedItems.splice(0, selectedItems.length);
                    selectedItems.push(selection);
                    Core.$apply(scope);
                }
            }
            function onTableDataChange(value) {
                gridOptions = value;
                if (gridOptions) {
                    selectedItems = gridOptions.selectedItems;
                    rowDetailTemplate = gridOptions.rowDetailTemplate;
                    rowDetailTemplateId = gridOptions.rowDetailTemplateId;
                    if (widget === null) {
                        var widgetOptions = {
                            selectHandler: selectHandler,
                            disableAddColumns: true,
                            rowDetailTemplateId: rowDetailTemplateId,
                            ignoreColumns: gridOptions.ignoreColumns,
                            flattenColumns: gridOptions.flattenColumns
                        };
                        var rootElement = $(element);
                        var tableElement = rootElement.children("table");
                        if (!tableElement.length) {
                            $("<table class='table table-bordered table-condensed'></table>").appendTo(rootElement);
                            tableElement = rootElement.children("table");
                        }
                        tableElement.removeClass('table-striped');
                        tableElement.addClass('dataTable');
                        var trElement = Core.getOrCreateElements(tableElement, ["thead", "tr"]);
                        destroyChildScopes();
                        var columns = [];
                        var columnCounter = 1;
                        var extraLeftColumn = rowDetailTemplate || rowDetailTemplateId;
                        if (extraLeftColumn) {
                            columns.push({
                                "mDataProp": null,
                                "sClass": "control center",
                                "sWidth": "30px",
                                "sDefaultContent": '<i class="icon-plus"></i>'
                            });
                            var th = trElement.children("th");
                            if (th.length < columnCounter++) {
                                $("<th></th>").appendTo(trElement);
                            }
                        }
                        var columnDefs = gridOptions.columnDefs;
                        if (angular.isString(columnDefs)) {
                            columnDefs = scope[columnDefs];
                        }
                        angular.forEach(columnDefs, function (columnDef) {
                            th = trElement.children("th");
                            if (th.length < columnCounter++) {
                                var name = columnDef.displayName || "";
                                $("<th>" + name + "</th>").appendTo(trElement);
                            }
                            columns.push(convertToDataTableColumn(columnDef));
                        });
                        widget = new DataTable.TableWidget(scope, $templateCache, $compile, columns, widgetOptions);
                        widget.tableElement = tableElement;
                        var sortInfo = gridOptions.sortInfo;
                        if (sortInfo && columnDefs) {
                            var sortColumns = [];
                            var field = sortInfo.field;
                            if (field) {
                                var idx = columnDefs.findIndex({ field: field });
                                if (idx >= 0) {
                                    if (extraLeftColumn) {
                                        idx += 1;
                                    }
                                    var asc = sortInfo.direction || "asc";
                                    asc = asc.toLowerCase();
                                    sortColumns.push([idx, asc]);
                                }
                            }
                            if (sortColumns.length) {
                                widget.sortColumns = sortColumns;
                            }
                        }
                        if (columns.every(function (col) { return col.sWidth; })) {
                            widget.dataTableConfig.bAutoWidth = false;
                        }
                        var filterText = null;
                        var filterOptions = gridOptions.filterOptions;
                        if (filterOptions) {
                            filterText = filterOptions.filterText;
                        }
                        if (filterText || (angular.isDefined(gridOptions.showFilter) && !gridOptions.showFilter)) {
                            widget.dataTableConfig.sDom = 'Rlrtip';
                        }
                        if (filterText) {
                            scope.$watch(filterText, function (value) {
                                var dataTable = widget.dataTable;
                                if (dataTable) {
                                    dataTable.fnFilter(value);
                                }
                            });
                        }
                        if (angular.isDefined(gridOptions.displayFooter) && !gridOptions.displayFooter && widget.dataTableConfig.sDom) {
                            widget.dataTableConfig.sDom = widget.dataTableConfig.sDom.replace('i', '');
                        }
                    }
                    if (!data) {
                        data = gridOptions.data;
                        if (data) {
                            var listener = function (value) {
                                if (initialised || (value && (!angular.isArray(value) || value.length))) {
                                    initialised = true;
                                    destroyChildScopes();
                                    widget.populateTable(value);
                                    updateLater();
                                }
                            };
                            scope.$watch(data, listener);
                            scope.$on("hawtio.datatable." + data, function (args) {
                                var value = Core.pathGet(scope, data);
                                listener(value);
                            });
                        }
                    }
                }
                updateGrid();
            }
            scope.$watch(attrs.hawtioDatatable, onTableDataChange);
            function updateLater() {
                timeoutId = $timeout(function () {
                    updateGrid();
                }, 300);
            }
            element.bind('$destroy', function () {
                destroyChildScopes();
                $timeout.cancel(timeoutId);
            });
            updateLater();
        };
    }]);
    hawtioPluginLoader.addModule(DataTable.pluginName);
})(DataTable || (DataTable = {}));
var FilterHelpers;
(function (FilterHelpers) {
    FilterHelpers.log = Logger.get("FilterHelpers");
    function search(object, filter, maxDepth, and) {
        if (maxDepth === void 0) { maxDepth = -1; }
        if (and === void 0) { and = true; }
        var f = filter.split(" ");
        var matches = f.filter(function (f) {
            return searchObject(object, f, maxDepth);
        });
        if (and) {
            return matches.length === f.length;
        }
        else {
            return matches.length > 0;
        }
    }
    FilterHelpers.search = search;
    function searchObject(object, filter, maxDepth, depth) {
        if (maxDepth === void 0) { maxDepth = -1; }
        if (depth === void 0) { depth = 0; }
        if ((maxDepth > 0 && depth >= maxDepth) || depth > 50) {
            return false;
        }
        var f = filter.toLowerCase();
        var answer = false;
        if (angular.isString(object)) {
            answer = object.toLowerCase().has(f);
        }
        else if (angular.isNumber(object)) {
            answer = ("" + object).toLowerCase().has(f);
        }
        else if (angular.isArray(object)) {
            answer = object.some(function (item) {
                return searchObject(item, f, maxDepth, depth + 1);
            });
        }
        else if (angular.isObject(object)) {
            answer = searchObject(Object.extended(object).values(), f, maxDepth, depth);
        }
        return answer;
    }
    FilterHelpers.searchObject = searchObject;
})(FilterHelpers || (FilterHelpers = {}));
var DataTable;
(function (DataTable) {
    var SimpleDataTable = (function () {
        function SimpleDataTable($compile) {
            var _this = this;
            this.$compile = $compile;
            this.restrict = 'A';
            this.scope = {
                config: '=hawtioSimpleTable',
                target: '@',
                showFiles: '@'
            };
            this.link = function ($scope, $element, $attrs) {
                return _this.doLink($scope, $element, $attrs);
            };
        }
        SimpleDataTable.prototype.doLink = function ($scope, $element, $attrs) {
            var defaultPrimaryKeyFn = function (entity, idx) {
                return entity["id"] || entity["_id"] || entity["name"] || idx;
            };
            var config = $scope.config;
            var dataName = config.data || "data";
            var primaryKeyFn = config.primaryKeyFn || defaultPrimaryKeyFn;
            $scope.rows = [];
            var scope = $scope.$parent || $scope;
            var listener = function (otherValue) {
                var value = Core.pathGet(scope, dataName);
                if (value && !angular.isArray(value)) {
                    value = [value];
                    Core.pathSet(scope, dataName, value);
                }
                if (!('sortInfo' in config) && 'columnDefs' in config) {
                    var ds = config.columnDefs.first()['defaultSort'];
                    var sortField;
                    if (angular.isUndefined(ds) || ds === true) {
                        sortField = config.columnDefs.first()['field'];
                    }
                    else {
                        sortField = config.columnDefs.slice(1).first()['field'];
                    }
                    config['sortInfo'] = {
                        sortBy: sortField,
                        ascending: true
                    };
                }
                else {
                    config['sortInfo'] = {
                        sortBy: '',
                        ascending: true
                    };
                }
                var sortInfo = $scope.config.sortInfo;
                var idx = -1;
                $scope.rows = (value || []).sortBy(sortInfo.sortBy, !sortInfo.ascending).map(function (entity) {
                    idx++;
                    return {
                        entity: entity,
                        index: idx,
                        getProperty: function (name) {
                            return entity[name];
                        }
                    };
                });
                Core.pathSet(scope, ['hawtioSimpleTable', dataName, 'rows'], $scope.rows);
                var reSelectedItems = [];
                $scope.rows.forEach(function (row, idx) {
                    var rpk = primaryKeyFn(row.entity, row.index);
                    var selected = config.selectedItems.some(function (s) {
                        var spk = primaryKeyFn(s, s.index);
                        return angular.equals(rpk, spk);
                    });
                    if (selected) {
                        row.entity.index = row.index;
                        reSelectedItems.push(row.entity);
                        DataTable.log.debug("Data changed so keep selecting row at index " + row.index);
                    }
                });
                config.selectedItems = reSelectedItems;
            };
            scope.$watch(dataName, listener);
            scope.$on("hawtio.datatable." + dataName, listener);
            function getSelectionArray() {
                var selectionArray = config.selectedItems;
                if (!selectionArray) {
                    selectionArray = [];
                    config.selectedItems = selectionArray;
                }
                if (angular.isString(selectionArray)) {
                    var name = selectionArray;
                    selectionArray = Core.pathGet(scope, name);
                    if (!selectionArray) {
                        selectionArray = [];
                        scope[name] = selectionArray;
                    }
                }
                return selectionArray;
            }
            function isMultiSelect() {
                var multiSelect = $scope.config.multiSelect;
                if (angular.isUndefined(multiSelect)) {
                    multiSelect = true;
                }
                return multiSelect;
            }
            $scope.toggleAllSelections = function () {
                var allRowsSelected = $scope.config.allRowsSelected;
                var newFlag = allRowsSelected;
                var selectionArray = getSelectionArray();
                selectionArray.splice(0, selectionArray.length);
                angular.forEach($scope.rows, function (row) {
                    row.selected = newFlag;
                    if (allRowsSelected) {
                        selectionArray.push(row.entity);
                    }
                });
            };
            $scope.toggleRowSelection = function (row) {
                if (row) {
                    var selectionArray = getSelectionArray();
                    if (!isMultiSelect()) {
                        selectionArray.splice(0, selectionArray.length);
                        angular.forEach($scope.rows, function (r) {
                            if (r !== row) {
                                r.selected = false;
                            }
                        });
                    }
                    var entity = row.entity;
                    if (entity) {
                        var idx = selectionArray.indexOf(entity);
                        if (row.selected) {
                            if (idx < 0) {
                                selectionArray.push(entity);
                            }
                        }
                        else {
                            $scope.config.allRowsSelected = false;
                            if (idx >= 0) {
                                selectionArray.splice(idx, 1);
                            }
                        }
                    }
                }
            };
            $scope.sortBy = function (field) {
                if ($scope.config.sortInfo.sortBy === field) {
                    $scope.config.sortInfo.ascending = !$scope.config.sortInfo.ascending;
                }
                else {
                    $scope.config.sortInfo.sortBy = field;
                    $scope.config.sortInfo.ascending = true;
                }
                $scope.$emit("hawtio.datatable." + dataName);
            };
            $scope.getClass = function (field) {
                if ('sortInfo' in $scope.config) {
                    if ($scope.config.sortInfo.sortBy === field) {
                        if ($scope.config.sortInfo.ascending) {
                            return 'asc';
                        }
                        else {
                            return 'desc';
                        }
                    }
                }
                return '';
            };
            $scope.showRow = function (row) {
                var filter = Core.pathGet($scope, ['config', 'filterOptions', 'filterText']);
                if (Core.isBlank(filter)) {
                    return true;
                }
                var data = null;
                try {
                    data = row['entity']['title'];
                }
                catch (e) {
                }
                if (!data) {
                    data = row.entity;
                }
                var match = FilterHelpers.search(data, filter);
                return match;
            };
            $scope.isSelected = function (row) {
                return config.selectedItems.some(row.entity);
            };
            $scope.onRowSelected = function (row) {
                var idx = config.selectedItems.indexOf(row.entity);
                if (idx >= 0) {
                    DataTable.log.debug("De-selecting row at index " + row.index);
                    config.selectedItems.splice(idx, 1);
                }
                else {
                    if (!config.multiSelect) {
                        config.selectedItems.length = 0;
                    }
                    DataTable.log.debug("Selecting row at index " + row.index);
                    row.entity.index = row.index;
                    config.selectedItems.push(row.entity);
                }
            };
            var rootElement = $element;
            rootElement.empty();
            var showCheckBox = firstValueDefined(config, ["showSelectionCheckbox", "displaySelectionCheckbox"], true);
            var enableRowClickSelection = firstValueDefined(config, ["enableRowClickSelection"], false);
            var onMouseDown;
            if (enableRowClickSelection) {
                onMouseDown = "ng-mousedown='onRowSelected(row)' ";
            }
            else {
                onMouseDown = "";
            }
            var headHtml = "<thead><tr>";
            var bodyHtml = "<tbody><tr ng-repeat='row in rows track by $index' ng-show='showRow(row)' " + onMouseDown + "ng-class=\"{'selected': isSelected(row)}\" >";
            var idx = 0;
            if (showCheckBox) {
                var toggleAllHtml = isMultiSelect() ? "<input type='checkbox' ng-show='rows.length' ng-model='config.allRowsSelected' ng-change='toggleAllSelections()'>" : "";
                headHtml += "\n<th class='simple-table-checkbox'>" + toggleAllHtml + "</th>";
                bodyHtml += "\n<td class='simple-table-checkbox'><input type='checkbox' ng-model='row.selected' ng-change='toggleRowSelection(row)'></td>";
            }
            angular.forEach(config.columnDefs, function (colDef) {
                var field = colDef.field;
                var cellTemplate = colDef.cellTemplate || '<div class="ngCellText" title="{{row.entity.' + field + '}}">{{row.entity.' + field + '}}</div>';
                headHtml += "\n<th class='clickable no-fade table-header' ng-click=\"sortBy('" + field + "')\" ng-class=\"getClass('" + field + "')\">{{config.columnDefs[" + idx + "].displayName}}<span class='indicator'></span></th>";
                bodyHtml += "\n<td>" + cellTemplate + "</td>";
                idx += 1;
            });
            var html = headHtml + "\n</tr></thead>\n" + bodyHtml + "\n</tr></tbody>";
            var newContent = this.$compile(html)($scope);
            rootElement.html(newContent);
        };
        return SimpleDataTable;
    })();
    DataTable.SimpleDataTable = SimpleDataTable;
    function firstValueDefined(object, names, defaultValue) {
        var answer = defaultValue;
        var found = false;
        angular.forEach(names, function (name) {
            var value = object[name];
            if (!found && angular.isDefined(value)) {
                answer = value;
                found = true;
            }
        });
        return answer;
    }
    DataTable._module.directive('hawtioSimpleTable', ["$compile", function ($compile) { return new DataTable.SimpleDataTable($compile); }]);
})(DataTable || (DataTable = {}));
var DockerRegistry;
(function (DockerRegistry) {
    DockerRegistry._module = angular.module(DockerRegistry.pluginName, ['hawtioCore', 'ngResource']);
    DockerRegistry.controller = PluginHelpers.createControllerFunction(DockerRegistry._module, DockerRegistry.pluginName);
    DockerRegistry.route = PluginHelpers.createRoutingFunction(DockerRegistry.templatePath);
    DockerRegistry._module.config(['$routeProvider', function ($routeProvider) {
        $routeProvider.when(UrlHelpers.join(DockerRegistry.context, 'list'), DockerRegistry.route('list.html', false));
    }]);
    DockerRegistry._module.factory('DockerRegistryRestURL', ['jolokiaUrl', 'jolokia', '$q', '$rootScope', function (jolokiaUrl, jolokia, $q, $rootScope) {
        var answer = $q.defer();
        jolokia.getAttribute(Kubernetes.managerMBean, 'DockerRegistry', undefined, onSuccess(function (response) {
            var proxified = UrlHelpers.maybeProxy(jolokiaUrl, response);
            DockerRegistry.log.debug("Discovered docker registry API URL: ", proxified);
            answer.resolve(proxified);
            Core.$apply($rootScope);
        }, {
            error: function (response) {
                DockerRegistry.log.debug("error fetching docker registry API details: ", response);
                answer.reject(response);
                Core.$apply($rootScope);
            }
        }));
        return answer.promise;
    }]);
    DockerRegistry._module.run(['viewRegistry', 'workspace', function (viewRegistry, workspace) {
        DockerRegistry.log.debug("Running");
        viewRegistry['docker-registry'] = UrlHelpers.join(DockerRegistry.templatePath, 'layoutDockerRegistry.html');
        workspace.topLevelTabs.push({
            id: 'docker-registry',
            content: 'Images',
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: 'KubernetesManager' }); },
            isActive: function (workspace) { return workspace.isLinkActive('docker-registry'); },
            href: function () { return DockerRegistry.defaultRoute; }
        });
    }]);
    hawtioPluginLoader.addModule(DockerRegistry.pluginName);
})(DockerRegistry || (DockerRegistry = {}));
var PollHelpers;
(function (PollHelpers) {
    var log = Logger.get("PollHelpers");
    function setupPolling($scope, updateFunction, period, $timeout, jolokia) {
        if (period === void 0) { period = 2000; }
        if ($scope.$hasPoller) {
            log.debug("scope already has polling set up, ignoring subsequent polling request");
            return;
        }
        $scope.$hasPoller = true;
        if (!$timeout) {
            $timeout = Core.injector.get('$timeout');
        }
        if (!jolokia) {
            jolokia = Core.injector.get('jolokia');
        }
        var promise = undefined;
        var name = $scope.name || 'anonymous scope';
        var refreshFunction = function () {
            updateFunction(function () {
                if (jolokia.isRunning() && $scope.$hasPoller) {
                    promise = $timeout(refreshFunction, period);
                }
            });
        };
        if ($scope.$on) {
            $scope.$on('$destroy', function () {
                log.debug("scope", name, " being destroyed, cancelling polling");
                delete $scope.$hasPoller;
                $timeout.cancel(promise);
            });
            $scope.$on('$routeChangeStart', function () {
                log.debug("route changing, cancelling polling for scope: ", name);
                delete $scope.$hasPoller;
                $timeout.cancel(promise);
            });
        }
        return refreshFunction;
    }
    PollHelpers.setupPolling = setupPolling;
})(PollHelpers || (PollHelpers = {}));
var DockerRegistry;
(function (DockerRegistry) {
    DockerRegistry.TopLevel = DockerRegistry.controller("TopLevel", ["$scope", "$http", "$timeout", function ($scope, $http, $timeout) {
        $scope.repositories = [];
        $scope.fetched = false;
        $scope.restURL = '';
        DockerRegistry.getDockerImageRepositories(function (restURL, repositories) {
            $scope.restURL = restURL;
            $scope.fetched = true;
            if (repositories) {
                $scope.repositories = repositories.results;
                var previous = angular.toJson($scope.repositories);
                $scope.fetch = PollHelpers.setupPolling($scope, function (next) {
                    var searchURL = UrlHelpers.join($scope.restURL, DockerRegistry.SEARCH_FRAGMENT);
                    $http.get(searchURL).success(function (repositories) {
                        if (repositories && repositories.results) {
                            if (previous !== angular.toJson(repositories.results)) {
                                $scope.repositories = repositories.results;
                                previous = angular.toJson($scope.repositories);
                            }
                        }
                        next();
                    });
                });
                $scope.fetch();
            }
            else {
                DockerRegistry.log.debug("Failed initial fetch of image repositories");
            }
        });
        $scope.$watchCollection('repositories', function (repositories) {
            if (!Core.isBlank($scope.restURL)) {
                if (!repositories || repositories.length === 0) {
                    $scope.$broadcast("DockerRegistry.Repositories", $scope.restURL, repositories);
                    return;
                }
                var outstanding = repositories.length;
                function maybeNotify() {
                    outstanding = outstanding - 1;
                    if (outstanding <= 0) {
                        $scope.$broadcast("DockerRegistry.Repositories", $scope.restURL, repositories);
                    }
                }
                repositories.forEach(function (repository) {
                    var tagURL = UrlHelpers.join($scope.restURL, 'v1/repositories/' + repository.name + '/tags');
                    $timeout(function () {
                        DockerRegistry.log.debug("Fetching tags from URL: ", tagURL);
                        $http.get(tagURL).success(function (tags) {
                            DockerRegistry.log.debug("Got tags: ", tags, " for image repository: ", repository.name);
                            repository.tags = tags;
                            maybeNotify();
                        }).error(function (data) {
                            DockerRegistry.log.debug("Error fetching data for image repository: ", repository.name, " error: ", data);
                            maybeNotify();
                        });
                    }, 500);
                });
            }
        });
    }]);
})(DockerRegistry || (DockerRegistry = {}));
var DockerRegistry;
(function (DockerRegistry) {
    DockerRegistry.TagController = DockerRegistry.controller("TagController", ["$scope", function ($scope) {
        $scope.selectImage = function (imageID) {
            $scope.$emit("DockerRegistry.SelectedImageID", imageID);
        };
    }]);
    DockerRegistry.ListController = DockerRegistry.controller("ListController", ["$scope", "$templateCache", "$http", function ($scope, $templateCache, $http) {
        $scope.imageRepositories = [];
        $scope.selectedImage = undefined;
        $scope.tableConfig = {
            data: 'imageRepositories',
            showSelectionCheckbox: true,
            enableRowClickSelection: false,
            multiSelect: true,
            selectedItems: [],
            filterOptions: {
                filterText: ''
            },
            columnDefs: [
                { field: 'name', displayName: 'Name', defaultSort: true },
                { field: 'description', displayName: 'Description' },
                { field: 'tags', displayName: 'Tags', cellTemplate: $templateCache.get("tagsTemplate.html") }
            ]
        };
        $scope.deletePrompt = function (selectedRepositories) {
            UI.multiItemConfirmActionDialog({
                collection: selectedRepositories,
                index: 'name',
                onClose: function (result) {
                    if (result) {
                        selectedRepositories.forEach(function (repository) {
                            var deleteURL = UrlHelpers.join($scope.restURL, '/v1/repositories/' + repository.name + '/');
                            DockerRegistry.log.debug("Using URL: ", deleteURL);
                            $http.delete(deleteURL).success(function (data) {
                                DockerRegistry.log.debug("Deleted repository: ", repository.name);
                            }).error(function (data) {
                                DockerRegistry.log.debug("Failed to delete repository: ", repository.name);
                            });
                        });
                    }
                },
                title: 'Delete Repositories?',
                action: 'The following repositories will be deleted:',
                okText: 'Delete',
                okClass: 'btn-danger',
                custom: 'This operation is permanent once completed!',
                customClass: 'alert alert-warning'
            }).open();
        };
        $scope.$on("DockerRegistry.SelectedImageID", function ($event, imageID) {
            var imageJsonURL = UrlHelpers.join($scope.restURL, '/v1/images/' + imageID + '/json');
            $http.get(imageJsonURL).success(function (image) {
                DockerRegistry.log.debug("Got image: ", image);
                $scope.selectedImage = image;
            });
        });
        $scope.$on('DockerRegistry.Repositories', function ($event, restURL, repositories) {
            $scope.imageRepositories = repositories;
        });
    }]);
})(DockerRegistry || (DockerRegistry = {}));
var Dozer;
(function (Dozer) {
    Dozer.jmxDomain = 'net.sourceforge.dozer';
    Dozer.introspectorMBean = "hawtio:type=Introspector";
    Dozer.excludedPackages = [
        'java.lang',
        'int',
        'double',
        'long'
    ];
    Dozer.elementNameMappings = {
        "Mapping": "mapping",
        "MappingClass": "class",
        "Field": "field"
    };
    Dozer.log = Logger.get("Dozer");
    function loadDozerModel(xml, pageId) {
        var doc = xml;
        if (angular.isString(xml)) {
            doc = $.parseXML(xml);
        }
        console.log("Has Dozer XML document: " + doc);
        var model = new Dozer.Mappings(doc);
        var mappingsElement = doc.documentElement;
        copyAttributes(model, mappingsElement);
        $(mappingsElement).children("mapping").each(function (idx, element) {
            var mapping = createMapping(element);
            model.mappings.push(mapping);
        });
        return model;
    }
    Dozer.loadDozerModel = loadDozerModel;
    function saveToXmlText(model) {
        var element = model.doc.documentElement.cloneNode(false);
        appendElement(model.mappings, element, null, 1);
        Dozer.addTextNode(element, "\n");
        var xmlText = Core.xmlNodeToString(element);
        return '<?xml version="1.0" encoding="UTF-8"?>\n' + xmlText;
    }
    Dozer.saveToXmlText = saveToXmlText;
    function findUnmappedFields(workspace, mapping, fn) {
        var className = mapping.class_a.value;
        findProperties(workspace, className, null, function (properties) {
            var answer = [];
            angular.forEach(properties, function (property) {
                console.log("got property " + JSON.stringify(property, null, "  "));
                var name = property.name;
                if (name) {
                    if (mapping.hasFromField(name)) {
                    }
                    else {
                        answer.push(new Dozer.UnmappedField(name, property));
                    }
                }
            });
            fn(answer);
        });
    }
    Dozer.findUnmappedFields = findUnmappedFields;
    function findProperties(workspace, className, filter, fn) {
        if (filter === void 0) { filter = null; }
        if (fn === void 0) { fn = null; }
        var mbean = getIntrospectorMBean(workspace);
        if (mbean) {
            if (filter) {
                return workspace.jolokia.execute(mbean, "findProperties", className, filter, onSuccess(fn));
            }
            else {
                return workspace.jolokia.execute(mbean, "getProperties", className, onSuccess(fn));
            }
        }
        else {
            if (fn) {
                return fn([]);
            }
            else {
                return [];
            }
        }
    }
    Dozer.findProperties = findProperties;
    function findClassNames(workspace, searchText, limit, fn) {
        if (limit === void 0) { limit = 20; }
        if (fn === void 0) { fn = null; }
        var mbean = getIntrospectorMBean(workspace);
        if (mbean) {
            return workspace.jolokia.execute(mbean, "findClassNames", searchText, limit, onSuccess(fn));
        }
        else {
            if (fn) {
                return fn([]);
            }
            else {
                return [];
            }
        }
    }
    Dozer.findClassNames = findClassNames;
    function getIntrospectorMBean(workspace) {
        return Dozer.introspectorMBean;
    }
    Dozer.getIntrospectorMBean = getIntrospectorMBean;
    function loadModelFromTree(rootTreeNode, oldModel) {
        oldModel.mappings = [];
        angular.forEach(rootTreeNode.childList, function (treeNode) {
            var mapping = Core.pathGet(treeNode, ["data", "entity"]);
            if (mapping) {
                oldModel.mappings.push(mapping);
            }
        });
        return oldModel;
    }
    Dozer.loadModelFromTree = loadModelFromTree;
    function createDozerTree(model) {
        var id = "mappings";
        var folder = new Folder(id);
        folder.addClass = "net-sourceforge-dozer-mappings";
        folder.domain = Dozer.jmxDomain;
        folder.typeName = "mappings";
        folder.entity = model;
        folder.key = Core.toSafeDomID(id);
        angular.forEach(model.mappings, function (mapping) {
            var mappingFolder = createMappingFolder(mapping, folder);
            folder.children.push(mappingFolder);
        });
        return folder;
    }
    Dozer.createDozerTree = createDozerTree;
    function createMappingFolder(mapping, parentFolder) {
        var mappingName = mapping.name();
        var mappingFolder = new Folder(mappingName);
        mappingFolder.addClass = "net-sourceforge-dozer-mapping";
        mappingFolder.typeName = "mapping";
        mappingFolder.domain = Dozer.jmxDomain;
        mappingFolder.key = (parentFolder ? parentFolder.key + "_" : "") + Core.toSafeDomID(mappingName);
        mappingFolder.parent = parentFolder;
        mappingFolder.entity = mapping;
        mappingFolder.icon = Core.url("/app/dozer/img/class.gif");
        angular.forEach(mapping.fields, function (field) {
            addMappingFieldFolder(field, mappingFolder);
        });
        return mappingFolder;
    }
    Dozer.createMappingFolder = createMappingFolder;
    function addMappingFieldFolder(field, mappingFolder) {
        var name = field.name();
        var fieldFolder = new Folder(name);
        fieldFolder.addClass = "net-sourceforge-dozer-field";
        fieldFolder.typeName = "field";
        fieldFolder.domain = Dozer.jmxDomain;
        fieldFolder.key = mappingFolder.key + "_" + Core.toSafeDomID(name);
        fieldFolder.parent = mappingFolder;
        fieldFolder.entity = field;
        fieldFolder.icon = Core.url("/app/dozer/img/attribute.gif");
        mappingFolder.children.push(fieldFolder);
        return fieldFolder;
    }
    Dozer.addMappingFieldFolder = addMappingFieldFolder;
    function createMapping(element) {
        var mapping = new Dozer.Mapping();
        var elementJQ = $(element);
        mapping.class_a = createMappingClass(elementJQ.children("class-a"));
        mapping.class_b = createMappingClass(elementJQ.children("class-b"));
        elementJQ.children("field").each(function (idx, fieldElement) {
            var field = createField(fieldElement);
            mapping.fields.push(field);
        });
        copyAttributes(mapping, element);
        return mapping;
    }
    function createField(element) {
        if (element) {
            var jqe = $(element);
            var a = jqe.children("a").text();
            var b = jqe.children("b").text();
            var field = new Dozer.Field(new Dozer.FieldDefinition(a), new Dozer.FieldDefinition(b));
            copyAttributes(field, element);
            return field;
        }
        return new Dozer.Field(new Dozer.FieldDefinition(""), new Dozer.FieldDefinition(""));
    }
    function createMappingClass(jqElement) {
        if (jqElement && jqElement[0]) {
            var element = jqElement[0];
            var text = element.textContent;
            if (text) {
                var mappingClass = new Dozer.MappingClass(text);
                copyAttributes(mappingClass, element);
                return mappingClass;
            }
        }
        return new Dozer.MappingClass("");
    }
    function copyAttributes(object, element) {
        var attributeMap = element.attributes;
        for (var i = 0; i < attributeMap.length; i++) {
            var attMap = attributeMap;
            var attr = attMap.item(i);
            if (attr) {
                var name = attr.localName;
                var value = attr.value;
                if (name && !name.startsWith("xmlns")) {
                    var safeName = Forms.safeIdentifier(name);
                    object[safeName] = value;
                }
            }
        }
    }
    function appendAttributes(object, element, ignorePropertyNames) {
        angular.forEach(object, function (value, key) {
            if (ignorePropertyNames.any(key)) {
            }
            else {
                if (value) {
                    var text = value.toString();
                    var name = key.replace(/_/g, '-');
                    element.setAttribute(name, text);
                }
            }
        });
    }
    Dozer.appendAttributes = appendAttributes;
    function appendElement(object, element, elementName, indentLevel) {
        if (elementName === void 0) { elementName = null; }
        if (indentLevel === void 0) { indentLevel = 0; }
        var answer = null;
        if (angular.isArray(object)) {
            angular.forEach(object, function (child) {
                answer = appendElement(child, element, elementName, indentLevel);
            });
        }
        else if (object) {
            if (!elementName) {
                var className = Core.pathGet(object, ["constructor", "name"]);
                if (!className) {
                    console.log("WARNING: no class name for value " + object);
                }
                else {
                    elementName = Dozer.elementNameMappings[className];
                    if (!elementName) {
                        console.log("WARNING: could not map class name " + className + " to an XML element name");
                    }
                }
            }
            if (elementName) {
                if (indentLevel) {
                    var text = indentText(indentLevel);
                    Dozer.addTextNode(element, text);
                }
                var doc = element.ownerDocument || document;
                var child = doc.createElement(elementName);
                var fn = object.saveToElement;
                if (fn) {
                    fn.apply(object, [child]);
                }
                else {
                    angular.forEach(object, function (value, key) {
                        console.log("has key " + key + " value " + value);
                    });
                }
                if ($(child).children().length) {
                    var text = indentText(indentLevel);
                    Dozer.addTextNode(child, text);
                }
                element.appendChild(child);
                answer = child;
            }
        }
        return answer;
    }
    Dozer.appendElement = appendElement;
    function nameOf(object) {
        var text = angular.isObject(object) ? object["value"] : null;
        if (!text && angular.isString(object)) {
            text = object;
        }
        return text || "?";
    }
    Dozer.nameOf = nameOf;
    function addTextNode(element, text) {
        if (text) {
            var doc = element.ownerDocument || document;
            var child = doc.createTextNode(text);
            element.appendChild(child);
        }
    }
    Dozer.addTextNode = addTextNode;
    function indentText(indentLevel) {
        var text = "\n";
        for (var i = 0; i < indentLevel; i++) {
            text += "  ";
        }
        return text;
    }
})(Dozer || (Dozer = {}));
var Dozer;
(function (Dozer) {
    var Mappings = (function () {
        function Mappings(doc, mappings) {
            if (mappings === void 0) { mappings = []; }
            this.doc = doc;
            this.mappings = mappings;
        }
        return Mappings;
    })();
    Dozer.Mappings = Mappings;
    var Mapping = (function () {
        function Mapping() {
            this.fields = [];
            this.map_id = Core.getUUID();
            this.class_a = new MappingClass('');
            this.class_b = new MappingClass('');
        }
        Mapping.prototype.name = function () {
            return Dozer.nameOf(this.class_a) + " -> " + Dozer.nameOf(this.class_b);
        };
        Mapping.prototype.hasFromField = function (name) {
            return this.fields.find(function (f) { return name === f.a.value; });
        };
        Mapping.prototype.hasToField = function (name) {
            return this.fields.find(function (f) { return name === f.b.value; });
        };
        Mapping.prototype.saveToElement = function (element) {
            Dozer.appendElement(this.class_a, element, "class-a", 2);
            Dozer.appendElement(this.class_b, element, "class-b", 2);
            Dozer.appendElement(this.fields, element, "field", 2);
            Dozer.appendAttributes(this, element, ["class_a", "class_b", "fields"]);
        };
        return Mapping;
    })();
    Dozer.Mapping = Mapping;
    var MappingClass = (function () {
        function MappingClass(value) {
            this.value = value;
        }
        MappingClass.prototype.saveToElement = function (element) {
            Dozer.addTextNode(element, this.value);
            Dozer.appendAttributes(this, element, ["value", "properties", "error"]);
        };
        return MappingClass;
    })();
    Dozer.MappingClass = MappingClass;
    var Field = (function () {
        function Field(a, b) {
            this.a = a;
            this.b = b;
        }
        Field.prototype.name = function () {
            return Dozer.nameOf(this.a) + " -> " + Dozer.nameOf(this.b);
        };
        Field.prototype.saveToElement = function (element) {
            Dozer.appendElement(this.a, element, "a", 3);
            Dozer.appendElement(this.b, element, "b", 3);
            Dozer.appendAttributes(this, element, ["a", "b"]);
        };
        return Field;
    })();
    Dozer.Field = Field;
    var FieldDefinition = (function () {
        function FieldDefinition(value) {
            this.value = value;
        }
        FieldDefinition.prototype.saveToElement = function (element) {
            Dozer.addTextNode(element, this.value);
            Dozer.appendAttributes(this, element, ["value", "properties", "error"]);
        };
        return FieldDefinition;
    })();
    Dozer.FieldDefinition = FieldDefinition;
    var UnmappedField = (function () {
        function UnmappedField(fromField, property, toField) {
            if (toField === void 0) { toField = null; }
            this.fromField = fromField;
            this.property = property;
            this.toField = toField;
        }
        return UnmappedField;
    })();
    Dozer.UnmappedField = UnmappedField;
})(Dozer || (Dozer = {}));
var Dozer;
(function (Dozer) {
    function schemaConfigure() {
        io_hawt_dozer_schema_Field["tabs"] = {
            'Fields': ['a.value', 'b.value'],
            'From Field': ['a\\..*'],
            'To Field': ['b\\..*'],
            'Field Configuration': ['*']
        };
        io_hawt_dozer_schema_Mapping["tabs"] = {
            'Classes': ['class-a.value', 'class-b.value'],
            'From Class': ['class-a\\..*'],
            'To Class': ['class-b\\..*'],
            'Class Configuration': ['*']
        };
        io_hawt_dozer_schema_Mapping.properties.fieldOrFieldExclude.hidden = true;
        Core.pathSet(io_hawt_dozer_schema_Field, ["properties", "a", "properties", "value", "label"], "From Field");
        Core.pathSet(io_hawt_dozer_schema_Field, ["properties", "b", "properties", "value", "label"], "To Field");
        Core.pathSet(io_hawt_dozer_schema_Mapping, ["properties", "class-a", "properties", "value", "label"], "From Class");
        Core.pathSet(io_hawt_dozer_schema_Mapping, ["properties", "class-b", "properties", "value", "label"], "To Class");
        Core.pathSet(io_hawt_dozer_schema_Field, ["properties", "a", "ignorePrefixInLabel"], true);
        Core.pathSet(io_hawt_dozer_schema_Field, ["properties", "b", "ignorePrefixInLabel"], true);
        Core.pathSet(io_hawt_dozer_schema_Mapping, ["properties", "class-a", "ignorePrefixInLabel"], true);
        Core.pathSet(io_hawt_dozer_schema_Mapping, ["properties", "class-b", "ignorePrefixInLabel"], true);
        Core.pathSet(io_hawt_dozer_schema_Mapping, ["properties", "class-a", "properties", "value", "formTemplate"], classNameWidget("class_a"));
        Core.pathSet(io_hawt_dozer_schema_Mapping, ["properties", "class-b", "properties", "value", "formTemplate"], classNameWidget("class_b"));
        Core.pathSet(io_hawt_dozer_schema_Field, ["properties", "a", "properties", "value", "formTemplate"], '<input type="text" ng-model="dozerEntity.a.value" ' + 'typeahead="title for title in fromFieldNames($viewValue) | filter:$viewValue" ' + 'typeahead-editable="true"  title="The Java class name"/>');
        Core.pathSet(io_hawt_dozer_schema_Field, ["properties", "b", "properties", "value", "formTemplate"], '<input type="text" ng-model="dozerEntity.b.value" ' + 'typeahead="title for title in toFieldNames($viewValue) | filter:$viewValue" ' + 'typeahead-editable="true"  title="The Java class name"/>');
        function classNameWidget(propertyName) {
            return '<input type="text" ng-model="dozerEntity.' + propertyName + '.value" ' + 'typeahead="title for title in classNames($viewValue) | filter:$viewValue" ' + 'typeahead-editable="true"  title="The Java class name"/>';
        }
    }
    Dozer.schemaConfigure = schemaConfigure;
})(Dozer || (Dozer = {}));
var ES;
(function (ES) {
    ES.config = {
        elasticsearch: "http://" + window.location.hostname + ":9200",
        indice: "twitter",
        doctype: "tweet",
        query: "*"
    };
})(ES || (ES = {}));
var ES;
(function (ES) {
    function isEmptyObject(value) {
        return $.isEmptyObject(value);
    }
    ES.isEmptyObject = isEmptyObject;
    function SearchCtrl($scope, $location, $log, ejsResource) {
        var esServer = $scope.esServer = ES.config["elasticsearch"];
        var query = $scope.queryTerm = ES.config["query"];
        var facetField = $scope.facetField = "tags";
        var facetType = $scope.facetType = "terms";
        var index = $scope.indice = ES.config["indice"];
        var type = $scope.docType = ES.config["doctype"];
        var ejs;
        var request;
        $scope.log = $log;
        $scope.search = function () {
            if (isEmptyObject(ejs)) {
                console.log("Init EJS server");
                ejs = initElasticsearchServer(esServer);
            }
            setupEsRequest();
            request = request.query(ejs.QueryStringQuery(query));
            var results = request.doSearch();
            console.log("Do Elastic Search");
            results.then(function (results) {
                $scope.queryTerm = "";
                if (typeof results.error != 'undefined') {
                    console.error("ES error : " + results.error);
                    return;
                }
                console.log(results.hits.total + " : results retrieved");
                $scope.results = results;
            });
        };
        $scope.facetTermsSearch = function () {
            if (isEmptyObject(ejs)) {
                console.log("Init EJS server");
                ejs = initElasticsearchServer(esServer);
            }
            setupEsRequest();
            if (!isEmptyObject($scope.facetField)) {
                facetField = $scope.facetField;
            }
            if (!isEmptyObject($scope.facetType)) {
                facetType = $scope.facetType;
            }
            request = request.query(ejs.QueryStringQuery(query)).facet(ejs.TermsFacet("termFacet").field(facetField).size(50));
            var results = request.doSearch();
            console.log("Do Elastic Search");
            results.then(function (results) {
                $scope.queryTerm = "";
                if (typeof results.error != 'undefined') {
                    console.error("ES error : " + results.error);
                    return;
                }
                console.log(results.hits.total + " : results retrieved");
                $scope.results = results;
            });
        };
        $scope.facetDateHistogramSearch = function () {
            if (isEmptyObject(ejs)) {
                console.log("Init EJS server");
                ejs = initElasticsearchServer(esServer);
            }
            setupEsRequest();
            if (!isEmptyObject($scope.facetField)) {
                facetField = $scope.facetField;
            }
            if (!isEmptyObject($scope.facetType)) {
                facetType = $scope.facetType;
            }
            request = request.query(ejs.QueryStringQuery(query)).facet(ejs.DateHistogramFacet("dateHistoFacet").field(facetField).interval("minute"));
            var results = request.doSearch();
            console.log("Do Elastic Search");
            results.then(function (results) {
                $scope.queryTerm = "";
                if (typeof results.error != 'undefined') {
                    console.error("ES error : " + results.error);
                    return;
                }
                console.log(results.hits.total + " : results retrieved");
                $scope.results = results;
            });
        };
        $scope.indexSampleDocs = function () {
            var host = "http://" + location.host;
            if (isEmptyObject(ejs)) {
                console.log("EJS object is not defined - create it - setupEsRequest");
                ejs = initElasticsearchServer(esServer);
            }
            var docs = [];
            $.getJSON(host + "/hawtio/app/elasticsearch/js/data.json", function (result) {
                $.each(result, function (i, field) {
                    console.log("Field : " + field);
                    docs[i] = ejs.Document(index, type, i).source(field);
                    docs[i].refresh(true).doIndex();
                });
            });
        };
        function setupEsRequest() {
            console.log("ES Server = " + $scope.esServer);
            console.log("Indice = " + $scope.indice);
            console.log("Type = " + $scope.docType);
            console.log("Query = " + $scope.queryTerm);
            if (!isEmptyObject($scope.indice)) {
                index = $scope.indice;
            }
            if (!isEmptyObject($scope.esServer)) {
                esServer = $scope.esServer;
            }
            if (!isEmptyObject($scope.docType)) {
                type = $scope.docType;
            }
            if (!isEmptyObject($scope.queryTerm)) {
                query = $scope.queryTerm;
            }
            var ejs = ejsResource($scope.esServer);
            request = ejs.Request().indices(index).types(type);
            console.log("Request to call ElasticSearch defined");
        }
        function initElasticsearchServer(esServer) {
            return ejsResource(esServer);
        }
        $scope.parse_error = function (data) {
            var _error = data.match("nested: (.*?);");
            return _error == null ? data : _error[1];
        };
    }
    ES.SearchCtrl = SearchCtrl;
})(ES || (ES = {}));
var ES;
(function (ES) {
    var pluginName = 'elasticsearch';
    var base_url = 'app/elasticsearch/html';
    ES._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'elasticjs.service', 'dangle']);
    ES._module.config(['$routeProvider', function ($routeProvider) {
        $routeProvider.when('/elasticsearch', { templateUrl: base_url + '/es.html' });
    }]);
    ES._module.run(["$location", "workspace", "viewRegistry", "helpRegistry", function ($location, workspace, viewRegistry, helpRegistry) {
        viewRegistry[pluginName] = 'app/elasticsearch/html/es.html';
        helpRegistry.addUserDoc(pluginName, 'app/elasticsearch/doc/help.md', function () {
            return false;
        });
    }]);
})(ES || (ES = {}));
var Wiki;
(function (Wiki) {
    var GitWikiRepository = (function () {
        function GitWikiRepository(factoryMethod) {
            this.factoryMethod = factoryMethod;
            this.directoryPrefix = "";
        }
        GitWikiRepository.prototype.getRepositoryLabel = function (fn, error) {
            this.git().getRepositoryLabel(fn, error);
        };
        GitWikiRepository.prototype.exists = function (branch, path, fn) {
            var fullPath = this.getPath(path);
            return this.git().exists(branch, fullPath, fn);
        };
        GitWikiRepository.prototype.completePath = function (branch, completionText, directoriesOnly, fn) {
            return this.git().completePath(branch, completionText, directoriesOnly, fn);
        };
        GitWikiRepository.prototype.getPage = function (branch, path, objectId, fn) {
            var _this = this;
            var git = this.git();
            path = path || "/";
            if (git) {
                if (objectId) {
                    var blobPath = this.getLogPath(path);
                    git.getContent(objectId, blobPath, function (content) {
                        var details = {
                            text: content,
                            directory: false
                        };
                        fn(details);
                    });
                }
                else {
                    var fullPath = this.getPath(path);
                    git.read(branch, fullPath, function (details) {
                        var children = details.children;
                        angular.forEach(children, function (child) {
                            var path = child.path;
                            if (path) {
                                var directoryPrefix = "/" + _this.directoryPrefix;
                                if (path.startsWith(directoryPrefix)) {
                                    path = "/" + path.substring(directoryPrefix.length);
                                    child.path = path;
                                }
                            }
                        });
                        fn(details);
                    });
                }
            }
            return git;
        };
        GitWikiRepository.prototype.diff = function (objectId, baseObjectId, path, fn) {
            var fullPath = this.getLogPath(path);
            var git = this.git();
            if (git) {
                git.diff(objectId, baseObjectId, fullPath, function (content) {
                    var details = {
                        text: content,
                        format: "diff",
                        directory: false
                    };
                    fn(details);
                });
            }
            return git;
        };
        GitWikiRepository.prototype.commitInfo = function (commitId, fn) {
            this.git().commitInfo(commitId, fn);
        };
        GitWikiRepository.prototype.commitTree = function (commitId, fn) {
            this.git().commitTree(commitId, fn);
        };
        GitWikiRepository.prototype.putPage = function (branch, path, contents, commitMessage, fn) {
            var fullPath = this.getPath(path);
            this.git().write(branch, fullPath, commitMessage, contents, fn);
        };
        GitWikiRepository.prototype.putPageBase64 = function (branch, path, contents, commitMessage, fn) {
            var fullPath = this.getPath(path);
            this.git().writeBase64(branch, fullPath, commitMessage, contents, fn);
        };
        GitWikiRepository.prototype.createDirectory = function (branch, path, commitMessage, fn) {
            var fullPath = this.getPath(path);
            this.git().createDirectory(branch, fullPath, commitMessage, fn);
        };
        GitWikiRepository.prototype.revertTo = function (branch, objectId, blobPath, commitMessage, fn) {
            var fullPath = this.getLogPath(blobPath);
            this.git().revertTo(branch, objectId, fullPath, commitMessage, fn);
        };
        GitWikiRepository.prototype.rename = function (branch, oldPath, newPath, commitMessage, fn) {
            var fullOldPath = this.getPath(oldPath);
            var fullNewPath = this.getPath(newPath);
            if (!commitMessage) {
                commitMessage = "Renaming page " + oldPath + " to " + newPath;
            }
            this.git().rename(branch, fullOldPath, fullNewPath, commitMessage, fn);
        };
        GitWikiRepository.prototype.removePage = function (branch, path, commitMessage, fn) {
            var fullPath = this.getPath(path);
            if (!commitMessage) {
                commitMessage = "Removing page " + path;
            }
            this.git().remove(branch, fullPath, commitMessage, fn);
        };
        GitWikiRepository.prototype.getPath = function (path) {
            var directoryPrefix = this.directoryPrefix;
            return (directoryPrefix) ? directoryPrefix + path : path;
        };
        GitWikiRepository.prototype.getLogPath = function (path) {
            return Core.trimLeading(this.getPath(path), "/");
        };
        GitWikiRepository.prototype.history = function (branch, objectId, path, limit, fn) {
            var fullPath = this.getLogPath(path);
            var git = this.git();
            if (git) {
                git.history(branch, objectId, fullPath, limit, fn);
            }
            return git;
        };
        GitWikiRepository.prototype.getContent = function (objectId, blobPath, fn) {
            var fullPath = this.getLogPath(blobPath);
            var git = this.git();
            if (git) {
                git.getContent(objectId, fullPath, fn);
            }
            return git;
        };
        GitWikiRepository.prototype.branches = function (fn) {
            var git = this.git();
            if (git) {
                git.branches(fn);
            }
            return git;
        };
        GitWikiRepository.prototype.jsonChildContents = function (path, nameWildcard, search, fn) {
            var fullPath = this.getLogPath(path);
            var git = this.git();
            if (git) {
                git.readJsonChildContent(fullPath, nameWildcard, search, fn);
            }
            return git;
        };
        GitWikiRepository.prototype.git = function () {
            var repository = this.factoryMethod();
            if (!repository) {
                console.log("No repository yet! TODO we should use a local impl!");
            }
            return repository;
        };
        return GitWikiRepository;
    })();
    Wiki.GitWikiRepository = GitWikiRepository;
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki.pluginName = 'wiki';
    Wiki.templatePath = 'app/wiki/html/';
    Wiki.tab = null;
    Wiki._module = angular.module(Wiki.pluginName, ['bootstrap', 'ui.bootstrap.dialog', 'ui.bootstrap.tabs', 'ngResource', 'hawtioCore', 'hawtio-ui', 'tree', 'camel']);
    Wiki.controller = PluginHelpers.createControllerFunction(Wiki._module, 'Wiki');
    Wiki.route = PluginHelpers.createRoutingFunction(Wiki.templatePath);
    Wiki._module.config(["$routeProvider", function ($routeProvider) {
        angular.forEach(["", "/branch/:branch"], function (path) {
            $routeProvider.when(UrlHelpers.join('/wiki', path, 'view'), Wiki.route('viewPage.html', false)).when(UrlHelpers.join('/wiki', path, 'create/*page'), Wiki.route('create.html', false)).when('/wiki' + path + '/view/*page', { templateUrl: 'app/wiki/html/viewPage.html', reloadOnSearch: false }).when('/wiki' + path + '/book/*page', { templateUrl: 'app/wiki/html/viewBook.html', reloadOnSearch: false }).when('/wiki' + path + '/edit/*page', { templateUrl: 'app/wiki/html/editPage.html' }).when('/wiki' + path + '/version/*page/:objectId', { templateUrl: 'app/wiki/html/viewPage.html' }).when('/wiki' + path + '/history/*page', { templateUrl: 'app/wiki/html/history.html' }).when('/wiki' + path + '/commit/*page/:objectId', { templateUrl: 'app/wiki/html/commit.html' }).when('/wiki' + path + '/diff/*page/:objectId/:baseObjectId', { templateUrl: 'app/wiki/html/viewPage.html', reloadOnSearch: false }).when('/wiki' + path + '/formTable/*page', { templateUrl: 'app/wiki/html/formTable.html' }).when('/wiki' + path + '/dozer/mappings/*page', { templateUrl: 'app/wiki/html/dozerMappings.html' }).when('/wiki' + path + '/configurations/*page', { templateUrl: 'app/wiki/html/configurations.html' }).when('/wiki' + path + '/configuration/:pid/*page', { templateUrl: 'app/wiki/html/configuration.html' }).when('/wiki' + path + '/newConfiguration/:factoryPid/*page', { templateUrl: 'app/wiki/html/configuration.html' }).when('/wiki' + path + '/camel/diagram/*page', { templateUrl: 'app/wiki/html/camelDiagram.html' }).when('/wiki' + path + '/camel/canvas/*page', { templateUrl: 'app/wiki/html/camelCanvas.html' }).when('/wiki' + path + '/camel/properties/*page', { templateUrl: 'app/wiki/html/camelProperties.html' });
        });
    }]);
    Wiki._module.factory('wikiRepository', ["workspace", "jolokia", "localStorage", function (workspace, jolokia, localStorage) {
        return new Wiki.GitWikiRepository(function () { return Git.createGitRepository(workspace, jolokia, localStorage); });
    }]);
    Wiki._module.factory('wikiBranchMenu', function () {
        var self = {
            items: [],
            addExtension: function (item) {
                self.items.push(item);
            },
            applyMenuExtensions: function (menu) {
                if (self.items.length === 0) {
                    return;
                }
                var extendedMenu = [{
                    heading: "Actions"
                }];
                self.items.forEach(function (item) {
                    if (item.valid()) {
                        extendedMenu.push(item);
                    }
                });
                if (extendedMenu.length > 1) {
                    menu.add(extendedMenu);
                }
            }
        };
        return self;
    });
    Wiki._module.factory('fileExtensionTypeRegistry', function () {
        return {
            "image": ["svg", "png", "ico", "bmp", "jpg", "gif"],
            "markdown": ["md", "markdown", "mdown", "mkdn", "mkd"],
            "htmlmixed": ["html", "xhtml", "htm"],
            "text/x-java": ["java"],
            "text/x-scala": ["scala"],
            "javascript": ["js", "json", "javascript", "jscript", "ecmascript", "form"],
            "xml": ["xml", "xsd", "wsdl", "atom"],
            "properties": ["properties"]
        };
    });
    Wiki._module.filter('fileIconClass', function () { return Wiki.iconClass; });
    Wiki._module.run(["$location", "workspace", "viewRegistry", "jolokia", "localStorage", "layoutFull", "helpRegistry", "preferencesRegistry", "wikiRepository", "postLoginTasks", "$rootScope", function ($location, workspace, viewRegistry, jolokia, localStorage, layoutFull, helpRegistry, preferencesRegistry, wikiRepository, postLoginTasks, $rootScope) {
        viewRegistry['wiki'] = Wiki.templatePath + 'layoutWiki.html';
        helpRegistry.addUserDoc('wiki', 'app/wiki/doc/help.md', function () {
            return Wiki.isWikiEnabled(workspace, jolokia, localStorage);
        });
        preferencesRegistry.addTab("Git", 'app/wiki/html/gitPreferences.html');
        Wiki.tab = {
            id: "wiki",
            content: "Wiki",
            title: "View and edit wiki pages",
            isValid: function (workspace) { return Wiki.isWikiEnabled(workspace, jolokia, localStorage); },
            href: function () { return "#/wiki/view"; },
            isActive: function (workspace) { return workspace.isLinkActive("/wiki") && !workspace.linkContains("fabric", "profiles") && !workspace.linkContains("editFeatures"); }
        };
        workspace.topLevelTabs.push(Wiki.tab);
        postLoginTasks.addTask('wikiGetRepositoryLabel', function () {
            wikiRepository.getRepositoryLabel(function (label) {
                Wiki.tab.content = label;
                Core.$apply($rootScope);
            }, function (response) {
            });
        });
        Wiki.documentTemplates.forEach(function (template) {
            if (!template['regex']) {
                template.regex = /(?:)/;
            }
        });
    }]);
    hawtioPluginLoader.addModule(Wiki.pluginName);
})(Wiki || (Wiki = {}));
var Fabric;
(function (Fabric) {
    Fabric.templatePath = 'app/fabric/html/';
    Fabric.activeMQTemplatePath = 'app/activemq/html/';
    Fabric._module = angular.module('fabric', ['bootstrap', 'ui.bootstrap', 'ui.bootstrap.dialog', 'ngResource', 'ngGrid', 'hawtio-forms', 'hawtioCore', 'wiki']);
    Fabric._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/fabric/containers/createContainer', { templateUrl: Fabric.templatePath + 'createContainer.html', reloadOnSearch: false }).when('/fabric/map', { templateUrl: Fabric.templatePath + 'map.html' }).when('/fabric/clusters/*page', { templateUrl: Fabric.templatePath + 'clusters.html' }).when('/fabric/containers', { templateUrl: Fabric.templatePath + 'containers.html', reloadOnSearch: false }).when('/fabric/container/:containerId', { templateUrl: Fabric.templatePath + 'container.html', reloadOnSearch: false }).when('/fabric/assignProfile', { templateUrl: Fabric.templatePath + 'assignProfile.html' }).when('/fabric/activeProfiles', { templateUrl: Fabric.templatePath + 'activeProfiles.html' }).when('/wiki/profile/:versionId/:profileId/editFeatures', { templateUrl: Fabric.templatePath + 'editFeatures.html' }).when('/fabric/profile/:versionId/:profileId/:fname', { templateUrl: Fabric.templatePath + 'pid.html' }).when('/fabric/migrate', { templateUrl: Fabric.templatePath + 'migrateVersions.html' }).when('/fabric/patching', { templateUrl: Fabric.templatePath + 'patching.html' }).when('/fabric/configurations/:versionId/:profileId', { templateUrl: 'app/osgi/html/configurations.html' }).when('/fabric/configuration/:versionId/:profileId/:pid', { templateUrl: 'app/osgi/html/pid.html' }).when('/fabric/configuration/:versionId/:profileId/:pid/:factoryPid', { templateUrl: 'app/osgi/html/pid.html' }).when('/fabric/mq/:versionId/brokers', { templateUrl: Fabric.templatePath + 'brokers.html' }).when('/fabric/mq/:versionId/brokerDiagram', { templateUrl: Fabric.activeMQTemplatePath + 'brokerDiagram.html', reloadOnSearch: false }).when('/fabric/mq/:versionId/brokerNetwork', { templateUrl: Fabric.templatePath + 'brokerNetwork.html' }).when('/fabric/mq/:versionId/createBroker', { templateUrl: Fabric.templatePath + 'createBroker.html' }).when('/fabric/camel/diagram', { templateUrl: 'app/camel/html/fabricDiagram.html', reloadOnSearch: false }).when('/fabric/api', { templateUrl: Fabric.templatePath + 'apis.html' }).when('/fabric/api/wsdl', { templateUrl: 'app/api/html/wsdl.html' }).when('/fabric/api/wadl', { templateUrl: 'app/api/html/wadl.html' }).when('/fabric/test', { templateUrl: Fabric.templatePath + 'test.html' }).when('/fabric/profileView', { templateUrl: Fabric.templatePath + 'profileView.html', reloadOnSearch: false }).when('/fabric/containerView', { templateUrl: Fabric.templatePath + 'containerView.html', reloadOnSearch: false });
    }]);
    Fabric._module.factory('serviceIconRegistry', function () {
        return Fabric.serviceIconRegistry;
    });
    Fabric._module.factory('containerIconRegistry', function () {
        return Fabric.containerIconRegistry;
    });
    Fabric._module.run(["$location", "workspace", "jolokia", "viewRegistry", "pageTitle", "helpRegistry", "$rootScope", "postLoginTasks", "preferencesRegistry", "wikiBranchMenu", "$dialog", "layoutFull", function ($location, workspace, jolokia, viewRegistry, pageTitle, helpRegistry, $rootScope, postLoginTasks, preferencesRegistry, wikiBranchMenu, $dialog, layoutFull) {
        var layoutFabric = Fabric.templatePath + 'layoutFabric.html';
        var layoutNoTabs = Fabric.templatePath + 'layoutNoTabs.html';
        viewRegistry['fabric/assignProfile'] = layoutFabric;
        viewRegistry['fabric/profileView'] = layoutNoTabs;
        viewRegistry['fabric/containerView'] = layoutNoTabs;
        viewRegistry['fabric/migrate'] = layoutNoTabs;
        viewRegistry['fabric/patching'] = layoutNoTabs;
        viewRegistry['fabric/map'] = layoutFabric;
        viewRegistry['fabric/clusters'] = layoutFabric;
        viewRegistry['fabric/container'] = layoutFabric;
        viewRegistry['fabric/activeProfiles'] = layoutFabric;
        viewRegistry['fabric/containers'] = layoutFabric;
        viewRegistry['fabric/configurations'] = layoutFabric;
        viewRegistry['fabric/configuration'] = layoutFabric;
        viewRegistry['fabric/mq'] = layoutFabric;
        viewRegistry['fabric/camel'] = layoutFabric;
        viewRegistry['fabric/api'] = layoutFabric;
        pageTitle.addTitleElement(function () {
            return Fabric.currentContainerId;
        });
        Fabric.addWikiBranchMenuExtensions(wikiBranchMenu, $dialog, workspace);
        postLoginTasks.addTask('fabricFetchContainerName', function () {
            if (Fabric.currentContainerId === '' && Fabric.fabricCreated(workspace)) {
                jolokia.request({
                    type: 'exec',
                    mbean: Fabric.managerMBean,
                    operation: 'currentContainer()',
                    arguments: []
                }, onSuccess(function (response) {
                    if (!response.value) {
                        return;
                    }
                    Fabric.currentContainer = response.value;
                    Fabric.currentContainerId = Fabric.currentContainer['id'];
                    if ('container' in Perspective.metadata) {
                        Core.pathSet(Perspective.metadata, ['container', 'label'], Fabric.currentContainerId);
                        Core.pathSet(Perspective.metadata, ['container', 'icon'], Fabric.getTypeIcon(Fabric.currentContainer));
                    }
                    Core.$apply($rootScope);
                }));
            }
        });
        preferencesRegistry.addTab("Fabric", "app/fabric/html/preferences.html", function () {
            return Fabric.isFMCContainer(workspace);
        });
        workspace.topLevelTabs.push({
            id: "fabric.runtime",
            content: "Services",
            title: "Manage your containers in this fabric",
            isValid: function (workspace) { return Fabric.isFMCContainer(workspace); },
            href: function () { return "#/fabric/containers"; },
            isActive: function (workspace) { return workspace.isLinkActive("fabric") && !workspace.isLinkActive("fabric/profileView") && !workspace.isLinkActive("fabric/containerView") && !workspace.isLinkActive("fabric/deploy") && !workspace.isLinkActive("fabric/requirements"); }
        });
        workspace.topLevelTabs.push({
            id: "fabric.profiles",
            content: "Profiles",
            title: "Select and deploy profiles into this fabric",
            isValid: function (workspace) { return Fabric.isFMCContainer(workspace); },
            href: function () { return "#/fabric/profileView"; },
            isActive: function (workspace) { return workspace.isLinkActive("fabric/profileView"); }
        });
        workspace.topLevelTabs.push({
            id: 'fabric.containers',
            content: 'Containers',
            title: 'View and manage containers in this fabric',
            isValid: function (workspace) { return Fabric.isFMCContainer(workspace); },
            href: function () { return '#/fabric/containerView'; },
            isActive: function (workspace) { return workspace.isLinkActive('fabric/containerView'); }
        });
        workspace.topLevelTabs.push({
            id: "fabric.configuration",
            content: "Wiki",
            title: "View the documentation and configuration of your profiles in Fabric",
            isValid: function (workspace, perspectiveId) {
                var answer = Fabric.isFMCContainer(workspace);
                if (answer) {
                    var currentId = Perspective.currentPerspectiveId($location, workspace, jolokia, localStorage);
                    answer = "fabric" === (perspectiveId === undefined ? currentId : perspectiveId);
                }
                return answer;
            },
            href: function () {
                return "#/wiki/branch/default-version/view/fabric/profiles";
            },
            isActive: function (workspace) { return workspace.isLinkActive("/wiki") && (workspace.linkContains("fabric", "profiles") || workspace.linkContains("editFeatures")); }
        });
        helpRegistry.addUserDoc('fabric', 'app/fabric/doc/help.md', function () {
            return Fabric.isFMCContainer(workspace);
        });
        helpRegistry.addDevDoc("fabric", 'app/fabric/doc/developer.md');
    }]);
    hawtioPluginLoader.addModule('fabric');
})(Fabric || (Fabric = {}));
var FabricDeploy;
(function (FabricDeploy) {
    FabricDeploy.log = Logger.get('FabricDeploy');
    FabricDeploy.pluginName = 'fabric-deploy';
    FabricDeploy.templatePath = 'app/fabric-deploy/html/';
    FabricDeploy._module = angular.module(FabricDeploy.pluginName, ['bootstrap', 'fabric']);
    FabricDeploy._module.config(['$routeProvider', function ($routeProvider) {
        $routeProvider.when('/fabric/deploy', { templateUrl: FabricDeploy.templatePath + 'deploy.html' });
    }]);
    FabricDeploy._module.run(['viewRegistry', 'layoutFull', 'workspace', function (viewRegistry, layoutFull, workspace) {
        FabricDeploy.log.debug("started");
    }]);
    hawtioPluginLoader.addModule(FabricDeploy.pluginName);
})(FabricDeploy || (FabricDeploy = {}));
var FabricDeploy;
(function (FabricDeploy) {
    FabricDeploy.DeployArtifact = FabricDeploy._module.directive("fabricDeployArtifact", [function () {
        FabricDeploy.log.debug("Creating deploy artifact directive...");
        return {
            restrict: 'A',
            replace: true,
            scope: {
                versionId: '@',
                profileId: '@'
            },
            templateUrl: FabricDeploy.templatePath + "deploy.html",
            controller: ["$scope", "$element", "FileUploader", "jolokiaUrl", "$templateCache", "jolokia", "userDetails", function ($scope, $element, FileUploader, jolokiaUrl, $templateCache, jolokia, userDetails) {
                $scope.artifactTemplate = '';
                jolokia.request({
                    type: 'read',
                    mbean: Fabric.managerMBean,
                    attribute: 'MavenRepoUploadURI'
                }, onSuccess(function (response) {
                    var uploadURI = response.value;
                    if (jolokiaUrl.has('/proxy')) {
                        uploadURI = 'proxy/' + uploadURI;
                    }
                    FabricDeploy.log.debug("Maven upload URI: ", uploadURI);
                    var uploader = $scope.artifactUploader = new FileUploader({
                        headers: {
                            'Authorization': Core.authHeaderValue(userDetails)
                        },
                        autoUpload: true,
                        withCredentials: true,
                        method: 'PUT',
                        url: uploadURI
                    });
                    $scope.doUpload = function () {
                        uploader.uploadAll();
                    };
                    uploader.onWhenAddingFileFailed = function (item, filter, options) {
                        FabricDeploy.log.debug('onWhenAddingFileFailed', item, filter, options);
                    };
                    uploader.onAfterAddingFile = function (fileItem) {
                        FabricDeploy.log.debug('onAfterAddingFile', fileItem);
                    };
                    uploader.onAfterAddingAll = function (addedFileItems) {
                        FabricDeploy.log.debug('onAfterAddingAll', addedFileItems);
                    };
                    uploader.onBeforeUploadItem = function (item) {
                        if ('file' in item) {
                            item.fileSizeMB = (item.file.size / 1024 / 1024).toFixed(2);
                        }
                        else {
                            item.fileSizeMB = 0;
                        }
                        item.url = UrlHelpers.join(uploadURI, item.file.name) + '?profile=' + $scope.profileId + '&version=' + $scope.versionId;
                        FabricDeploy.log.debug('onBeforeUploadItem', item);
                    };
                    uploader.onProgressItem = function (fileItem, progress) {
                        FabricDeploy.log.debug('onProgressItem', fileItem, progress);
                    };
                    uploader.onProgressAll = function (progress) {
                        FabricDeploy.log.debug('onProgressAll', progress);
                    };
                    uploader.onSuccessItem = function (fileItem, response, status, headers) {
                        FabricDeploy.log.debug('onSuccessItem', fileItem, response, status, headers);
                        Core.notification('success', 'Added ' + fileItem.file.name);
                    };
                    uploader.onErrorItem = function (fileItem, response, status, headers) {
                        FabricDeploy.log.debug('onErrorItem', fileItem, response, status, headers);
                        Core.notification('error', 'Failed to add ' + fileItem.file.name);
                    };
                    uploader.onCancelItem = function (fileItem, response, status, headers) {
                        FabricDeploy.log.debug('onCancelItem', fileItem, response, status, headers);
                    };
                    uploader.onCompleteItem = function (fileItem, response, status, headers) {
                        FabricDeploy.log.debug('onCompleteItem', fileItem, response, status, headers);
                    };
                    uploader.onCompleteAll = function () {
                        FabricDeploy.log.debug('onCompleteAll');
                        uploader.clearQueue();
                    };
                    FabricDeploy.log.debug('uploader', uploader);
                    $scope.artifactTemplate = $templateCache.get('fileUpload.html');
                    Core.$apply($scope);
                }));
            }]
        };
    }]);
})(FabricDeploy || (FabricDeploy = {}));
var ObjectHelpers;
(function (ObjectHelpers) {
    function toMap(arr, index, decorator) {
        if (!arr || arr.length === 0) {
            return {};
        }
        var answer = {};
        arr.forEach(function (item) {
            if (angular.isObject(item)) {
                answer[item[index]] = item;
                if (angular.isFunction(decorator)) {
                    decorator(item);
                }
            }
        });
        return answer;
    }
    ObjectHelpers.toMap = toMap;
})(ObjectHelpers || (ObjectHelpers = {}));
var SelectionHelpers;
(function (SelectionHelpers) {
    var log = Logger.get("SelectionHelpers");
    function selectNone(group) {
        group.forEach(function (item) {
            item['selected'] = false;
        });
    }
    SelectionHelpers.selectNone = selectNone;
    function selectAll(group, filter) {
        group.forEach(function (item) {
            if (!filter) {
                item['selected'] = true;
            }
            else {
                if (filter(item)) {
                    item['selected'] = true;
                }
            }
        });
    }
    SelectionHelpers.selectAll = selectAll;
    function toggleSelection(item) {
        item['selected'] = !item['selected'];
    }
    SelectionHelpers.toggleSelection = toggleSelection;
    function selectOne(group, item) {
        selectNone(group);
        toggleSelection(item);
    }
    SelectionHelpers.selectOne = selectOne;
    function sync(selections, group, index) {
        group.forEach(function (item) {
            item['selected'] = selections.any(function (selection) {
                return selection[index] === item[index];
            });
        });
        return group.filter(function (item) {
            return item['selected'];
        });
    }
    SelectionHelpers.sync = sync;
    function select(group, item, $event) {
        var ctrlKey = $event.ctrlKey;
        if (!ctrlKey) {
            if (item['selected']) {
                toggleSelection(item);
            }
            else {
                selectOne(group, item);
            }
        }
        else {
            toggleSelection(item);
        }
    }
    SelectionHelpers.select = select;
    function isSelected(item, yes, no) {
        return maybe(item['selected'], yes, no);
    }
    SelectionHelpers.isSelected = isSelected;
    function clearGroup(group) {
        group.length = 0;
    }
    SelectionHelpers.clearGroup = clearGroup;
    function toggleSelectionFromGroup(group, item, search) {
        var searchMethod = search || item;
        if (group.any(searchMethod)) {
            group.remove(searchMethod);
        }
        else {
            group.add(item);
        }
    }
    SelectionHelpers.toggleSelectionFromGroup = toggleSelectionFromGroup;
    function stringOrBoolean(str, answer) {
        if (angular.isDefined(str)) {
            return str;
        }
        else {
            return answer;
        }
    }
    function nope(str) {
        return stringOrBoolean(str, false);
    }
    function yup(str) {
        return stringOrBoolean(str, true);
    }
    function maybe(answer, yes, no) {
        if (answer) {
            return yup(yes);
        }
        else {
            return nope(no);
        }
    }
    function isInGroup(group, item, yes, no, search) {
        if (!group) {
            return nope(no);
        }
        var searchMethod = search || item;
        return maybe(group.any(searchMethod), yes, no);
    }
    SelectionHelpers.isInGroup = isInGroup;
    function filterByGroup(group, item, yes, no, search) {
        if (group.length === 0) {
            return yup(yes);
        }
        var searchMethod = search || item;
        if (angular.isArray(item)) {
            return maybe(group.intersect(item).length === group.length, yes, no);
        }
        else {
            return maybe(group.any(searchMethod), yes, no);
        }
    }
    SelectionHelpers.filterByGroup = filterByGroup;
    function syncGroupSelection(group, collection, attribute) {
        var newGroup = [];
        if (attribute) {
            group.forEach(function (groupItem) {
                var first = collection.find(function (collectionItem) {
                    return groupItem[attribute] === collectionItem[attribute];
                });
                if (first) {
                    newGroup.push(first);
                }
            });
        }
        else {
            group.forEach(function (groupItem) {
                var first = collection.find(function (collectionItem) {
                    return Object.equal(groupItem, collectionItem);
                });
                if (first) {
                    newGroup.push(first);
                }
            });
        }
        clearGroup(group);
        group.add(newGroup);
    }
    SelectionHelpers.syncGroupSelection = syncGroupSelection;
    function decorate($scope) {
        $scope.selectNone = selectNone;
        $scope.selectAll = selectAll;
        $scope.toggleSelection = toggleSelection;
        $scope.selectOne = selectOne;
        $scope.select = select;
        $scope.clearGroup = clearGroup;
        $scope.toggleSelectionFromGroup = toggleSelectionFromGroup;
        $scope.isInGroup = isInGroup;
        $scope.viewOnly = false;
        $scope.filterByGroup = filterByGroup;
    }
    SelectionHelpers.decorate = decorate;
})(SelectionHelpers || (SelectionHelpers = {}));
var ProfileHelpers;
(function (ProfileHelpers) {
    function getTags(profile) {
        var answer = profile.tags;
        if (!answer || !answer.length) {
            answer = profile.id.split('-');
            answer = answer.first(answer.length - 1);
        }
        return answer;
    }
    ProfileHelpers.getTags = getTags;
})(ProfileHelpers || (ProfileHelpers = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.service("ProfileCart", function () {
        return [];
    });
    Fabric._module.service("ProfileViewActions", ['$location', '$rootScope', function ($location, $rootScope) {
        return {
            'Deploy': {
                index: 0,
                icon: 'icon-ok',
                buttonClass: 'btn-success',
                objectName: Fabric.managerMBean,
                methodName: 'createContainers',
                title: 'Deploy the selected profiles to new containers',
                action: function () {
                    var me = $location.path();
                    $location.path('/fabric/containers/createContainer').search({
                        p: 'fabric',
                        vid: '',
                        pid: '',
                        hideProfileSelector: true,
                        returnTo: me,
                        nextPage: '/fabric/containerView?groupBy=profileIds'
                    });
                    Core.$apply($rootScope);
                }
            },
            'Assign': {
                index: 2,
                icon: 'icon-truck',
                buttonClass: 'btn-primary',
                objectName: Fabric.managerMBean,
                methodName: 'addProfilesToContainer',
                title: 'Deploy the selected profiles to existing containers',
                action: function () {
                    $location.path('/fabric/assignProfile');
                    Core.$apply($rootScope);
                }
            }
        };
    }]);
    Fabric.AppViewPaneHeaderController = Fabric._module.controller("Fabric.AppViewPaneHeaderController", ["$scope", "ProfileCart", "ProfileViewActions", function ($scope, ProfileCart, ProfileViewActions) {
        SelectionHelpers.decorate($scope);
        var lastIndex = null;
        var buttons = [];
        angular.forEach(ProfileViewActions, function (value, key) {
            value['name'] = key;
            buttons.add(value);
        });
        $scope.actionButtons = buttons;
        $scope.cartItems = ProfileCart;
        $scope.getName = function () {
            return $scope.cartItems.map(function (p) {
                return p.id;
            }).join(", ");
        };
        $scope.$watch('filter', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.$emit("Fabric.AppViewPaneController.filter", newValue);
            }
        });
    }]);
    Fabric.AppViewController = Fabric._module.controller("Fabric.AppViewController", ["$scope", 'jolokia', "$templateCache", "ProfileCart", "$location", "workspace", "marked", function ($scope, jolokia, $templateCache, ProfileCart, $location, workspace, marked) {
        $scope.selectedVersion = {};
        $scope.profiles = [];
        $scope.cartItems = ProfileCart;
        $scope.tags = [];
        $scope.selectedTags = [];
        $scope.textFilter = '';
        $scope.lowercaseTextFilter = '';
        SelectionHelpers.decorate($scope);
        $scope.$on('Fabric.AppViewPaneController.filter', function ($event, newValue) {
            $scope.textFilter = newValue;
        });
        $scope.filterProfiles = function (profile) {
            var answer = $scope.filterByGroup($scope.selectedTags, profile.tags);
            if (answer && !Core.isBlank($scope.textFilter)) {
                var filter = $scope.textFilter.toLowerCase();
                return FilterHelpers.searchObject(profile, filter);
            }
            return answer;
        };
        var profileFields = ['id', 'abstract', 'hidden', 'attributes', 'overlay', 'containerCount', 'associatedContainers', 'fileConfigurations', 'iconURL', 'summaryMarkdown', 'tags'];
        var unreg = null;
        Fabric.loadRestApi(jolokia, workspace, undefined, function (response) {
            $scope.restApiUrl = UrlHelpers.maybeProxy(Core.injector.get('jolokiaUrl'), response.value);
            Fabric.log.debug("Scope rest API: ", $scope.restApiUrl);
            $scope.$watch('selectedVersion.id', function (newValue, oldValue) {
                if (!Core.isBlank(newValue)) {
                    if (unreg) {
                        unreg();
                    }
                    unreg = Core.registerForChanges(jolokia, $scope, {
                        type: 'exec',
                        mbean: Fabric.managerMBean,
                        operation: 'getProfiles(java.lang.String,java.util.List)',
                        arguments: [newValue, profileFields]
                    }, render);
                }
            });
        });
        $scope.viewProfile = function (profile) {
            Fabric.gotoProfile(workspace, jolokia, workspace.localStorage, $location, profile.versionId, profile.id);
        };
        function render(response) {
            var value = response.value;
            $scope.profiles = [];
            $scope.tags = [];
            value.forEach(function (profile) {
                if (profile.abstract || profile.hidden || profile.overlay) {
                    return;
                }
                var summaryMarkdown = profile["summaryMarkdown"];
                var tags = ProfileHelpers.getTags(profile);
                $scope.tags.add(tags);
                $scope.profiles.push({
                    id: profile.id,
                    versionId: $scope.selectedVersion.id,
                    name: profile.id,
                    tags: tags,
                    iconURL: Fabric.toIconURL($scope, profile.iconURL),
                    summary: summaryMarkdown ? marked(summaryMarkdown) : "",
                    containerCount: profile.containerCount,
                    associatedContainers: profile.associatedContainers
                });
            });
            $scope.profiles = $scope.profiles.sortBy('name');
            SelectionHelpers.syncGroupSelection($scope.cartItems, $scope.profiles, 'id');
            $scope.tags = $scope.tags.unique().sort();
            Core.$apply($scope);
        }
    }]);
})(Fabric || (Fabric = {}));
var FabricRequirements;
(function (FabricRequirements) {
    FabricRequirements.requirementsContext = '/fabric/requirements';
    FabricRequirements.requirementsHash = '#' + FabricRequirements.requirementsContext;
    FabricRequirements.pluginName = "FabricRequirements";
    FabricRequirements.templatePath = 'app/fabric-requirements/html/';
    FabricRequirements.log = Logger.get(FabricRequirements.pluginName);
    FabricRequirements._module = angular.module(FabricRequirements.pluginName, ['hawtioCore', 'fabric']);
    FabricRequirements.controller = PluginHelpers.createControllerFunction(FabricRequirements._module, FabricRequirements.pluginName);
    FabricRequirements.route = PluginHelpers.createRoutingFunction(FabricRequirements.templatePath);
    var fabricRoute = PluginHelpers.createRoutingFunction('app/fabric/html/');
    FabricRequirements._module.config(['$routeProvider', function ($routeProvider) {
        $routeProvider.when(UrlHelpers.join(FabricRequirements.requirementsContext, 'profile'), FabricRequirements.route('profileRequirements.html')).when(UrlHelpers.join(FabricRequirements.requirementsContext, 'sshConfig'), FabricRequirements.route('sshConfig.html')).when(UrlHelpers.join(FabricRequirements.requirementsContext, 'dockerConfig'), FabricRequirements.route('dockerConfig.html')).when(UrlHelpers.join(FabricRequirements.requirementsContext, 'status'), fabricRoute('activeProfiles.html'));
    }]);
    FabricRequirements._module.run(['viewRegistry', 'layoutFull', 'workspace', 'ProfileViewActions', '$location', '$rootScope', function (viewRegistry, layoutFull, workspace, ProfileViewActions, $location, $rootScope) {
        viewRegistry['fabric/requirements'] = FabricRequirements.templatePath + 'layout.html';
        workspace.topLevelTabs.push({
            id: 'fabric.requirements',
            content: 'Scaling',
            isValid: function (workspace) { return Fabric.isFMCContainer(workspace); },
            isActive: function (workspace) { return workspace.isLinkActive('fabric/requirements'); },
            href: function () { return '#/fabric/requirements/profile'; }
        });
        ProfileViewActions['Add Requirements'] = {
            index: 3,
            icon: 'icon-cog',
            buttonClass: 'btn-primary',
            objectName: Fabric.managerMBean,
            methodName: 'requirementsJson',
            title: 'Create requirements for the selected profiles',
            action: function () {
                $location.path('/fabric/requirements/profile');
                Core.$apply($rootScope);
            }
        };
    }]);
    hawtioPluginLoader.addModule(FabricRequirements.pluginName);
})(FabricRequirements || (FabricRequirements = {}));
var FileUpload;
(function (FileUpload) {
    function useJolokiaTransport(uploader, jolokia, onLoad) {
        var uploaderInternal = uploader;
        var $rootScope = Core.injector.get("$rootScope");
        uploaderInternal._xhrTransport = function (item) {
            var reader = new FileReader();
            reader.onload = function () {
                if (reader.readyState === 2) {
                    var parameters = onLoad(reader.result);
                    jolokia.request(parameters, onSuccess(function (response) {
                        item.json = reader.result;
                        uploaderInternal._onSuccessItem(item, response, response.status, {});
                        uploaderInternal._onCompleteItem(item, response, response.status, {});
                        Core.$apply($rootScope);
                    }, {
                        error: function (response) {
                            uploaderInternal._onErrorItem(item, response, response.status, {});
                            uploaderInternal._onCompleteItem(item, response, response.status, {});
                            Core.$apply($rootScope);
                        }
                    }));
                }
            };
            reader.readAsText(item._file);
        };
    }
    FileUpload.useJolokiaTransport = useJolokiaTransport;
})(FileUpload || (FileUpload = {}));
var FabricRequirements;
(function (FabricRequirements) {
    FabricRequirements._module.service("CurrentRequirements", function () {
        return {
            $dirty: false
        };
    });
    FabricRequirements.RequirementsController = FabricRequirements.controller("RequirementsController", ["$scope", "jolokia", "workspace", "ProfileCart", "$templateCache", "FileUploader", "userDetails", "jolokiaUrl", "$location", "$timeout", "CurrentRequirements", "$element", function ($scope, jolokia, workspace, ProfileCart, $templateCache, FileUploader, userDetails, jolokiaUrl, $location, $timeout, CurrentRequirements, $element) {
        $scope.tabs = {
            '0': {
                name: 'Profile Requirements',
                href: function () { return FabricRequirements.requirementsHash + '/profile'; },
                isActive: function () { return UrlHelpers.contextActive($location.path(), 'profile'); }
            },
            '1': {
                name: 'SSH Configuration',
                href: function () { return FabricRequirements.requirementsHash + '/sshConfig'; },
                isActive: function () { return UrlHelpers.contextActive($location.path(), 'sshConfig'); }
            },
            '2': {
                name: 'Docker Configuration',
                href: function () { return FabricRequirements.requirementsHash + '/dockerConfig'; },
                isActive: function () { return UrlHelpers.contextActive($location.path(), 'dockerConfig'); }
            },
            '3': {
                name: 'Status',
                href: function () { return FabricRequirements.requirementsHash + '/status'; },
                isActive: function () { return UrlHelpers.contextActive($location.path(), 'status'); }
            }
        };
        $scope.requirements = CurrentRequirements;
        $scope.template = '';
        $scope.newTag = '';
        $scope.addTag = function (tag) {
            if (tag && !$scope.requirements.$tags.some(function (t) {
                return t === tag;
            })) {
                $scope.requirements.$tags.push(tag);
                $scope.newTag = '';
                $element.find('#inputNewTag').val('');
            }
        };
        $scope.cancelChanges = function () {
            if ($scope.requirements.$dirty) {
                FabricRequirements.log.debug("Cancelling changes");
                $timeout(function () {
                    Object.merge($scope.requirements, $scope.requirementsFromServer, true);
                }, 20);
            }
        };
        $scope.onDrop = function (data, model, property) {
            FabricRequirements.log.debug("On drop - data: ", data, " model: ", model, " property: ", property);
            if (!model[property]) {
                model[property] = [];
            }
            if (!model[property].any(data)) {
                model[property].push(data);
                $scope.requirements.$dirty = true;
            }
        };
        $scope.$on('hawtio-drop', function ($event, data) {
            $scope.onDrop(data.data, data.model, data.property);
        });
        $scope.saveChanges = function () {
            if ($scope.requirements.$dirty) {
                function onRequirementsSaved() {
                    Core.notification("success", "Saved the requirements");
                    Core.$apply($scope);
                }
                var json = angular.toJson($scope.requirements);
                FabricRequirements.log.debug("Saving requirementS: ", json);
                $scope.requirements.$dirty = false;
                jolokia.execute(Fabric.managerMBean, "requirementsJson", json, onSuccess(onRequirementsSaved));
            }
        };
        $scope.onChange = function () {
            $scope.requirements.$dirty = true;
        };
        Fabric.loadRestApi(jolokia, workspace, undefined, function (response) {
            var uploadUrl = jolokiaUrl;
            $scope.uploader = new FileUploader({
                autoUpload: true,
                removeAfterUpload: true,
                url: uploadUrl
            });
            FileUpload.useJolokiaTransport($scope.uploader, jolokia, function (json) {
                return {
                    'type': 'exec',
                    mbean: Fabric.managerMBean,
                    operation: 'requirementsJson',
                    arguments: [json]
                };
            });
            $scope.uploader.onBeforeUploadItem = function (item) {
                Core.notification('info', 'Uploading ' + item);
            };
            $scope.uploader.onSuccessItem = function (item) {
                $scope.requirements = angular.fromJson(item.json);
            };
            $scope.uploader.onCompleteAll = function () {
                Core.notification('success', 'Imported requirements');
            };
            function createTagList(requirements) {
                var tags = [];
                ['sshConfiguration', 'dockerConfiguration'].forEach(function (config) {
                    if (requirements[config] && requirements[config].hosts) {
                        requirements.sshConfiguration.hosts.forEach(function (host) {
                            tags.add(host.tags);
                        });
                    }
                });
                requirements.profileRequirements.forEach(function (p) {
                    ['sshScalingRequirements', 'dockerScalingRequirements'].forEach(function (req) {
                        if (p[req] && p[req].hostTags) {
                            tags.add(p[req].hostTags);
                        }
                    });
                });
                requirements.$tags = tags.unique().sort();
            }
            Core.registerForChanges(jolokia, $scope, {
                type: 'exec',
                mbean: Fabric.managerMBean,
                operation: "requirements()"
            }, function (response) {
                $scope.requirementsFromServer = response.value;
                if (!$scope.requirements.$dirty) {
                    Object.merge($scope.requirements, $scope.requirementsFromServer, true);
                }
                var profileRequirements = $scope.requirements.profileRequirements;
                ProfileCart.forEach(function (profile) {
                    var id = profile.id;
                    if (!profileRequirements.some(function (r) {
                        return r.profile === id;
                    })) {
                        profileRequirements.push({
                            profile: id,
                            minimumInstances: null,
                            maximumInstances: null,
                            dependentProfiles: []
                        });
                        if (!$scope.requirements.$dirty) {
                            $scope.requirements.$dirty = true;
                        }
                    }
                });
                ProfileCart.length = 0;
                if (Core.isBlank($scope.template)) {
                    $scope.template = $templateCache.get('pageTemplate.html');
                }
                createTagList($scope.requirements);
                Core.$apply($scope);
            });
        });
    }]);
})(FabricRequirements || (FabricRequirements = {}));
var Forms;
(function (Forms) {
    Forms.log = Logger.get("Forms");
    function defaultValues(entity, schema) {
        if (entity && schema) {
            angular.forEach(schema.properties, function (property, key) {
                var defaultValue = property.default;
                if (defaultValue && !entity[key]) {
                    console.log("===== defaulting value " + defaultValue + " into entity[" + key + "]");
                    entity[key] = defaultValue;
                }
            });
        }
    }
    Forms.defaultValues = defaultValues;
    function resolveTypeNameAlias(type, schema) {
        if (type && schema) {
            var alias = lookupDefinition(type, schema);
            if (alias) {
                var realType = alias["type"];
                if (realType) {
                    type = realType;
                }
            }
        }
        return type;
    }
    Forms.resolveTypeNameAlias = resolveTypeNameAlias;
    function isJsonType(name, schema, typeName) {
        var definition = lookupDefinition(name, schema);
        while (definition) {
            var extendsTypes = Core.pathGet(definition, ["extends", "type"]);
            if (extendsTypes) {
                if (typeName === extendsTypes) {
                    return true;
                }
                else {
                    definition = lookupDefinition(extendsTypes, schema);
                }
            }
            else {
                return false;
            }
        }
        return false;
    }
    Forms.isJsonType = isJsonType;
    function safeIdentifier(id) {
        if (id) {
            return id.replace(/-/g, "_");
        }
        return id;
    }
    Forms.safeIdentifier = safeIdentifier;
    function lookupDefinition(name, schema) {
        if (schema) {
            var defs = schema.definitions;
            if (defs) {
                var answer = defs[name];
                if (answer) {
                    var fullSchema = answer["fullSchema"];
                    if (fullSchema) {
                        return fullSchema;
                    }
                    var extendsTypes = Core.pathGet(answer, ["extends", "type"]);
                    if (extendsTypes) {
                        fullSchema = angular.copy(answer);
                        fullSchema.properties = fullSchema.properties || {};
                        if (!angular.isArray(extendsTypes)) {
                            extendsTypes = [extendsTypes];
                        }
                        angular.forEach(extendsTypes, function (extendType) {
                            if (angular.isString(extendType)) {
                                var extendDef = lookupDefinition(extendType, schema);
                                var properties = Core.pathGet(extendDef, ["properties"]);
                                if (properties) {
                                    angular.forEach(properties, function (property, key) {
                                        fullSchema.properties[key] = property;
                                    });
                                }
                            }
                        });
                        answer["fullSchema"] = fullSchema;
                        return fullSchema;
                    }
                }
                return answer;
            }
        }
        return null;
    }
    Forms.lookupDefinition = lookupDefinition;
    function findArrayItemsSchema(property, schema) {
        var items = null;
        if (property && schema) {
            items = property.items;
            if (items) {
                var typeName = items["type"];
                if (typeName) {
                    var definition = lookupDefinition(typeName, schema);
                    if (definition) {
                        return definition;
                    }
                }
            }
            var additionalProperties = property.additionalProperties;
            if (additionalProperties) {
                if (additionalProperties["$ref"] === "#") {
                    return schema;
                }
            }
        }
        return items;
    }
    Forms.findArrayItemsSchema = findArrayItemsSchema;
    function isObjectType(definition) {
        var typeName = Core.pathGet(definition, "type");
        return typeName && "object" === typeName;
    }
    Forms.isObjectType = isObjectType;
    function isKind(definition, kind) {
        var kindName = Core.pathGet(definition, "kind");
        return kindName && kind === kindName;
    }
    Forms.isKind = isKind;
    function isArrayOrNestedObject(property, schema) {
        if (property) {
            var propType = resolveTypeNameAlias(property["type"], schema);
            if (propType) {
                if (propType === "object" || propType === "array") {
                    return true;
                }
            }
        }
        return false;
    }
    Forms.isArrayOrNestedObject = isArrayOrNestedObject;
    function configure(config, scopeConfig, attrs) {
        if (angular.isDefined(scopeConfig)) {
            config = angular.extend(config, scopeConfig);
        }
        return angular.extend(config, attrs);
    }
    Forms.configure = configure;
    function getControlGroup(config, arg, id) {
        var rc = angular.element('<div class="' + config.controlgroupclass + '"></div>');
        if (angular.isDefined(arg.description)) {
            rc.attr('title', arg.description);
        }
        if (config['properties'] && config['properties'][id]) {
            var elementConfig = config['properties'][id];
            if (elementConfig && 'control-attributes' in elementConfig) {
                angular.forEach(elementConfig['control-attributes'], function (value, key) {
                    rc.attr(key, value);
                });
            }
        }
        return rc;
    }
    Forms.getControlGroup = getControlGroup;
    function getLabel(config, arg, label, required) {
        if (required === void 0) { required = false; }
        if (required) {
            return angular.element('<label class="strong ' + config.labelclass + '">' + label + ': </label>');
        }
        else {
            return angular.element('<label class="' + config.labelclass + '">' + label + ': </label>');
        }
    }
    Forms.getLabel = getLabel;
    function getControlDiv(config) {
        return angular.element('<div class="' + config.controlclass + '"></div>');
    }
    Forms.getControlDiv = getControlDiv;
    function getHelpSpan(config, arg, id, property) {
        if (property === void 0) { property = null; }
        var help = Core.pathGet(config.data, ['properties', id, 'help']);
        if (Core.isBlank(help)) {
            help = Core.pathGet(config.data, ['properties', id, 'description']);
        }
        if (Core.isBlank(help) && angular.isDefined(property)) {
            help = Core.pathGet(property, ['help']);
            if (Core.isBlank(help)) {
                help = Core.pathGet(property, ['description']);
            }
        }
        var show = config.showhelp || "true";
        if (!Core.isBlank(help)) {
            return angular.element('<span class="help-block" ng-show="' + show + '">' + help + '</span>');
        }
        else {
            return angular.element('<span class="help-block"></span>');
        }
    }
    Forms.getHelpSpan = getHelpSpan;
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    function createWidget(propTypeName, property, schema, config, id, ignorePrefixInLabel, configScopeName, wrapInGroup, disableHumanizeLabel) {
        if (wrapInGroup === void 0) { wrapInGroup = true; }
        if (disableHumanizeLabel === void 0) { disableHumanizeLabel = false; }
        var input = null;
        var group = null;
        function copyElementAttributes(element, propertyName) {
            var propertyAttributes = property[propertyName];
            if (propertyAttributes) {
                angular.forEach(propertyAttributes, function (value, key) {
                    if (angular.isString(value)) {
                        element.attr(key, value);
                    }
                });
            }
        }
        function copyAttributes() {
            copyElementAttributes(input, "input-attributes");
            angular.forEach(property, function (value, key) {
                if (angular.isString(value) && key.indexOf("$") < 0 && key !== "type") {
                    var html = Core.escapeHtml(value);
                    input.attr(key, html);
                }
            });
        }
        var options = {
            valueConverter: null
        };
        var safeId = Forms.safeIdentifier(id);
        var required = property.required || false;
        var inputMarkup = createStandardWidgetMarkup(propTypeName, property, schema, config, options, safeId);
        if (inputMarkup) {
            input = angular.element(inputMarkup);
            copyAttributes();
            id = safeId;
            var modelName = config.model || Core.pathGet(property, ["input-attributes", "ng-model"]);
            if (!modelName) {
                modelName = config.getEntity() + "." + id;
            }
            input.attr("ng-model", modelName);
            input.attr('name', id);
            var title = property.title || property.tooltip || property.label;
            if (title) {
                input.attr('title', title);
            }
            var tooltip = property.tooltip || property.description;
            if (tooltip) {
                input.attr('tooltip', tooltip);
            }
            var disableHumanizeLabelValue = disableHumanizeLabel || property.disableHumanizeLabel;
            var defaultLabel = id;
            if (ignorePrefixInLabel || property.ignorePrefixInLabel) {
                var idx = id.lastIndexOf('.');
                if (idx > 0) {
                    defaultLabel = id.substring(idx + 1);
                }
            }
            if (input.attr("type") !== "hidden" && wrapInGroup) {
                group = this.getControlGroup(config, config, id);
                var labelText = property.title || property.label || (disableHumanizeLabelValue ? defaultLabel : Core.humanizeValue(defaultLabel));
                var labelElement = Forms.getLabel(config, config, labelText, required);
                if (tooltip) {
                    labelElement.attr('title', tooltip);
                }
                else if (title) {
                    labelElement.attr('title', title);
                }
                group.append(labelElement);
                copyElementAttributes(labelElement, "label-attributes");
                var controlDiv = Forms.getControlDiv(config);
                controlDiv.append(input);
                controlDiv.append(Forms.getHelpSpan(config, config, id, property));
                group.append(controlDiv);
                var showEmpty = config.showempty;
                if (angular.isDefined(showEmpty)) {
                    var attValue = "true";
                    if (showEmpty === "true" || showEmpty === "false") {
                        attValue = showEmpty;
                    }
                    else if (angular.isString(id)) {
                        attValue = showEmpty + '(\'' + id + '\')';
                    }
                    group.attr("ng-show", attValue);
                }
                copyElementAttributes(controlDiv, "control-attributes");
                copyElementAttributes(group, "control-group-attributes");
                var scope = config.scope;
                if (scope && modelName) {
                    var onModelChange = function (newValue) {
                        scope.$emit("hawtio.form.modelChange", modelName, newValue);
                    };
                    var fn = onModelChange;
                    var converterFn = options.valueConverter;
                    if (converterFn) {
                        fn = function () {
                            converterFn(scope, modelName);
                            var newValue = Core.pathGet(scope, modelName);
                            onModelChange(newValue);
                        };
                    }
                    scope.$watch(modelName, fn);
                }
            }
        }
        else {
            input = angular.element('<div></div>');
            input.attr(Forms.normalize(propTypeName, property, schema), '');
            copyAttributes();
            input.attr('entity', config.getEntity());
            input.attr('mode', config.getMode());
            var fullSchemaName = config.schemaName;
            if (fullSchemaName) {
                input.attr('schema', fullSchemaName);
            }
            if (configScopeName) {
                input.attr('data', configScopeName);
            }
            if (ignorePrefixInLabel || property.ignorePrefixInLabel) {
                input.attr('ignore-prefix-in-label', true);
            }
            if (disableHumanizeLabel || property.disableHumanizeLabel) {
                input.attr('disable-humanize-label', true);
            }
            input.attr('name', id);
        }
        var label = property.label;
        if (label) {
            input.attr('title', label);
        }
        try {
            if (config.isReadOnly()) {
                input.attr('readonly', 'true');
                if (input[0].localName === "select" || (input[0].localName === "input" && input.attr("type") === "checkbox")) {
                    input.attr('disabled', 'true');
                }
            }
        }
        catch (e) {
        }
        if (required) {
            if (input[0].localName === "select" || (input[0].localName === "input" && input.attr("type") === "checkbox")) {
                input.removeAttr('required');
            }
            else {
                input.attr('required', 'true');
            }
        }
        return group ? group : input;
    }
    Forms.createWidget = createWidget;
    function createStandardWidgetMarkup(propTypeName, property, schema, config, options, id) {
        var type = Forms.resolveTypeNameAlias(propTypeName, schema);
        if (!type) {
            return '<input type="text"/>';
        }
        var custom = Core.pathGet(property, ["formTemplate"]);
        if (custom) {
            return null;
        }
        var inputElement = Core.pathGet(property, ["input-element"]);
        if (inputElement) {
            return "<" + inputElement + "></" + inputElement + ">";
        }
        var enumValues = Core.pathGet(property, ["enum"]);
        if (enumValues) {
            var required = true;
            var valuesScopeName = null;
            var attributes = "";
            if (enumValues) {
                var scope = config.scope;
                var data = config.data;
                if (data && scope) {
                    var fullSchema = scope[config.schemaName];
                    var model = angular.isString(data) ? scope[data] : data;
                    var paths = id.split(".");
                    var property = null;
                    angular.forEach(paths, function (path) {
                        property = Core.pathGet(model, ["properties", path]);
                        var typeName = Core.pathGet(property, ["type"]);
                        var alias = Forms.lookupDefinition(typeName, fullSchema);
                        if (alias) {
                            model = alias;
                        }
                    });
                    var values = Core.pathGet(property, ["enum"]);
                    if (angular.isUndefined(values)) {
                        values = enumValues;
                    }
                    valuesScopeName = "$values_" + id.replace(/\./g, "_");
                    scope[valuesScopeName] = values;
                }
            }
            if (valuesScopeName) {
                attributes += ' ng-options="value for value in ' + valuesScopeName + '"';
            }
            var defaultOption = required ? "" : '<option value=""></option>';
            return '<select' + attributes + '>' + defaultOption + '</select>';
        }
        if (angular.isArray(type)) {
            return null;
        }
        if (!angular.isString(type)) {
            return null;
        }
        var defaultValueConverter = null;
        var defaultValue = property.default || property.defaultValue;
        if (defaultValue) {
            defaultValueConverter = function (scope, modelName) {
                var value = Core.pathGet(scope, modelName);
                if (!value) {
                    Core.pathSet(scope, modelName, defaultValue);
                }
            };
            options.valueConverter = defaultValueConverter;
        }
        function getModelValueOrDefault(scope, modelName) {
            var value = Core.pathGet(scope, modelName);
            if (!value) {
                var defaultValue = property.default || property.defaultValue;
                if (defaultValue) {
                    value = defaultValue;
                    Core.pathSet(scope, modelName, value);
                }
            }
            return value;
        }
        switch (type.toLowerCase()) {
            case "int":
            case "integer":
            case "long":
            case "short":
            case "java.lang.integer":
            case "java.lang.long":
            case "float":
            case "double":
            case "java.lang.float":
            case "java.lang.double":
                options.valueConverter = function (scope, modelName) {
                    var value = getModelValueOrDefault(scope, modelName);
                    if (value && angular.isString(value)) {
                        var numberValue = Number(value);
                        Core.pathSet(scope, modelName, numberValue);
                    }
                };
                return '<input type="number"/>';
            case "array":
            case "java.lang.array":
            case "java.lang.iterable":
            case "java.util.list":
            case "java.util.collection":
            case "java.util.iterator":
            case "java.util.set":
            case "object[]":
                return null;
            case "boolean":
            case "bool":
            case "java.lang.boolean":
                options.valueConverter = function (scope, modelName) {
                    var value = getModelValueOrDefault(scope, modelName);
                    if (value && "true" === value) {
                        Core.pathSet(scope, modelName, true);
                    }
                };
                return '<input type="checkbox"/>';
            case "password":
                return '<input type="password"/>';
            case "hidden":
                return '<input type="hidden"/>';
            case "map":
                return null;
            default:
                return '<input type="text"/>';
        }
    }
    Forms.createStandardWidgetMarkup = createStandardWidgetMarkup;
    function mapType(type) {
        switch (type.toLowerCase()) {
            case "int":
            case "integer":
            case "long":
            case "short":
            case "java.lang.integer":
            case "java.lang.long":
            case "float":
            case "double":
            case "java.lang.float":
            case "java.lang.double":
                return "number";
            case "array":
            case "java.lang.array":
            case "java.lang.iterable":
            case "java.util.list":
            case "java.util.collection":
            case "java.util.iterator":
            case "java.util.set":
            case "object[]":
                return "text";
            case "boolean":
            case "bool":
            case "java.lang.boolean":
                return "checkbox";
            case "password":
                return "password";
            case "hidden":
                return "hidden";
            default:
                return "text";
        }
    }
    Forms.mapType = mapType;
    function normalize(type, property, schema) {
        type = Forms.resolveTypeNameAlias(type, schema);
        if (!type) {
            return "hawtio-form-text";
        }
        var custom = Core.pathGet(property, ["formTemplate"]);
        if (custom) {
            return "hawtio-form-custom";
        }
        var enumValues = Core.pathGet(property, ["enum"]);
        if (enumValues) {
            return "hawtio-form-select";
        }
        if (angular.isArray(type)) {
            return null;
        }
        if (!angular.isString(type)) {
            try {
                console.log("Unsupported JSON schema type value " + JSON.stringify(type));
            }
            catch (e) {
                console.log("Unsupported JSON schema type value " + type);
            }
            return null;
        }
        switch (type.toLowerCase()) {
            case "int":
            case "integer":
            case "long":
            case "short":
            case "java.lang.integer":
            case "java.lang.long":
            case "float":
            case "double":
            case "java.lang.float":
            case "java.lang.double":
                return "hawtio-form-number";
            case "array":
            case "java.lang.array":
            case "java.lang.iterable":
            case "java.util.list":
            case "java.util.collection":
            case "java.util.iterator":
            case "java.util.set":
            case "object[]":
                var items = property.items;
                if (items) {
                    var typeName = items.type;
                    if (typeName && typeName === "string") {
                        return "hawtio-form-string-array";
                    }
                }
                else {
                    return "hawtio-form-string-array";
                }
                Forms.log.debug("Returning hawtio-form-array for : ", property);
                return "hawtio-form-array";
            case "boolean":
            case "bool":
            case "java.lang.boolean":
                return "hawtio-form-checkbox";
            case "password":
                return "hawtio-form-password";
            case "hidden":
                return "hawtio-form-hidden";
            case "map":
                return "hawtio-form-map";
            default:
                return "hawtio-form-text";
        }
    }
    Forms.normalize = normalize;
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    var SimpleFormConfig = (function () {
        function SimpleFormConfig() {
            this.name = 'form';
            this.method = 'post';
            this.entity = 'entity';
            this.schemaName = 'schema';
            this.mode = 'edit';
            this.data = {};
            this.json = undefined;
            this.scope = null;
            this.scopeName = null;
            this.properties = [];
            this.action = '';
            this.formclass = 'hawtio-form form-horizontal no-bottom-margin';
            this.controlgroupclass = 'control-group';
            this.controlclass = 'controls';
            this.labelclass = 'control-label';
            this.showtypes = 'false';
            this.showhelp = 'true';
            this.showempty = 'true';
            this.onsubmit = 'onSubmit';
        }
        SimpleFormConfig.prototype.getMode = function () {
            return this.mode || "edit";
        };
        SimpleFormConfig.prototype.getEntity = function () {
            return this.entity || "entity";
        };
        SimpleFormConfig.prototype.isReadOnly = function () {
            return this.getMode() === "view";
        };
        return SimpleFormConfig;
    })();
    Forms.SimpleFormConfig = SimpleFormConfig;
    var SimpleForm = (function () {
        function SimpleForm(workspace, $compile) {
            var _this = this;
            this.workspace = workspace;
            this.$compile = $compile;
            this.restrict = 'A';
            this.scope = true;
            this.replace = true;
            this.transclude = true;
            this.attributeName = 'simpleForm';
            this.link = function (scope, element, attrs) {
                return _this.doLink(scope, element, attrs);
            };
        }
        SimpleForm.prototype.isReadOnly = function () {
            return false;
        };
        SimpleForm.prototype.doLink = function (scope, element, attrs) {
            var config = new SimpleFormConfig;
            var fullSchemaName = attrs["schema"];
            var fullSchema = fullSchemaName ? scope[fullSchemaName] : null;
            var compiledNode = null;
            var childScope = null;
            var tabs = null;
            var fieldset = null;
            var schema = null;
            var configScopeName = attrs[this.attributeName] || attrs["data"];
            var firstControl = null;
            var simple = this;
            scope.$watch(configScopeName, onWidgetDataChange);
            function onWidgetDataChange(scopeData) {
                if (scopeData) {
                    onScopeData(scopeData);
                }
            }
            function onScopeData(scopeData) {
                config = Forms.configure(config, scopeData, attrs);
                config.schemaName = fullSchemaName;
                config.scopeName = configScopeName;
                config.scope = scope;
                var entityName = config.getEntity();
                if (angular.isDefined(config.json)) {
                    config.data = $.parseJSON(config.json);
                }
                else {
                    config.data = scopeData;
                }
                var form = simple.createForm(config);
                fieldset = form.find('fieldset');
                schema = config.data;
                tabs = {
                    elements: {},
                    locations: {},
                    use: false
                };
                if (schema && angular.isDefined(schema.tabs)) {
                    tabs.use = true;
                    tabs['div'] = $('<div class="tabbable hawtio-form-tabs"></div>');
                    angular.forEach(schema.tabs, function (value, key) {
                        tabs.elements[key] = $('<div class="tab-pane" title="' + key + '"></div>');
                        tabs['div'].append(tabs.elements[key]);
                        value.forEach(function (val) {
                            tabs.locations[val] = key;
                        });
                    });
                    if (!tabs.locations['*']) {
                        tabs.locations['*'] = Object.extended(schema.tabs).keys()[0];
                    }
                }
                if (!tabs.use) {
                    fieldset.append('<div class="spacer"></div>');
                }
                if (schema) {
                    if (tabs.use) {
                        var tabKeyToIdPropObject = {};
                        angular.forEach(schema.properties, function (property, id) {
                            var tabkey = findTabOrderValue(id);
                            var array = tabKeyToIdPropObject[tabkey];
                            if (!array) {
                                array = [];
                                tabKeyToIdPropObject[tabkey] = array;
                            }
                            array.push({ id: id, property: property });
                        });
                        angular.forEach(schema.tabs, function (value, key) {
                            value.forEach(function (val) {
                                var array = tabKeyToIdPropObject[val];
                                if (array) {
                                    angular.forEach(array, function (obj) {
                                        var id = obj.id;
                                        var property = obj.property;
                                        if (id && property) {
                                            addProperty(id, property);
                                        }
                                    });
                                }
                            });
                        });
                    }
                    else {
                        angular.forEach(schema.properties, function (property, id) {
                            addProperty(id, property);
                        });
                    }
                }
                if (tabs.use) {
                    var tabDiv = tabs['div'];
                    var tabCount = Object.keys(tabs.elements).length;
                    if (tabCount < 2) {
                        angular.forEach(tabDiv.children().children(), function (control) {
                            fieldset.append(control);
                        });
                    }
                    else {
                        fieldset.append(tabDiv);
                    }
                }
                var findFunction = function (scope, func) {
                    if (angular.isDefined(scope[func]) && angular.isFunction(scope[func])) {
                        return scope;
                    }
                    if (angular.isDefined(scope.$parent) && scope.$parent !== null) {
                        return findFunction(scope.$parent, func);
                    }
                    else {
                        return null;
                    }
                };
                var onSubmitFunc = config.onsubmit.replace('(', '').replace(')', '');
                var onSubmit = maybeGet(findFunction(scope, onSubmitFunc), onSubmitFunc);
                if (onSubmit === null) {
                    onSubmit = function (json, form) {
                        Forms.log.info("No submit handler defined for form:", form.get(0).name);
                    };
                }
                if (angular.isDefined(onSubmit)) {
                    form.submit(function () {
                        Forms.log.debug("child scope: ", childScope);
                        Forms.log.debug("form name: ", config);
                        if (childScope[config.name].$invalid) {
                            return false;
                        }
                        var entity = scope[entityName];
                        onSubmit(entity, form);
                        return false;
                    });
                }
                fieldset.append('<input type="submit" style="position: absolute; left: -9999px; width: 1px; height: 1px;">');
                var autoFocus = form.find("*[autofocus]");
                if (!autoFocus || !autoFocus.length) {
                    if (firstControl) {
                        console.log("No autofocus element, so lets add one!");
                        var input = firstControl.find("input").first() || firstControl.find("select").first();
                        if (input) {
                            input.attr("autofocus", "true");
                        }
                    }
                }
                if (compiledNode) {
                    $(compiledNode).remove();
                }
                if (childScope) {
                    childScope.$destroy();
                }
                childScope = scope.$new(false);
                compiledNode = simple.$compile(form)(childScope);
                var formsScopeProperty = "forms";
                var forms = scope[formsScopeProperty];
                if (!forms) {
                    forms = {};
                    scope[formsScopeProperty] = forms;
                }
                var formName = config.name;
                if (formName) {
                    var formObject = childScope[formName];
                    if (formObject) {
                        forms[formName] = formObject;
                    }
                    var formScope = formName += "$scope";
                    forms[formScope] = childScope;
                }
                $(element).append(compiledNode);
            }
            function findTabKey(id) {
                var tabkey = tabs.locations[id];
                if (!tabkey) {
                    angular.forEach(tabs.locations, function (value, key) {
                        if (!tabkey && key !== "*" && id.match(key)) {
                            tabkey = value;
                        }
                    });
                }
                if (!tabkey) {
                    tabkey = tabs.locations['*'];
                }
                return tabkey;
            }
            function findTabOrderValue(id) {
                var answer = null;
                angular.forEach(schema.tabs, function (value, key) {
                    value.forEach(function (val) {
                        if (!answer && val !== "*" && id.match(val)) {
                            answer = val;
                        }
                    });
                });
                if (!answer) {
                    answer = '*';
                }
                return answer;
            }
            function addProperty(id, property, ignorePrefixInLabel) {
                if (ignorePrefixInLabel === void 0) { ignorePrefixInLabel = property.ignorePrefixInLabel; }
                var propTypeName = property.type;
                if ("java.lang.String" === propTypeName) {
                    propTypeName = "string";
                }
                var propSchema = Forms.lookupDefinition(propTypeName, schema);
                if (!propSchema) {
                    propSchema = Forms.lookupDefinition(propTypeName, fullSchema);
                }
                var disableHumanizeLabel = schema ? schema.disableHumanizeLabel : false;
                if (property.hidden) {
                    return;
                }
                if (property.kind === "expression") {
                    propSchema = Forms.lookupDefinition("expression", fullSchema);
                    var childId = id + ".language";
                    var childId2 = id + ".expression";
                    var adjustedProperty = jQuery.extend(true, {}, propSchema.properties.expression);
                    adjustedProperty.description = property.description;
                    adjustedProperty.title = property.title;
                    adjustedProperty.required = property.required;
                    var input = Forms.createWidget(propTypeName, propSchema.properties.language, schema, config, childId, ignorePrefixInLabel, configScopeName, true, disableHumanizeLabel);
                    var input2 = Forms.createWidget(propTypeName, adjustedProperty, schema, config, childId2, ignorePrefixInLabel, configScopeName, true, disableHumanizeLabel);
                    var selectWidget = input.find("select");
                    var inputWidget = input2.find("input");
                    if (selectWidget && inputWidget) {
                        selectWidget.attr("style", "width: 120px; margin-right: 10px");
                        inputWidget.attr("style", "width: 470px");
                        inputWidget.before(selectWidget);
                    }
                    fieldset.append(input2);
                    return;
                }
                var nestedProperties = null;
                if (!propSchema && "object" === propTypeName && property.properties) {
                    nestedProperties = property.properties;
                }
                else if (propSchema && Forms.isObjectType(propSchema)) {
                    nestedProperties = propSchema.properties;
                }
                if (nestedProperties) {
                    angular.forEach(nestedProperties, function (childProp, childId) {
                        var newId = id + "." + childId;
                        addProperty(newId, childProp, property.ignorePrefixInLabel);
                    });
                }
                else {
                    var wrapInGroup = true;
                    var input = Forms.createWidget(propTypeName, property, schema, config, id, ignorePrefixInLabel, configScopeName, wrapInGroup, disableHumanizeLabel);
                    if (tabs.use) {
                        var tabkey = findTabKey(id);
                        tabs.elements[tabkey].append(input);
                    }
                    else {
                        fieldset.append(input);
                    }
                    if (!firstControl) {
                        firstControl = input;
                    }
                }
            }
            function maybeGet(scope, func) {
                if (scope !== null) {
                    return scope[func];
                }
                return null;
            }
        };
        SimpleForm.prototype.createForm = function (config) {
            var form = $('<form class="' + config.formclass + '" novalidate><fieldset></fieldset></form>');
            form.attr('name', config.name);
            form.attr('action', config.action);
            form.attr('method', config.method);
            form.find('fieldset').append(this.getLegend(config));
            return form;
        };
        SimpleForm.prototype.getLegend = function (config) {
            var description = Core.pathGet(config, "data.description");
            if (description) {
                return '<legend>' + description + '</legend>';
            }
            return '';
        };
        return SimpleForm;
    })();
    Forms.SimpleForm = SimpleForm;
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    var InputTableConfig = (function () {
        function InputTableConfig() {
            this.name = 'form';
            this.method = 'post';
            this.entity = 'entity';
            this.tableConfig = 'tableConfig';
            this.mode = 'edit';
            this.data = {};
            this.json = undefined;
            this.properties = [];
            this.action = '';
            this.tableclass = 'table table-striped inputTable';
            this.controlgroupclass = 'control-group';
            this.controlclass = 'controls pull-right';
            this.labelclass = 'control-label';
            this.showtypes = 'true';
            this.removeicon = 'icon-remove';
            this.editicon = 'icon-edit';
            this.addicon = 'icon-plus';
            this.removetext = 'Remove';
            this.edittext = 'Edit';
            this.addtext = 'Add';
            this.onadd = 'onadd';
            this.onedit = 'onedit';
            this.onremove = 'onRemove';
            this.primaryKeyProperty = undefined;
        }
        InputTableConfig.prototype.getTableConfig = function () {
            return this.tableConfig || "tableConfig";
        };
        return InputTableConfig;
    })();
    Forms.InputTableConfig = InputTableConfig;
    var InputTable = (function () {
        function InputTable(workspace, $compile) {
            var _this = this;
            this.workspace = workspace;
            this.$compile = $compile;
            this.restrict = 'A';
            this.scope = true;
            this.replace = true;
            this.transclude = true;
            this.attributeName = 'hawtioInputTable';
            this.link = function (scope, element, attrs) {
                return _this.doLink(scope, element, attrs);
            };
        }
        InputTable.prototype.doLink = function (scope, element, attrs) {
            var _this = this;
            var config = new InputTableConfig;
            var configName = attrs[this.attributeName];
            var tableConfig = Core.pathGet(scope, configName);
            config = Forms.configure(config, tableConfig, attrs);
            var entityName = attrs["entity"] || config.data || "entity";
            var propertyName = attrs["property"] || "arrayData";
            var entityPath = entityName + "." + propertyName;
            var primaryKeyProperty = config.primaryKeyProperty;
            var tableName = config["title"] || entityName;
            if (angular.isDefined(config.json)) {
                config.data = $.parseJSON(config.json);
            }
            else {
                config.data = scope[config.data];
            }
            var div = $("<div></div>");
            var tableConfig = Core.pathGet(scope, configName);
            if (!tableConfig) {
                console.log("No table configuration for table " + tableName);
            }
            else {
                tableConfig["selectedItems"] = [];
                scope.config = tableConfig;
            }
            var table = this.createTable(config, configName);
            var group = this.getControlGroup(config, {}, "");
            var controlDiv = this.getControlDiv(config);
            controlDiv.addClass('btn-group');
            group.append(controlDiv);
            function updateData(action) {
                var data = Core.pathGet(scope, entityPath);
                if (!data) {
                    data = [];
                }
                if (!angular.isArray(data) && data) {
                    data = [data];
                }
                data = action(data);
                Core.pathSet(scope, entityPath, data);
                scope.$emit("hawtio.datatable." + entityPath, data);
                Core.$apply(scope);
            }
            function removeSelected(data) {
                angular.forEach(scope.config.selectedItems, function (selected) {
                    var id = selected["_id"];
                    if (angular.isArray(data)) {
                        data = data.remove(function (value) { return Object.equal(value, selected); });
                        delete selected["_id"];
                        data = data.remove(function (value) { return Object.equal(value, selected); });
                    }
                    else {
                        delete selected["_id"];
                        if (id) {
                            delete data[id];
                        }
                        else {
                            var found = false;
                            angular.forEach(data, function (value, key) {
                                if (!found && (Object.equal(value, selected))) {
                                    console.log("Found row to delete! " + key);
                                    delete data[key];
                                    found = true;
                                }
                            });
                            if (!found) {
                                console.log("Could not find " + JSON.stringify(selected) + " in " + JSON.stringify(data));
                            }
                        }
                    }
                });
                return data;
            }
            var add = null;
            var edit = null;
            var remove = null;
            var addDialog = null;
            var editDialog = null;
            var readOnly = attrs["readonly"];
            if (!readOnly) {
                var property = null;
                var dataName = attrs["data"];
                var dataModel = dataName ? Core.pathGet(scope, dataName) : null;
                var schemaName = attrs["schema"] || dataName;
                var schema = schemaName ? Core.pathGet(scope, schemaName) : null;
                if (propertyName && dataModel) {
                    property = Core.pathGet(dataModel, ["properties", propertyName]);
                }
                add = this.getAddButton(config);
                scope.addDialogOptions = {
                    backdropFade: true,
                    dialogFade: true
                };
                scope.showAddDialog = false;
                scope.openAddDialog = function () {
                    scope.addEntity = {};
                    scope.addFormConfig = Forms.findArrayItemsSchema(property, schema);
                    var childDataModelName = "addFormConfig";
                    if (!addDialog) {
                        var title = "Add " + tableName;
                        addDialog = $('<div modal="showAddDialog" close="closeAddDialog()" options="addDialogOptions">\n' + '<div class="modal-header"><h4>' + title + '</h4></div>\n' + '<div class="modal-body"><div simple-form="addFormConfig" entity="addEntity" data="' + childDataModelName + '" schema="' + schemaName + '"></div></div>\n' + '<div class="modal-footer">' + '<button class="btn btn-primary add" type="button" ng-click="addAndCloseDialog()">Add</button>' + '<button class="btn btn-warning cancel" type="button" ng-click="closeAddDialog()">Cancel</button>' + '</div></div>');
                        div.append(addDialog);
                        _this.$compile(addDialog)(scope);
                    }
                    scope.showAddDialog = true;
                    Core.$apply(scope);
                };
                scope.closeAddDialog = function () {
                    scope.showAddDialog = false;
                    scope.addEntity = {};
                };
                scope.addAndCloseDialog = function () {
                    var newData = scope.addEntity;
                    Forms.log.info("About to add the new entity " + JSON.stringify(newData));
                    if (newData) {
                        updateData(function (data) {
                            if (primaryKeyProperty) {
                                data.remove(function (entity) { return entity[primaryKeyProperty] === newData[primaryKeyProperty]; });
                            }
                            data.push(newData);
                            return data;
                        });
                    }
                    scope.closeAddDialog();
                };
                edit = this.getEditButton(config);
                scope.editDialogOptions = {
                    backdropFade: true,
                    dialogFade: true
                };
                scope.showEditDialog = false;
                scope.openEditDialog = function () {
                    var selected = scope.config.selectedItems;
                    var editObject = {};
                    if (selected && selected.length) {
                        angular.copy(selected[0], editObject);
                    }
                    scope.editEntity = editObject;
                    scope.editFormConfig = Forms.findArrayItemsSchema(property, schema);
                    if (!editDialog) {
                        var title = "Edit " + tableName;
                        editDialog = $('<div modal="showEditDialog" close="closeEditDialog()" options="editDialogOptions">\n' + '<div class="modal-header"><h4>' + title + '</h4></div>\n' + '<div class="modal-body"><div simple-form="editFormConfig" entity="editEntity"></div></div>\n' + '<div class="modal-footer">' + '<button class="btn btn-primary save" type="button" ng-click="editAndCloseDialog()">Save</button>' + '<button class="btn btn-warning cancel" type="button" ng-click="closeEditDialog()">Cancel</button>' + '</div></div>');
                        div.append(editDialog);
                        _this.$compile(editDialog)(scope);
                    }
                    scope.showEditDialog = true;
                    Core.$apply(scope);
                };
                scope.closeEditDialog = function () {
                    scope.showEditDialog = false;
                    scope.editEntity = {};
                };
                scope.editAndCloseDialog = function () {
                    var newData = scope.editEntity;
                    console.log("About to edit the new entity " + JSON.stringify(newData));
                    if (newData) {
                        updateData(function (data) {
                            data = removeSelected(data);
                            data.push(newData);
                            return data;
                        });
                    }
                    scope.closeEditDialog();
                };
                remove = this.getRemoveButton(config);
            }
            var findFunction = function (scope, func) {
                if (angular.isDefined(scope[func]) && angular.isFunction(scope[func])) {
                    return scope;
                }
                if (angular.isDefined(scope.$parent) && scope.$parent !== null) {
                    return findFunction(scope.$parent, func);
                }
                else {
                    return null;
                }
            };
            function maybeGet(scope, func) {
                if (scope !== null) {
                    return scope[func];
                }
                return null;
            }
            var onRemoveFunc = config.onremove.replace('(', '').replace(')', '');
            var onEditFunc = config.onedit.replace('(', '').replace(')', '');
            var onAddFunc = config.onadd.replace('(', '').replace(')', '');
            var onRemove = maybeGet(findFunction(scope, onRemoveFunc), onRemoveFunc);
            var onEdit = maybeGet(findFunction(scope, onEditFunc), onEditFunc);
            var onAdd = maybeGet(findFunction(scope, onAddFunc), onAddFunc);
            if (onRemove === null) {
                onRemove = function () {
                    updateData(function (data) {
                        return removeSelected(data);
                    });
                };
            }
            if (onEdit === null) {
                onEdit = function () {
                    scope.openEditDialog();
                };
            }
            if (onAdd === null) {
                onAdd = function (form) {
                    scope.openAddDialog();
                };
            }
            if (add) {
                add.click(function (event) {
                    onAdd();
                    return false;
                });
                controlDiv.append(add);
            }
            if (edit) {
                edit.click(function (event) {
                    onEdit();
                    return false;
                });
                controlDiv.append(edit);
            }
            if (remove) {
                remove.click(function (event) {
                    onRemove();
                    return false;
                });
                controlDiv.append(remove);
            }
            $(div).append(group);
            $(div).append(table);
            $(element).append(div);
            this.$compile(div)(scope);
        };
        InputTable.prototype.getAddButton = function (config) {
            return $('<button type="button" class="btn add"><i class="' + config.addicon + '"></i> ' + config.addtext + '</button>');
        };
        InputTable.prototype.getEditButton = function (config) {
            return $('<button type="button" class="btn edit" ng-disabled="!config.selectedItems.length"><i class="' + config.editicon + '"></i> ' + config.edittext + '</button>');
        };
        InputTable.prototype.getRemoveButton = function (config) {
            return $('<button type="remove" class="btn remove" ng-disabled="!config.selectedItems.length"><i class="' + config.removeicon + '"></i> ' + config.removetext + '</button>');
        };
        InputTable.prototype.createTable = function (config, tableConfig) {
            var tableType = "hawtio-simple-table";
            var table = $('<table class="' + config.tableclass + '" ' + tableType + '="' + tableConfig + '"></table>');
            return table;
        };
        InputTable.prototype.getLegend = function (config) {
            var description = Core.pathGet(config, "data.description");
            if (description) {
                return '<legend>' + config.data.description + '</legend>';
            }
            return '';
        };
        InputTable.prototype.getControlGroup = function (config, arg, id) {
            var rc = $('<div class="' + config.controlgroupclass + '"></div>');
            if (angular.isDefined(arg.description)) {
                rc.attr('title', arg.description);
            }
            return rc;
        };
        InputTable.prototype.getControlDiv = function (config) {
            return $('<div class="' + config.controlclass + '"></div>');
        };
        InputTable.prototype.getHelpSpan = function (config, arg, id) {
            var rc = $('<span class="help-block"></span>');
            if (angular.isDefined(arg.type) && config.showtypes !== 'false') {
                rc.append('Type: ' + arg.type);
            }
            return rc;
        };
        return InputTable;
    })();
    Forms.InputTable = InputTable;
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    var InputBaseConfig = (function () {
        function InputBaseConfig() {
            this.name = 'input';
            this.type = '';
            this.description = '';
            this._default = '';
            this.scope = null;
            this.mode = 'edit';
            this.schemaName = "schema";
            this.controlgroupclass = 'control-group';
            this.controlclass = 'controls';
            this.labelclass = 'control-label';
            this.showtypes = 'false';
            this.formtemplate = null;
            this.entity = 'entity';
            this.model = undefined;
        }
        InputBaseConfig.prototype.getEntity = function () {
            return this.entity || "entity";
        };
        InputBaseConfig.prototype.getMode = function () {
            return this.mode || "edit";
        };
        InputBaseConfig.prototype.isReadOnly = function () {
            return this.getMode() === "view";
        };
        return InputBaseConfig;
    })();
    Forms.InputBaseConfig = InputBaseConfig;
    var InputBase = (function () {
        function InputBase(workspace, $compile) {
            var _this = this;
            this.workspace = workspace;
            this.$compile = $compile;
            this.restrict = 'A';
            this.scope = true;
            this.replace = false;
            this.transclude = false;
            this.attributeName = '';
            this.link = function (scope, element, attrs) {
                return _this.doLink(scope, element, attrs);
            };
        }
        InputBase.prototype.doLink = function (scope, element, attrs) {
            var config = new InputBaseConfig;
            config = Forms.configure(config, null, attrs);
            config.scope = scope;
            config.schemaName = attrs["schema"] || "schema";
            var id = Forms.safeIdentifier(config.name);
            var group = this.getControlGroup(config, config, id);
            var modelName = config.model;
            if (!angular.isDefined(modelName)) {
                modelName = config.getEntity() + "." + id;
            }
            var defaultLabel = id;
            if ("true" === attrs["ignorePrefixInLabel"]) {
                var idx = id.lastIndexOf('.');
                if (idx > 0) {
                    defaultLabel = id.substring(idx + 1);
                }
            }
            var disableHumanizeLabel = "true" === attrs["disableHumanizeLabel"];
            var labelText = attrs["title"] || (disableHumanizeLabel ? defaultLabel : Core.humanizeValue(defaultLabel));
            group.append(Forms.getLabel(config, config, labelText));
            var controlDiv = Forms.getControlDiv(config);
            controlDiv.append(this.getInput(config, config, id, modelName));
            controlDiv.append(Forms.getHelpSpan(config, config, id));
            group.append(controlDiv);
            $(element).append(this.$compile(group)(scope));
            if (scope && modelName) {
                scope.$watch(modelName, onModelChange);
            }
            function onModelChange(newValue) {
                scope.$emit("hawtio.form.modelChange", modelName, newValue);
            }
        };
        InputBase.prototype.getControlGroup = function (config1, config2, id) {
            return Forms.getControlGroup(config1, config2, id);
        };
        InputBase.prototype.getInput = function (config, arg, id, modelName) {
            var rc = $('<span class="form-data"></span>');
            if (modelName) {
                rc.attr('ng-model', modelName);
                rc.append('{{' + modelName + '}}');
            }
            return rc;
        };
        return InputBase;
    })();
    Forms.InputBase = InputBase;
    var TextInput = (function (_super) {
        __extends(TextInput, _super);
        function TextInput(workspace, $compile) {
            _super.call(this, workspace, $compile);
            this.workspace = workspace;
            this.$compile = $compile;
            this.type = "text";
        }
        TextInput.prototype.getInput = function (config, arg, id, modelName) {
            if (config.isReadOnly()) {
                return _super.prototype.getInput.call(this, config, arg, id, modelName);
            }
            var rc = $('<input type="' + this.type + '">');
            rc.attr('name', id);
            if (modelName) {
                rc.attr('ng-model', modelName);
            }
            if (config.isReadOnly()) {
                rc.attr('readonly', 'true');
            }
            var required = config.$attr["required"];
            if (required && required !== "false") {
                rc.attr('required', 'true');
            }
            return rc;
        };
        return TextInput;
    })(InputBase);
    Forms.TextInput = TextInput;
    var HiddenText = (function (_super) {
        __extends(HiddenText, _super);
        function HiddenText(workspace, $compile) {
            _super.call(this, workspace, $compile);
            this.workspace = workspace;
            this.$compile = $compile;
            this.type = "hidden";
        }
        HiddenText.prototype.getControlGroup = function (config1, config2, id) {
            var group = _super.prototype.getControlGroup.call(this, config1, config2, id);
            group.css({ 'display': 'none' });
            return group;
        };
        HiddenText.prototype.getInput = function (config, arg, id, modelName) {
            var rc = _super.prototype.getInput.call(this, config, arg, id, modelName);
            rc.attr('readonly', 'true');
            return rc;
        };
        return HiddenText;
    })(TextInput);
    Forms.HiddenText = HiddenText;
    var PasswordInput = (function (_super) {
        __extends(PasswordInput, _super);
        function PasswordInput(workspace, $compile) {
            _super.call(this, workspace, $compile);
            this.workspace = workspace;
            this.$compile = $compile;
            this.type = "password";
        }
        return PasswordInput;
    })(TextInput);
    Forms.PasswordInput = PasswordInput;
    var CustomInput = (function (_super) {
        __extends(CustomInput, _super);
        function CustomInput(workspace, $compile) {
            _super.call(this, workspace, $compile);
            this.workspace = workspace;
            this.$compile = $compile;
        }
        CustomInput.prototype.getInput = function (config, arg, id, modelName) {
            var template = arg.formtemplate;
            template = Core.unescapeHtml(template);
            var rc = $(template);
            if (!rc.attr("name")) {
                rc.attr('name', id);
            }
            if (modelName) {
                rc.attr('ng-model', modelName);
            }
            if (config.isReadOnly()) {
                rc.attr('readonly', 'true');
            }
            return rc;
        };
        return CustomInput;
    })(InputBase);
    Forms.CustomInput = CustomInput;
    var SelectInput = (function (_super) {
        __extends(SelectInput, _super);
        function SelectInput(workspace, $compile) {
            _super.call(this, workspace, $compile);
            this.workspace = workspace;
            this.$compile = $compile;
        }
        SelectInput.prototype.getInput = function (config, arg, id, modelName) {
            if (config.isReadOnly()) {
                return _super.prototype.getInput.call(this, config, arg, id, modelName);
            }
            var required = true;
            var defaultOption = required ? "" : '<option value=""></option>';
            var rc = $('<select>' + defaultOption + '</select>');
            rc.attr('name', id);
            var scope = config.scope;
            var data = config.data;
            if (data && scope) {
                var fullSchema = scope[config.schemaName];
                var model = scope[data];
                var paths = id.split(".");
                var property = null;
                angular.forEach(paths, function (path) {
                    property = Core.pathGet(model, ["properties", path]);
                    var typeName = Core.pathGet(property, ["type"]);
                    var alias = Forms.lookupDefinition(typeName, fullSchema);
                    if (alias) {
                        model = alias;
                    }
                });
                var values = Core.pathGet(property, ["enum"]);
                scope["$selectValues"] = values;
                rc.attr("ng-options", "value for value in $selectValues");
            }
            if (modelName) {
                rc.attr('ng-model', modelName);
            }
            if (config.isReadOnly()) {
                rc.attr('readonly', 'true');
            }
            return rc;
        };
        return SelectInput;
    })(InputBase);
    Forms.SelectInput = SelectInput;
    var NumberInput = (function (_super) {
        __extends(NumberInput, _super);
        function NumberInput(workspace, $compile) {
            _super.call(this, workspace, $compile);
            this.workspace = workspace;
            this.$compile = $compile;
        }
        NumberInput.prototype.getInput = function (config, arg, id, modelName) {
            if (config.isReadOnly()) {
                return _super.prototype.getInput.call(this, config, arg, id, modelName);
            }
            var rc = $('<input type="number">');
            rc.attr('name', id);
            if (angular.isDefined(arg.def)) {
                rc.attr('value', arg.def);
            }
            if (angular.isDefined(arg.minimum)) {
                rc.attr('min', arg.minimum);
            }
            if (angular.isDefined(arg.maximum)) {
                rc.attr('max', arg.maximum);
            }
            if (modelName) {
                rc.attr('ng-model', modelName);
            }
            if (config.isReadOnly()) {
                rc.attr('readonly', 'true');
            }
            var scope = config.scope;
            if (scope) {
                function onModelChange() {
                    var value = Core.pathGet(scope, modelName);
                    if (value && angular.isString(value)) {
                        var numberValue = Number(value);
                        Core.pathSet(scope, modelName, numberValue);
                    }
                }
                scope.$watch(modelName, onModelChange);
                onModelChange();
            }
            return rc;
        };
        return NumberInput;
    })(InputBase);
    Forms.NumberInput = NumberInput;
    var StringArrayInput = (function (_super) {
        __extends(StringArrayInput, _super);
        function StringArrayInput(workspace, $compile) {
            _super.call(this, workspace, $compile);
            this.workspace = workspace;
            this.$compile = $compile;
        }
        StringArrayInput.prototype.getInput = function (config, arg, id, modelName) {
            var rowScopeName = "_" + id;
            var ngRepeat = rowScopeName + ' in ' + modelName;
            var readOnlyWidget = '{{' + rowScopeName + '}}';
            if (config.isReadOnly()) {
                return angular.element('<ul><li ng-repeat="' + rowScopeName + ' in ' + modelName + '">' + readOnlyWidget + '</li></ul>');
            }
            else {
                var scope = config.scope;
                var fallbackSchemaName = (arg.$attr || {})["schema"] || "schema";
                var schema = scope[config.schemaName] || scope[fallbackSchemaName] || {};
                var properties = schema.properties || {};
                var arrayProperty = properties[id] || {};
                var property = arrayProperty["items"] || {};
                var propTypeName = property.type;
                var ignorePrefixInLabel = true;
                var disableHumanizeLabel = property.disableHumanizeLabel;
                var configScopeName = null;
                var value = Core.pathGet(scope, modelName);
                if (!value) {
                    Core.pathSet(scope, modelName, []);
                }
                var methodPrefix = "_form_stringArray" + rowScopeName + "_";
                var itemKeys = methodPrefix + "keys";
                var addMethod = methodPrefix + "add";
                var removeMethod = methodPrefix + "remove";
                function updateKeys() {
                    var value = Core.pathGet(scope, modelName);
                    scope[itemKeys] = value ? Object.keys(value) : [];
                    scope.$emit("hawtio.form.modelChange", modelName, value);
                }
                updateKeys();
                scope[addMethod] = function () {
                    var value = Core.pathGet(scope, modelName) || [];
                    value.push("");
                    Core.pathSet(scope, modelName, value);
                    updateKeys();
                };
                scope[removeMethod] = function (idx) {
                    var value = Core.pathGet(scope, modelName) || [];
                    if (idx < value.length) {
                        value.splice(idx, 1);
                    }
                    Core.pathSet(scope, modelName, value);
                    updateKeys();
                };
                var itemId = modelName + "[" + rowScopeName + "]";
                var itemsConfig = {
                    model: itemId
                };
                var wrapInGroup = false;
                var widget = Forms.createWidget(propTypeName, property, schema, itemsConfig, itemId, ignorePrefixInLabel, configScopeName, wrapInGroup, disableHumanizeLabel);
                if (!widget) {
                    widget = angular.element(readOnlyWidget);
                }
                var markup = angular.element('<div class="controls" style="white-space: nowrap" ng-repeat="' + rowScopeName + ' in ' + itemKeys + '"></div>');
                markup.append(widget);
                markup.append(angular.element('<a ng-click="' + removeMethod + '(' + rowScopeName + ')" title="Remove this value"><i class="red icon-remove"></i></a>'));
                markup.after(angular.element('<a ng-click="' + addMethod + '()" title="Add a new value"><i class="icon-plus"></i></a>'));
                return markup;
            }
        };
        return StringArrayInput;
    })(InputBase);
    Forms.StringArrayInput = StringArrayInput;
    var ArrayInput = (function (_super) {
        __extends(ArrayInput, _super);
        function ArrayInput(workspace, $compile) {
            _super.call(this, workspace, $compile);
            this.workspace = workspace;
            this.$compile = $compile;
        }
        ArrayInput.prototype.doLink = function (scope, element, attrs) {
            var config = new InputBaseConfig;
            config = Forms.configure(config, null, attrs);
            var id = config.name;
            var dataName = attrs["data"] || "";
            var entityName = attrs["entity"] || config.entity;
            var schemaName = attrs["schema"] || config.schemaName;
            function renderRow(cell, type, data) {
                if (data) {
                    var description = data["description"];
                    if (!description) {
                        angular.forEach(data, function (value, key) {
                            if (value && !description) {
                                description = value;
                            }
                        });
                    }
                    return description;
                }
                return null;
            }
            var tableConfigPaths = ["properties", id, "inputTable"];
            var tableConfig = null;
            Core.pathGet(scope, tableConfigPaths);
            if (!tableConfig) {
                var tableConfigScopeName = tableConfigPaths.join(".");
                var disableHumanizeLabel = "true" === attrs["disableHumanizeLabel"];
                var cellDescription = disableHumanizeLabel ? id : Core.humanizeValue(id);
                tableConfig = {
                    formConfig: config,
                    title: cellDescription,
                    data: config.entity + "." + id,
                    displayFooter: false,
                    showFilter: false,
                    columnDefs: [
                        {
                            field: '_id',
                            displayName: cellDescription,
                            render: renderRow
                        }
                    ]
                };
                Core.pathSet(scope, tableConfigPaths, tableConfig);
            }
            var table = $('<div hawtio-input-table="' + tableConfigScopeName + '" data="' + dataName + '" property="' + id + '" entity="' + entityName + '" schema="' + schemaName + '"></div>');
            if (config.isReadOnly()) {
                table.attr("readonly", "true");
            }
            $(element).append(this.$compile(table)(scope));
        };
        return ArrayInput;
    })(InputBase);
    Forms.ArrayInput = ArrayInput;
    var BooleanInput = (function (_super) {
        __extends(BooleanInput, _super);
        function BooleanInput(workspace, $compile) {
            _super.call(this, workspace, $compile);
            this.workspace = workspace;
            this.$compile = $compile;
        }
        BooleanInput.prototype.getInput = function (config, arg, id, modelName) {
            var rc = $('<input class="hawtio-checkbox" type="checkbox">');
            rc.attr('name', id);
            if (config.isReadOnly()) {
                rc.attr('disabled', 'true');
            }
            if (modelName) {
                rc.attr('ng-model', modelName);
            }
            if (config.isReadOnly()) {
                rc.attr('readonly', 'true');
            }
            var scope = config.scope;
            if (scope) {
                function onModelChange() {
                    var value = Core.pathGet(scope, modelName);
                    if (value && "true" === value) {
                        Core.pathSet(scope, modelName, true);
                    }
                }
                scope.$watch(modelName, onModelChange);
                onModelChange();
            }
            return rc;
        };
        return BooleanInput;
    })(InputBase);
    Forms.BooleanInput = BooleanInput;
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    var SubmitForm = (function () {
        function SubmitForm() {
            var _this = this;
            this.restrict = 'A';
            this.scope = true;
            this.link = function (scope, element, attrs) {
                return _this.doLink(scope, element, attrs);
            };
        }
        SubmitForm.prototype.doLink = function (scope, element, attrs) {
            var el = $(element);
            var target = 'form[name=' + attrs['hawtioSubmit'] + ']';
            el.click(function () {
                $(target).submit();
                return false;
            });
        };
        return SubmitForm;
    })();
    Forms.SubmitForm = SubmitForm;
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    var ResetForm = (function () {
        function ResetForm() {
            var _this = this;
            this.restrict = 'A';
            this.scope = true;
            this.link = function (scope, element, attrs) {
                return _this.doLink(scope, element, attrs);
            };
        }
        ResetForm.prototype.doLink = function (scope, element, attrs) {
            var el = $(element);
            var target = 'form[name=' + attrs['hawtioReset'] + ']';
            el.click(function () {
                var forms = $(target);
                for (var i = 0; i < forms.length; i++) {
                    forms[i].reset();
                }
                return false;
            });
        };
        return ResetForm;
    })();
    Forms.ResetForm = ResetForm;
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    Forms.pluginName = 'hawtio-forms';
    Forms.templateUrl = 'app/forms/html/';
    Forms._module = angular.module(Forms.pluginName, ['bootstrap', 'ngResource', 'hawtioCore', 'datatable', 'ui.bootstrap', 'ui.bootstrap.dialog', 'hawtio-ui']);
    Forms._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/forms/test', { templateUrl: 'app/forms/html/test.html' }).when('/forms/testTable', { templateUrl: 'app/forms/html/testTable.html' });
    }]);
    Forms._module.directive('simpleForm', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.SimpleForm(workspace, $compile);
    }]);
    Forms._module.directive('hawtioForm', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.SimpleForm(workspace, $compile);
    }]);
    Forms._module.directive('hawtioInputTable', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.InputTable(workspace, $compile);
    }]);
    Forms._module.directive('hawtioFormText', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.TextInput(workspace, $compile);
    }]);
    Forms._module.directive('hawtioFormPassword', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.PasswordInput(workspace, $compile);
    }]);
    Forms._module.directive('hawtioFormHidden', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.HiddenText(workspace, $compile);
    }]);
    Forms._module.directive('hawtioFormNumber', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.NumberInput(workspace, $compile);
    }]);
    Forms._module.directive('hawtioFormSelect', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.SelectInput(workspace, $compile);
    }]);
    Forms._module.directive('hawtioFormArray', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.ArrayInput(workspace, $compile);
    }]);
    Forms._module.directive('hawtioFormStringArray', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.StringArrayInput(workspace, $compile);
    }]);
    Forms._module.directive('hawtioFormCheckbox', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.BooleanInput(workspace, $compile);
    }]);
    Forms._module.directive('hawtioFormCustom', ["workspace", "$compile", function (workspace, $compile) {
        return new Forms.CustomInput(workspace, $compile);
    }]);
    Forms._module.directive('hawtioSubmit', function () {
        return new Forms.SubmitForm();
    });
    Forms._module.directive('hawtioReset', function () {
        return new Forms.ResetForm();
    });
    Forms._module.run(["helpRegistry", function (helpRegistry) {
        helpRegistry.addDevDoc("forms", 'app/forms/doc/developer.md');
    }]);
    hawtioPluginLoader.addModule(Forms.pluginName);
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    function createFormElement() {
        return {
            type: undefined
        };
    }
    Forms.createFormElement = createFormElement;
    function createFormTabs() {
        return {};
    }
    Forms.createFormTabs = createFormTabs;
    function createFormConfiguration() {
        return {
            properties: {}
        };
    }
    Forms.createFormConfiguration = createFormConfiguration;
    function createFormGridConfiguration() {
        return {
            rowSchema: {},
            rows: []
        };
    }
    Forms.createFormGridConfiguration = createFormGridConfiguration;
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    var formGrid = Forms._module.directive("hawtioFormGrid", ['$templateCache', '$interpolate', '$compile', function ($templateCache, $interpolate, $compile) {
        return {
            restrict: 'A',
            replace: true,
            scope: {
                configuration: '=hawtioFormGrid'
            },
            templateUrl: Forms.templateUrl + 'formGrid.html',
            link: function (scope, element, attrs) {
                function createColumns() {
                    return [];
                }
                function createColumnSequence() {
                    var columns = createColumns();
                    if (angular.isDefined(scope.configuration.rowSchema.columnOrder)) {
                        var order = scope.configuration.rowSchema.columnOrder;
                        order.forEach(function (column) {
                            var property = Core.pathGet(scope.configuration.rowSchema.properties, [column]);
                            Core.pathSet(property, ['key'], column);
                            columns.push(property);
                        });
                    }
                    angular.forEach(scope.configuration.rowSchema.properties, function (property, key) {
                        if (!columns.some(function (c) {
                            return c.key === key;
                        })) {
                            property.key = key;
                            columns.push(property);
                        }
                    });
                    return columns;
                }
                function newHeaderRow() {
                    var header = element.find('thead');
                    header.empty();
                    return header.append($templateCache.get('rowTemplate.html')).find('tr');
                }
                function buildTableHeader(columns) {
                    var headerRow = newHeaderRow();
                    columns.forEach(function (property) {
                        var headingName = property.label || property.key;
                        if (!scope.configuration.rowSchema.disableHumanizeLabel) {
                            headingName = headingName.titleize();
                        }
                        var headerTemplate = property.headerTemplate || $templateCache.get('headerCellTemplate.html');
                        var interpolateFunc = $interpolate(headerTemplate);
                        headerRow.append(interpolateFunc({ label: headingName }));
                    });
                    headerRow.append($templateCache.get("emptyHeaderCellTemplate.html"));
                }
                function clearBody() {
                    var body = element.find('tbody');
                    body.empty();
                    return body;
                }
                function newBodyRow() {
                    return angular.element($templateCache.get('rowTemplate.html'));
                }
                function buildTableBody(columns, parent) {
                    var rows = scope.configuration.rows;
                    rows.forEach(function (row, index) {
                        var tr = newBodyRow();
                        columns.forEach(function (property) {
                            var type = Forms.mapType(property.type);
                            if (type === "number" && "input-attributes" in property) {
                                var template = property.template || $templateCache.get('cellNumberTemplate.html');
                                var interpolateFunc = $interpolate(template);
                                tr.append(interpolateFunc({
                                    row: 'configuration.rows[' + index + ']',
                                    type: type,
                                    key: property.key,
                                    min: (property["input-attributes"].min ? property["input-attributes"].min : ""),
                                    max: (property["input-attributes"].max ? property["input-attributes"].max : "")
                                }));
                            }
                            else {
                                var template = property.template || $templateCache.get('cellTemplate.html');
                                var interpolateFunc = $interpolate(template);
                                tr.append(interpolateFunc({
                                    row: 'configuration.rows[' + index + ']',
                                    type: type,
                                    key: property.key
                                }));
                            }
                        });
                        var func = $interpolate($templateCache.get("deleteRowTemplate.html"));
                        tr.append(func({
                            index: index
                        }));
                        parent.append(tr);
                    });
                }
                scope.removeThing = function (index) {
                    scope.configuration.rows.removeAt(index);
                };
                scope.addThing = function () {
                    scope.configuration.rows.push(scope.configuration.onAdd());
                };
                scope.getHeading = function () {
                    if (Core.isBlank(scope.configuration.rowName)) {
                        return 'items'.titleize();
                    }
                    return scope.configuration.rowName.pluralize().titleize();
                };
                scope.$watch('configuration.noDataTemplate', function (newValue, oldValue) {
                    var noDataTemplate = scope.configuration.noDataTemplate || $templateCache.get('heroUnitTemplate.html');
                    element.find('.nodata').html($compile(noDataTemplate)(scope));
                });
                scope.$watch('configuration.rowSchema', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        var columns = createColumnSequence();
                        buildTableHeader(columns);
                    }
                }, true);
                scope.$watchCollection('configuration.rows', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        var body = clearBody();
                        var columns = createColumnSequence();
                        var tmp = angular.element('<div></div>');
                        buildTableBody(columns, tmp);
                        body.append($compile(tmp.children())(scope));
                    }
                });
            }
        };
    }]);
})(Forms || (Forms = {}));
var FabricRequirements;
(function (FabricRequirements) {
    FabricRequirements.DockerConfigController = FabricRequirements.controller("DockerConfigController", ["$scope", "jolokia", "$templateCache", function ($scope, jolokia, $templateCache) {
        $scope.gridConfig = Forms.createFormGridConfiguration();
        $scope.tableTemplate = '';
        if (!$scope.requirements.dockerConfiguration) {
            $scope.requirements.dockerConfiguration = Fabric.createDockerConfiguration();
        }
        if (!$scope.requirements.dockerConfiguration.hosts) {
            $scope.requirements.dockerConfiguration.hosts = [];
        }
        $scope.$watch('requirements.dockerConfiguration.hosts', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.requirements.$dirty = true;
            }
        }, true);
        Fabric.getDtoSchema(undefined, "io.fabric8.api.DockerConfiguration", jolokia, function (dockerConfigurationSchema) {
            FabricRequirements.log.debug("Received dockerConfigurationSchema: ", dockerConfigurationSchema);
            Fabric.getDtoSchema(undefined, 'io.fabric8.api.DockerHostConfiguration', jolokia, function (dockerHostConfigurationSchema) {
                FabricRequirements.log.debug("Received dockerHostConfigurationSchema: ", dockerHostConfigurationSchema);
                ['password', 'passPhrase'].forEach(function (s) {
                    Core.pathSet(dockerHostConfigurationSchema, ['properties', s, 'type'], 'password');
                });
                ['maximumContainerCount', 'port'].forEach(function (s) {
                    Core.pathSet(dockerHostConfigurationSchema, ['properties', s, 'type'], 'integer');
                    Core.pathSet(dockerHostConfigurationSchema, ['properties', s, 'input-attributes', 'min'], '1');
                    Core.pathSet(dockerHostConfigurationSchema, ['properties', s, 'input-attributes', 'max'], '65535');
                });
                $scope.gridConfig.rowSchema = dockerHostConfigurationSchema;
                $scope.gridConfig.rowName = "docker host";
                $scope.gridConfig.heading = true;
                $scope.gridConfig.noDataTemplate = $templateCache.get('noDataTemplate');
                $scope.gridConfig.rowSchema.columnOrder = ['hostName', 'port', 'username', 'password', 'privateKeyFile', 'passPhrase', 'path', 'preferredAddress', 'tags'];
                Core.pathSet($scope.gridConfig, ['rowSchema', 'properties', 'tags', 'template'], $templateCache.get('tagCell.html'));
                $scope.gridConfig.rows = $scope.requirements.dockerConfiguration.hosts;
                $scope.gridConfig.onAdd = function () {
                    var answer = Fabric.createDockerHostConfiguration();
                    answer.hostName = 'New Host';
                    return answer;
                };
                $scope.tableTemplate = $templateCache.get('tableTemplate');
                Core.$apply($scope);
            });
        });
    }]);
})(FabricRequirements || (FabricRequirements = {}));
var Health;
(function (Health) {
    Health.log = Logger.get("Health");
    Health.healthDomains = {
        "org.apache.activemq": "ActiveMQ",
        "org.apache.camel": "Camel",
        "io.fabric8": "Fabric8"
    };
    function hasHealthMBeans(workspace) {
        var beans = getHealthMBeans(workspace);
        if (beans) {
            if (angular.isArray(beans))
                return beans.length >= 1;
            return true;
        }
        return false;
    }
    Health.hasHealthMBeans = hasHealthMBeans;
    function getHealthMBeans(workspace) {
        if (workspace) {
            var healthMap = workspace.mbeanServicesToDomain["Health"] || {};
            var selection = workspace.selection;
            if (selection) {
                var domain = selection.domain;
                if (domain) {
                    var mbean = healthMap[domain];
                    if (mbean) {
                        return mbean;
                    }
                }
            }
            if (healthMap) {
                var answer = [];
                angular.forEach(healthMap, function (value) {
                    if (angular.isArray(value)) {
                        answer = answer.concat(value);
                    }
                    else {
                        answer.push(value);
                    }
                });
                return answer;
            }
            else
                return null;
        }
    }
    Health.getHealthMBeans = getHealthMBeans;
    function decorate($scope) {
        $scope.levelSorting = {
            'ERROR': 0,
            'WARNING': 1,
            'INFO': 2
        };
        $scope.colorMaps = {
            'ERROR': {
                'Health': '#ff0a47',
                'Remaining': '#e92614'
            },
            'WARNING': {
                'Health': '#33cc00',
                'Remaining': '#f7ee09'
            },
            'INFO': {
                'Health': '#33cc00',
                'Remaining': '#00cc33'
            }
        };
        $scope.showKey = function (key) {
            if (key === "colorMap" || key === "data") {
                return false;
            }
            return true;
        };
        $scope.sanitize = function (value) {
            var answer = {};
            Object.extended(value).keys().forEach(function (key) {
                if ($scope.showKey(key) && value[key]) {
                    answer[key] = value[key];
                }
            });
            return answer;
        };
        $scope.getTitle = function (value) {
            if (!value) {
                return '';
            }
            if (value['healthId'].endsWith('profileHealth')) {
                return 'Profile: <strong>' + value['profile'] + '</strong>';
            }
            return 'HealthID: <strong>' + value['healthId'] + '</strong>';
        };
        $scope.generateChartData = function (value) {
            var healthPercentCurrent = 0;
            var healthPercentRemaining = 1;
            if ('healthPercent' in value) {
                var healthPercent = value['healthPercent'];
                healthPercentCurrent = healthPercent.round(3);
                healthPercentRemaining = 1 - healthPercentCurrent;
                healthPercentRemaining = healthPercentRemaining.round(3);
            }
            value.data = {
                total: 1,
                terms: [{
                    term: 'Health',
                    count: healthPercentCurrent
                }, {
                    term: 'Remaining',
                    count: healthPercentRemaining
                }]
            };
            value.colorMap = $scope.colorMaps[value.level];
        };
    }
    Health.decorate = decorate;
})(Health || (Health = {}));
var FabricRequirements;
(function (FabricRequirements) {
    FabricRequirements.ProfileRequirementsController = FabricRequirements.controller("ProfileRequirementsController", ["$scope", "jolokia", "$templateCache", function ($scope, jolokia, $templateCache) {
        Health.decorate($scope);
        $scope.hideTitle = true;
        $scope.healthTemplate = '';
        Core.registerForChanges(jolokia, $scope, {
            type: 'exec',
            mbean: Fabric.healthMBean,
            operation: 'healthList',
            arguments: []
        }, function (response) {
            $scope.fabricHealth = ObjectHelpers.toMap(response.value, 'profile', $scope.generateChartData);
            if (Core.isBlank($scope.healthTemplate)) {
                $scope.healthTemplate = $templateCache.get('healthTemplate.html');
            }
            else {
                $scope.healthTemplate = $scope.healthTemplate + ' ';
            }
            FabricRequirements.log.debug("Got health mbean list: ", $scope.fabricHealth);
            Core.$apply($scope);
        });
        $scope.profileRequirementsString = angular.toJson(($scope.requirements || {}).profileRequirements || [], true);
        $scope.remove = function (profileRequirement) {
            var oldLength = $scope.requirements.profileRequirements.length;
            $scope.requirements.profileRequirements.remove(function (r) {
                return r.profile === profileRequirement.profile;
            });
            var newLength = $scope.requirements.profileRequirements.length;
            if (oldLength > newLength) {
                $scope.requirements.$dirty = true;
            }
        };
    }]);
})(FabricRequirements || (FabricRequirements = {}));
var FabricRequirements;
(function (FabricRequirements) {
    FabricRequirements.SshConfigController = FabricRequirements.controller("SshConfigController", ["$scope", "jolokia", "$templateCache", function ($scope, jolokia, $templateCache) {
        $scope.forms = {
            sshConfig: {}
        };
        $scope.tableTemplate = '';
        if (!$scope.requirements.sshConfiguration) {
            $scope.requirements.sshConfiguration = Fabric.createSshConfiguration();
        }
        if (!$scope.requirements.sshConfiguration.hosts) {
            $scope.requirements.sshConfiguration.hosts = [];
        }
        $scope.gridConfig = Forms.createFormGridConfiguration();
        $scope.$watch("requirements.sshConfiguration.hosts", function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.requirements.$dirty = true;
            }
        }, true);
        $scope.$watch("forms.sshConfig.$dirty", function (newValue) {
            if (newValue) {
                $scope.requirements.$dirty = true;
            }
        });
        $scope.noop = function () {
        };
        Fabric.getDtoSchema(undefined, "io.fabric8.api.SshConfiguration", jolokia, function (sshConfigurationSchema) {
            Fabric.getDtoSchema(undefined, "io.fabric8.api.SshHostConfiguration", jolokia, function (hostConfigurationSchema) {
                ['defaultPassword', 'defaultPassPhrase'].forEach(function (s) {
                    Core.pathSet(sshConfigurationSchema, ['properties', s, 'type'], 'password');
                });
                Core.pathSet(sshConfigurationSchema, ['properties', 'defaultPort', 'type'], 'integer');
                Core.pathSet(sshConfigurationSchema, ['properties', 'defaultPort', 'input-attributes', 'min'], '1');
                ['password', 'passPhrase'].forEach(function (s) {
                    Core.pathSet(hostConfigurationSchema, ['properties', s, 'type'], 'password');
                });
                ['maximumContainerCount', 'port'].forEach(function (s) {
                    Core.pathSet(hostConfigurationSchema, ['properties', s, 'type'], 'integer');
                    Core.pathSet(hostConfigurationSchema, ['properties', s, 'input-attributes', 'min'], '1');
                    Core.pathSet(hostConfigurationSchema, ['properties', s, 'input-attributes', 'max'], '65535');
                });
                sshConfigurationSchema['tabs'] = {
                    'Defaults': ['defaultUsername', 'defaultPassword', 'defaultPort', 'defaultPrivateKeyFile', 'defaultPassPhrase', 'defaultPath', '*']
                };
                delete sshConfigurationSchema.properties.hosts;
                $scope.gridConfig.rowSchema = hostConfigurationSchema;
                $scope.gridConfig.rowName = "host";
                $scope.gridConfig.heading = true;
                $scope.gridConfig.noDataTemplate = $templateCache.get('noDataTemplate');
                $scope.gridConfig.rowSchema.columnOrder = ['hostName', 'port', 'username', 'password', 'privateKeyFile', 'passPhrase', 'path', 'preferredAddress', 'tags'];
                Core.pathSet($scope.gridConfig, ['rowSchema', 'properties', 'tags', 'template'], $templateCache.get('tagCell.html'));
                $scope.gridConfig.rows = $scope.requirements.sshConfiguration.hosts;
                $scope.gridConfig.onAdd = function () {
                    var answer = Fabric.createSshHostConfiguration();
                    answer.hostName = 'New Host';
                    return answer;
                };
                FabricRequirements.log.debug("gridConfig: ", $scope.gridConfig);
                $scope.formConfig = sshConfigurationSchema;
                $scope.tableTemplate = $templateCache.get('tableTemplate');
                Core.$apply($scope);
            });
        });
    }]);
})(FabricRequirements || (FabricRequirements = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.ActiveProfileController", ["$scope", "jolokia", function ($scope, jolokia) {
        $scope.addToDashboardLink = function () {
            var href = "#/fabric/activeProfiles";
            var title = "Active Profiles";
            var size = angular.toJson({
                size_y: 1,
                size_x: 5
            });
            return "#/dashboard/add?tab=dashboard" + "&href=" + encodeURIComponent(href) + "&size=" + encodeURIComponent(size) + "&title=" + encodeURIComponent(title);
        };
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.FabricApisController", ["$scope", "localStorage", "$routeParams", "$location", "jolokia", "workspace", "$compile", "$templateCache", function ($scope, localStorage, $routeParams, $location, jolokia, workspace, $compile, $templateCache) {
        $scope.path = "apis";
        Fabric.initScope($scope, $location, jolokia, workspace);
        $scope.apis = null;
        $scope.selectedApis = [];
        $scope.initDone = false;
        $scope.versionId = Fabric.getDefaultVersionId(jolokia);
        $scope.apiOptions = {
            data: 'apis',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                filterText: "",
                useExternalFilter: false
            },
            selectedItems: $scope.selectedApis,
            rowHeight: 32,
            showSelectionCheckbox: false,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'serviceName',
                    displayName: 'Service',
                    cellTemplate: '<div class="ngCellText">{{row.entity.serviceName}}</div>',
                    width: "***"
                },
                {
                    field: 'wadlHref',
                    displayName: 'APIs',
                    cellTemplate: '<div class="ngCellText">' + '<a ng-show="row.entity.apidocsHref" ng-href="{{row.entity.apidocsHref}}"><i class="icon-puzzle-piece"></i> Swagger</a> ' + '<a ng-show="row.entity.wadlHref" ng-href="{{row.entity.wadlHref}}"><i class="icon-puzzle-piece"></i> WADL</a> ' + '<a ng-show="row.entity.wsdlHref" ng-href="{{row.entity.wsdlHref}}"><i class="icon-puzzle-piece"></i> WSDL</a>' + '</div>',
                    width: "*"
                },
                {
                    field: 'container',
                    displayName: 'Container',
                    cellTemplate: '<div class="ngCellText"><span fabric-container-link="{{row.entity.container}}"/></div>',
                    width: "*"
                },
                {
                    field: 'version',
                    displayName: 'Version',
                    cellTemplate: '<div class="ngCellText">{{row.entity.version}}</div>',
                    width: "*"
                },
                {
                    field: 'endpoint',
                    displayName: 'Location',
                    cellTemplate: '<div class="ngCellText"><a target="endpoint" href="{{row.entity.endpoint}}">{{row.entity.endpoint}}</a></div>',
                    width: "***"
                }
            ]
        };
        function matchesFilter(text) {
            var filter = $scope.searchFilter;
            return !filter || (text && text.has(filter));
        }
        if (Fabric.fabricCreated(workspace)) {
            var query = { type: 'exec', mbean: Fabric.managerMBean, operation: 'clusterJson', arguments: [$scope.path] };
            scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(onClusterData, query));
        }
        function addObjectNameProperties(object) {
            var objectName = object["objectName"];
            if (objectName) {
                var properties = Core.objectNameProperties(objectName);
                if (properties) {
                    angular.forEach(properties, function (value, key) {
                        if (!object[key]) {
                            object[key] = value;
                        }
                    });
                }
            }
            return null;
        }
        function createFlatList(array, json, path) {
            if (path === void 0) { path = ""; }
            angular.forEach(json, function (value, key) {
                var childPath = path + "/" + key;
                function addParameters(href) {
                    angular.forEach(["container", "objectName"], function (name) {
                        var param = value[name];
                        if (param) {
                            href += "&" + name + "=" + encodeURIComponent(param);
                        }
                    });
                    return href;
                }
                var services = value["services"];
                if (services && angular.isArray(services) && value["id"]) {
                    value["path"] = childPath;
                    if (services.length) {
                        var url = services[0];
                        value["endpoint"] = url;
                        addObjectNameProperties(value);
                        url = Core.useProxyIfExternal(url);
                        value["serviceName"] = Core.trimQuotes(value["service"]);
                        var apidocs = value["apidocs"];
                        var wadl = value["wadl"];
                        var wsdl = value["wsdl"];
                        if (apidocs) {
                            value["apidocsHref"] = addParameters("/hawtio-swagger/index.html?baseUri=" + url + apidocs);
                        }
                        if (wadl) {
                            value["wadlHref"] = addParameters("#/fabric/api/wadl?wadl=" + encodeURIComponent(url + wadl));
                        }
                        if (wsdl) {
                            value["wsdlHref"] = addParameters("#/fabric/api/wsdl?wsdl=" + encodeURIComponent(url + wsdl));
                        }
                    }
                    array.push(value);
                }
                else {
                    createFlatList(array, value, childPath);
                }
            });
        }
        function onClusterData(response) {
            $scope.initDone = true;
            var responseJson = null;
            if (response) {
                responseJson = response.value;
            }
            if ($scope.responseJson === responseJson) {
                return;
            }
            $scope.apis = [];
            $scope.responseJson = responseJson;
            try {
                var json = JSON.parse(responseJson);
                createFlatList($scope.apis, json);
                Core.$apply($scope);
            }
            catch (e) {
                console.log("Failed to parse JSON " + e);
                console.log("JSON: " + responseJson);
            }
        }
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric.AssignProfileController = Fabric._module.controller("Fabric.AssignProfileController", ["$scope", "jolokia", "$location", "$routeParams", "workspace", "ProfileCart", function ($scope, jolokia, $location, $routeParams, workspace, ProfileCart) {
        $scope.profileId = $routeParams['pid'];
        $scope.versionId = $routeParams['vid'];
        if (ProfileCart.length > 0) {
            $scope.profileId = ProfileCart.map(function (p) {
                return p.id;
            });
            $scope.versionId = ProfileCart.first().versionId;
        }
        Fabric.initScope($scope, $location, jolokia, workspace);
        $scope.containerIdFilter = '';
        var valid = true;
        if (!$scope.profileId) {
            Fabric.log.debug("No profile ID specified, redirecting to app view");
            valid = false;
        }
        if (!$scope.versionId && valid) {
            Fabric.log.debug("No version ID specified, redirecting to app view");
            valid = false;
        }
        if (!valid) {
            $location.path("/profiles");
        }
        $scope.gotoCreate = function () {
            var ids = $scope.profileId;
            if (angular.isArray(ids)) {
                ids = ids.join(',');
            }
            $location.path('/fabric/containers/createContainer').search({
                versionId: $scope.versionId,
                profileIds: ids
            });
        };
        $scope.$watch('containers', function (newValue, oldValue) {
            if (newValue !== oldValue && newValue) {
                $scope.selected = newValue.filter(function (c) {
                    return c['selected'];
                });
            }
        }, true);
        $scope.assignProfiles = function () {
            var requests = [];
            var profileIds = $scope.profileId;
            if (!angular.isArray(profileIds)) {
                profileIds = [profileIds];
            }
            $scope.selected.forEach(function (c) {
                requests.push({
                    type: 'exec',
                    mbean: Fabric.managerMBean,
                    operation: 'addProfilesToContainer',
                    arguments: [c.id, profileIds]
                });
            });
            var outstanding = requests.length;
            jolokia.request(requests, onSuccess(function () {
                outstanding = outstanding - 1;
                if (outstanding === 0) {
                    Core.notification('success', "Applied " + $scope.profileId);
                    SelectionHelpers.clearGroup(ProfileCart);
                    Core.$apply($scope);
                }
            }));
            setTimeout(function () {
                $location.path("/fabric/containers");
                Core.$apply($scope);
            }, 30);
        };
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric.FabricBrokersController = Fabric._module.controller("Fabric.FabricBrokersController", ["$scope", "localStorage", "$routeParams", "$location", "jolokia", "workspace", "$compile", "$templateCache", function ($scope, localStorage, $routeParams, $location, jolokia, workspace, $compile, $templateCache) {
        Fabric.initScope($scope, $location, jolokia, workspace);
        $scope.maps = {
            group: {},
            profile: {},
            broker: {},
            container: {}
        };
        $scope.version = $routeParams['versionId'];
        if ($scope.version == 'default-version') {
            $scope.version = Fabric.getDefaultVersionId(jolokia);
        }
        $scope.selectedVersion = { id: $scope.version };
        $scope.showBroker = function (broker) {
            var brokerVersion = broker.version;
            var brokerProfile = broker.profile;
            var brokerId = broker.id;
            var path = Fabric.brokerConfigLink(workspace, jolokia, localStorage, brokerVersion, brokerProfile, brokerId);
            $location.path(path);
        };
        $scope.connectToBroker = function (container, broker) {
            Fabric.connectToBroker($scope, container);
        };
        $scope.createBroker = function (group, profile) {
            var args = {};
            if (group) {
                var groupId = group["id"];
                if (groupId) {
                    args["group"] = groupId;
                }
            }
            if (profile) {
                var profileId = profile["id"];
                if (profileId) {
                    args["profile"] = profileId;
                }
            }
            $location.url("/fabric/mq/" + $scope.selectedVersion.id + "/createBroker").search(args);
        };
        function matchesFilter(text) {
            var filter = $scope.searchFilter;
            return !filter || (text && text.toLowerCase().has(filter.toLowerCase()));
        }
        $scope.groupMatchesFilter = function (group) {
            return matchesFilter(group.id) || group.profiles.find(function (item) { return $scope.profileMatchesFilter(item); });
        };
        $scope.profileMatchesFilter = function (profile) {
            return matchesFilter(profile.id) || matchesFilter(profile.group) || matchesFilter(profile.version) || profile.brokers.find(function (item) { return $scope.brokerMatchesFilter(item); });
        };
        $scope.brokerMatchesFilter = function (broker) {
            return matchesFilter(broker.id) || matchesFilter(broker.group) || matchesFilter(broker.version) || broker.containers.find(function (item) { return $scope.containerMatchesFilter(item); });
        };
        $scope.containerMatchesFilter = function (container) {
            return matchesFilter(container.id) || matchesFilter(container.group) || matchesFilter(container.profile) || matchesFilter(container.version) || matchesFilter(container.brokerName) || (container.master && $scope.searchFilter && $scope.searchFilter.has("master"));
        };
        if (Fabric.hasMQManager) {
            var unreg = null;
            $scope.$watch('selectedVersion.id', function (newValue, oldValue) {
                if (!Core.isBlank(newValue)) {
                    if (unreg) {
                        unreg();
                    }
                    unreg = Core.register(jolokia, $scope, { type: 'exec', mbean: Fabric.mqManagerMBean, operation: "loadBrokerStatus(java.lang.String)", arguments: [newValue] }, onSuccess(onBrokerData));
                }
            });
        }
        function onBrokerData(response) {
            if (response) {
                var responseJson = angular.toJson(response.value);
                if ($scope.responseJson === responseJson) {
                    return;
                }
                $scope.responseJson = responseJson;
                var brokers = response.value;
                function findByIdOrCreate(collection, id, map, fn) {
                    var value = collection.find(function (v) {
                        return v && v['id'] === id;
                    });
                    if (!value) {
                        value = fn();
                        value["id"] = id;
                        collection.push(value);
                        var old = map[id];
                        value["expanded"] = old ? old["expanded"] : true;
                        map[id] = value;
                    }
                    return value;
                }
                $scope.groups = [];
                var maps = $scope.maps;
                angular.forEach(brokers, function (brokerStatus) {
                    var groupId = brokerStatus.group || "Unknown";
                    var profileId = brokerStatus.profile || "Unknown";
                    var brokerId = brokerStatus.brokerName || "Unknown";
                    var containerId = brokerStatus.container;
                    var versionId = brokerStatus.version || "1.0";
                    var group = findByIdOrCreate($scope.groups, groupId, maps.group, function () {
                        return {
                            profiles: []
                        };
                    });
                    var profile = findByIdOrCreate(group.profiles, profileId, maps.profile, function () {
                        return {
                            group: groupId,
                            version: versionId,
                            requirements: {
                                minimumInstances: brokerStatus.minimumInstances
                            },
                            brokers: [],
                            containers: {}
                        };
                    });
                    var connectTo = (brokerStatus.networks || []).join(",");
                    var broker = findByIdOrCreate(profile.brokers, brokerId, maps.broker, function () {
                        return {
                            group: groupId,
                            profile: profileId,
                            version: versionId,
                            containers: [],
                            connectTo: connectTo
                        };
                    });
                    if (containerId) {
                        var container = findByIdOrCreate(broker.containers, containerId, maps.container, function () {
                            return brokerStatus;
                        });
                        if (container.master) {
                            container.masterTooltip = " is the master for broker: " + brokerId;
                        }
                        profile.containers[containerId] = container;
                    }
                });
                angular.forEach($scope.groups, function (group) {
                    angular.forEach(group.profiles, function (profile) {
                        angular.forEach(profile.brokers, function (broker) {
                            broker.containers = broker.containers.sortBy(function (c) {
                                return c.id;
                            });
                        });
                        var count = Object.values(profile.containers).length;
                        var required = profile.requirements.minimumInstances || 0;
                        var max = profile.requirements.maximumInstances || -1;
                        profile.requireStyle = Fabric.containerCountBadgeStyle(required, max, count);
                        profile.count = count;
                        profile.requiredToolTip = "this profile requires " + Core.maybePlural(required, "container") + " to be running but is currently running " + Core.maybePlural(count, "container");
                        if (required > count) {
                            profile.requiredToolTip += ". click here to create more containers";
                        }
                    });
                });
                Core.$apply($scope);
            }
        }
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.ClusterController", ["$scope", "$location", "$routeParams", "workspace", "jolokia", "$templateCache", function ($scope, $location, $routeParams, workspace, jolokia, $templateCache) {
        $scope.path = $routeParams["page"] || "/";
        if (!$scope.path.startsWith("/")) {
            $scope.path = "/" + $scope.path;
        }
        $scope.getIconClass = Wiki.iconClass;
        $scope.gridOptions = {
            data: 'children',
            displayFooter: false,
            sortInfo: { fields: ['name'], directions: ['asc'] },
            columnDefs: [
                {
                    field: 'name',
                    displayName: 'Name',
                    cellTemplate: $templateCache.get('fileCellTemplate.html'),
                    headerCellTemplate: $templateCache.get('fileColumnTemplate.html'),
                    cellFilter: ""
                }
            ]
        };
        $scope.isTabActive = function (href) {
            var tidy = Core.trimLeading(href, "#");
            var loc = $location.path();
            return loc === tidy;
        };
        $scope.childLink = function (child) {
            var prefix = "#/fabric/clusters/" + Core.trimLeading($scope.path, "/") + "/";
            var postFix = "";
            var path = child.name;
            return Core.createHref($location, prefix + path + postFix);
        };
        $scope.$watch('workspace.tree', function () {
            setTimeout(updateView, 50);
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateView, 50);
        });
        updateView();
        function updateView() {
            loadBreadcrumbs();
            var mbean = Fabric.getZooKeeperFacadeMBean(workspace);
            if (mbean) {
                jolokia.execute(mbean, "read", $scope.path, onSuccess(onContents));
            }
        }
        function onContents(contents) {
            $scope.children = [];
            $scope.stringData = null;
            $scope.html = null;
            if (contents) {
                angular.forEach(contents.children, function (childName) {
                    $scope.children.push({ name: childName });
                });
                if (!$scope.children.length) {
                    var stringData = contents.stringData;
                    if (stringData) {
                        $scope.stringData = stringData;
                        var json = Core.tryParseJson(stringData);
                        if (json) {
                            $scope.html = Core.valueToHtml(json);
                        }
                        else {
                            $scope.html = stringData;
                        }
                    }
                }
            }
            Core.$apply($scope);
        }
        function loadBreadcrumbs() {
            var href = "#/fabric/clusters";
            $scope.breadcrumbs = [
                { href: href + "/", name: "/" }
            ];
            var path = $scope.path;
            var array = path ? path.split("/") : [];
            angular.forEach(array, function (name) {
                if (name) {
                    if (!name.startsWith("/") && !href.endsWith("/")) {
                        href += "/";
                    }
                    href += name;
                    $scope.breadcrumbs.push({ href: href, name: name });
                }
            });
        }
    }]);
})(Fabric || (Fabric = {}));
var Log;
(function (Log) {
    Log.log = Logger.get("Logs");
    function logSourceHref(row) {
        if (!row) {
            return "";
        }
        var log = row.entity;
        if (log) {
            return logSourceHrefEntity(log);
        }
        else {
            return logSourceHrefEntity(row);
        }
    }
    Log.logSourceHref = logSourceHref;
    function treeContainsLogQueryMBean(workspace) {
        return workspace.treeContainsDomainAndProperties('io.fabric8.insight', { type: 'LogQuery' }) || workspace.treeContainsDomainAndProperties('org.fusesource.insight', { type: 'LogQuery' });
    }
    Log.treeContainsLogQueryMBean = treeContainsLogQueryMBean;
    function isSelectionLogQueryMBean(workspace) {
        return workspace.hasDomainAndProperties('io.fabric8.insight', { type: 'LogQuery' }) || workspace.hasDomainAndProperties('org.fusesource.insight', { type: 'LogQuery' });
    }
    Log.isSelectionLogQueryMBean = isSelectionLogQueryMBean;
    function findLogQueryMBean(workspace) {
        var node = workspace.findMBeanWithProperties('io.fabric8.insight', { type: 'LogQuery' });
        if (!node) {
            node = workspace.findMBeanWithProperties('org.fusesource.insight', { type: 'LogQuery' });
        }
        return node ? node.objectName : null;
    }
    Log.findLogQueryMBean = findLogQueryMBean;
    function logSourceHrefEntity(log) {
        var fileName = Log.removeQuestion(log.fileName);
        var className = Log.removeQuestion(log.className);
        var properties = log.properties;
        var mavenCoords = "";
        if (properties) {
            mavenCoords = properties["maven.coordinates"];
        }
        if (mavenCoords && fileName) {
            var link = "#/source/view/" + mavenCoords + "/class/" + className + "/" + fileName;
            var line = log.lineNumber;
            if (line) {
                link += "?line=" + line;
            }
            return link;
        }
        else {
            return "";
        }
    }
    Log.logSourceHrefEntity = logSourceHrefEntity;
    function hasLogSourceHref(log) {
        var properties = log.properties;
        if (!properties) {
            return false;
        }
        var mavenCoords = "";
        if (properties) {
            mavenCoords = properties["maven.coordinates"];
        }
        return angular.isDefined(mavenCoords) && mavenCoords !== "";
    }
    Log.hasLogSourceHref = hasLogSourceHref;
    function hasLogSourceLineHref(log) {
        var line = log["lineNumber"];
        return angular.isDefined(line) && line !== "" && line !== "?";
    }
    Log.hasLogSourceLineHref = hasLogSourceLineHref;
    function removeQuestion(text) {
        return (!text || text === "?") ? null : text;
    }
    Log.removeQuestion = removeQuestion;
    var _stackRegex = /\s*at\s+([\w\.$_]+(\.([\w$_]+))*)\((.*)?:(\d+)\).*\[(.*)\]/;
    function formatStackTrace(exception) {
        if (!exception) {
            return '';
        }
        if (!angular.isArray(exception) && angular.isString(exception)) {
            exception = exception.split('\n');
        }
        if (!angular.isArray(exception)) {
            return "";
        }
        var answer = '<ul class="unstyled">\n';
        exception.each(function (line) {
            answer += "<li>" + Log.formatStackLine(line) + "</li>\n";
        });
        answer += "</ul>\n";
        return answer;
    }
    Log.formatStackTrace = formatStackTrace;
    function formatStackLine(line) {
        var match = _stackRegex.exec(line);
        if (match && match.length > 6) {
            var classAndMethod = match[1];
            var fileName = match[4];
            var line = match[5];
            var mvnCoords = match[6];
            if (classAndMethod && fileName && mvnCoords) {
                var className = classAndMethod;
                var idx = classAndMethod.lastIndexOf('.');
                if (idx > 0) {
                    className = classAndMethod.substring(0, idx);
                }
                var link = "#/source/view/" + mvnCoords + "/class/" + className + "/" + fileName;
                if (angular.isDefined(line)) {
                    link += "?line=" + line;
                }
                return "<div class='stack-line'>  at <a href='" + link + "'>" + classAndMethod + "</a>(<span class='fileName'>" + fileName + "</span>:<span class='lineNumber'>" + line + "</span>)[<span class='mavenCoords'>" + mvnCoords + "</span>]</div>";
            }
        }
        var bold = true;
        if (line) {
            line = line.trim();
            if (line.startsWith('at')) {
                line = '  ' + line;
                bold = false;
            }
        }
        if (bold) {
            return '<pre class="stack-line bold">' + line + '</pre>';
        }
        else {
            return '<pre class="stack-line">' + line + '</pre>';
        }
    }
    Log.formatStackLine = formatStackLine;
    function getLogCacheSize(localStorage) {
        var text = localStorage['logCacheSize'];
        if (text) {
            return parseInt(text);
        }
        return 1000;
    }
    Log.getLogCacheSize = getLogCacheSize;
})(Log || (Log = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.ContainerController", ["$scope", "$routeParams", "$location", "jolokia", "workspace", "userDetails", function ($scope, $routeParams, $location, jolokia, workspace, userDetails) {
        Fabric.initScope($scope, $location, jolokia, workspace);
        var GET_CONTAINER_MBEANS = ['getContainer(java.lang.String)', 'getContainer(java.lang.String, java.util.List)'];
        if ($scope.inDashboard) {
            $scope.operation = GET_CONTAINER_MBEANS[1];
        }
        else {
            $scope.operation = GET_CONTAINER_MBEANS[0];
        }
        $scope.mavenRepoUploadUri;
        $scope.mavenRepoDownloadUri;
        $scope.zookeeperUrl;
        $scope.username = userDetails.username;
        $scope.password = userDetails.password;
        $scope.knownTabs = ["Status", "Settings", "URLs", "Provision list"];
        $scope.tab = $routeParams['tab'];
        if (!$scope.tab) {
            $scope.tab = 'Status';
        }
        else if (!$scope.knownTabs.any(function (t) { return t == $scope.tab; })) {
            $scope.tab = 'Status';
        }
        $scope.$watch('tab', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $location.search({ tab: newValue }).replace();
            }
        });
        $scope.loading = true;
        $scope.containerId = $routeParams.containerId;
        $scope.addToDashboardLink = function () {
            var href = "#/fabric/container/:containerId";
            var routeParams = angular.toJson($routeParams);
            var title = $scope.containerId;
            return "#/dashboard/add?tab=dashboard&href=" + encodeURIComponent(href) + "&routeParams=" + encodeURIComponent(routeParams) + "&title=" + encodeURIComponent(title);
        };
        $scope.versionTitle = "Migrate to:";
        $scope.selectedProfiles = [];
        $scope.selectedProfilesDialog = [];
        $scope.selectedProfilesString = '';
        $scope.addProfileDialog = new UI.Dialog();
        $scope.deleteProfileDialog = new UI.Dialog();
        $scope.deleteContainerDialog = new UI.Dialog();
        $scope.$watch('selectedProfiles', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.selectedProfilesString = '';
                $scope.selectedProfiles.each(function (p) {
                    $scope.selectedProfilesString += '<li>' + p.id + '</li>\n';
                });
            }
        }, true);
        $scope.stop = function () {
            ContainerHelpers.doStopContainer($scope, jolokia, $scope.containerId);
        };
        $scope.start = function () {
            ContainerHelpers.doStartContainer($scope, jolokia, $scope.containerId);
        };
        $scope.statusIcon = function () {
            return Fabric.statusIcon($scope.row);
        };
        $scope.getGitURL = function (jolokiaUrl) {
            var answer = jolokiaUrl ? jolokiaUrl.replace("jolokia", "git/fabric") : null;
            if (answer !== null) {
                var command = "git clone -b 1.0 " + answer;
                if ($scope.username !== null && $scope.password !== null) {
                    command = command.replace("://", "://" + $scope.username + ":" + $scope.password + "@");
                }
                answer = command;
            }
            return answer;
        };
        $scope.getSshURL = function (sshUrl) {
            if (!sshUrl) {
                return '';
            }
            var answer = sshUrl;
            if ($scope.username !== null && $scope.password !== null) {
                var parts = sshUrl.split(":");
                if (parts.length === 2) {
                    answer = "ssh -p " + parts[1] + " " + $scope.username + "@" + parts[0];
                }
            }
            return answer;
        };
        $scope.getJmxURL = function (jmxUrl) {
            return jmxUrl;
        };
        $scope.getType = function () {
            if ($scope.row) {
                if ($scope.row.ensembleServer) {
                    return "Fabric Server";
                }
                else if ($scope.row.managed) {
                    return "Managed Container";
                }
                else {
                    return "Unmanaged Container";
                }
            }
            return "";
        };
        $scope.updateContainerProperty = function (propertyName, row) {
            Fabric.setContainerProperty(jolokia, row.id, propertyName, row[propertyName], function () {
                Core.$apply($scope);
            }, function (response) {
                Core.notification('error', 'Failed to set container property due to : ' + response.error);
                Core.$apply($scope);
            });
        };
        $scope.updateJvmOpts = function () {
            jolokia.execute(Fabric.managerMBean, 'setJvmOpts(java.lang.String,java.lang.String)', $scope.containerId, $scope.jvmOpts, onSuccess(function () {
                Core.$apply($scope);
            }, {
                error: function (ex) {
                    Fabric.log.debug(ex.error);
                }
            }));
        };
        $scope.getJvmOpts = function () {
            jolokia.execute(Fabric.managerMBean, 'getJvmOpts(java.lang.String)', $scope.containerId, onSuccess(function (result) {
                $scope.jvmOpts = result;
                Core.$apply($scope);
            }, {
                error: function (ex) {
                    Fabric.log.debug(ex.error);
                }
            }));
        };
        $scope.displayJvmOpts = function () {
            var result = false;
            if ($scope.row) {
                try {
                    var providerType = $scope.row.metadata.createOptions.providerType;
                    if ($scope.row.type == "karaf" && (providerType == "child" || providerType == "ssh")) {
                        result = true;
                    }
                }
                catch (exception) {
                }
            }
            return result;
        };
        $scope.getClass = function (item) {
            if (!$scope.provisionListFilter) {
                return 'no-filter';
            }
            else if (item.has($scope.provisionListFilter)) {
                return 'match-filter';
            }
            else {
                return 'no-match-filter';
            }
        };
        $scope.addProfiles = function () {
            $scope.addProfileDialog.close();
            var addedProfiles = $scope.selectedProfilesDialog.map(function (p) {
                return p.id;
            });
            var text = Core.maybePlural(addedProfiles.length, "profile");
            Fabric.addProfilesToContainer(jolokia, $scope.row.id, addedProfiles, function () {
                Core.notification('success', "Successfully added " + text);
                $scope.selectedProfilesDialog = [];
                $scope.$broadcast('fabricProfileRefresh');
                Core.$apply($scope);
            }, function (response) {
                Core.notification('error', "Failed to add " + text + " due to " + response.error);
                $scope.selectedProfilesDialog = [];
                Core.$apply($scope);
            });
        };
        $scope.getArguments = function () {
            if ($scope.inSafeMode) {
                return [$scope.containerId, ["alive", "aliveAndOK", "children", "childrenIds", "debugPort", "ensembleServer", "geoLocation", "httpUrl", "id", "ip", "jmxDomains", "jmxUrl", "jolokiaUrl", "localHostname", "localIp", "location", "manualIp", "maximumPort", "metadata", "minimumPort", "parent", "parentId", "processId", "profileIds", "profiles", "provisionChecksums", "provisionException", "provisionList", "provisionResult", "provisionStatus", "provisionStatusMap", "provisioningComplete", "provisioningPending", "publicHostname", "publicIp", "resolver", "root", "sshUrl", "type", "version", "versionId"]];
            }
            else if ($scope.inDashboard) {
                return [$scope.containerId, ['id', 'versionId', 'profileIds', 'provisionResult', 'jolokiaUrl', 'alive', 'jmxDomains', 'ensembleServer', 'debugPort']];
            }
            return [$scope.containerId];
        };
        $scope.deleteProfiles = function () {
            $scope.deleteProfileDialog.close();
            var removedProfiles = $scope.selectedProfiles.map(function (p) {
                return p.id;
            });
            var text = Core.maybePlural(removedProfiles.length, "profile");
            Fabric.removeProfilesFromContainer(jolokia, $scope.row.id, removedProfiles, function () {
                Core.notification('success', "Successfully removed " + text);
                $scope.selectedProfiles = [];
                $scope.$broadcast('fabricProfileRefresh');
                Core.$apply($scope);
            }, function (response) {
                Core.notification('error', "Failed to remove " + text + " due to " + response.error);
                $scope.selectedProfiles = [];
                Core.$apply($scope);
            });
        };
        $scope.$on("fabricProfileRefresh", function () {
            setTimeout(function () {
                jolokia.request({
                    type: 'exec',
                    mbean: Fabric.managerMBean,
                    operation: $scope.operation,
                    arguments: $scope.getArguments()
                }, {
                    method: 'POST',
                    success: function (response) {
                        render(response);
                    }
                });
            }, 500);
        });
        if (angular.isDefined($scope.containerId)) {
            Core.register(jolokia, $scope, {
                type: 'read',
                mbean: Fabric.managerMBean,
                attribute: ["MavenRepoURI", "MavenRepoUploadURI", "ZookeeperUrl"],
            }, onSuccess(mavenAndZookeeperUris));
            try {
                jolokia.execute(Fabric.managerMBean, $scope.operation, $scope.getArguments());
            }
            catch (exception) {
                $scope.inSafeMode = true;
                $scope.operation = GET_CONTAINER_MBEANS[1];
            }
            Core.register(jolokia, $scope, {
                type: 'exec',
                mbean: Fabric.managerMBean,
                operation: $scope.operation,
                arguments: $scope.getArguments()
            }, onSuccess(render));
        }
        $scope.formatStackTrace = function (exception) {
            return Log.formatStackTrace(exception);
        };
        function mavenAndZookeeperUris(response) {
            var obj = response.value;
            if (obj) {
                $scope.mavenRepoUploadUri = obj.MavenRepoUploadURI;
                $scope.mavenRepoDownloadUri = obj.MavenRepoURI;
                $scope.zookeeperUrl = obj.ZookeeperUrl;
            }
        }
        function render(response) {
            if (!angular.isDefined($scope.responseJson)) {
                $scope.loading = false;
            }
            var responseJson = angular.toJson(response.value);
            if ($scope.responseJson !== responseJson) {
                $scope.responseJson = responseJson;
                $scope.row = response.value;
                $scope.container = $scope.row;
                if ($scope.row) {
                    var row = $scope.row;
                    row.debugHost = row.publicIp || row.localHostname || row.localIp || row.ip || row.manualIp;
                    if (angular.isDefined($scope.row.provisionException) && angular.isString($scope.row.provisionException)) {
                        $scope.row.provisionExceptionArray = $scope.row.provisionException.lines();
                    }
                    $scope.services = Fabric.getServiceList($scope.row);
                    if (angular.isDefined($scope.resolverWatch) && angular.isFunction($scope.resolverWatch)) {
                        $scope.resolverWatch();
                    }
                    $scope.resolverWatch = $scope.$watch('row.resolver', function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            $scope.updateContainerProperty('resolver', $scope.row);
                        }
                    });
                    if ($scope.row.jmxDomains && $scope.row.jmxDomains.length > 0) {
                        $scope.row.jmxDomains = $scope.row.jmxDomains.sortBy(function (n) { return n.toString().toLowerCase(); });
                    }
                    if ($scope.displayJvmOpts()) {
                        $scope.getJvmOpts();
                    }
                }
                Core.$apply($scope);
            }
        }
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    function ContainerListDirectiveController($scope, $element, $attrs, jolokia, $location, workspace, $templateCache) {
        $scope.containerArgs = ["id", "alive", "parentId", "profileIds", "versionId", "provisionResult", "jolokiaUrl", "root", 'jmxDomains', "type", "metadata", "location"];
        $scope.profileFields = ["id", "hidden"];
        $scope.containersOp = 'containers(java.util.List, java.util.List)';
        $scope.ensembleContainerIdListOp = 'EnsembleContainers';
        $scope.containers = [];
        $scope.activeProfiles = [];
        $scope.selectedContainers = [];
        $scope.selectedContainerIds = [];
        $scope.showSelect = true;
        $scope.requirements = null;
        $scope.name = "ContainerListDirectiveController";
        Fabric.initScope($scope, $location, jolokia, workspace);
        SelectionHelpers.decorate($scope);
        $scope.currentPage = $templateCache.get("addProfileRequirements");
        $scope.editRequirements = {
            dialog: new UI.Dialog(),
            excludeProfiles: [],
            selectedProfiles: [],
            excludeDependentProfiles: [],
            selectedDependentProfiles: [],
            addDependentProfileDialog: new UI.Dialog(),
            versionId: null,
            addProfileSelectShow: false,
            dialogOpen: function (profile) {
                var editRequirementsEntity = {
                    profileRequirements: []
                };
                if ($scope.requirements) {
                    angular.copy($scope.requirements, editRequirementsEntity);
                }
                var profileRequirements = editRequirementsEntity.profileRequirements;
                if (profileRequirements) {
                    angular.forEach($scope.activeProfiles, function (profile) {
                        var currentRequirements = profile.requirements;
                        if (!currentRequirements) {
                            currentRequirements = {
                                profile: profile.id
                            };
                            profile.requirements = currentRequirements;
                        }
                        if (!profileRequirements.find(function (p) {
                            return p.profile === currentRequirements.profile;
                        })) {
                            profileRequirements.push(currentRequirements);
                        }
                    });
                }
                if (!profile && $scope.activeProfiles.length) {
                    profile = $scope.activeProfiles[0];
                }
                if (profile) {
                    $scope.editRequirements.versionId = profile.versionId;
                }
                $scope.editRequirements.entity = editRequirementsEntity;
                $scope.editRequirements.dialog.open();
            },
            addDependentProfileDialogOpen: function (requirement) {
                $scope.editRequirements.addDependentProfileDialogProfile = requirement.profile;
                $scope.editRequirements.selectedDependentProfiles.splice(0, $scope.editRequirements.selectedDependentProfiles.length);
                $scope.editRequirements.excludeDependentProfiles = [requirement.profile].concat(requirement.dependentProfiles || []);
                $scope.editRequirements.addDependentProfilesToRequirement = requirement;
                $scope.editRequirements.addDependentProfileDialogShow = true;
            },
            addDependentProfileDialogHide: function () {
                $scope.editRequirements.addDependentProfileDialogShow = false;
            },
            addDependentProfileDialogApply: function () {
                var requirement = $scope.editRequirements.addDependentProfilesToRequirement;
                angular.forEach($scope.editRequirements.selectedDependentProfiles, function (profile) {
                    var id = profile.id;
                    if (id && requirement) {
                        if (!requirement.dependentProfiles)
                            requirement.dependentProfiles = [];
                        if (!requirement.dependentProfiles.find(function (el) {
                            return el === id;
                        })) {
                            requirement.dependentProfiles.push(id);
                        }
                    }
                });
                $scope.editRequirements.addDependentProfileDialogHide();
            },
            addProfileRequirementOpen: function () {
                $scope.editRequirements.selectedProfiles.splice(0, $scope.editRequirements.selectedProfiles.length);
                $scope.editRequirements.excludeProfiles = $scope.editRequirements.entity.profileRequirements.map(function (r) {
                    return r.profile;
                });
                $scope.editRequirements.addProfileRequirementShow = true;
            },
            addProfileRequirementHide: function () {
                $scope.editRequirements.addProfileRequirementShow = false;
            },
            addProfileRequirementApply: function () {
                var entity = $scope.editRequirements.entity;
                var profileRequirements = entity.profileRequirements;
                if (!profileRequirements) {
                    profileRequirements = [];
                    entity.profileRequirements = profileRequirements;
                }
                angular.forEach($scope.editRequirements.selectedProfiles, function (profile) {
                    var id = profile.id;
                    if (id) {
                        profileRequirements.push({ profile: id });
                    }
                });
                $scope.editRequirements.addProfileRequirementHide();
            }
        };
        $scope.getFilteredName = function (item) {
            return item.versionId + " / " + item.id;
        };
        $scope.filterContainer = function (container) {
            var filterText = $scope.containerIdFilter;
            var filterName = $scope.getFilteredName(container);
            if (!Core.matchFilterIgnoreCase(filterName, filterText)) {
                var profileIds = container.profileIds;
                if (profileIds) {
                    return profileIds.any(function (id) { return Core.matchFilterIgnoreCase(id, filterText); });
                }
                return false;
            }
            return true;
        };
        $scope.$watch('editRequirements.addDependentProfileDialogShow', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue) {
                    $scope.currentPage = $templateCache.get("addDependentProfile");
                }
                else {
                    $scope.currentPage = $templateCache.get("addProfileRequirements");
                }
            }
        });
        $scope.$watch('editRequirements.addProfileRequirementShow', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue) {
                    $scope.currentPage = $templateCache.get("addProfileRequirement");
                }
                else {
                    $scope.currentPage = $templateCache.get("addProfileRequirements");
                }
            }
        });
        $scope.updateActiveProfiles = function () {
            var activeProfiles = $scope.activeProfiles;
            $scope.activeProfiles = $scope.getActiveProfiles();
            $scope.activeProfiles.each(function (activeProfile) {
                var ap = activeProfiles.find(function (ap) {
                    return ap.id === activeProfile.id && ap.versionId === activeProfile.versionId;
                });
                if (ap) {
                    activeProfile['selected'] = ap.selected;
                    activeProfile['expanded'] = ap.expanded;
                }
                else {
                    activeProfile['selected'] = false;
                    activeProfile['expanded'] = false;
                }
            });
        };
        $scope.updateContainers = function (newContainers) {
            var response = angular.toJson(newContainers);
            if ($scope.containersResponse !== response) {
                $scope.containersResponse = response;
                newContainers = newContainers.sortBy('id');
                var rootContainers = newContainers.exclude(function (c) {
                    return !c.root;
                });
                var childContainers = newContainers.exclude(function (c) {
                    return c.root;
                });
                if (childContainers.length > 0) {
                    var tmp = [];
                    rootContainers.each(function (c) {
                        tmp.add(c);
                        var children = childContainers.exclude(function (child) {
                            return child.parentId !== c.id;
                        });
                        tmp.add(children);
                    });
                    newContainers = tmp;
                }
                if (angular.isDefined($scope.atVersion)) {
                    newContainers = newContainers.filter(function (c) {
                        return c.versionId === $scope.atVersion;
                    });
                }
                if (angular.isDefined($scope.withoutProfile)) {
                    newContainers = newContainers.filter(function (c) {
                        return !c.profileIds.any(function (p) {
                            return p === $scope.withoutProfile;
                        });
                    });
                }
                newContainers.each(function (container) {
                    container.services = Fabric.getServiceList(container);
                    container.icon = Fabric.getTypeIcon(container);
                    var c = $scope.containers.find(function (c) {
                        return c.id === container.id;
                    });
                    if (c) {
                        container['selected'] = c.selected;
                    }
                    else {
                        container['selected'] = false;
                    }
                    if ($scope.selectedContainerIds.any(container.id)) {
                        container.selected = true;
                    }
                });
                $scope.containers = newContainers;
                $scope.updateActiveProfiles();
                Core.$apply($scope);
            }
        };
        $scope.getActiveProfiles = function () {
            var answer = [];
            $scope.containers.each(function (container) {
                container.profileIds.each(function (profile) {
                    var p = container.profiles.find(function (p) {
                        return p.id === profile;
                    });
                    if (p && Core.parseBooleanValue(p.hidden)) {
                        return;
                    }
                    var activeProfile = answer.find(function (o) {
                        return o.versionId === container.versionId && o.id === profile;
                    });
                    if (activeProfile) {
                        activeProfile['containers'] = activeProfile['containers'].include(container.id).unique();
                        activeProfile.count = activeProfile['containers'].length;
                    }
                    else {
                        answer.push({
                            id: profile,
                            count: 1,
                            versionId: container.versionId,
                            containers: [container.id],
                            selected: false,
                            requirements: null,
                            requireStyle: null
                        });
                    }
                });
            });
            if ($scope.requirements) {
                angular.forEach($scope.requirements.profileRequirements, function (profileRequirement) {
                    var id = profileRequirement.profile;
                    var min = profileRequirement.minimumInstances;
                    var max = profileRequirement.maximumInstances;
                    if (id) {
                        var profile = answer.find(function (p) { return (p.id === id); });
                        function requireStyle() {
                            var count = 0;
                            if (profile) {
                                count = profile['count'];
                            }
                            return Fabric.containerCountBadgeStyle(min, max, count);
                        }
                        if (profile) {
                            profile["requirements"] = profileRequirement;
                            profile["requireStyle"] = requireStyle();
                        }
                        else {
                            answer.push({
                                id: id,
                                count: 0,
                                versionId: $scope.requirements.version || "1.0",
                                containers: [],
                                selected: false,
                                requirements: profileRequirement,
                                requireStyle: requireStyle()
                            });
                        }
                    }
                });
            }
            return answer;
        };
        $scope.updateEnsembleContainerIdList = function (ids) {
            var response = angular.toJson(ids);
            if ($scope.ensembleContainerIdsResponse !== response) {
                $scope.ensembleContainerIdsResponse = response;
                $scope.ensembleContainerIds = ids;
                Core.$apply($scope);
            }
        };
        $scope.dispatch = function (response) {
            switch (response.request.operation) {
                case ($scope.containersOp):
                    $scope.updateContainers(response.value);
                    return;
            }
            switch (response.request.attribute) {
                case ($scope.ensembleContainerIdListOp):
                    $scope.updateEnsembleContainerIdList(response.value);
                    return;
            }
        };
        $scope.setActiveProfile = function (profile) {
            $scope.clearSelection($scope.activeProfiles);
            if (!profile || profile === null) {
                return;
            }
            profile.selected = true;
        };
        Core.register(jolokia, $scope, [
            { type: 'exec', mbean: Fabric.managerMBean, operation: $scope.containersOp, arguments: [$scope.containerArgs, $scope.profileFields] },
            { type: 'read', mbean: Fabric.clusterManagerMBean, attribute: $scope.ensembleContainerIdListOp }
        ], onSuccess($scope.dispatch, { silent: true }));
    }
    Fabric.ContainerListDirectiveController = ContainerListDirectiveController;
    ;
    function ContainerListDirectiveLink($scope, $element, $attrs) {
        $scope.showSelect = Core.parseBooleanValue(UI.getIfSet('showSelect', $attrs, 'true'));
        var atVersion = UI.getIfSet('atVersion', $attrs, null);
        var withoutProfile = UI.getIfSet('withoutProfile', $attrs, null);
        if (atVersion !== null) {
            $scope.atVersion = $scope.$eval(atVersion);
        }
        if (withoutProfile !== null) {
            $scope.withoutProfile = $scope.$eval(withoutProfile);
        }
    }
    Fabric.ContainerListDirectiveLink = ContainerListDirectiveLink;
    ;
    function ActiveProfileListController($scope, $element, $attrs, jolokia, $location, workspace, $templateCache, $timeout) {
        ContainerListDirectiveController($scope, $element, $attrs, jolokia, $location, workspace, $templateCache);
        $scope.name = "ActiveProfileListController";
        $scope.searchFilter = '';
        $scope.isOpen = function (profile) {
            if ($scope.searchFilter !== '') {
                return "opened";
            }
            return "closed";
        };
        $scope.containersForProfile = function (id) {
            return $scope.containers.filter(function (container) {
                return container.profileIds.some(id);
            });
        };
        $scope.containersForProfileAndVersion = function (profileId, versionId) {
            return $scope.containers.filter(function (container) {
                return container.profileIds.some(profileId) && container.versionId == versionId;
            });
        };
        $scope.profileMatchesFilter = function (profile) {
            var filterText = $scope.searchFilter;
            return Core.matchFilterIgnoreCase(profile.id, filterText) || !profile.containers.filter(function (id) { return Core.matchFilterIgnoreCase(id, filterText); }).isEmpty();
        };
        $scope.containerMatchesFilter = function (container) {
            var filterText = $scope.searchFilter;
            return Core.matchFilterIgnoreCase(container.id, filterText) || !container.profileIds.filter(function (id) { return Core.matchFilterIgnoreCase(id, filterText); }).isEmpty;
        };
        $scope.updateRequirements = function (requirements) {
            function onRequirementsSaved(response) {
                $scope.requirements = requirements;
                Core.notification("success", "Updated the requirements");
                $scope.updateActiveProfiles();
                Core.$apply($scope);
            }
            ;
            if (requirements) {
                $scope.editRequirements.dialog.close();
                var json = JSON.stringify(requirements);
                jolokia.execute(Fabric.managerMBean, "requirementsJson", json, onSuccess(onRequirementsSaved));
            }
        };
        function onRequirements(response) {
            var responseJson = angular.toJson(response.value);
            if (responseJson !== $scope.requirementsResponse) {
                $scope.requirementsResponse = responseJson;
                $scope.requirements = response.value;
                $scope.updateActiveProfiles();
                Core.$apply($scope);
            }
        }
        Core.register(jolokia, $scope, { type: 'exec', mbean: Fabric.managerMBean, operation: "requirements()" }, onSuccess(onRequirements));
    }
    Fabric.ActiveProfileListController = ActiveProfileListController;
    ;
})(Fabric || (Fabric = {}));
var StorageHelpers;
(function (StorageHelpers) {
    function bindModelToLocalStorage(options) {
        var prefix = options.$scope.name + ':' || '::';
        var storageKey = prefix + options.modelName;
        var toParam = options.to || Core.doNothing;
        var fromParam = options.from || Core.doNothing;
        var toWrapper = function (value) {
            if (angular.isFunction(options.onChange)) {
                options.onChange(value);
            }
            var answer = toParam(value);
            options.localStorage[storageKey] = answer;
            return answer;
        };
        var fromWrapper = function (value) {
            if (value === undefined || value === null) {
                value = options.localStorage[storageKey];
            }
            return fromParam(value);
        };
        var storedValue = fromWrapper(undefined);
        ControllerHelpers.bindModelToSearchParam(options.$scope, options.$location, options.modelName, options.paramName, storedValue || options.initialValue, toWrapper, fromWrapper);
    }
    StorageHelpers.bindModelToLocalStorage = bindModelToLocalStorage;
})(StorageHelpers || (StorageHelpers = {}));
var Fabric;
(function (Fabric) {
    Fabric.ContainerViewController = Fabric._module.controller("Fabric.ContainerViewController", ["$scope", "jolokia", "$location", "localStorage", "$route", "workspace", "marked", "ProfileCart", "$dialog", function ($scope, jolokia, $location, localStorage, $route, workspace, marked, ProfileCart, $dialog) {
        $scope.name = Fabric.ContainerViewController.name;
        $scope.containers = [];
        $scope.selectedContainers = [];
        $scope.groupBy = 'none';
        $scope.filter = '';
        $scope.cartItems = [];
        $scope.versionIdFilter = '';
        $scope.profileIdFilter = '';
        $scope.locationIdFilter = '';
        $scope.hasCounts = true;
        $scope.toString = Core.toString;
        $scope.createLocationDialog = ContainerHelpers.getCreateLocationDialog($scope, $dialog);
        var containerFields = ['id', 'profileIds', 'profiles', 'versionId', 'location', 'alive', 'type', 'ensembleServer', 'provisionResult', 'root', 'jolokiaUrl', 'jmxDomains', 'metadata'];
        var profileFields = ['id', 'hidden', 'version', 'summaryMarkdown', 'iconURL', 'tags'];
        Fabric.initScope($scope, $location, jolokia, workspace);
        SelectionHelpers.decorate($scope);
        $scope.viewOnly = true;
        StorageHelpers.bindModelToLocalStorage({
            $scope: $scope,
            $location: $location,
            localStorage: localStorage,
            modelName: 'groupBy',
            paramName: 'groupBy',
            initialValue: $scope.groupBy
        });
        StorageHelpers.bindModelToLocalStorage({
            $scope: $scope,
            $location: $location,
            localStorage: localStorage,
            modelName: 'versionIdFilter',
            paramName: 'versionIdFilter',
            initialValue: $scope.versionIdFilter
        });
        StorageHelpers.bindModelToLocalStorage({
            $scope: $scope,
            $location: $location,
            localStorage: localStorage,
            modelName: 'profileIdFilter',
            paramName: 'profileIdFilter',
            initialValue: $scope.profileIdFilter
        });
        StorageHelpers.bindModelToLocalStorage({
            $scope: $scope,
            $location: $location,
            localStorage: localStorage,
            modelName: 'locationIdFilter',
            paramName: 'locationIdFilter',
            initialValue: $scope.locationIdFilter
        });
        $scope.groupByClass = ControllerHelpers.createClassSelector({
            'profileIds': 'btn-primary',
            'location': 'btn-primary',
            'none': 'btn-primary'
        });
        $scope.$watch('containers', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.selectedContainers = $scope.containers.filter(function (container) {
                    return container['selected'];
                });
            }
        }, true);
        $scope.maybeShowLocation = function () {
            return ($scope.groupBy === 'location' || $scope.groupBy === 'none') && $scope.selectedContainers.length > 0;
        };
        $scope.showContainersFor = function (thing) {
            if (angular.isString(thing)) {
                $scope.locationIdFilter = thing;
            }
            else {
                $scope.profileIdFilter = thing.id;
                $scope.versionIdFilter = thing.version;
            }
            $scope.groupBy = 'none';
        };
        $scope.filterProfiles = function (profile) {
            return FilterHelpers.searchObject(profile.id, $scope.filter);
        };
        $scope.filterContainers = function (container) {
            if (!Core.isBlank($scope.versionIdFilter) && container.versionId !== $scope.versionIdFilter) {
                return false;
            }
            if (!Core.isBlank($scope.profileIdFilter) && !container.profileIds.any($scope.profileIdFilter)) {
                return false;
            }
            if (!Core.isBlank($scope.locationIdFilter) && container.location !== $scope.locationIdFilter) {
                return false;
            }
            return FilterHelpers.searchObject(container.id, $scope.filter);
        };
        $scope.filterContainer = $scope.filterContainers;
        $scope.viewProfile = function (profile) {
            Fabric.gotoProfile(workspace, jolokia, workspace.localStorage, $location, profile.version, profile.id);
        };
        function maybeAdd(group, thing, index) {
            if (angular.isArray(thing)) {
                thing.forEach(function (i) {
                    maybeAdd(group, i, index);
                });
            }
            else {
                if (!group.any(function (item) {
                    return thing[index] === item[index];
                })) {
                    group.add(thing);
                }
            }
        }
        function groupByVersions(containers) {
            var answer = {};
            containers.forEach(function (container) {
                var versionId = container.versionId;
                var version = answer[versionId] || { containers: [], profiles: [] };
                maybeAdd(version.containers, container, 'id');
                maybeAdd(version.profiles, container.profiles, 'id');
                answer[versionId] = version;
            });
            return answer;
        }
        function groupByLocation(containers) {
            var answer = {};
            containers.forEach(function (container) {
                var location = container.location;
                var loc = answer[location] || { containers: Array() };
                maybeAdd(loc.containers, container, 'id');
                answer[location] = loc;
            });
            return answer;
        }
        Fabric.loadRestApi(jolokia, workspace, undefined, function (response) {
            $scope.restApiUrl = UrlHelpers.maybeProxy(Core.injector.get('jolokiaUrl'), response.value);
            Fabric.log.debug("Scope rest API: ", $scope.restApiUrl);
            Core.registerForChanges(jolokia, $scope, {
                type: 'exec',
                mbean: Fabric.managerMBean,
                operation: 'containers(java.util.List, java.util.List)',
                arguments: [containerFields, profileFields]
            }, function (response) {
                var containers = response.value;
                SelectionHelpers.sync($scope.selectedContainers, containers, 'id');
                var versions = {};
                var locations = {};
                containers.forEach(function (container) {
                    if (Core.isBlank(container.location)) {
                        container.location = ContainerHelpers.NO_LOCATION;
                    }
                    container.profiles = container.profiles.filter(function (p) {
                        return !p.hidden;
                    });
                    container.icon = Fabric.getTypeIcon(container);
                    container.services = Fabric.getServiceList(container);
                });
                var versions = groupByVersions(containers);
                angular.forEach(versions, function (version, versionId) {
                    version.profiles.forEach(function (profile) {
                        var containers = version.containers.filter(function (c) {
                            return c.profileIds.some(profile.id);
                        });
                        profile.aliveCount = containers.count(function (c) {
                            return c.alive;
                        });
                        profile.deadCount = containers.length - profile.aliveCount;
                        profile.summary = profile.summaryMarkdown ? marked(profile.summaryMarkdown) : '';
                        profile.iconURL = Fabric.toIconURL($scope, profile.iconURL);
                        profile.tags = ProfileHelpers.getTags(profile);
                    });
                });
                var locations = groupByLocation(containers);
                var locationIds = ContainerHelpers.extractLocations(containers);
                $scope.locationMenu = ContainerHelpers.buildLocationMenu($scope, jolokia, locationIds);
                $scope.locations = locations;
                $scope.versions = versions;
                $scope.containers = containers;
                Core.$apply($scope);
            });
            Core.registerForChanges(jolokia, $scope, {
                type: 'read',
                mbean: Fabric.clusterManagerMBean,
                attribute: 'EnsembleContainers'
            }, function (response) {
                $scope.ensembleContainerIds = response.value;
                Core.$apply($scope);
            });
        });
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.ContainersController", ["$scope", "$location", "$route", "jolokia", "workspace", "$dialog", function ($scope, $location, $route, jolokia, workspace, $dialog) {
        Fabric.initScope($scope, $location, jolokia, workspace);
        $scope.selectedContainers = [];
        $scope.createLocationDialog = ContainerHelpers.getCreateLocationDialog($scope, $dialog);
        Core.bindModelToSearchParam($scope, $location, "containerIdFilter", "q", "");
        Core.reloadWhenParametersChange($route, $scope, $location);
        $scope.addToDashboardLink = function () {
            var href = "#/fabric/containers";
            var title = "Containers";
            var size = angular.toJson({ size_y: 1, size_x: 4 });
            return "#/dashboard/add?tab=dashboard" + "&href=" + encodeURIComponent(href) + "&size=" + encodeURIComponent(size) + "&title=" + encodeURIComponent(title);
        };
        $scope.$watch('containers', function (oldValue, newValue) {
            if (oldValue !== newValue) {
                $scope.selectedContainers = $scope.containers.filter(function (c) {
                    return c.selected;
                });
                var locations = ContainerHelpers.extractLocations($scope.containers);
                $scope.locationMenu = ContainerHelpers.buildLocationMenu($scope, jolokia, locations);
                if ($scope.selectedContainers.length > 0) {
                    $scope.activeContainerId = '';
                }
            }
        }, true);
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric.CreateBrokerController = Fabric._module.controller("Fabric.CreateBrokerController", ["$scope", "localStorage", "$routeParams", "$location", "jolokia", "workspace", "$compile", "$templateCache", function ($scope, localStorage, $routeParams, $location, jolokia, workspace, $compile, $templateCache) {
        Fabric.initScope($scope, $location, jolokia, workspace);
        $scope.defaultGroup = "default";
        $scope.defaultBrokerName = "brokerName";
        $scope.groups = [];
        $scope.possibleNetworks = [];
        $scope.profiles = [];
        $scope.parentProfiles = [];
        $scope.entity = {
            group: $scope.defaultGroup,
            ssl: true,
            version: $routeParams['versionId']
        };
        $scope.otherEntity = {
            networkConnectAll: false
        };
        $scope.forms = {};
        $scope.onSubmit = function (json, form) {
            $scope.message = ($scope.entity.brokerName || "unknown") + " in group " + ($scope.entity.group || "unknown");
            Core.notification("info", "Creating broker " + $scope.message);
            var tmpJson = JSON.stringify($scope.entity, null, '  ');
            jolokia.execute(Fabric.mqManagerMBean, "saveBrokerConfigurationJSON", tmpJson, onSuccess(onSave));
            $location.path("/fabric/mq/" + $routeParams['versionId'] + "/brokers");
            Core.$apply($scope);
        };
        $scope.brokerNameExists = function () {
            var name = $scope.entity.brokerName;
            return name && $scope.brokerNames.indexOf(name) >= 0;
        };
        function updatePossibleNetworks() {
            var group = $scope.entity.group;
            $scope.possibleNetworks = [].concat($scope.groups);
            if (group) {
                $scope.possibleNetworks = $scope.possibleNetworks.remove(group);
            }
        }
        $scope.$watch("entity.group", updatePossibleNetworks);
        $scope.$watch("otherEntity.networkConnectAll", function () {
            if ($scope.otherEntity.networkConnectAll) {
                $scope.entity.networks = $scope.possibleNetworks;
            }
        });
        angular.forEach(["group", "profile"], function (param) {
            var value = $routeParams[param];
            if (value) {
                $scope.entity[param] = value;
            }
        });
        if (!$scope.entity.kind) {
            $scope.entity.kind = "MasterSlave";
        }
        Fabric.getDtoSchema("brokerConfig", "io.fabric8.api.jmx.MQBrokerConfigDTO", jolokia, function (schema) {
            $scope.schema = schema;
            configureSchema(schema);
            jolokia.execute(Fabric.mqManagerMBean, "loadBrokerStatus(java.lang.String)", $routeParams['versionId'], onSuccess(onBrokerData));
            Core.$apply($scope);
        });
        function configureSchema(schema) {
            delete schema.properties['username'];
            delete schema.properties['password'];
            delete schema.properties['properties'];
            var isReplicated = "entity.kind == 'Replicated'";
            var isStandalone = "entity.kind == 'StandAlone'";
            Core.pathSet(schema.properties, ['group', 'required'], true);
            Core.pathSet(schema.properties, ['group', 'tooltip'], 'The peer group name of message brokers. The group is name is used by messaging clients to connect to a broker; so it represents a peer group of brokers used for load balancing.');
            Core.pathSet(schema.properties, ['group', 'input-attributes', 'typeahead'], 'title for title in groups | filter:$viewValue');
            Core.pathSet(schema.properties, ['group', 'input-attributes', 'typeahead-editable'], 'true');
            Core.pathSet(schema.properties, ['brokerName', 'required'], true);
            Core.pathSet(schema.properties, ['brokerName', 'tooltip'], 'The name of the broker.');
            Core.pathSet(schema.properties, ['brokerName', 'input-attributes', 'autofocus'], 'true');
            Core.pathSet(schema.properties, ['parentProfile', 'tooltip'], 'The parent profile used by the profile.');
            Core.pathSet(schema.properties, ['parentProfile', 'input-attributes', 'typeahead'], 'p.id for p in parentProfiles | filter:$viewValue');
            Core.pathSet(schema.properties, ['parentProfile', 'input-attributes', 'typeahead-editable'], 'false');
            Core.pathSet(schema.properties, ['parentProfile', 'input-attributes', "placeholder"], "{{" + isReplicated + " ? 'mq-replicated' : 'mq-base'}}");
            Core.pathSet(schema.properties, ['profile', 'tooltip'], 'The profile to create instances of this broker.');
            Core.pathSet(schema.properties, ['profile', 'input-attributes', 'typeahead'], 'title for title in profiles | filter:$viewValue');
            Core.pathSet(schema.properties, ['profile', 'input-attributes', 'typeahead-editable'], 'true');
            Core.pathSet(schema.properties, ['profile', 'input-attributes', "placeholder"], "mq-broker-{{entity.group || 'default'}}.{{entity.brokerName || 'brokerName'}}");
            Core.pathSet(schema.properties, ['clientProfile', 'tooltip'], 'The profile used by messaging clients to connect to this group of brokers.');
            Core.pathSet(schema.properties, ['clientProfile', 'input-attributes', 'typeahead'], 'title for title in profiles | filter:$viewValue');
            Core.pathSet(schema.properties, ['clientProfile', 'input-attributes', 'typeahead-editable'], 'true');
            Core.pathSet(schema.properties, ['clientProfile', 'input-attributes', "placeholder"], "mq-client-{{entity.group || 'default'}}");
            Core.pathSet(schema.properties, ['clientParentProfile', 'tooltip'], 'The parent profile used by the client profile.');
            Core.pathSet(schema.properties, ['clientParentProfile', 'input-attributes', 'typeahead'], 'p.id for p in parentProfiles | filter:$viewValue');
            Core.pathSet(schema.properties, ['clientParentProfile', 'input-attributes', 'typeahead-editable'], 'false');
            Core.pathSet(schema.properties, ['clientParentProfile', 'input-attributes', 'placeholder'], 'mq-client-base');
            Core.pathSet(schema.properties, ['parentProfile', 'input-attributes', "placeholder"], "default");
            Core.pathSet(schema.properties, ['data', 'input-attributes', "placeholder"], "${karaf.base}/data/{{entity.brokerName || 'brokerName'}}");
            Core.pathSet(schema.properties, ['configUrl', 'input-attributes', "placeholder"], "profile:broker.xml");
            Core.pathSet(schema.properties, ['replicas', 'control-group-attributes', "ng-show"], isReplicated);
            Core.pathSet(schema.properties, ['replicas', 'input-attributes', "value"], "{{3}}");
            Core.pathSet(schema.properties, ['replicas', 'input-attributes', "min"], "1");
            Core.pathSet(schema.properties, ['minimumInstances', 'control-group-attributes', "ng-hide"], isReplicated);
            Core.pathSet(schema.properties, ['minimumInstances', 'input-attributes', "value"], "{{" + isStandalone + " ? 1 : 2}}");
            Core.pathSet(schema.properties, ['minimumInstances', 'input-attributes', "min"], "1");
            Core.pathSet(schema.properties, ['networksPassword', 'type'], 'password');
            Core.pathSet(schema.properties, ['networks', 'items', 'input-attributes', 'typeahead-editable'], 'true');
            Core.pathSet(schema.properties, ['networks', 'input-attributes', "ng-hide"], "otherEntity.networkConnectAll");
            Core.pathSet(schema.properties, ['networks', 'tooltip'], 'The broker groups to create a store and forward network to');
            Core.pathSet(schema.properties, ['networkConnectAll', 'type'], 'boolean');
            Core.pathSet(schema.properties, ['networkConnectAll', 'input-attributes', 'ng-model'], "otherEntity.networkConnectAll");
            Core.pathSet(schema.properties, ['networkConnectAll', 'label'], 'Network to all groups');
            Core.pathSet(schema.properties, ['networkConnectAll', 'tooltip'], 'Should this broker create a store and forward network to all the known groups of brokers');
            Core.pathSet(schema.properties, ['version', 'input-attributes', 'value'], "{{'" + $routeParams['versionId'] + "'}}");
            Core.pathSet(schema.properties, ['version', 'input-attributes', 'readonly'], 'true');
            Core.pathSet(schema.properties, ['version', 'label'], "Fabric version");
            schema['tabs'] = {
                'Default': ['group', 'brokerName', 'kind', 'profile', 'clientProfile', 'data', 'configUrl', 'replicas', 'minimumInstances', 'version', 'networkConnectAll', 'networks'],
                'Advanced': ['parentProfile', 'clientParentProfile', 'networksUserName', 'networksPassword', '*']
            };
        }
        function onBrokerData(brokerStatuses) {
            var networkNames = brokerStatuses.map(function (s) { return s.networks; }).flatten().unique();
            var groups = brokerStatuses.map(function (s) { return s.group; }).unique();
            $scope.groups = networkNames.concat(groups).unique().sort();
            $scope.profiles = brokerStatuses.map(function (s) { return s.profile; }).unique().sort();
            $scope.brokerNames = brokerStatuses.map(function (s) { return s.brokerName; }).unique().sort();
            updatePossibleNetworks();
            var version = brokerStatuses.map(function (s) { return s.version; }).find(function (s) { return s; }) || "1.0";
            if (version) {
                jolokia.execute(Fabric.managerMBean, "getProfiles(java.lang.String,java.util.List)", version, ["id", "abstract"], onSuccess(onProfileData));
            }
            Core.$apply($scope);
        }
        function onProfileData(profileData) {
            if (profileData) {
                $scope.parentProfiles = profileData.filter(function (p) { return !p.abstract; }).sortBy("id");
            }
        }
        function onSave(response) {
            Core.notification("success", "Created broker " + $scope.message);
            Core.$apply($scope);
        }
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric.CreateContainerController = Fabric._module.controller("Fabric.CreateContainerController", ["$scope", "$element", "$compile", "$location", "workspace", "jolokia", "localStorage", "userDetails", "ProfileCart", function ($scope, $element, $compile, $location, workspace, jolokia, localStorage, userDetails, ProfileCart) {
        var log = Logger.get("Fabric");
        $scope.versionsOp = 'versions()';
        $scope.entity = {
            number: 1,
            saveJmxCredentials: true
        };
        var localStorageProperties = {
            child: {},
            openshift: {
                serverUrl: 'openshift.serverUrl',
                domain: 'openshift.domain',
                gearProfile: 'openshift.gearProfile'
            },
            jclouds: {
                owner: 'jclouds.owner',
                credential: 'jclouds.credential',
                providerName: 'jclouds.providerName',
                imageId: 'jclouds.imageId',
                hardwareId: 'jclouds.hardwareId',
                locationId: 'jclouds.locationId',
                group: 'jclouds.group',
                instanceType: 'jclouds.instanceType'
            }
        };
        $scope.providers = Fabric.registeredProviders(jolokia);
        $scope.selectedProvider = $scope.providers[Object.extended($scope.providers).keys().first()];
        $scope.resolvers = [];
        $scope.schema = {};
        $scope.response = {};
        $scope.versions = [];
        $scope.profiles = [];
        $scope.selectedVersion = {};
        $scope.selectedProfiles = [];
        $scope.selectedProfileIds = '';
        $scope.selectedVersionId = '';
        $scope.profileIdFilter = '';
        $scope.hideProfileSelector = false;
        $scope.returnTo = '/fabric/containerView?groupBy=none';
        $scope.nextPage = '/fabric/containerView?groupBy=none';
        Core.bindModelToSearchParam($scope, $location, 'hideProfileSelector', 'hideProfileSelector', $scope.hideProfileSelector, Core.parseBooleanValue);
        Core.bindModelToSearchParam($scope, $location, 'returnTo', 'returnTo', $scope.returnTo);
        Core.bindModelToSearchParam($scope, $location, 'nextPage', 'nextPage', $scope.nextPage);
        $scope.child = {
            rootContainers: []
        };
        $scope.allContainers = [];
        $scope.openShift = {
            loginDataKey: "openshift.loginData",
            params: null,
            domains: [],
            gearProfiles: [],
            tryLogin: "",
            login: function () {
                var entity = $scope.entity;
                var serverUrl = Core.pathGet(entity, ["serverUrl"]) || "openshift.redhat.com";
                var login = Core.pathGet(entity, ["login"]);
                var password = Core.pathGet(entity, ["password"]);
                log.debug("Invoking login to server " + serverUrl + " user " + login);
                $scope.openShift.loginFailed = false;
                if (serverUrl && login && password) {
                    $scope.openShift.domains = [];
                    Fabric.getOpenShiftDomains(workspace, jolokia, serverUrl, login, password, function (results) {
                        $scope.openShift.domains = results;
                        log.debug("found openshift domains: " + results);
                        if (results.length === 1) {
                            $scope.entity.domain = results[0];
                        }
                        Core.$apply($scope);
                        Fabric.getOpenShiftGearProfiles(workspace, jolokia, serverUrl, login, password, function (results) {
                            $scope.openShift.gearProfiles = results;
                            log.debug("found openshift gears: " + $scope.openShift.gearProfiles);
                            Fabric.OpenShiftCredentials.username = login;
                            Fabric.OpenShiftCredentials.password = password;
                            savePropertiesInLocalStorage();
                            var loginData = {
                                domains: $scope.openShift.domains,
                                gearProfiles: $scope.openShift.gearProfiles
                            };
                            localStorage[$scope.openShift.loginDataKey] = angular.toJson(loginData);
                            Core.$apply($scope);
                        });
                    }, function (error) {
                        $scope.openShift.loginFailed = true;
                        Core.$apply($scope);
                    });
                }
            }
        };
        $scope.jclouds = {};
        $scope.forms = {};
        $scope.showAddProfileDialog = false;
        $scope.$watch('selectedProvider', function (newValue, oldValue) {
            if ($scope.selectedProvider) {
                Fabric.getSchema($scope.selectedProvider.id, $scope.selectedProvider.className, jolokia, function (schema) {
                    $scope.schema = schema;
                    $scope.resolvers = Fabric.getResolvers($scope.selectedProvider.id);
                    Core.$apply($scope);
                });
            }
        }, true);
        $scope.$watch('schema', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.entity['providerType'] = $scope.selectedProvider.id;
                $location.search('tab', $scope.selectedProvider.id);
                var providerId = $scope.entity['providerType'];
                var properties = localStorageProperties[providerId];
                angular.forEach(properties, function (value, key) {
                    var localValue = localStorage[value];
                    if (localValue) {
                        $scope.entity[key] = localValue;
                        log.debug("Defaulted entity " + key + " to " + localValue + " from localStorage");
                    }
                });
                if (providerId === "openshift") {
                    Core.pathSet($scope.entity, ['login'], Fabric.OpenShiftCredentials.username);
                    Core.pathSet($scope.entity, ['password'], Fabric.OpenShiftCredentials.password);
                    var loginDataText = localStorage[$scope.openShift.loginDataKey];
                    if (loginDataText) {
                        log.debug("Loaded openshift login details: " + loginDataText);
                        var loginData = Wiki.parseJson(loginDataText);
                        if (loginData) {
                            angular.forEach(["domains", "gearProfiles"], function (key) {
                                var value = loginData[key];
                                if (value && angular.isArray(value) && value.length) {
                                    $scope.openShift[key] = value;
                                }
                            });
                        }
                    }
                }
                Forms.defaultValues($scope.entity, $scope.schema);
                $scope.allContainers = Fabric.getContainerIds(jolokia);
                if ($scope.selectedProvider.id === 'child') {
                    var rootContainers = Fabric.getRootContainers(jolokia);
                    $scope.child.rootContainers = rootContainers;
                    if (rootContainers && rootContainers.length === 1 && !$scope.entity["parent"]) {
                        $scope.entity["parent"] = rootContainers[0];
                    }
                    Core.pathSet($scope.entity, ['jmxUser'], userDetails.username);
                    Core.pathSet($scope.entity, ['jmxPassword'], userDetails.password);
                }
                else {
                    if ('parent' in $scope.entity) {
                        delete $scope.entity["parent"];
                    }
                }
                window.setTimeout(function () {
                    $('input[ng-model]').trigger('input');
                }, 100);
            }
        }, true);
        $scope.$watch('versions', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (!$scope.selectedVersion) {
                    if ($scope.selectedVersionId !== '') {
                        $scope.selectedVersion = $scope.versions.find(function (v) {
                            return v.id === $scope.selectedVersionId;
                        });
                    }
                    else {
                        $scope.selectedVersion = $scope.versions.find(function (v) {
                            return v.defaultVersion;
                        });
                    }
                }
            }
        });
        $scope.$watch('selectedVersion', function (newValue, oldValue) {
            if (oldValue !== newValue) {
                if (newValue && 'id' in newValue) {
                    $scope.selectedVersionId = newValue['id'];
                    $location.search('versionId', $scope.selectedVersionId);
                }
            }
        }, true);
        $scope.deselect = function (profile) {
            profile.selected = false;
            $scope.selectedProfiles.remove(function (p) {
                return p.id === profile.id;
            });
        };
        $scope.$watch('selectedProfiles', function (newValue, oldValue) {
            if (oldValue !== newValue) {
                log.debug("selectedProfiles: ", $scope.selectedProfiles);
                if ($scope.selectedProfiles.length > 0) {
                    $scope.selectedProfileIds = $scope.selectedProfiles.map(function (p) {
                        return p.id;
                    }).join(',');
                }
                else {
                    $scope.selectedProfileIds = "";
                }
                log.debug("selectedProfileIds: ", $scope.selectedProfileIds);
            }
        }, true);
        $scope.$watch('selectedProfileIds', function (newValue, oldValue) {
            if (Core.isBlank($scope.selectedProfileIds)) {
                $scope.selectedProfiles.length = 0;
                $location.search('profileIds', null);
            }
            else {
                var profileIds = $scope.selectedProfileIds.split(',');
                var selected = [];
                profileIds.each(function (id) {
                    selected.push({
                        id: id,
                        selected: true
                    });
                });
                $scope.selectedProfiles = selected;
                $location.search('profileIds', $scope.selectedProfileIds);
            }
        });
        $scope.massage = function (str) {
            if (str === 'name') {
                return 'containerName';
            }
            return str;
        };
        $scope.rootContainers = function () {
            return Fabric.getRootContainers(jolokia);
        };
        $scope.init = function () {
            var tab = $location.search()['tab'];
            if (tab) {
                $scope.selectedProvider = $scope.providers[tab];
            }
            var parentId = $location.search()['parentId'];
            if (parentId) {
                $scope.entity['parent'] = parentId;
            }
            var versionId = $location.search()['versionId'];
            if (versionId) {
                $scope.selectedVersion = {
                    id: versionId
                };
            }
            else if (ProfileCart.length > 0) {
                $scope.selectedVersion = {
                    id: ProfileCart.first().versionId
                };
            }
            var profileIds = $location.search()['profileIds'];
            if (profileIds) {
                $scope.selectedProfileIds = profileIds;
            }
            else if (ProfileCart.length > 0) {
                $scope.selectedProfileIds = ProfileCart.map(function (p) {
                    return p.id;
                }).join(',');
            }
            var count = $location.search()['number'];
            if (count) {
                $scope.entity.number = count;
            }
        };
        $scope.init();
        $scope.$on('$routeUpdate', $scope.init);
        function savePropertiesInLocalStorage() {
            var providerId = $scope.entity['providerType'];
            var properties = localStorageProperties[providerId];
            angular.forEach(properties, function (value, key) {
                var entityValue = $scope.entity[key];
                if (entityValue) {
                    localStorage[value] = entityValue;
                }
            });
        }
        $scope.goBack = function () {
            var target = new URI($scope.returnTo);
            $location.path(target.path()).search(target.search(true));
        };
        $scope.goForward = function () {
            var target = new URI($scope.nextPage);
            $location.path(target.path()).search(target.search(true));
        };
        $scope.onSubmit = function (json, form) {
            var providerId = $scope.entity['providerType'];
            json = Fabric.sanitizeJson(json);
            if (json.number === 1) {
                delete json.number;
            }
            var selectedVersion = $scope.selectedVersion;
            if (selectedVersion) {
                json['version'] = selectedVersion.id;
            }
            if ($scope.selectedProfiles.length > 0) {
                json['profiles'] = $scope.selectedProfiles.map(function (p) {
                    return p.id;
                });
            }
            var createJson = angular.toJson(json);
            log.debug("createContainers json:\n" + createJson);
            setTimeout(function () {
                jolokia.execute(Fabric.managerMBean, 'createContainers(java.util.Map)', createJson, {
                    method: "post",
                    success: function (response) {
                        log.debug("Response from creating container(s): ", response);
                        var error = false;
                        if ('<not available>' in response) {
                            var message = response['<not available>'];
                            if (message.toLowerCase().has('exception')) {
                                error = true;
                                var cont = "container";
                                if (json.number) {
                                    cont = Core.maybePlural(json.number, "container");
                                }
                                Core.notification('error', "Creating " + cont + " failed: " + message);
                            }
                        }
                        var text = response[json.name];
                        if (text && text.toLowerCase().has('already exists')) {
                            error = true;
                            Core.notification('error', "Creating container " + json.name + " failed as a container with that name already exists.");
                        }
                        angular.forEach(response.value, function (value, key) {
                            error = true;
                            Core.notification('error', "Creating container " + key + " failed: " + value);
                        });
                        if (!error) {
                            SelectionHelpers.clearGroup(ProfileCart);
                            Core.notification('success', "Successfully created containers");
                        }
                        Core.$apply($scope);
                    },
                    error: function (response) {
                        Core.notification('error', "Error creating containers: " + response.error);
                        Core.$apply($scope);
                    }
                });
                Core.$apply($scope);
            }, 10);
            $scope.goForward();
        };
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.CreateFabricController", ["$scope", "jolokia", "$location", "workspace", "branding", function ($scope, jolokia, $location, workspace, branding) {
        $scope.$on('$routeChangeSuccess', function () {
            if (workspace.treeContainsDomainAndProperties(Fabric.jmxDomain, { type: "Fabric" })) {
                $location.url("/fabric/view");
            }
        });
        Fabric.getSchema('createEnsemble', 'io.fabric8.api.CreateEnsembleOptions', jolokia, function (schema) {
            $scope.schema = schema;
            Core.$apply($scope);
        });
        $scope.creating = false;
        $scope.entity = {
            zooKeeperServerPort: 2181,
            globalResolver: 'localhostname',
            resolver: 'localhostname',
            agentEnabled: true,
            autoImportEnabled: true,
            minimumPort: 0,
            maximumPort: 65535,
            profiles: ['fabric', 'hawtio']
        };
        if (branding.profile) {
            $scope.entity.profiles.push(branding.profile);
        }
        $scope.forms = {};
        $scope.onSubmit = function (json, form) {
            json = Fabric.sanitizeJson(json);
            setTimeout(function () {
                jolokia.execute(Fabric.clusterBootstrapManagerMBean, 'createCluster(java.util.Map)', angular.toJson(json), {
                    method: 'post',
                    success: function (response) {
                        Core.notification('success', "Created fabric!");
                        $location.url("/fabric/containers");
                        Core.$apply($scope);
                    },
                    error: function (response) {
                        Core.notification('error', "Error creating fabric: " + response.error);
                        Core.$apply($scope);
                    }
                });
                Core.notification('info', "Creating fabric, please wait...");
                $location.url("/openlogs");
                Core.$apply($scope);
            }, 30);
        };
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.FeatureEditController", ["$scope", "$routeParams", "$location", "jolokia", "xml2json", "workspace", function ($scope, $routeParams, $location, jolokia, xml2json, workspace) {
        Fabric.initScope($scope, $location, jolokia, workspace);
        SelectionHelpers.decorate($scope);
        $scope.getProfileFeaturesOp = "getProfileFeatures(java.lang.String, java.lang.String)";
        $scope.versionId = $routeParams.versionId;
        $scope.profileId = $routeParams.profileId;
        $scope.features = [];
        $scope.selectedRepoFeatures = [];
        $scope.deletingFeatures = [];
        $scope.addingFeatures = [];
        $scope.selectedRepoSelectedFeatures = [];
        $scope.featureGridOptions = {
            data: 'selectedRepoFeatures',
            selectedItems: $scope.selectedRepoSelectedFeatures,
            displayFooter: false,
            showFilter: false,
            keepLastSelected: true,
            showSelectionCheckbox: true,
            filterOptions: {
                filterText: ''
            },
            columnDefs: [
                {
                    field: 'name',
                    displayName: 'Name'
                },
                {
                    field: 'version',
                    displayName: 'Version'
                }
            ]
        };
        $scope.filter = function (feature) {
            return FilterHelpers.searchObject(feature, $scope.featureGridOptions.filterOptions.filterText, 2);
        };
        $scope.$watch('features', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.parentFeatures = $scope.features.filter(function (f) {
                    return f.isParentFeature;
                });
                $scope.profileFeatures = $scope.features.filter(function (f) {
                    return !f.isParentFeature;
                });
                $scope.addingFeatures = $scope.features.filter(function (f) {
                    return f.adding;
                });
                $scope.deletingFeatures = $scope.features.filter(function (f) {
                    return f.deleting;
                });
            }
        }, true);
        $scope.$watch('addingFeatures', function (newValue, oldValue) {
            if (newValue !== oldValue) {
            }
        }, true);
        $scope.getClass = function (feature) {
            if (feature.adding) {
                return "adding";
            }
            if (feature.deleting) {
                return "deleting";
            }
            return "";
        };
        $scope.removeFeature = function (feature) {
            if (feature.adding) {
                $scope.features.remove(function (f) {
                    return f.id === feature.id;
                });
            }
            else {
                feature.deleting = !feature.deleting;
            }
        };
        $scope.addSelectedFeatures = function (withVersion) {
            $scope.selectedRepoSelectedFeatures.forEach(function (feature) {
                var id = feature.name;
                if (withVersion) {
                    id = id + "/" + feature.version;
                }
                $scope.features.push({
                    id: id,
                    adding: true
                });
            });
        };
        $scope.save = function () {
            jolokia.request({
                type: 'exec',
                mbean: Fabric.managerMBean,
                operation: 'getConfigurationFile(java.lang.String, java.lang.String, java.lang.String)',
                arguments: [$scope.versionId, $scope.profileId, 'io.fabric8.agent.properties']
            }, onSuccess($scope.doSave));
        };
        $scope.doSave = function (response) {
            var configFile = response.value.decodeBase64();
            var lines = configFile.lines();
            if ($scope.deletingFeatures.length > 0) {
                $scope.deletingFeatures.each(function (feature) {
                    lines.remove(function (line) {
                        return line.startsWith("feature." + feature.id);
                    });
                });
            }
            if ($scope.addingFeatures.length > 0) {
                $scope.addingFeatures.each(function (feature) {
                    lines.add("feature." + feature.id + " = " + feature.id);
                });
            }
            configFile = lines.join('\n');
            Fabric.saveConfigFile(jolokia, $scope.versionId, $scope.profileId, 'io.fabric8.agent.properties', configFile.encodeBase64(), function () {
                Core.notification('success', "Updated feature definitions...");
                Core.$apply($scope);
            });
        };
        $scope.selectFeature = function (feature, $event) {
            SelectionHelpers.select($scope.selectedRepoFeatures, feature, $event);
            $scope.selectedRepoSelectedFeatures = $scope.selectedRepoFeatures.filter(function (f) { return SelectionHelpers.isSelected(f); });
        };
        Core.registerForChanges(jolokia, $scope, {
            type: 'exec',
            mbean: Fabric.managerMBean,
            operation: $scope.getProfileFeaturesOp,
            arguments: [$scope.versionId, $scope.profileId]
        }, function (response) {
            $scope.features = response.value.featureDefinitions;
            var repositories = response.value.repositoryDefinitions;
            var selectedRepoFeatures = [];
            repositories.forEach(function (repo) {
                var repoJson = xml2json(repo['data']);
                if ('feature' in repoJson) {
                    var features = repoJson['feature'];
                    if (!angular.isArray(features)) {
                        features = [features];
                    }
                    selectedRepoFeatures = selectedRepoFeatures.include(features);
                }
            });
            $scope.selectedRepoSelectedFeatures = SelectionHelpers.sync($scope.selectedRepoSelectedFeatures, selectedRepoFeatures, 'id');
            $scope.selectedRepoFeatures = selectedRepoFeatures.sortBy('name');
            Core.$apply($scope);
        });
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.directive('fabricVersionSelector', ["$templateCache", function ($templateCache) {
        return Fabric.VersionSelector($templateCache);
    }]);
    Fabric._module.directive('fabricProfileSelector', function () {
        return new Fabric.ProfileSelector();
    });
    Fabric._module.directive('fabricContainerList', function () {
        return {
            restrict: 'A',
            replace: true,
            templateUrl: Fabric.templatePath + "containerList.html",
            scope: false,
            controller: ["$scope", "$element", "$attrs", "jolokia", "$location", "workspace", "$templateCache", Fabric.ContainerListDirectiveController],
            link: ["$scope", "$element", "$attrs", Fabric.ContainerListDirectiveLink]
        };
    });
    Fabric._module.directive('fabricProfileDetails', function () {
        return new Fabric.ProfileDetails();
    });
    Fabric._module.directive('fabricActiveProfileList', function () {
        return {
            restrict: 'A',
            replace: true,
            templateUrl: Fabric.templatePath + "activeProfileList.html",
            scope: false,
            controller: ["$scope", "$element", "$attrs", "jolokia", "$location", "workspace", "$templateCache", "$timeout", Fabric.ActiveProfileListController],
            link: ["$scope", "$element", "$attrs", Fabric.ContainerListDirectiveLink]
        };
    });
    Fabric._module.directive('fabricProfileLink', ["workspace", "jolokia", "localStorage", function (workspace, jolokia, localStorage) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attrs) {
                var profileId = $attrs['fabricProfileLink'];
                if (profileId && !profileId.isBlank() && Fabric.fabricCreated(workspace)) {
                    var container = Fabric.getCurrentContainer(jolokia, ['versionId']);
                    var versionId = container['versionId'];
                    if (versionId && !versionId.isBlank()) {
                        var url = '#' + Fabric.profileLink(workspace, jolokia, localStorage, versionId, profileId);
                        if (angular.isDefined($attrs['file'])) {
                            url = url + "/" + $attrs['file'];
                        }
                        $element.attr('href', url);
                    }
                }
            }
        };
    }]);
    Fabric._module.directive('fabricContainers', ["$location", "jolokia", "workspace", "$compile", function ($location, jolokia, workspace, $compile) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attrs) {
                var model = $attrs['fabricContainers'];
                var profileId = $attrs['profile'];
                var version = $scope.versionId || $scope.version || "1.0";
                if (model && !model.isBlank() && profileId && !profileId.isBlank()) {
                    Fabric.initScope($scope, $location, jolokia, workspace);
                    var containerIds = Fabric.getContainerIdsForProfile(jolokia, version, profileId);
                    Fabric.log.info("Searching for containers for profile: " + profileId + " version " + version + ". Found: " + containerIds);
                    $scope[model] = containerIds;
                    $scope["onCancel"] = function () {
                        console.log("In our new cancel thingy!");
                    };
                    var dialog = $("<div ng-include=\"'app/fabric/html/connectToContainerDialog.html'\"></div>");
                    var answer = $compile(dialog)($scope);
                    $element.append(answer);
                }
            }
        };
    }]);
    Fabric._module.directive('fabricContainerLink', ["$location", "jolokia", "workspace", function ($location, jolokia, workspace) {
        return {
            restrict: 'A',
            scope: { containerModel: '@fabricContainerLink' },
            link: function ($scope, $element, $attrs) {
                $scope.$watch("containerModel", function (nv) {
                    var modelName = $scope.containerModel;
                    var containerId = modelName;
                    var container = null;
                    if (modelName && !modelName.isBlank()) {
                        var modelValue = Core.pathGet($scope, modelName);
                        if (angular.isObject(modelValue)) {
                            var id = modelValue["container"] || modelValue["containerId"] || modelValue["id"];
                            if (id && modelValue["provisionResult"]) {
                                container = modelValue;
                                containerId = id;
                            }
                        }
                        if (!container) {
                            var fields = ["alive", "provisionResult", "versionId", "jmxDomains"];
                            container = Fabric.getContainerFields(jolokia, containerId, fields);
                        }
                        var link = "#/fabric/container/" + containerId;
                        var title = Fabric.statusTitle(container) || "container " + containerId;
                        var icon = Fabric.statusIcon(container) || "";
                        var html = "<a href='" + link + "' title='" + title + "'><i class='" + icon + "'></i> " + containerId + "</a>";
                        $element.html(html);
                    }
                    else {
                        $element.html(" ");
                    }
                });
            }
        };
    }]);
    Fabric._module.directive('fabricContainerConnect', ["$location", "jolokia", function ($location, jolokia) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attrs) {
                var containerId = $attrs['fabricContainerConnect'];
                var view = $attrs['view'];
                if (containerId && !containerId.isBlank()) {
                    var fields = ["jolokiaUrl"];
                    var connectFn = function () {
                        var container = Fabric.getContainerFields(jolokia, containerId, fields);
                        Fabric.log.info("Connecting to container id " + containerId + " view + " + view);
                        container["id"] = containerId;
                        $scope.doConnect(container, view);
                        Core.$apply($scope);
                    };
                    $element.on("click", connectFn);
                }
            }
        };
    }]);
    Fabric._module.directive('fabricVersionLink', ["workspace", "jolokia", "localStorage", function (workspace, jolokia, localStorage) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attrs) {
                var versionLink = $attrs['fabricVersionLink'];
                if (versionLink && !versionLink.isBlank() && Fabric.fabricCreated(workspace)) {
                    var container = Fabric.getCurrentContainer(jolokia, ['versionId']);
                    var versionId = container['versionId'] || "1.0";
                    if (versionId && !versionId.isBlank()) {
                        var url = "#/wiki/branch/" + versionId + "/" + Core.trimLeading(versionLink, "/");
                        $element.attr('href', url);
                    }
                }
            }
        };
    }]);
    Fabric._module.directive('containerNameAvailable', ["workspace", "jolokia", "localStorage", function (workspace, jolokia, localStorage) {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function ($scope, $element, $attrs, $ctrl) {
                $ctrl.$parsers.unshift(function (viewValue) {
                    var found = $scope.child.rootContainers.indexOf(viewValue);
                    if (found === -1) {
                        found = $scope.allContainers.indexOf(viewValue);
                    }
                    if (found !== -1) {
                        $ctrl.$setValidity('taken', false);
                        return undefined;
                    }
                    else {
                        $ctrl.$setValidity('taken', true);
                        return viewValue;
                    }
                });
            }
        };
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric.TopLevelController = Fabric._module.controller("Fabric.TopLevelController", ['$scope', function ($scope) {
        $scope.managerMBean = Fabric.managerMBean;
        $scope.clusterBootstrapManagerMBean = Fabric.clusterBootstrapManagerMBean;
        $scope.clusterManagerMBean = Fabric.clusterManagerMBean;
        $scope.openShiftFabricMBean = Fabric.openShiftFabricMBean;
        $scope.mqManagerMBean = Fabric.mqManagerMBean;
        $scope.healthMBean = Fabric.healthMBean;
        $scope.schemaLookupMBean = Fabric.schemaLookupMBean;
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric.startMaps = function () {
    };
    Fabric._module.controller("Fabric.MapController", ["$scope", "$templateCache", "jolokia", function ($scope, $templateCache, jolokia) {
        $scope.myMarkers = [];
        $scope.containers = {};
        $scope.template = "";
        $scope.first = true;
        $scope.myMap = null;
        $scope.start = function () {
            $scope.mapOptions = {
                center: new google.maps.LatLng(35.784, -78.670),
                zoom: 15,
                mapTypeId: google.maps.MapTypeId.ROADMAP
            };
            Core.register(jolokia, $scope, {
                type: 'exec',
                mbean: Fabric.managerMBean,
                operation: 'containers()',
                arguments: []
            }, onSuccess(render));
        };
        Fabric.startMaps = $scope.start;
        $('body').append('<script type="text/javascript" src="//maps.google.com/maps/api/js?sensor=false&async=2&callback=Fabric.startMaps"></script>');
        function render(response) {
            if (response && response.value) {
                response.value.forEach(function (container) {
                    var addMarker = false;
                    var id = container.id;
                    var containerData = $scope.containers[id];
                    if (!containerData) {
                        containerData = {
                            name: id,
                        };
                        $scope.containers[id] = containerData;
                        addMarker = true;
                    }
                    containerData.alive = container.alive;
                    containerData.version = container.versionId;
                    containerData.profileIds = container.profileIds;
                    var geoLocation = container["geoLocation"];
                    if (geoLocation) {
                        var values = geoLocation.split(",");
                        if (values.length >= 2) {
                            var lattitude = Core.parseFloatValue(values[0], "lattitude");
                            var longitude = Core.parseFloatValue(values[1], "longitude");
                            if (lattitude && longitude) {
                                if ($scope.myMap) {
                                    var marker = containerData.marker;
                                    if (addMarker || !marker) {
                                        Fabric.log.info("Adding marker as we have map " + $scope.myMap);
                                        marker = new google.maps.Marker({
                                            position: new google.maps.LatLng(lattitude, longitude),
                                            map: $scope.myMap,
                                            title: container.id,
                                            tooltip: "(lattitude: " + lattitude + ", longitude: " + longitude + ")"
                                        });
                                        containerData.marker = marker;
                                        $scope.myMarkers.push(marker);
                                    }
                                }
                                else {
                                    if (containerData.marker) {
                                        containerData.marker.position = new google.maps.LatLng(lattitude, longitude);
                                    }
                                }
                                containerData.lattitude = lattitude;
                                containerData.longitude = longitude;
                            }
                        }
                    }
                });
                if ($scope.myMarkers.length > 0 && $scope.first) {
                    if ($scope.myMap) {
                        var marker = $scope.myMarkers[0];
                        Fabric.log.info("Auto selecting first container on map: " + marker.title);
                        $scope.myMap.panTo(marker.getPosition());
                        $scope.first = false;
                    }
                }
                $scope.template = $templateCache.get("pageTemplate");
                Core.$apply($scope);
            }
        }
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.MigrateContainersController", ["$scope", "jolokia", "$location", function ($scope, jolokia, $location) {
        $scope.versions = [];
        $scope.containers = [];
        $scope.containersResponse = [];
        $scope.selectedVersion = [];
        $scope.selectedContainers = [];
        $scope.showApply = false;
        $scope.versionGridOptions = {
            data: 'versions',
            selectedItems: $scope.selectedVersion,
            showSelectionCheckbox: true,
            multiSelect: false,
            keepLastSelected: true,
            columnDefs: [{
                field: 'id',
                displayName: 'Version Name',
                width: '94%'
            }],
            filterOptions: {
                filterText: ''
            }
        };
        $scope.containerGridOptions = {
            data: 'containers',
            selectedItems: $scope.selectedContainers,
            showSelectionCheckbox: true,
            multiSelect: true,
            keepLastSelected: false,
            columnDefs: [{
                field: 'id',
                displayName: 'Container Name',
                width: '94%'
            }],
            filterOptions: {
                filterText: ''
            }
        };
        $scope.canApply = function () {
            return !($scope.selectedVersion.length > 0 && $scope.selectedContainers.length > 0);
        };
        $scope.render = function (response) {
            if (response.request.operation === 'versions()') {
                if (!Object.equal($scope.versions, response.value)) {
                    $scope.versions = response.value;
                    Core.$apply($scope);
                }
            }
            if (response.request.operation === 'containerIds()') {
                if (!Object.equal($scope.containersResponse, response.value)) {
                    $scope.containersResponse = response.value;
                    $scope.containers = [];
                    $scope.containersResponse.each(function (container) {
                        $scope.containers.push({
                            id: container
                        });
                    });
                    Core.$apply($scope);
                }
            }
        };
        $scope.migrateContainers = function () {
            var containerIds = $scope.selectedContainers.map(function (container) {
                return container.id;
            });
            var versionId = $scope.selectedVersion[0].id;
            Core.notification('info', "Moving containers to version " + versionId);
            $location.path("/fabric/containers");
            Fabric.migrateContainers(jolokia, versionId, containerIds, function () {
                Core.notification('success', "Successfully migrated containers");
            }, function (response) {
                Core.notification('error', "Failed to migrate containers due to " + response.error);
            });
        };
        Core.register(jolokia, $scope, [
            { type: 'exec', mbean: Fabric.managerMBean, operation: 'versions()' },
            { type: 'exec', mbean: Fabric.managerMBean, operation: 'containerIds()' }
        ], onSuccess($scope.render));
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.NavBarController", ["$scope", "$location", "jolokia", "workspace", "localStorage", function ($scope, $location, jolokia, workspace, localStorage) {
        $scope.activeVersion = "1.0";
        $scope.mapsEnabled = localStorage['fabricEnableMaps'];
        $scope.$on('$routeUpdate', reloadVersion);
        $scope.isActive = function (href) {
            return workspace.isLinkActive(href);
        };
        $scope.clusterLink = function () {
            return Core.createHref($location, "#/fabric/clusters/fabric/registry/clusters", ["cv", "cp", "pv"]);
        };
        function reloadVersion() {
            $scope.activeVersion = Fabric.getActiveVersion($location);
        }
        function reloadData() {
            reloadVersion();
            $scope.hasFabric = Fabric.hasFabric(workspace);
            $scope.hasMQManager = Fabric.hasMQManager(workspace);
            if ($scope.hasFabric) {
                var containerId = null;
                Fabric.containerWebAppURL(jolokia, "drools-wb-distribution-wars", containerId, onDroolsUrl, onDroolsUrl);
                $scope.canUpload = workspace.treeContainsDomainAndProperties('hawtio', { type: 'UploadManager' });
            }
        }
        reloadData();
        function onDroolsUrl(response) {
            var url = response ? response.value : null;
            console.log("========== onDroolsUrl: " + url);
            $scope.droolsHref = url;
            Core.$apply($scope);
        }
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.PatchingController", ["$scope", "jolokia", "localStorage", "$location", function ($scope, jolokia, localStorage, $location) {
        $scope.files = [];
        $scope.targetVersion = $location.search()['versionId'];
        $scope.newVersionName = '';
        $scope.proxyUser = localStorage['fabric.userName'];
        $scope.proxyPassword = localStorage['fabric.password'];
        $scope.saveJmxCredentials = false;
        $scope.cancel = function () {
            $location.url('wiki/branch/default-version/view/fabric/profiles');
        };
        $scope.valid = function () {
            return $scope.files && $scope.files.length > 0 && $scope.targetVersion !== null && $scope.proxyUser && $scope.proxyPassword;
        };
        $scope.go = function () {
            var message = $scope.files.length + ' patches';
            if ($scope.files.length === 1) {
                message = "patch: " + $scope.files[0].fileName;
            }
            Core.notification('info', "Applying " + message);
            if ($scope.saveJmxCredentials) {
                localStorage['fabric.userName'] = $scope.proxyUser;
                localStorage['fabric.password'] = $scope.proxyPassword;
            }
            var files = $scope.files.map(function (file) {
                return file.absolutePath;
            });
            Fabric.applyPatches(jolokia, files, $scope.targetVersion, $scope.newVersionName, $scope.proxyUser, $scope.proxyPassword, function () {
                Core.notification('success', "Successfully applied " + message);
                $location.url("/fabric/view");
                Core.$apply($scope);
            }, function (response) {
                Fabric.log.error("Failed to apply ", message, " due to ", response.error);
                Fabric.log.info("Stack trace: ", response.stacktrace);
                Core.$apply($scope);
            });
        };
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.PIDController", ["$scope", "$routeParams", "jolokia", "$location", function ($scope, $routeParams, jolokia, $location) {
        $scope.versionId = $routeParams.versionId;
        $scope.profileId = $routeParams.profileId;
        $scope.fname = $routeParams.fname;
        $scope.response = undefined;
        $scope.data = "";
        $scope.dirty = false;
        $scope.getMode = function () {
            var parts = $scope.fname.split('.');
            var mode = parts[parts.length - 1];
            if (!mode) {
                return 'text';
            }
            switch (mode) {
                case 'cfg':
                    mode = "properties";
                    break;
            }
            return mode;
        };
        $scope.mode = $scope.getMode();
        if (angular.isDefined($scope.versionId) && angular.isDefined($scope.profileId) && angular.isDefined($scope.fname)) {
            Core.register(jolokia, $scope, {
                type: 'exec',
                mbean: Fabric.managerMBean,
                operation: 'getConfigurationFile(java.lang.String,java.lang.String,java.lang.String)',
                arguments: [$scope.versionId, $scope.profileId, $scope.fname]
            }, onSuccess(render));
        }
        $scope.save = function () {
            Fabric.saveConfigFile(jolokia, $scope.versionId, $scope.profileId, $scope.fname, $scope.data.encodeBase64(), function () {
                $scope.dirty = false;
                Core.notification('success', "Saved " + $scope.fname);
                $location.path("/fabric/profile/" + $scope.versionId + "/" + $scope.profileId);
            }, function (response) {
                Core.notification('error', "Failed to save " + $scope.fname + " due to " + response.error);
            });
        };
        function stringToBytes(s) {
            return s.codes();
        }
        function bytesToString(b) {
            var answer = [];
            b.forEach(function (b) {
                answer.push(String.fromCharCode(b));
            });
            return answer.join('');
        }
        function render(response) {
            if (!Object.equal($scope.response, response.value)) {
                $scope.response = response.value;
                $scope.data = $scope.response.decodeBase64();
                $scope.mode = $scope.getMode();
                Core.$apply($scope);
            }
        }
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.PreferencesController", ["$scope", "localStorage", function ($scope, localStorage) {
        Core.initPreferenceScope($scope, localStorage, {
            'fabricAlwaysPrompt': {
                'value': false,
                'converter': Core.parseBooleanValue
            },
            'fabricEnableMaps': {
                'value': true,
                'converter': Core.parseBooleanValue
            },
            'fabricVerboseNotifications': {
                'value': true,
                'converter': Core.parseBooleanValue
            }
        });
    }]);
})(Fabric || (Fabric = {}));
var Osgi;
(function (Osgi) {
    Osgi.log = Logger.get("OSGi");
    function defaultBundleValues(workspace, $scope, values) {
        var allValues = values;
        angular.forEach(values, function (row) {
            row["ImportData"] = parseActualPackages(row["ImportedPackages"]);
            row["ExportData"] = parseActualPackages(row["ExportedPackages"]);
            row["IdentifierLink"] = bundleLinks(workspace, row["Identifier"]);
            row["Hosts"] = labelBundleLinks(workspace, row["Hosts"], allValues);
            row["Fragments"] = labelBundleLinks(workspace, row["Fragments"], allValues);
            row["ImportedPackages"] = row["ImportedPackages"].union([]);
            row["StateStyle"] = getStateStyle("label", row["State"]);
            row["RequiringBundles"] = labelBundleLinks(workspace, row["RequiringBundles"], allValues);
        });
        return values;
    }
    Osgi.defaultBundleValues = defaultBundleValues;
    function getStateStyle(prefix, state) {
        switch (state) {
            case "INSTALLED":
                return prefix + "-important";
            case "RESOLVED":
                return prefix + "-inverse";
            case "STARTING":
                return prefix + "-warning";
            case "ACTIVE":
                return prefix + "-success";
            case "STOPPING":
                return prefix + "-info";
            case "UNINSTALLED":
                return "";
            default:
                return prefix + "-important";
        }
    }
    Osgi.getStateStyle = getStateStyle;
    function defaultServiceValues(workspace, $scope, values) {
        angular.forEach(values, function (row) {
            row["BundleIdentifier"] = bundleLinks(workspace, row["BundleIdentifier"]);
        });
        return values;
    }
    Osgi.defaultServiceValues = defaultServiceValues;
    function defaultPackageValues(workspace, $scope, values) {
        var packages = [];
        function onPackageEntry(packageEntry, row) {
            if (!row)
                row = packageEntry;
            var name = packageEntry["Name"];
            var version = packageEntry["Version"];
            if (name && !name.startsWith("#")) {
                packageEntry["VersionLink"] = "<a href='" + Core.url("#/osgi/package/" + name + "/" + version + workspace.hash()) + "'>" + version + "</a>";
                var importingBundles = row["ImportingBundles"] || packageEntry["ImportingBundles"];
                var exportingBundles = row["ExportingBundles"] || packageEntry["ExportingBundles"];
                packageEntry["ImportingBundleLinks"] = bundleLinks(workspace, importingBundles);
                packageEntry["ImportingBundleLinks"] = bundleLinks(workspace, importingBundles);
                packageEntry["ExportingBundleLinks"] = bundleLinks(workspace, exportingBundles);
                packages.push(packageEntry);
            }
        }
        var childValues = values.values;
        if (childValues) {
            angular.forEach(childValues, onPackageEntry);
        }
        angular.forEach(values, function (row) {
            angular.forEach(row, function (version) {
                angular.forEach(version, function (packageEntry) {
                    onPackageEntry(packageEntry, row);
                });
            });
        });
        return packages;
    }
    Osgi.defaultPackageValues = defaultPackageValues;
    function defaultConfigurationValues(workspace, $scope, values) {
        var array = [];
        angular.forEach(values, function (row) {
            var map = {};
            map["Pid"] = row[0];
            map["PidLink"] = "<a href='" + Core.url("#/osgi/pid/" + row[0] + workspace.hash()) + "'>" + row[0] + "</a>";
            map["Bundle"] = row[1];
            array.push(map);
        });
        return array;
    }
    Osgi.defaultConfigurationValues = defaultConfigurationValues;
    function parseActualPackages(packages) {
        var result = {};
        for (var i = 0; i < packages.length; i++) {
            var pkg = packages[i];
            var idx = pkg.indexOf(";");
            if (idx > 0) {
                var name = pkg.substring(0, idx);
                var ver = pkg.substring(idx + 1);
                var data = result[name];
                if (data === undefined) {
                    data = {};
                    result[name] = data;
                }
                data["ReportedVersion"] = ver;
            }
        }
        return result;
    }
    Osgi.parseActualPackages = parseActualPackages;
    function parseManifestHeader(headers, name) {
        var result = {};
        var data = {};
        var hdr = headers[name];
        if (hdr === undefined) {
            return result;
        }
        var ephdr = hdr.Value;
        var inPkg = true;
        var inQuotes = false;
        var pkgName = "";
        var daDecl = "";
        for (var i = 0; i < ephdr.length; i++) {
            var c = ephdr[i];
            if (c === '"') {
                inQuotes = !inQuotes;
                continue;
            }
            if (inQuotes) {
                daDecl += c;
                continue;
            }
            if (c === ';') {
                if (inPkg) {
                    inPkg = false;
                }
                else {
                    handleDADecl(data, daDecl);
                    daDecl = "";
                }
                continue;
            }
            if (c === ',') {
                handleDADecl(data, daDecl);
                result[pkgName] = data;
                data = {};
                pkgName = "";
                daDecl = "";
                inPkg = true;
                continue;
            }
            if (inPkg) {
                pkgName += c;
            }
            else {
                daDecl += c;
            }
        }
        handleDADecl(data, daDecl);
        result[pkgName] = data;
        return result;
    }
    Osgi.parseManifestHeader = parseManifestHeader;
    function handleDADecl(data, daDecl) {
        var didx = daDecl.indexOf(":=");
        if (didx > 0) {
            data["D" + daDecl.substring(0, didx)] = daDecl.substring(didx + 2);
            return;
        }
        var aidx = daDecl.indexOf("=");
        if (aidx > 0) {
            data["A" + daDecl.substring(0, aidx)] = daDecl.substring(aidx + 1);
            return;
        }
    }
    function toCollection(values) {
        var collection = values;
        if (!angular.isArray(values)) {
            collection = [values];
        }
        return collection;
    }
    Osgi.toCollection = toCollection;
    function labelBundleLinks(workspace, values, allValues) {
        var answer = "";
        var sorted = toCollection(values).sort(function (a, b) {
            return a - b;
        });
        angular.forEach(sorted, function (value, key) {
            var prefix = "";
            if (answer.length > 0) {
                prefix = " ";
            }
            var info = allValues[value] || {};
            var labelText = info.SymbolicName;
            answer += prefix + "<a class='label' href='" + Core.url("#/osgi/bundle/" + value + workspace.hash()) + "'>" + labelText + "</a>";
        });
        return answer;
    }
    Osgi.labelBundleLinks = labelBundleLinks;
    function bundleLinks(workspace, values) {
        var answer = "";
        var sorted = toCollection(values).sort(function (a, b) {
            return a - b;
        });
        angular.forEach(sorted, function (value, key) {
            var prefix = "";
            if (answer.length > 0) {
                prefix = " ";
            }
            answer += prefix + "<a class='label' href='" + Core.url("#/osgi/bundle/" + value + workspace.hash()) + "'>" + value + "</a>";
        });
        return answer;
    }
    Osgi.bundleLinks = bundleLinks;
    function pidLinks(workspace, values) {
        var answer = "";
        angular.forEach(toCollection(values), function (value, key) {
            var prefix = "";
            if (answer.length > 0) {
                prefix = " ";
            }
            answer += prefix + "<a href='" + Core.url("#/osgi/bundle/" + value + workspace.hash()) + "'>" + value + "</a>";
        });
        return answer;
    }
    Osgi.pidLinks = pidLinks;
    function findBundle(bundleId, values) {
        var answer = "";
        angular.forEach(values, function (row) {
            var id = row["Identifier"];
            if (bundleId === id.toString()) {
                answer = row;
                return answer;
            }
        });
        return answer;
    }
    Osgi.findBundle = findBundle;
    function getSelectionBundleMBean(workspace) {
        if (workspace) {
            var folder = workspace.tree.navigate("osgi.core", "bundleState");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionBundleMBean = getSelectionBundleMBean;
    function findFirstObjectName(node) {
        if (node) {
            var answer = node.objectName;
            if (answer) {
                return answer;
            }
            else {
                var children = node.children;
                if (children && children.length) {
                    return findFirstObjectName(children[0]);
                }
            }
        }
        return null;
    }
    Osgi.findFirstObjectName = findFirstObjectName;
    function getSelectionFrameworkMBean(workspace) {
        if (workspace) {
            var folder = workspace.tree.navigate("osgi.core", "framework");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionFrameworkMBean = getSelectionFrameworkMBean;
    function getSelectionServiceMBean(workspace) {
        if (workspace) {
            var folder = workspace.tree.navigate("osgi.core", "serviceState");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionServiceMBean = getSelectionServiceMBean;
    function getSelectionPackageMBean(workspace) {
        if (workspace) {
            var folder = workspace.tree.navigate("osgi.core", "packageState");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionPackageMBean = getSelectionPackageMBean;
    function getSelectionConfigAdminMBean(workspace) {
        if (workspace) {
            var folder = workspace.tree.navigate("osgi.compendium", "cm");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionConfigAdminMBean = getSelectionConfigAdminMBean;
    function getMetaTypeMBean(workspace) {
        if (workspace) {
            var mbeanTypesToDomain = workspace.mbeanTypesToDomain;
            var typeFolder = mbeanTypesToDomain["MetaTypeFacade"] || {};
            var mbeanFolder = typeFolder["io.fabric8"] || {};
            return mbeanFolder["objectName"];
        }
        return null;
    }
    Osgi.getMetaTypeMBean = getMetaTypeMBean;
    function getProfileMetadataMBean(workspace) {
        if (workspace) {
            var mbeanTypesToDomain = workspace.mbeanTypesToDomain;
            var typeFolder = mbeanTypesToDomain["ProfileMetadata"] || {};
            var mbeanFolder = typeFolder["io.fabric8"] || {};
            return mbeanFolder["objectName"];
        }
        return null;
    }
    Osgi.getProfileMetadataMBean = getProfileMetadataMBean;
    function getHawtioOSGiToolsMBean(workspace) {
        if (workspace) {
            var mbeanTypesToDomain = workspace.mbeanTypesToDomain;
            var toolsFacades = mbeanTypesToDomain["OSGiTools"] || {};
            var hawtioFolder = toolsFacades["hawtio"] || {};
            return hawtioFolder["objectName"];
        }
        return null;
    }
    Osgi.getHawtioOSGiToolsMBean = getHawtioOSGiToolsMBean;
    function getHawtioConfigAdminMBean(workspace) {
        if (workspace) {
            var mbeanTypesToDomain = workspace.mbeanTypesToDomain;
            var typeFolder = mbeanTypesToDomain["ConfigAdmin"] || {};
            var mbeanFolder = typeFolder["hawtio"] || {};
            return mbeanFolder["objectName"];
        }
        return null;
    }
    Osgi.getHawtioConfigAdminMBean = getHawtioConfigAdminMBean;
    function createConfigPidLink($scope, workspace, pid, isFactory) {
        if (isFactory === void 0) { isFactory = false; }
        return Core.url("#" + createConfigPidPath($scope, pid, isFactory) + workspace.hash());
    }
    Osgi.createConfigPidLink = createConfigPidLink;
    function createConfigPidPath($scope, pid, isFactory) {
        if (isFactory === void 0) { isFactory = false; }
        var link = pid;
        var versionId = $scope.versionId;
        var profileId = $scope.profileId;
        if (versionId && versionId) {
            var configPage = isFactory ? "/newConfiguration/" : "/configuration/";
            return "/wiki/branch/" + versionId + configPage + link + "/" + $scope.pageId;
        }
        else {
            return "/osgi/pid/" + link;
        }
    }
    Osgi.createConfigPidPath = createConfigPidPath;
    function initProfileScope($scope, $routeParams, $location, localStorage, jolokia, workspace, initFn) {
        if (initFn === void 0) { initFn = null; }
        Wiki.initScope($scope, $routeParams, $location);
        $scope.versionId = $routeParams.versionId || $scope.branch;
        $scope.profileId = $routeParams.profileId || Fabric.pagePathToProfileId($scope.pageId);
        if (!$scope.pageId) {
            $scope.pageId = Fabric.fabricTopLevel + Fabric.profilePath($scope.profileId);
        }
        if (!initFn) {
            initFn = function () { return null; };
        }
        var versionId = $scope.versionId;
        var profileId = $scope.profileId;
        $scope.profileNotRunning = false;
        $scope.profileMetadataMBean = null;
        if (versionId && profileId) {
            $scope.inFabricProfile = true;
            $scope.configurationsLink = "/wiki/branch/" + versionId + "/configurations/" + $scope.pageId;
            $scope.profileMetadataMBean = getProfileMetadataMBean(workspace);
            if ($scope.profileMetadataMBean) {
                $scope.profileNotRunning = true;
                $scope.jolokia = jolokia;
                $scope.workspace = workspace;
                initFn();
            }
            else {
                Fabric.profileJolokia(jolokia, profileId, versionId, function (profileJolokia) {
                    if (profileJolokia) {
                        $scope.jolokia = profileJolokia;
                        $scope.workspace = Core.createRemoteWorkspace(profileJolokia, $location, localStorage);
                    }
                    else {
                        $scope.jolokia = jolokia;
                        $scope.workspace = workspace;
                        $scope.profileNotRunning = true;
                        $scope.profileMetadataMBean = getProfileMetadataMBean(workspace);
                    }
                    initFn();
                });
            }
        }
        else {
            $scope.configurationsLink = "/osgi/configurations";
            $scope.jolokia = jolokia;
            $scope.workspace = workspace;
            initFn();
        }
    }
    Osgi.initProfileScope = initProfileScope;
    function getConfigurationProperties(workspace, jolokia, pid, onDataFn) {
        var mbean = getSelectionConfigAdminMBean(workspace);
        var answer = null;
        if (jolokia && mbean) {
            answer = jolokia.execute(mbean, 'getProperties', pid, onSuccess(onDataFn));
        }
        return answer;
    }
    Osgi.getConfigurationProperties = getConfigurationProperties;
    function removeFactoryPidPrefix(pid, factoryPid) {
        if (pid && factoryPid) {
            if (pid.startsWith(factoryPid)) {
                return pid.substring(factoryPid.length + 1);
            }
            var idx = factoryPid.lastIndexOf(".");
            if (idx > 0) {
                var prefix = factoryPid.substring(0, idx + 1);
                return Core.trimLeading(pid, prefix);
            }
        }
        return pid;
    }
    Osgi.removeFactoryPidPrefix = removeFactoryPidPrefix;
})(Osgi || (Osgi = {}));
var Maven;
(function (Maven) {
    Maven.log = Logger.get("Maven");
    function getMavenIndexerMBean(workspace) {
        if (workspace) {
            var mavenStuff = workspace.mbeanTypesToDomain["Indexer"] || {};
            var object = mavenStuff["hawtio"] || {};
            return object.objectName;
        }
        else
            return null;
    }
    Maven.getMavenIndexerMBean = getMavenIndexerMBean;
    function getAetherMBean(workspace) {
        if (workspace) {
            var mavenStuff = workspace.mbeanTypesToDomain["AetherFacade"] || {};
            var object = mavenStuff["hawtio"] || {};
            return object.objectName;
        }
        else
            return null;
    }
    Maven.getAetherMBean = getAetherMBean;
    function mavenLink(url) {
        var path = null;
        if (url) {
            if (url.startsWith("mvn:")) {
                path = url.substring(4);
            }
            else {
                var idx = url.indexOf(":mvn:");
                if (idx > 0) {
                    path = url.substring(idx + 5);
                }
            }
        }
        return path ? "#/maven/artifact/" + path : null;
    }
    Maven.mavenLink = mavenLink;
    function getName(row) {
        var id = (row.group || row.groupId) + "/" + (row.artifact || row.artifactId);
        if (row.version) {
            id += "/" + row.version;
        }
        if (row.classifier) {
            id += "/" + row.classifier;
        }
        if (row.packaging) {
            id += "/" + row.packaging;
        }
        return id;
    }
    Maven.getName = getName;
    function completeMavenUri($q, $scope, workspace, jolokia, query) {
        var mbean = getMavenIndexerMBean(workspace);
        if (!angular.isDefined(mbean)) {
            return $q.when([]);
        }
        var parts = query.split('/');
        if (parts.length === 1) {
            return Maven.completeGroupId(mbean, $q, $scope, workspace, jolokia, query, null, null);
        }
        if (parts.length === 2) {
            return Maven.completeArtifactId(mbean, $q, $scope, workspace, jolokia, parts[0], parts[1], null, null);
        }
        if (parts.length === 3) {
            return Maven.completeVersion(mbean, $q, $scope, workspace, jolokia, parts[0], parts[1], parts[2], null, null);
        }
        return $q.when([]);
    }
    Maven.completeMavenUri = completeMavenUri;
    function completeVersion(mbean, $q, $scope, workspace, jolokia, groupId, artifactId, partial, packaging, classifier) {
        var deferred = $q.defer();
        jolokia.request({
            type: 'exec',
            mbean: mbean,
            operation: 'versionComplete(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)',
            arguments: [groupId, artifactId, partial, packaging, classifier]
        }, {
            method: 'POST',
            success: function (response) {
                $scope.$apply(function () {
                    deferred.resolve(response.value.sortBy().first(15));
                });
            },
            error: function (response) {
                $scope.$apply(function () {
                    console.log("got back an error: ", response);
                    deferred.reject();
                });
            }
        });
        return deferred.promise;
    }
    Maven.completeVersion = completeVersion;
    function completeArtifactId(mbean, $q, $scope, workspace, jolokia, groupId, partial, packaging, classifier) {
        var deferred = $q.defer();
        jolokia.request({
            type: 'exec',
            mbean: mbean,
            operation: 'artifactIdComplete(java.lang.String, java.lang.String, java.lang.String, java.lang.String)',
            arguments: [groupId, partial, packaging, classifier]
        }, {
            method: 'POST',
            success: function (response) {
                $scope.$apply(function () {
                    deferred.resolve(response.value.sortBy().first(15));
                });
            },
            error: function (response) {
                $scope.$apply(function () {
                    console.log("got back an error: ", response);
                    deferred.reject();
                });
            }
        });
        return deferred.promise;
    }
    Maven.completeArtifactId = completeArtifactId;
    function completeGroupId(mbean, $q, $scope, workspace, jolokia, partial, packaging, classifier) {
        if (partial.length < 5) {
            return $q.when([]);
        }
        var deferred = $q.defer();
        jolokia.request({
            type: 'exec',
            mbean: mbean,
            operation: 'groupIdComplete(java.lang.String, java.lang.String, java.lang.String)',
            arguments: [partial, packaging, classifier]
        }, {
            method: 'POST',
            success: function (response) {
                $scope.$apply(function () {
                    deferred.resolve(response.value.sortBy().first(15));
                });
            },
            error: function (response) {
                console.log("got back an error: ", response);
                $scope.$apply(function () {
                    deferred.reject();
                });
            }
        });
        return deferred.promise;
    }
    Maven.completeGroupId = completeGroupId;
    function addMavenFunctions($scope, workspace) {
        $scope.detailLink = function (row) {
            var group = row.groupId;
            var artifact = row.artifactId;
            var version = row.version || "";
            var classifier = row.classifier || "";
            var packaging = row.packaging || "";
            if (group && artifact) {
                return "#/maven/artifact/" + group + "/" + artifact + "/" + version + "/" + classifier + "/" + packaging;
            }
            return "";
        };
        $scope.javadocLink = function (row) {
            var group = row.groupId;
            var artifact = row.artifactId;
            var version = row.version;
            if (group && artifact && version) {
                return "javadoc/" + group + ":" + artifact + ":" + version + "/";
            }
            return "";
        };
        $scope.versionsLink = function (row) {
            var group = row.groupId;
            var artifact = row.artifactId;
            var classifier = row.classifier || "";
            var packaging = row.packaging || "";
            if (group && artifact) {
                return "#/maven/versions/" + group + "/" + artifact + "/" + classifier + "/" + packaging;
            }
            return "";
        };
        $scope.dependenciesLink = function (row) {
            var group = row.groupId;
            var artifact = row.artifactId;
            var classifier = row.classifier || "";
            var packaging = row.packaging || "";
            var version = row.version;
            if (group && artifact) {
                return "#/maven/dependencies/" + group + "/" + artifact + "/" + version + "/" + classifier + "/" + packaging;
            }
            return "";
        };
        $scope.hasDependencyMBean = function () {
            var mbean = Maven.getAetherMBean(workspace);
            return angular.isDefined(mbean);
        };
        $scope.sourceLink = function (row) {
            var group = row.groupId;
            var artifact = row.artifactId;
            var version = row.version;
            if (group && artifact && version) {
                return "#/source/index/" + group + ":" + artifact + ":" + version + "/";
            }
            return "";
        };
    }
    Maven.addMavenFunctions = addMavenFunctions;
})(Maven || (Maven = {}));
var Fabric;
(function (Fabric) {
    var ProfileDetails = (function () {
        function ProfileDetails() {
            this.restrict = 'A';
            this.replace = true;
            this.templateUrl = Fabric.templatePath + "profileDetailsDirective.html";
            this.scope = {
                versionId: '=',
                profileId: '='
            };
            this.controller = ["$scope", "$element", "$attrs", "$routeParams", "jolokia", "$location", "workspace", "marked", "$q", function ($scope, $element, $attrs, $routeParams, jolokia, $location, workspace, marked, $q) {
                $scope.inDirective = true;
                $scope.managerMBean = Fabric.managerMBean;
                Fabric.initScope($scope, $location, jolokia, workspace);
                Fabric.loadRestApi(jolokia, workspace, $scope);
                $scope.loading = true;
                $scope.mavenMBean = Maven.getMavenIndexerMBean(workspace);
                if (!angular.isDefined($scope.versionId)) {
                    $scope.versionId = $routeParams.versionId;
                }
                if (!angular.isDefined($scope.profileId)) {
                    $scope.profileId = $routeParams.profileId;
                }
                $scope.newFileDialog = false;
                $scope.deleteFileDialog = false;
                $scope.newFileName = '';
                $scope.markedForDeletion = '';
                $scope.newProfileName = '';
                $scope.deleteThingDialog = false;
                $scope.changeParentsDialog = false;
                $scope.removeParentDialog = false;
                $scope.newThingName = '';
                $scope.selectedParents = [];
                $scope.profilePath = Fabric.profilePath;
                $scope.pageId = Fabric.fabricTopLevel + Fabric.profilePath($scope.profileId);
                $scope.gotoCreateContainer = function () {
                    var me = $location.path();
                    $location.path('/fabric/containers/createContainer').search({
                        versionId: $scope.versionId,
                        profileIds: $scope.profileId,
                        hideProfileSelector: true,
                        returnTo: me,
                        nextPage: me
                    });
                };
                var versionId = $scope.versionId;
                var profileId = $scope.profileId;
                if (versionId && versionId) {
                    Fabric.profileJolokia(jolokia, profileId, versionId, function (profileJolokia) {
                        $scope.profileJolokia = profileJolokia;
                        if (!profileJolokia) {
                            $scope.profileNotRunning = true;
                            $scope.profileMetadataMBean = Osgi.getProfileMetadataMBean(workspace);
                        }
                    });
                }
                $scope.$watch('activeTab', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        $scope.newThingName = '';
                    }
                });
                $scope.$watch('versionId', function (newValue, oldValue) {
                    if (angular.isDefined($scope.versionId) && angular.isDefined($scope.profileId)) {
                        $scope.doRegister();
                    }
                });
                $scope.$watch('profileId', function (newValue, oldValue) {
                    if (angular.isDefined($scope.versionId) && angular.isDefined($scope.profileId)) {
                        $scope.doRegister();
                    }
                });
                $scope.doCompletionFabric = function (something) {
                    if (something.startsWith("mvn:")) {
                        $scope.prefix = "mvn:";
                        return Maven.completeMavenUri($q, $scope, workspace, jolokia, something.from(4));
                    }
                    $scope.prefix = "";
                    return $q.when([]);
                };
                $scope.uriParts = [];
                $scope.$watch('newThingName', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        $scope.uriParts = newValue.split("/");
                    }
                });
                $scope.$watch('uriParts', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        if (!$scope.prefix || $scope.prefix === '') {
                            return;
                        }
                        if (newValue && newValue.length > 0 && !newValue.first().startsWith($scope.prefix)) {
                            if (newValue.first() === "" || newValue.first().length < $scope.prefix.length) {
                                return;
                            }
                            if (oldValue.length === 0) {
                                return;
                            }
                            if (oldValue.length === 1) {
                                $scope.newThingName = $scope.prefix + newValue.first();
                            }
                            else {
                                var merged = oldValue.first(oldValue.length - 1).include(newValue.first());
                                $scope.newThingName = merged.join('/');
                            }
                        }
                    }
                }, true);
                $scope.doRegister = function () {
                    Core.unregister(jolokia, $scope);
                    if ($scope.versionId && $scope.profileId && !$scope.versionId.isBlank() && !$scope.profileId.isBlank()) {
                        Core.register(jolokia, $scope, {
                            type: 'exec',
                            mbean: Fabric.managerMBean,
                            operation: 'getProfile(java.lang.String, java.lang.String)',
                            arguments: [$scope.versionId, $scope.profileId]
                        }, onSuccess(render));
                    }
                };
                $scope.showChangeParentsDialog = function () {
                    $scope.selectedParents = $scope.row.parentIds.map(function (parent) {
                        return {
                            id: parent,
                            selected: true
                        };
                    });
                    $scope.changeParentsDialog = true;
                };
                $scope.removeParentProfile = function (parent) {
                    $scope.markedForDeletion = parent;
                    $scope.removeParentDialog = true;
                };
                $scope.doRemoveParentProfile = function () {
                    var parents = $scope.row.parentIds.exclude($scope.markedForDeletion);
                    Fabric.changeProfileParents(jolokia, $scope.versionId, $scope.profileId, parents, function () {
                        Core.notification('success', 'Removed parent profile ' + $scope.markedForDeletion + ' from ' + $scope.profileId);
                        Core.$apply($scope);
                    }, function (response) {
                        Core.notification('error', 'Failed to change parent profiles of ' + $scope.profileId + ' due to ' + response.error);
                        Core.$apply($scope);
                    });
                };
                $scope.changeAttribute = function (attribute, value) {
                    jolokia.request({
                        type: 'exec',
                        method: 'post',
                        mbean: Fabric.managerMBean,
                        operation: 'setProfileAttribute',
                        arguments: [$scope.versionId, $scope.profileId, attribute, value]
                    }, {
                        success: function () {
                            Fabric.log.debug("Set attribute ", attribute, " to ", value);
                            Core.$apply($scope);
                        },
                        error: function (response) {
                            Fabric.log.debug("Failed to set attribute ", attribute, " to ", value, " due to ", response.error);
                            Core.$apply($scope);
                        }
                    });
                };
                $scope.doChangeParents = function () {
                    $scope.changeParentsDialog = false;
                    var parents = $scope.selectedParents.map(function (parent) {
                        return parent.id;
                    });
                    Fabric.changeProfileParents(jolokia, $scope.versionId, $scope.profileId, parents, function () {
                        Fabric.log.debug('Successfully changed parent profiles of ', $scope.profileId);
                        Core.$apply($scope);
                    }, function (response) {
                        Fabric.log.debug('Failed to change parent profiles of ', $scope.profileId, ' due to ', response.error);
                        Core.$apply($scope);
                    });
                };
                $scope.goto = function (location) {
                    $location.url(location);
                };
                $scope.addNewThing = function (title, type, current) {
                    if (Core.isBlank($scope.newThingName)) {
                        return;
                    }
                    $scope.thingName = title;
                    $scope.currentThing = current;
                    $scope.currentThingType = type;
                    $scope.doAddThing();
                };
                $scope.deleteThing = function (title, type, current, item) {
                    $scope.thingName = title;
                    $scope.currentThing = current;
                    $scope.currentThingType = type;
                    $scope.currentThingItem = item;
                    $scope.deleteThingDialog = true;
                };
                $scope.updateThing = function (title, type, current) {
                    $scope.thingName = title;
                    $scope.currentThing = current;
                    $scope.currentThingType = type;
                    $scope.callSetProfileThing("Changed", "change", title);
                };
                $scope.mavenLink = function (url) {
                    return Maven.mavenLink(url);
                };
                $scope.callSetProfileThing = function (success, error, thing) {
                    jolokia.request({
                        type: 'exec',
                        mbean: Fabric.managerMBean,
                        operation: "setProfile" + $scope.currentThingType + "(java.lang.String, java.lang.String, java.util.List)",
                        arguments: [$scope.versionId, $scope.profileId, $scope.currentThing]
                    }, {
                        method: 'POST',
                        success: function () {
                            Core.notification('success', success + ' ' + thing);
                            $scope.newThingName = '';
                            Core.$apply($scope);
                        },
                        error: function (response) {
                            Core.notification('error', 'Failed to ' + error + ' ' + thing + ' due to ' + response.error);
                            Core.$apply($scope);
                        }
                    });
                };
                $scope.doDeleteThing = function () {
                    $scope.currentThing.remove($scope.currentThingItem);
                    $scope.callSetProfileThing('Deleted', 'delete', $scope.currentThingItem);
                };
                $scope.doAddThing = function () {
                    if (!$scope.currentThing.any($scope.newThingName)) {
                        $scope.currentThing.push($scope.newThingName);
                        $scope.addThingDialog = false;
                        $scope.callSetProfileThing('Added', 'add', $scope.newThingName);
                    }
                    else {
                        Core.notification('error', 'There is already a ' + $scope.thingName + ' with the name ' + $scope.newThingName);
                    }
                };
                $scope.deleteFile = function (file) {
                    $scope.markedForDeletion = file;
                    $scope.deleteFileDialog = true;
                };
                $scope.doDeleteFile = function () {
                    $scope.deleteFileDialog = false;
                    Fabric.deleteConfigFile(jolokia, $scope.versionId, $scope.profileId, $scope.markedForDeletion, function () {
                        Core.notification('success', 'Deleted file ' + $scope.markedForDeletion);
                        $scope.markedForDeletion = '';
                        Core.$apply($scope);
                    }, function (response) {
                        Core.notification('error', 'Failed to delete file ' + $scope.markedForDeletion + ' due to ' + response.error);
                        $scope.markedForDeletion = '';
                        Core.$apply($scope);
                    });
                };
                $scope.doCreateFile = function () {
                    $scope.newFileDialog = false;
                    Fabric.newConfigFile(jolokia, $scope.versionId, $scope.profileId, $scope.newFileName, function () {
                        Core.notification('success', 'Created new configuration file ' + $scope.newFileName);
                        $location.path("/fabric/profile/" + $scope.versionId + "/" + $scope.profileId + "/" + $scope.newFileName);
                    }, function (response) {
                        Core.notification('error', 'Failed to create ' + $scope.newFileName + ' due to ' + response.error);
                    });
                };
                $scope.copyProfile = function () {
                    $scope.copyProfileDialog = false;
                    if ($scope.profileId.has('-') && !$scope.newProfileName.has('-')) {
                        var parts = $scope.profileId.split('-');
                        parts.pop();
                        parts.push($scope.newProfileName);
                        $scope.newProfileName = parts.join('-');
                    }
                    var existingProfile = jolokia.request({
                        type: 'exec',
                        mbean: Fabric.managerMBean,
                        operation: "getProfile(java.lang.String,java.lang.String)",
                        arguments: [$scope.versionId, $scope.newProfileName]
                    });
                    if (existingProfile.value) {
                        Core.notification('error', 'Failed to create new profile ' + $scope.newProfileName + '. A profile with the same name already exists.');
                        Core.$apply($scope);
                        return;
                    }
                    Core.notification('info', 'Copying ' + $scope.profileId + ' to ' + $scope.newProfileName);
                    Fabric.copyProfile(jolokia, $scope.versionId, $scope.profileId, $scope.newProfileName, true, function () {
                        Core.notification('success', 'Created new profile ' + $scope.newProfileName);
                        Fabric.gotoProfile(workspace, jolokia, localStorage, $location, $scope.versionId, { id: $scope.newProfileName });
                        Core.$apply($scope);
                    }, function (response) {
                        Core.notification('error', 'Failed to create new profile ' + $scope.newProfileName + ' due to ' + response.error);
                        Core.$apply($scope);
                    });
                };
                function render(response) {
                    if (!angular.isDefined($scope.row)) {
                        $scope.loading = false;
                    }
                    var responseJson = angular.toJson(response.value);
                    if ($scope.profileResponseJson !== responseJson) {
                        if (!$scope.activeTab) {
                            $scope.activeTab = "features";
                        }
                        $scope.profileResponseJson = responseJson;
                        $scope.row = response.value;
                        var id = $scope.row.id;
                        var version = $scope.row.version;
                        if (angular.isDefined($scope.row) && $scope.row.summaryMarkdown != null) {
                            $scope.summaryHtml = marked($scope.row.summaryMarkdown);
                        }
                        else {
                            $scope.summaryHtml = null;
                        }
                        $scope.row.systemProperties = [];
                        angular.forEach($scope.row.containerConfiguration, function (v, k) {
                            if (k.startsWith("system.")) {
                                $scope.row.systemProperties.push({ name: k.substring(7), value: v });
                            }
                        });
                        $scope.sysPropsTableData = {
                            rows: $scope.row.systemProperties
                        };
                        $scope.configFolderLink = null;
                        if ($scope.hasFabricWiki() && id && version) {
                            $scope.configFolderLink = "#/wiki/branch/" + version + "/view/fabric/profiles/" + Fabric.profilePath(id);
                        }
                        $scope.row.iconURL = Fabric.toIconURL($scope, response.value.iconURL);
                        Fabric.log.info("Icon URL " + $scope.row.iconURL);
                        Core.$apply($scope);
                    }
                }
                $scope.sysPropsTableConfig = {
                    data: "sysPropsTableData.rows",
                    multiSelect: false,
                    showSelectionCheckbox: false,
                    enableRowClickSelection: true,
                    primaryKeyProperty: 'name',
                    properties: {
                        'rows': {
                            items: {
                                properties: {
                                    'name': {
                                        description: 'System property name',
                                        type: 'java.lang.String'
                                    },
                                    'value': {
                                        description: 'System property value',
                                        type: 'java.lang.String'
                                    }
                                }
                            }
                        }
                    },
                    displayFooter: false,
                    showFilter: false,
                    columnDefs: [
                        { field: "name", displayName: "Name" },
                        { field: "value", displayName: "Value" }
                    ]
                };
                $scope.$on("hawtio.datatable.sysPropsTableData.rows", function (ev, data) {
                    var props = {};
                    angular.forEach(data, function (v) {
                        props[v.name] = v.value;
                    });
                    jolokia.request({
                        type: 'exec',
                        mbean: Fabric.managerMBean,
                        operation: "setProfileSystemProperties(java.lang.String, java.lang.String, java.util.Map)",
                        arguments: [$scope.versionId, $scope.profileId, props]
                    }, {
                        method: 'POST',
                        success: function () {
                            Core.notification('success', "System properties updated");
                            Core.$apply($scope);
                        },
                        error: function (response) {
                            Core.notification('error', 'Failed to update system properties due to ' + response.error);
                            Core.$apply($scope);
                        }
                    });
                });
            }];
        }
        return ProfileDetails;
    })();
    Fabric.ProfileDetails = ProfileDetails;
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    var ProfileSelector = (function () {
        function ProfileSelector() {
            this.restrict = 'A';
            this.replace = true;
            this.templateUrl = Fabric.templatePath + "profileSelector.html";
            this.scope = {
                selectedProfiles: '=fabricProfileSelector',
                versionId: '=',
                filterWatch: '@',
                selectedWatch: '@',
                clearOnVersionChange: '@',
                noLinks: '@',
                showHeader: '@',
                useCircles: '@',
                expanded: '@',
                excludedProfiles: '=',
                includedProfiles: '='
            };
            this.controller = ["$scope", "$element", "$attrs", "workspace", "jolokia", "localStorage", "$location", function ($scope, $element, $attrs, workspace, jolokia, localStorage, $location) {
                $scope.profiles = [];
                $scope.responseJson = '';
                $scope.filterText = '';
                $scope.clearOnVersionChange = false;
                $scope.noLinks = false;
                $scope.selectedAll = false;
                $scope.indeterminate = false;
                $scope.showFilter = true;
                $scope.useCircles = false;
                $scope.expanded = false;
                $scope.tree = [];
                $scope.showProfile = function (profile) {
                    return Core.matchFilterIgnoreCase(profile.id, $scope.filterText);
                };
                $scope.showBranch = function (branch) {
                    return $scope.filterText.isBlank() || branch.profiles.some(function (profile) {
                        return Core.matchFilterIgnoreCase(profile.id, $scope.filterText);
                    });
                };
                $scope.goto = function (profile) {
                    Fabric.gotoProfile(workspace, jolokia, localStorage, $location, $scope.versionId, profile);
                };
                $scope.render = function (response) {
                    var responseJson = angular.toJson(response.value);
                    if ($scope.responseJson !== responseJson) {
                        $scope.responseJson = responseJson;
                        var selected = $scope.selectedProfiles;
                        $scope.profiles = response.value.sortBy(function (profile) {
                            return profile.id;
                        });
                        angular.forEach(selected, function (profile) {
                            var p = $scope.profiles.find(function (p) {
                                return p.id === profile.id;
                            });
                            if (p && profile) {
                                p.selected = profile.selected;
                            }
                        });
                        $scope.profiles = $scope.profiles.exclude(function (p) {
                            return p.hidden;
                        });
                        if ($scope.excludedProfiles) {
                            $scope.profiles = $scope.excluded();
                        }
                        if ($scope.includedProfiles) {
                            $scope.profiles = $scope.included();
                        }
                        var paths = [];
                        $scope.profiles.each(function (profile) {
                            var path = profile.id.split('-');
                            profile.name = path.last();
                            profile.path = path.exclude(profile.name).join(' / ');
                            paths.push(profile.path);
                        });
                        paths = paths.unique().sortBy('length').sortBy(function (n) {
                            return n;
                        });
                        var tree = [];
                        paths.forEach(function (path) {
                            var branch = {
                                expanded: $scope.expanded,
                                path: path,
                                profiles: $scope.profiles.filter(function (profile) {
                                    return profile.path === path;
                                })
                            };
                            tree.push(branch);
                        });
                        $scope.tree = tree;
                        Core.$apply($scope);
                    }
                };
                $scope.excluded = function () {
                    return $scope.profiles.exclude(function (p) {
                        return $scope.excludedProfiles.some(function (e) {
                            return e === p.id;
                        });
                    });
                };
                $scope.included = function () {
                    return $scope.profiles.exclude(function (p) {
                        return $scope.includedProfiles.none(function (e) {
                            return e === p.id;
                        });
                    });
                };
                $scope.isOpen = function (branch) {
                    if ($scope.filterText !== '') {
                        return "opened";
                    }
                    if (branch.expanded) {
                        return "opened";
                    }
                    return "closed";
                };
                $scope.isOpenIcon = function (branch) {
                    if (branch.expanded) {
                        return "icon-folder-open";
                    }
                    return "icon-folder-closed";
                };
                $scope.$watch('includedProfiles', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        $scope.init();
                    }
                }, true);
                $scope.$watch('excludedProfiles', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        $scope.init();
                    }
                }, true);
                $scope.abstract = function () {
                    return $scope.profiles.filter(function (profile) {
                        return profile['abstract'];
                    });
                };
                $scope.selected = function () {
                    return $scope.profiles.filter(function (profile) {
                        return profile['selected'];
                    });
                };
                $scope.selectAll = function () {
                    $scope.profiles.each(function (profile) {
                        profile.selected = true;
                    });
                };
                $scope.selectNone = function () {
                    $scope.profiles.each(function (profile) {
                        delete profile.selected;
                    });
                };
                $scope.$parent.profileSelectAll = $scope.selectAll;
                $scope.$parent.profileSelectNone = $scope.selectNone;
                $scope.getSelectedClass = function (profile) {
                    if (profile.abstract) {
                        return "abstract";
                    }
                    if (profile.selected) {
                        return "selected";
                    }
                    return "";
                };
                $scope.$watch('selectedAll', function (newValue, oldValue) {
                    if (!$scope.indeterminate && newValue !== oldValue) {
                        if (newValue) {
                            $scope.selectAll();
                        }
                        else {
                            $scope.selectNone();
                        }
                    }
                });
                $scope.$watch('profiles', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        $scope.selectedProfiles = $scope.selected();
                    }
                }, true);
                $scope.$on("fabricProfileRefresh", function () {
                    if ($scope.versionId) {
                        jolokia.request({
                            type: 'exec',
                            mbean: Fabric.managerMBean,
                            operation: 'getProfiles(java.lang.String, java.util.List)',
                            arguments: [$scope.versionId, ['id', 'hidden']]
                        }, {
                            method: 'POST',
                            success: function (response) {
                                $scope.render(response);
                            }
                        });
                    }
                });
                $scope.init = function () {
                    Fabric.log.debug("Initializing profile selector, version: ", $scope.versionId);
                    $scope.responseJson = null;
                    Core.unregister(jolokia, $scope);
                    if ($scope.versionId !== '') {
                        if ($scope.clearOnVersionChange) {
                            $scope.selectNone();
                        }
                        if ($scope.versionId) {
                            Core.register(jolokia, $scope, {
                                type: 'exec',
                                mbean: Fabric.managerMBean,
                                operation: 'getProfiles(java.lang.String, java.util.List)',
                                arguments: [$scope.versionId, ['id', 'hidden', 'abstract']]
                            }, onSuccess($scope.render, {
                                error: function (response) {
                                    Fabric.log.debug("Error fetching profiles: ", response.error, " unregistering poller");
                                    Core.unregister(jolokia, $scope);
                                }
                            }));
                        }
                    }
                };
                $scope.$watch('versionId', function (newValue, oldValue) {
                    Fabric.log.debug("versionId, newValue: ", newValue, " oldValue: ", oldValue);
                    if ($scope.versionId && $scope.versionId !== '') {
                        Fabric.log.debug("Unregistering old poller");
                        Core.unregister(jolokia, $scope);
                        jolokia.request({
                            type: 'exec',
                            mbean: Fabric.managerMBean,
                            operation: 'versions()',
                            arguments: []
                        }, {
                            method: 'POST',
                            success: function (response) {
                                if (response.value.some(function (version) {
                                    return version.id === newValue;
                                })) {
                                    Fabric.log.debug("registering new poller");
                                    $scope.init();
                                    Core.$apply($scope);
                                }
                            },
                            error: function (response) {
                                Core.$apply($scope);
                            }
                        });
                    }
                });
            }];
            this.link = function ($scope, $element, $attrs) {
                var selector = $element.find('#selector');
                if (!angular.isDefined($attrs['showHeader'])) {
                    $scope.showFilter = true;
                }
                else {
                    $scope.showFilter = $attrs['showHeader'];
                }
                if (angular.isDefined($attrs['filterWatch'])) {
                    $scope.$parent.$watch($attrs['filterWatch'], function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            $scope.filterText = newValue;
                        }
                    });
                }
                $scope.$watch('indeterminate', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        selector.prop('indeterminate', $scope.indeterminate);
                    }
                });
                $scope.$watch('selectedProfiles', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        oldValue.each(function (profile) {
                            $scope.profiles.find(function (p) { return p.id == profile.id; }).selected = false;
                        });
                        newValue.each(function (profile) {
                            $scope.profiles.find(function (p) { return p.id == profile.id; }).selected = true;
                        });
                        if ($scope.selectedProfiles.length > 0) {
                            if ($scope.selectedProfiles.length !== $scope.profiles.length) {
                                $scope.indeterminate = true;
                                $scope.selectedAll = false;
                                $scope.$parent.profileSomeSelected = true;
                                $scope.$parent.profileNoneSelected = false;
                                $scope.$parent.profileAllSelected = false;
                            }
                            else {
                                $scope.indeterminate = false;
                                $scope.selectedAll = true;
                                $scope.$parent.profileSomeSelected = false;
                                $scope.$parent.profileNoneSelected = false;
                                $scope.$parent.profileAllSelected = true;
                            }
                        }
                        else {
                            $scope.indeterminate = false;
                            $scope.selectedAll = false;
                            $scope.$parent.profileSomeSelected = false;
                            $scope.$parent.profileNoneSelected = true;
                            $scope.$parent.profileAllSelected = false;
                        }
                    }
                }, true);
            };
        }
        return ProfileSelector;
    })();
    Fabric.ProfileSelector = ProfileSelector;
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    Fabric._module.controller("Fabric.TestController", ["$scope", "jolokia", "$q", "workspace", "$templateCache", function ($scope, jolokia, $q, workspace, $templateCache) {
        $scope.mavenMBean = Maven.getMavenIndexerMBean(workspace);
        $scope.html = "text/html";
        $scope.versionSelector = $templateCache.get("versionSelectorTemplate");
        $scope.profileIncludes = $templateCache.get("profile-includes");
        $scope.profileExcludes = $templateCache.get("profile-excludes");
        $scope.containerList = $templateCache.get("containerListTemplate");
        $scope.profileLink = $templateCache.get("profileLinkTemplate");
        $scope.version = {};
        $scope.versionId = '';
        $scope.someUri = '';
        $scope.uriParts = [];
        $scope.version = {};
        $scope.osp = [];
        $scope.vid = '1.0';
        $scope.someProfiles = ['a-mq', 'aws-ec2'];
        $scope.selectedProfiles = [{
            id: '1-dot-0',
            selected: true
        }, {
            id: 'a-mq',
            selected: true
        }];
        $scope.selectedProfilesString = "";
        $scope.$watch('version', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if ($scope.version && !Object.equal($scope.version, {})) {
                    $scope.versionId = $scope.version.id;
                }
            }
        });
        $scope.$watch('osp', function (newValue, oldValue) {
            $scope.selectedProfilesString = angular.toJson($scope.osp);
        });
        $scope.$watch('someUri', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.uriParts = newValue.split("/");
            }
        });
        $scope.$watch('uriParts', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue.length === 1 && newValue.length < oldValue.length) {
                    if (oldValue.last() !== '' && newValue.first().has(oldValue.last())) {
                        var merged = oldValue.first(oldValue.length - 1).include(newValue.first());
                        $scope.someUri = merged.join('/');
                    }
                }
            }
        }, true);
        $scope.doCompletionMaven = function (something) {
            return Maven.completeMavenUri($q, $scope, workspace, jolokia, something);
        };
        $scope.doCompletionFabric = function (something) {
            return Fabric.completeUri($q, $scope, workspace, jolokia, something);
        };
    }]);
})(Fabric || (Fabric = {}));
var Fabric;
(function (Fabric) {
    function VersionSelector($templateCache) {
        return {
            restrict: 'A',
            replace: true,
            templateUrl: Fabric.templatePath + "versionSelector.html",
            scope: {
                selectedVersion: '=fabricVersionSelector',
                availableVersions: '=?',
                menuBind: '=?',
                exclude: '@'
            },
            controller: ["$scope", "$element", "$attrs", "jolokia", function ($scope, $element, $attrs, jolokia) {
                $scope.versions = [];
                $scope.responseJson = '';
                $scope.$watch('selectedVersion', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        if (newValue && 'id' in newValue) {
                            $scope.selectedVersion = $scope.versions.find(function (version) {
                                return version.id === newValue['id'];
                            });
                        }
                        else {
                            $scope.selectedVersion = $scope.versions.find(function (version) {
                                return version.defaultVersion;
                            });
                        }
                    }
                });
                $scope.$watch('versions', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        if ($scope.selectedVersion && 'id' in $scope.selectedVersion) {
                            $scope.selectedVersion = $scope.versions.find(function (version) {
                                return version.id === $scope.selectedVersion['id'];
                            });
                        }
                        else {
                            $scope.selectedVersion = $scope.versions.find(function (version) {
                                return version.defaultVersion;
                            });
                        }
                    }
                }, true);
                function excludeVersions(versions, exclude) {
                    if (angular.isString(exclude)) {
                        if (exclude.has("[") && exclude.has("]")) {
                            exclude = angular.fromJson(exclude);
                        }
                        else {
                            exclude = [exclude];
                        }
                    }
                    if (!exclude || exclude.length === 0) {
                        return versions;
                    }
                    return versions.exclude(function (v) {
                        return exclude.some(function (e) {
                            return e === v.id;
                        });
                    });
                }
                function generateMenu(versions) {
                    return $scope.versions.map(function (v) {
                        return {
                            title: v.id,
                            action: function () {
                                $scope.selectedVersion = v;
                                if (!Core.isBlank($scope.onPick)) {
                                    $scope.$parent.$eval($scope.onPick, {
                                        version: v['id']
                                    });
                                }
                            }
                        };
                    });
                }
                $scope.$watch('exclude', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        if ($scope.responseJson) {
                            var versions = angular.fromJson($scope.responseJson);
                            buildArray(versions);
                        }
                    }
                });
                function buildArray(versions) {
                    $scope.versions = Fabric.sortVersions(versions, $scope.desc);
                    $scope.versions = excludeVersions($scope.versions, $scope.exclude);
                    if ($scope.config) {
                        $scope.config.items = generateMenu($scope.versions);
                    }
                    $scope.availableVersions = $scope.versions;
                }
                $scope.render = function (response) {
                    var responseJson = angular.toJson(response.value);
                    if ($scope.responseJson !== responseJson) {
                        $scope.responseJson = responseJson;
                        buildArray(response.value);
                        Core.$apply($scope);
                    }
                };
                Core.register(jolokia, $scope, {
                    type: 'exec',
                    mbean: Fabric.managerMBean,
                    operation: 'versions(java.util.List)',
                    arguments: [
                        ['id', 'defaultVersion']
                    ]
                }, onSuccess($scope.render));
            }],
            link: function ($scope, $element, $attrs) {
                $scope.template = $templateCache.get('withSelect');
                if (Core.parseBooleanValue($attrs['useMenu'])) {
                    $scope.config = {
                        title: 'Version'
                    };
                    if (!Core.isBlank($attrs['menuTitle'])) {
                        $scope.config.title = $attrs['menuTitle'];
                    }
                    if (!Core.isBlank($attrs['menuBind'])) {
                        $scope.$watch('menuBind', function (newValue, oldValue) {
                            if (!Core.isBlank(newValue)) {
                                $scope.config.title = newValue;
                            }
                        });
                    }
                    if (!Core.isBlank($attrs['onPick'])) {
                        $scope.onPick = $attrs['onPick'];
                    }
                    if (!Core.isBlank($attrs['useIcon'])) {
                        $scope.config.icon = $attrs['useIcon'];
                    }
                    $scope.desc = 'desc' in $attrs;
                    $scope.template = $templateCache.get('withMenu');
                }
            }
        };
    }
    Fabric.VersionSelector = VersionSelector;
})(Fabric || (Fabric = {}));
var ForceGraph;
(function (ForceGraph) {
    var pluginName = 'forceGraph';
    ForceGraph._module = angular.module(pluginName, ['bootstrap', 'ngResource']);
    ForceGraph._module.directive('hawtioForceGraph', function () {
        return new ForceGraph.ForceGraphDirective();
    });
    hawtioPluginLoader.addModule(pluginName);
})(ForceGraph || (ForceGraph = {}));
var ForceGraph;
(function (ForceGraph) {
    var log = Logger.get("ForceGraph");
    var ForceGraphDirective = (function () {
        function ForceGraphDirective() {
            this.restrict = 'A';
            this.replace = true;
            this.transclude = false;
            this.scope = {
                graph: '=graph',
                nodesize: '@',
                selectedModel: '@',
                linkDistance: '@',
                markerKind: '@',
                charge: '@'
            };
            this.link = function ($scope, $element, $attrs) {
                $scope.trans = [0, 0];
                $scope.scale = 1;
                $scope.$watch('graph', function (oldVal, newVal) {
                    updateGraph();
                });
                $scope.redraw = function () {
                    $scope.trans = d3.event.translate;
                    $scope.scale = d3.event.scale;
                    $scope.viewport.attr("transform", "translate(" + $scope.trans + ")" + " scale(" + $scope.scale + ")");
                };
                $scope.tick = function () {
                    $scope.graphEdges.attr("d", function (d) {
                        var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
                        return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                    });
                    $scope.graphNodes.attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    });
                    $scope.graphLabels.attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    });
                    if (Object.hasOwnProperty.call(window, "ActiveXObject") || !window.ActiveXObject) {
                        $scope.svg.selectAll(".link").each(function () {
                            this.parentNode.insertBefore(this, this);
                        });
                    }
                };
                $scope.mover = function (d) {
                    if (d.popup != null) {
                        $("#pop-up").fadeOut(100, function () {
                            if (d.popup.title != null) {
                                $("#pop-up-title").html(d.popup.title);
                            }
                            else {
                                $("#pop-up-title").html("");
                            }
                            if (d.popup.content != null) {
                                $("#pop-up-content").html(d.popup.content);
                            }
                            else {
                                $("#pop-up-content").html("");
                            }
                            var popLeft = (d.x * $scope.scale) + $scope.trans[0] + 20;
                            var popTop = (d.y * $scope.scale) + $scope.trans[1] + 20;
                            $("#pop-up").css({ "left": popLeft, "top": popTop });
                            $("#pop-up").fadeIn(100);
                        });
                    }
                };
                $scope.mout = function (d) {
                    $("#pop-up").fadeOut(50);
                };
                var updateGraph = function () {
                    var canvas = $($element);
                    var h = $($element).parent().height();
                    var w = $($element).parent().width();
                    var i = 0;
                    canvas.children("svg").remove();
                    $scope.svg = d3.select(canvas[0]).append("svg").attr("width", w).attr("height", h);
                    var linkTypes = null;
                    if ($scope.graph) {
                        linkTypes = $scope.graph.linktypes;
                    }
                    if (!linkTypes) {
                        return;
                    }
                    $scope.svg.append("svg:defs").selectAll("marker").data(linkTypes).enter().append("svg:marker").attr("id", String).attr("viewBox", "0 -5 10 10").attr("refX", 15).attr("refY", -1.5).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").append("svg:path").attr("d", "M0,-5L10,0L0,5");
                    $scope.svg.append("svg:g").append("svg:rect").attr("class", "graphbox.frame").attr('width', w).attr('height', h);
                    $scope.viewport = $scope.svg.append("svg:g").call(d3.behavior.zoom().on("zoom", $scope.redraw)).append("svg:g");
                    $scope.viewport.append("svg:rect").attr("width", 1000000).attr("height", 1000000).attr("class", "graphbox").attr("transform", "translate(-50000, -500000)");
                    if ($scope.graph) {
                        var ownerScope = $scope.$parent || $scope;
                        var selectedModel = $scope.selectedModel || "selectedNode";
                        $scope.force = d3.layout.force().nodes($scope.graph.nodes).links($scope.graph.links).size([w, h]).on("tick", $scope.tick);
                        if (angular.isDefined($scope.linkDistance)) {
                            $scope.force.linkDistance($scope.linkDistance);
                        }
                        if (angular.isDefined($scope.charge)) {
                            $scope.force.charge($scope.charge);
                        }
                        var markerTypeName = $scope.markerKind || "marker-end";
                        $scope.graphEdges = $scope.viewport.append("svg:g").selectAll("path").data($scope.force.links()).enter().append("svg:path").attr("class", function (d) {
                            return "link " + d.type;
                        }).attr(markerTypeName, function (d) {
                            return "url(#" + d.type + ")";
                        });
                        $scope.graphNodes = $scope.viewport.append("svg:g").selectAll("circle").data($scope.force.nodes()).enter().append("a").attr("xlink:href", function (d) {
                            return d.navUrl;
                        }).on("mouseover.onLink", function (d, i) {
                            var sel = d3.select(d3.event.target);
                            sel.classed('selected', true);
                            ownerScope[selectedModel] = d;
                            Core.pathSet(ownerScope, selectedModel, d);
                            Core.$apply(ownerScope);
                        }).on("mouseout.onLink", function (d, i) {
                            var sel = d3.select(d3.event.target);
                            sel.classed('selected', false);
                        });
                        function hasImage(d) {
                            return d.image && d.image.url;
                        }
                        $scope.graphNodes.filter(function (d) {
                            return d.image != null;
                        }).append("image").attr("xlink:href", function (d) {
                            return d.image.url;
                        }).attr("x", function (d) {
                            return -(d.image.width / 2);
                        }).attr("y", function (d) {
                            return -(d.image.height / 2);
                        }).attr("width", function (d) {
                            return d.image.width;
                        }).attr("height", function (d) {
                            return d.image.height;
                        });
                        $scope.graphNodes.filter(function (d) { return !hasImage(d); }).append("circle").attr("class", function (d) {
                            return d.type;
                        }).attr("r", function (d) {
                            return d.size || $scope.nodesize;
                        });
                        $scope.graphLabels = $scope.viewport.append("svg:g").selectAll("g").data($scope.force.nodes()).enter().append("svg:g");
                        $scope.graphLabels.append("svg:text").attr("x", 8).attr("y", ".31em").attr("class", "shadow").text(function (d) {
                            return d.name;
                        });
                        $scope.graphLabels.append("svg:text").attr("x", 8).attr("y", ".31em").text(function (d) {
                            return d.name;
                        });
                        $scope.force.start();
                        $scope.graphNodes.call($scope.force.drag).on("mouseover", $scope.mover).on("mouseout", $scope.mout);
                    }
                };
            };
        }
        return ForceGraphDirective;
    })();
    ForceGraph.ForceGraphDirective = ForceGraphDirective;
})(ForceGraph || (ForceGraph = {}));
var ForceGraph;
(function (ForceGraph) {
    var GraphBuilder = (function () {
        function GraphBuilder() {
            this.nodes = {};
            this.links = [];
            this.linkTypes = {};
        }
        GraphBuilder.prototype.addNode = function (node) {
            if (!this.nodes[node.id]) {
                this.nodes[node.id] = node;
            }
        };
        GraphBuilder.prototype.getNode = function (id) {
            return this.nodes[id];
        };
        GraphBuilder.prototype.hasLinks = function (id) {
            var _this = this;
            var result = false;
            this.links.forEach(function (link) {
                if (link.source.id == id || link.target.id == id) {
                    result = result || (_this.nodes[link.source.id] != null && _this.nodes[link.target.id] != null);
                }
            });
            return result;
        };
        GraphBuilder.prototype.addLink = function (srcId, targetId, linkType) {
            if ((this.nodes[srcId] != null) && (this.nodes[targetId] != null)) {
                this.links.push({
                    source: this.nodes[srcId],
                    target: this.nodes[targetId],
                    type: linkType
                });
                if (!this.linkTypes[linkType]) {
                    this.linkTypes[linkType] = {
                        used: true
                    };
                }
                ;
            }
        };
        GraphBuilder.prototype.nodeIndex = function (id, nodes) {
            var result = -1;
            var index = 0;
            for (index = 0; index < nodes.length; index++) {
                var node = nodes[index];
                if (node.id == id) {
                    result = index;
                    break;
                }
            }
            return result;
        };
        GraphBuilder.prototype.filterNodes = function (filter) {
            var filteredNodes = {};
            var newLinks = [];
            d3.values(this.nodes).forEach(function (node) {
                if (filter(node)) {
                    filteredNodes[node.id] = node;
                }
            });
            this.links.forEach(function (link) {
                if (filteredNodes[link.source.id] && filteredNodes[link.target.id]) {
                    newLinks.push(link);
                }
            });
            this.nodes = filteredNodes;
            this.links = newLinks;
        };
        GraphBuilder.prototype.buildGraph = function () {
            var _this = this;
            var graphNodes = [];
            var linktypes = d3.keys(this.linkTypes);
            var graphLinks = [];
            d3.values(this.nodes).forEach(function (node) {
                if (node.includeInGraph == null || node.includeInGraph) {
                    node.includeInGraph = true;
                    graphNodes.push(node);
                }
            });
            this.links.forEach(function (link) {
                if (_this.nodes[link.source.id] != null && _this.nodes[link.target.id] != null && _this.nodes[link.source.id].includeInGraph && _this.nodes[link.target.id].includeInGraph) {
                    graphLinks.push({
                        source: _this.nodeIndex(link.source.id, graphNodes),
                        target: _this.nodeIndex(link.target.id, graphNodes),
                        type: link.type
                    });
                }
            });
            return {
                nodes: graphNodes,
                links: graphLinks,
                linktypes: linktypes
            };
        };
        return GraphBuilder;
    })();
    ForceGraph.GraphBuilder = GraphBuilder;
})(ForceGraph || (ForceGraph = {}));
var Forms;
(function (Forms) {
    var mapDirective = Forms._module.directive("hawtioFormMap", [function () {
        return {
            restrict: 'A',
            replace: true,
            templateUrl: UrlHelpers.join(Forms.templateUrl, "formMapDirective.html"),
            scope: {
                description: '@',
                entity: '=',
                mode: '=',
                data: '=',
                name: '@'
            },
            link: function (scope, element, attr) {
                scope.deleteKey = function (key) {
                    try {
                        delete scope.entity[scope.name]["" + key];
                    }
                    catch (e) {
                        Forms.log.debug("failed to delete key: ", key, " from entity: ", scope.entity);
                    }
                };
                scope.addItem = function (newItem) {
                    if (!scope.entity) {
                        scope.entity = {};
                    }
                    Core.pathSet(scope.entity, [scope.name, newItem.key], newItem.value);
                    scope.showForm = false;
                };
                scope.$watch('showForm', function (newValue) {
                    if (newValue) {
                        scope.newItem = {
                            key: undefined,
                            value: undefined
                        };
                    }
                });
            }
        };
    }]);
})(Forms || (Forms = {}));
var Forms;
(function (Forms) {
    Forms.FormTestController = Forms._module.controller("Forms.FormTestController", ["$scope", function ($scope) {
        $scope.editing = false;
        $scope.html = "text/html";
        $scope.javascript = "javascript";
        $scope.basicFormEx1Entity = {
            'key': 'Some key',
            'value': 'Some value'
        };
        $scope.basicFormEx1EntityString = angular.toJson($scope.basicFormEx1Entity, true);
        $scope.basicFormEx1Result = '';
        $scope.toggleEdit = function () {
            $scope.editing = !$scope.editing;
        };
        $scope.view = function () {
            if (!$scope.editing) {
                return "view";
            }
            return "edit";
        };
        $scope.basicFormEx1 = '<div simple-form name="some-form" action="#/forms/test" method="post" data="basicFormEx1SchemaObject" entity="basicFormEx1Entity" onSubmit="callThis()"></div>';
        $scope.toObject = function (str) {
            return angular.fromJson(str.replace("'", "\""));
        };
        $scope.fromObject = function (str) {
            return angular.toJson($scope[str], true);
        };
        $scope.basicFormEx1Schema = '' + '{\n' + '   "properties": {\n' + '     "key": {\n' + '       "description": "Argument key",\n' + '       "type": "java.lang.String"\n' + '     },\n' + '     "value": {\n' + '       "description": "Argument Value",\n' + '       "type": "java.lang.String"\n' + '     },\n' + '     "longArg": {\n' + '       "description": "Long argument",\n' + '       "type": "Long",\n' + '       "minimum": "5",\n' + '       "maximum": "10"\n' + '     },\n' + '     "intArg": {\n' + '       "description": "Int argument",\n' + '       "type": "Integer"\n' + '     },\n' + '     "objectArg": {\n' + '       "description": "some object",\n' + '       "type": "object"\n' + '     },\n' + '     "booleanArg": {\n' + '       "description": "Some boolean value",\n' + '       "type": "java.lang.Boolean"\n' + '     }\n' + '   },\n' + '   "description": "Show some stuff in a form",\n' + '   "type": "java.lang.String",\n' + '   "tabs": {\n' + '     "Tab One": ["key", "value"],\n' + '     "Tab Two": ["*"],\n' + '     "Tab Three": ["booleanArg"]\n' + '   }\n' + '}';
        $scope.basicFormEx1SchemaObject = $scope.toObject($scope.basicFormEx1Schema);
        $scope.updateSchema = function () {
            $scope.basicFormEx1SchemaObject = $scope.toObject($scope.basicFormEx1Schema);
        };
        $scope.updateEntity = function () {
            $scope.basicFormEx1Entity = angular.fromJson($scope.basicFormEx1EntityString);
        };
        $scope.hawtioResetEx = '<a class="btn" href="" hawtio-reset="some-form"><i class="icon-refresh"></i> Clear</a>';
        $scope.hawtioSubmitEx = '      <a class="btn" href="" hawtio-submit="some-form"><i class="icon-save"></i> Save</a>';
        $scope.callThis = function (json, form) {
            $scope.basicFormEx1Result = angular.toJson(json, true);
            Core.notification('success', 'Form "' + form.get(0).name + '" submitted...');
            Core.$apply($scope);
        };
        $scope.config = {
            name: 'form-with-config-object',
            action: "/some/url",
            method: "post",
            data: 'setVMOption',
            showtypes: 'false'
        };
        $scope.cheese = {
            key: "keyABC",
            value: "valueDEF",
            intArg: 999
        };
        $scope.onCancel = function (form) {
            Core.notification('success', 'Cancel clicked on form "' + form.get(0).name + '"');
        };
        $scope.onSubmit = function (json, form) {
            Core.notification('success', 'Form "' + form.get(0).name + '" submitted... (well not really), data:' + JSON.stringify(json));
        };
        $scope.derp = function (json, form) {
            Core.notification('error', 'derp with json ' + JSON.stringify(json));
        };
        $scope.inputTableData = {
            rows: [
                { id: "object1", name: 'foo' },
                { id: "object2", name: 'bar' }
            ]
        };
        $scope.inputTableConfig = {
            data: 'inputTableData.rows',
            displayFooter: false,
            showFilter: false,
            showSelectionCheckbox: false,
            enableRowClickSelection: true,
            primaryKeyProperty: 'id',
            properties: {
                'rows': { items: { type: 'string', properties: {
                    'id': {
                        description: 'Object ID',
                        type: 'java.lang.String'
                    },
                    'name': {
                        description: 'Object Name',
                        type: 'java.lang.String'
                    }
                } } }
            },
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'ID'
                },
                {
                    field: 'name',
                    displayName: 'Name'
                }
            ]
        };
    }]);
})(Forms || (Forms = {}));
var Health;
(function (Health) {
    var pluginName = 'health';
    Health._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'hawtioCore', 'hawtio-ui']);
    Health._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/health', { templateUrl: 'app/health/html/health.html' });
    }]);
    Health._module.run(["$location", "workspace", "viewRegistry", "layoutFull", "helpRegistry", function ($location, workspace, viewRegistry, layoutFull, helpRegistry) {
        viewRegistry['health'] = layoutFull;
        helpRegistry.addUserDoc('health', 'app/health/doc/help.md', function () {
            return Health.hasHealthMBeans(workspace);
        });
        workspace.topLevelTabs.push({
            id: "health",
            content: "Health",
            title: "View the health of the various sub systems",
            isValid: function (workspace) { return Health.hasHealthMBeans(workspace); },
            href: function () { return "#/health"; },
            isActive: function (workspace) { return workspace.isTopTabActive("health"); }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Health || (Health = {}));
var Health;
(function (Health) {
    Health.HealthController = Health._module.controller("Health.HealthController", ["$scope", "jolokia", "workspace", "$templateCache", function ($scope, jolokia, workspace, $templateCache) {
        Health.decorate($scope);
        $scope.results = [];
        $scope.responses = {};
        $scope.mbeans = [];
        $scope.mbeanStatus = {};
        $scope.displays = [];
        $scope.page = '';
        $scope.pageFilter = '';
        $scope.$watch('mbeans', function (newValue, oldValue) {
            Core.unregister(jolokia, $scope);
            if (!newValue) {
                return;
            }
            $scope.mbeanStatus = {};
            newValue.forEach(function (mbean) {
                var unregFunc = Core.register(jolokia, $scope, {
                    type: 'exec',
                    mbean: mbean,
                    operation: "healthList()"
                }, {
                    success: $scope.render,
                    error: function (response) {
                        Health.log.info("Failed to invoke healthList() on mbean: " + mbean + " due to: ", response.error);
                        Health.log.debug("Stack trace: ", response.stacktrace.split("\n"));
                        unregFunc();
                    }
                });
                var error = function (response) {
                    if (!response.error.has("AttributeNotFoundException")) {
                        Health.log.info("Failed to read CurrentStatus on mbean: " + mbean + " due to: ", response.error);
                        Health.log.debug("Stack trace: ", response.stacktrace.split("\n"));
                    }
                };
                jolokia.request({
                    type: 'read',
                    mbean: mbean,
                    attribute: 'CurrentStatus'
                }, {
                    success: function (response) {
                        $scope.mbeanStatus[response.request['mbean']] = response.value;
                        Core.register(jolokia, $scope, {
                            type: 'read',
                            mbean: mbean,
                            attribute: 'CurrentStatus'
                        }, {
                            success: function (response) {
                                if (response.value === $scope.mbeanStatus[response.request['mbean']]) {
                                    return;
                                }
                                $scope.mbeanStatus[response.request['mbean']] = response.value;
                                Core.$apply($scope);
                            },
                            error: error
                        });
                    },
                    error: error
                });
            });
        }, true);
        $scope.getTitleClass = function (display) {
            if (!display) {
                return "warning";
            }
            if (!display.values || display.values.length === 0) {
                return "ok";
            }
            var answer = "ok";
            display.values.forEach(function (value) {
                if (answer !== "warning" && value.level && value.level.toLowerCase() !== 'info') {
                    answer = "warning";
                }
            });
            return answer;
        };
        $scope.getHumanName = function (name) {
            var answer = name;
            if (name.startsWith("org.apache.activemq")) {
                var nameParts = name.split(',');
                nameParts.forEach(function (part) {
                    if (part.startsWith('brokerName')) {
                        var parts = part.split('=');
                        if (parts[1]) {
                            answer = "Broker: " + parts[1];
                        }
                    }
                });
                return answer;
            }
            if (name.startsWith("io.fabric8:service")) {
                return "Fabric8";
            }
            var nameParts = name.split(',');
            nameParts.forEach(function (part) {
                if (part.startsWith('desc')) {
                    var parts = part.split('=');
                    if (parts[1]) {
                        answer = parts[1];
                    }
                }
            });
            return answer;
        };
        $scope.getMBeans = function () {
            var healthMap = Health.getHealthMBeans(workspace);
            Health.log.debug("HealthMap: ", healthMap);
            if (healthMap) {
                if (!angular.isArray(healthMap)) {
                    return [healthMap.objectName];
                }
                var answer = healthMap.map(function (obj) {
                    return obj.objectName;
                });
                Health.log.debug("Health mbeans: ", answer);
                return answer;
            }
            else {
                Health.log.debug("No health mbeans found...");
                return [];
            }
        };
        $scope.$on('jmxTreeUpdated', function () {
            $scope.mbeans = $scope.getMBeans();
        });
        $scope.$on('$routeChangeSuccess', function () {
            $scope.mbeans = $scope.getMBeans();
        });
        $scope.mbeans = $scope.getMBeans();
        $scope.render = function (response) {
            var mbean = response.request['mbean'];
            var values = response.value;
            var responseJson = angular.toJson(values);
            if (mbean in $scope.responses) {
                if ($scope.responses[mbean] === responseJson) {
                    return;
                }
            }
            $scope.responses[mbean] = responseJson;
            var display = $scope.displays.find(function (m) {
                return m.mbean === mbean;
            });
            values = defaultValues(values);
            values = values.sortBy(function (value) {
                if (!value.level) {
                    return 99;
                }
                return $scope.levelSorting[value.level];
            });
            values.forEach($scope.generateChartData);
            if (!display) {
                $scope.displays.push({
                    mbean: mbean,
                    values: values
                });
            }
            else {
                display.values = values;
            }
            if ($scope.page === '') {
                $scope.page = $templateCache.get('pageTemplate');
            }
            Core.$apply($scope);
        };
        $scope.filterValues = function (value) {
            var json = angular.toJson(value);
            return json.has($scope.pageFilter);
        };
        $scope.isPercentage = function (key) {
            if (key !== undefined && key.toUpperCase().indexOf("PERCENT") > 0) {
                return true;
            }
            return false;
        };
        function defaultValues(values) {
            angular.forEach(values, function (aData) {
                var domain = aData["domain"];
                if (!domain) {
                    var id = aData["healthId"];
                    if (id) {
                        var idx = id.lastIndexOf('.');
                        if (idx > 0) {
                            domain = id.substring(0, idx);
                            var alias = Health.healthDomains[domain];
                            if (alias) {
                                domain = alias;
                            }
                            var kind = aData["kind"];
                            if (!kind) {
                                kind = Core.humanizeValue(id.substring(idx + 1));
                                aData["kind"] = kind;
                            }
                        }
                    }
                    aData["domain"] = domain;
                }
            });
            return values;
        }
        function createOKStatus(object) {
            return {
                healthId: object.domain + ".status",
                level: "INFO",
                message: object.title + " is OK"
            };
        }
    }]);
})(Health || (Health = {}));
var ArrayHelpers;
(function (ArrayHelpers) {
    function removeElements(collection, newCollection, index) {
        if (index === void 0) { index = 'id'; }
        var oldLength = collection.length;
        collection.remove(function (item) {
            return !newCollection.any(function (c) {
                return c[index] === item[index];
            });
        });
        return collection.length !== oldLength;
    }
    ArrayHelpers.removeElements = removeElements;
    function sync(collection, newCollection, index) {
        if (index === void 0) { index = 'id'; }
        var answer = removeElements(collection, newCollection, index);
        newCollection.forEach(function (item) {
            var oldItem = collection.find(function (c) {
                return c[index] === item[index];
            });
            if (!oldItem) {
                answer = true;
                collection.push(item);
            }
            else {
                if (item !== oldItem) {
                    angular.copy(item, oldItem);
                    answer = true;
                }
            }
        });
        return answer;
    }
    ArrayHelpers.sync = sync;
})(ArrayHelpers || (ArrayHelpers = {}));
var Infinispan;
(function (Infinispan) {
    var CLI = (function () {
        function CLI(workspace, jolokia) {
            this.workspace = workspace;
            this.jolokia = jolokia;
            this.cacheName = null;
            this.sessionId = null;
            this.useSessionIds = true;
        }
        CLI.prototype.setCacheName = function (name) {
            if (name) {
                name = Core.trimQuotes(name);
                var postfix = "(local)";
                if (name.endsWith(postfix)) {
                    name = name.substring(0, name.length - postfix.length);
                }
            }
            if (!this.cacheName || this.cacheName !== name) {
                if (this.sessionId) {
                    this.deleteSession(this.sessionId);
                }
                this.cacheName = name;
                this.createSession();
            }
        };
        CLI.prototype.createSession = function () {
            var _this = this;
            if (this.useSessionIds) {
                var mbean = Infinispan.getInterpreterMBean(this.workspace);
                if (mbean) {
                    var cli = this;
                    this.jolokia.execute(mbean, "createSessionId", this.cacheName, onSuccess(function (value) {
                        console.log("Has session ID: " + value);
                        _this.sessionId = value;
                    }));
                }
                else {
                    this.warnMissingMBean();
                }
            }
        };
        CLI.prototype.execute = function (sql, handler) {
            if (sql) {
                sql = sql.trim();
                if (!sql.endsWith(";")) {
                    sql += ";";
                }
                var sessionId = (this.useSessionIds) ? this.sessionId : null;
                if (!this.useSessionIds) {
                    sql = "cache " + this.cacheName + "; " + sql;
                }
                if (sessionId || !this.useSessionIds) {
                    var mbean = Infinispan.getInterpreterMBean(this.workspace);
                    if (mbean) {
                        this.jolokia.execute(mbean, "execute", sessionId, sql, onSuccess(handler));
                    }
                    else {
                        this.warnMissingMBean();
                    }
                }
                else {
                    Core.notification("warning", "Cannot evaluate SQL as we don't have a sessionId yet!");
                }
            }
        };
        CLI.prototype.deleteSession = function (sessionId) {
        };
        CLI.prototype.warnMissingMBean = function () {
            Core.notification("error", "No Interpreter MBean available");
        };
        return CLI;
    })();
    Infinispan.CLI = CLI;
})(Infinispan || (Infinispan = {}));
var Infinispan;
(function (Infinispan) {
    function infinispanCacheName(entity) {
        if (entity) {
            var id = entity._id;
            if (id) {
                var prefix = 'name="';
                var idx = id.indexOf(prefix);
                if (idx > 0) {
                    idx += prefix.length;
                    var lastIdx = id.indexOf('"', idx + 1);
                    if (lastIdx > 0) {
                        return id.substring(idx, lastIdx);
                    }
                    else {
                        return id.substring(idx);
                    }
                }
            }
            return id;
        }
        return null;
    }
    Infinispan.infinispanCacheName = infinispanCacheName;
    function getInterpreterMBean(workspace) {
        if (workspace) {
            var folder = workspace.findMBeanWithProperties(Infinispan.jmxDomain, { component: "Interpreter", type: "CacheManager" });
            if (folder) {
                return folder.objectName;
            }
        }
        return null;
    }
    Infinispan.getInterpreterMBean = getInterpreterMBean;
    function getSelectedCacheName(workspace) {
        var selection = workspace.selection;
        if (selection && selection.domain === Infinispan.jmxDomain) {
            return selection.entries["name"];
        }
        return null;
    }
    Infinispan.getSelectedCacheName = getSelectedCacheName;
})(Infinispan || (Infinispan = {}));
var Infinispan;
(function (Infinispan) {
    var pluginName = 'infinispan';
    Infinispan.jmxDomain = "";
    var jmxDomain1 = 'org.infinispan';
    var jmxDomain2 = 'jboss.infinispan';
    var toolBar = "app/infinispan/html/attributeToolBar.html";
    Infinispan._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'hawtioCore']);
    Infinispan._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/infinispan/query', { templateUrl: 'app/infinispan/html/query.html' });
    }]);
    Infinispan._module.filter('infinispanCacheName', function () { return Infinispan.infinispanCacheName; });
    Infinispan._module.run(["workspace", "viewRegistry", "helpRegistry", function (workspace, viewRegistry, helpRegistry) {
        if (workspace.treeContainsDomainAndProperties(jmxDomain2)) {
            Infinispan.jmxDomain = jmxDomain2;
        }
        else {
            Infinispan.jmxDomain = jmxDomain1;
        }
        viewRegistry['infinispan'] = 'app/infinispan/html/layoutCacheTree.html';
        helpRegistry.addUserDoc('infinispan', 'app/infinispan/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties(Infinispan.jmxDomain);
        });
        var nameTemplate = '<div class="ngCellText" title="Infinispan cache">{{row.entity | infinispanCacheName}}</div>';
        var attributes = workspace.attributeColumnDefs;
        attributes[Infinispan.jmxDomain + "/Caches/folder"] = [
            { field: '_id', displayName: 'Name', cellTemplate: nameTemplate, width: "**" },
            { field: 'numberOfEntries', displayName: 'Entries' },
            { field: 'hits', displayName: 'Hits' },
            { field: 'hitRatio', displayName: 'Hit Ratio' },
            { field: 'stores', displayName: 'Stores' },
            { field: 'averageReadTime', displayName: 'Avg Read Time' },
            { field: 'averageWriteTime', displayName: 'Avg Write Time' }
        ];
        workspace.topLevelTabs.push({
            id: "infinispan",
            content: "Infinispan",
            title: "View your distributed data",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties(Infinispan.jmxDomain); },
            href: function () { return "#/jmx/attributes?tab=infinispan"; },
            isActive: function (workspace) { return workspace.isTopTabActive("infinispan"); }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-pencil"></i> Query',
            title: "Perform InSQL commands on the cache",
            isValid: function (workspace) { return Infinispan.getSelectedCacheName(workspace) && Infinispan.getInterpreterMBean(workspace); },
            href: function () { return "#/infinispan/query"; }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Infinispan || (Infinispan = {}));
var Infinispan;
(function (Infinispan) {
    Infinispan._module.controller("Infinispan.QueryController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var interpreter = new Infinispan.CLI(workspace, jolokia);
        $scope.logs = [];
        $scope.filteredLogs = [];
        $scope.selectedItems = [];
        $scope.searchText = "";
        $scope.filter = {
            logLevelQuery: "",
            logLevelExactMatch: false
        };
        var columnDefs = [
            {
                field: 'key',
                displayName: 'Key'
            },
            {
                field: 'value',
                displayName: 'Value'
            }
        ];
        $scope.gridOptions = {
            selectedItems: $scope.selectedItems,
            data: 'filteredLogs',
            displayFooter: false,
            showFilter: false,
            filterOptions: {
                filterText: "searchText"
            },
            columnDefs: columnDefs,
            rowDetailTemplateId: "logDetailTemplate"
        };
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(refreshCacheName, 50);
        });
        $scope.$watch('workspace.selection', function () {
            refreshCacheName();
        });
        $scope.doQuery = function () {
            if ($scope.sql) {
                interpreter.execute($scope.sql, handleResults);
            }
        };
        function handleResults(results) {
            $scope.output = null;
            if (!results) {
                console.log("no output...");
            }
            else {
                var error = results["ERROR"] || "";
                var stackTrace = results["STACKTRACE"] || "";
                if (error || stackTrace) {
                    if (stackTrace) {
                        error += "\n" + stackTrace;
                    }
                    Core.notification("error", error);
                }
                else {
                    var output = results["OUTPUT"];
                    if (!output) {
                        Core.notification("error", "No results!");
                    }
                    else {
                        $scope.output = output;
                        console.log("==== output: " + output);
                        Core.$apply($scope);
                    }
                }
            }
        }
        function refreshCacheName() {
            var cacheName = Infinispan.getSelectedCacheName(workspace);
            console.log("selected cacheName is: " + cacheName);
            if (cacheName) {
                interpreter.setCacheName(cacheName);
            }
        }
    }]);
})(Infinispan || (Infinispan = {}));
var Infinispan;
(function (Infinispan) {
    Infinispan._module.controller("Infinispan.TreeHeaderController", ["$scope", function ($scope) {
        $scope.expandAll = function () {
            Tree.expandAll("#infinispantree");
        };
        $scope.contractAll = function () {
            Tree.contractAll("#infinispantree");
        };
    }]);
    Infinispan._module.controller("Infinispan.TreeController", ["$scope", "$location", "workspace", function ($scope, $location, workspace) {
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateSelectionFromURL, 50);
        });
        $scope.$watch('workspace.tree', function () {
            if (workspace.moveIfViewInvalid())
                return;
            var children = [];
            var tree = workspace.tree;
            if (tree) {
                var domainName = Infinispan.jmxDomain;
                var folder = tree.get(domainName);
                if (folder) {
                    var cachesFolder = new Folder("Caches");
                    cachesFolder.domain = domainName;
                    cachesFolder.key = "root-Infinispan-Caches";
                    cachesFolder.typeName = "Caches";
                    children.push(cachesFolder);
                    addAllCacheStatistics(folder, cachesFolder);
                }
                var treeElement = $("#infinispantree");
                Jmx.enableTree($scope, $location, workspace, treeElement, children);
                setTimeout(updateSelectionFromURL, 50);
            }
        });
        function addAllCacheStatistics(folder, answer) {
            if (folder) {
                var children = folder.children;
                if (children) {
                    angular.forEach(folder.children, function (value, key) {
                        if (value.objectName && value.title === "Statistics") {
                            var cacheName = value.parent.parent.title || value.title;
                            var name = Core.humanizeValue(cacheName);
                            var cacheFolder = new Folder(name);
                            cacheFolder.addClass = "org-infinispn-cache";
                            cacheFolder.typeName = "Cache";
                            cacheFolder.parent = folder;
                            cacheFolder.key = answer.key + "-" + cacheName;
                            cacheFolder.objectName = value.objectName;
                            cacheFolder.domain = value.domain;
                            cacheFolder.entries = value.entries;
                            cacheFolder.tooltip = "Cache name: " + cacheName;
                            answer.children.push(cacheFolder);
                        }
                        else {
                            addAllCacheStatistics(value, answer);
                        }
                    });
                }
            }
        }
        function updateSelectionFromURL() {
            Jmx.updateTreeSelectionFromURL($location, $("#infinispantree"), true);
        }
    }]);
})(Infinispan || (Infinispan = {}));
var Insight;
(function (Insight) {
    Insight.pluginName = 'insight';
    Insight._module = angular.module(Insight.pluginName, ['hawtioCore']);
    Insight._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/insight/all', { templateUrl: 'app/insight/html/all.html' }).when('/insight/jvms', { templateUrl: 'app/insight/html/jvms.html' }).when('/insight/elasticsearch', { templateUrl: 'app/insight/html/eshead.html' }).when('/insight/logs', { redirectTo: function () {
            return '/insight/dashboard?kbnId=app/insight/dashboards/logs&p=insight&tab=insight-logs';
        } }).when('/insight/camel', { redirectTo: function () {
            return '/insight/dashboard?kbnId=app/insight/dashboards/camel&p=insight&tab=insight-camel';
        } }).when('/insight/dashboard', { templateUrl: '../hawtio-kibana/app/partials/dashboard.html' });
    }]);
    Insight._module.run(["workspace", "viewRegistry", "helpRegistry", "serviceIconRegistry", "layoutFull", function (workspace, viewRegistry, helpRegistry, serviceIconRegistry, layoutFull) {
        serviceIconRegistry.addIcons({
            title: "Fabric8 Insight",
            type: "icon",
            src: "icon-eye-open"
        }, "org.fusesource.insight", "io.fabric8.insight");
        Perspective.metadata['insight'] = {
            icon: {
                title: "Fabric8 Insight",
                type: "icon",
                src: "icon-eye-open"
            },
            label: "Insight",
            isValid: function (workspace) { return Insight.hasInsight(workspace); },
            topLevelTabs: {
                includes: [
                    {
                        href: "#/camin"
                    },
                    {
                        id: "insight-logs"
                    },
                    {
                        id: "insight-camel"
                    },
                    {
                        id: "insight-eshead"
                    }
                ]
            }
        };
        viewRegistry["insight"] = "../hawtio-kibana/app/partials/hawtioLayout.html";
        viewRegistry["eshead"] = layoutFull;
        helpRegistry.addUserDoc('insight', 'app/insight/doc/help.md', function () {
            return Fabric.hasFabric(workspace) && Insight.hasInsight(workspace);
        });
        workspace.topLevelTabs.push({
            id: "insight-metrics",
            content: "Metrics",
            title: "View Insight metrics",
            href: function () { return "#/insight/all"; },
            isValid: function (workspace) {
                return Fabric.hasFabric(workspace) && Insight.hasInsight(workspace);
            }
        });
        workspace.topLevelTabs.push({
            id: "insight-logs",
            content: "Logs",
            title: "View Insight Logs",
            href: function () { return "#/insight/logs"; },
            isValid: function (workspace) {
                return Fabric.hasFabric(workspace) && Insight.hasInsight(workspace) && Insight.hasKibana(workspace);
            },
            isActive: function () { return workspace.isTopTabActive("insight-logs"); }
        });
        workspace.topLevelTabs.push({
            id: "insight-camel",
            content: "Camel Events",
            title: "View Insight Camel",
            href: function () { return "#/insight/camel"; },
            isValid: function (workspace) {
                return Fabric.hasFabric(workspace) && Insight.hasInsight(workspace) && Insight.hasKibana(workspace);
            },
            isActive: function () { return workspace.isTopTabActive("insight-camel"); }
        });
        workspace.topLevelTabs.push({
            id: "insight-eshead",
            content: "Elasticsearch",
            title: "View Insight Elasticsearch",
            href: function () { return "#/insight/elasticsearch?tab=eshead"; },
            isValid: function (workspace) {
                return Fabric.hasFabric(workspace) && Insight.hasInsight(workspace) && Insight.hasEsHead(workspace);
            },
            isActive: function () { return workspace.isTopTabActive("insight-eshead"); }
        });
    }]);
    hawtioPluginLoader.addModule(Insight.pluginName);
})(Insight || (Insight = {}));
var Insight;
(function (Insight) {
    Insight._module.controller("Insight.AllController", ["$scope", "jolokia", "localStorage", "workspace", function ($scope, jolokia, localStorage, workspace) {
        $scope.result = null;
        $scope.containers = [];
        $scope.profiles = [Insight.allContainers];
        $scope.versions = [];
        $scope.profile = Insight.allContainers;
        $scope.time_options = ['1m', '5m', '15m', '1h', '6h', '12h'];
        $scope.timespan = '1m';
        $scope.updateRate = parseInt(localStorage['updateRate']);
        $scope.chartsMeta = [];
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Insight.managerMBean,
            operation: 'containers()',
            arguments: []
        }, onSuccess(onContainers));
        function onContainers(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.containers = [];
                $scope.profiles = [Insight.allContainers];
                $scope.versions = [];
                $scope.result.forEach(function (container) {
                    $scope.profiles = $scope.profiles.union(container.profileIds.map(function (id) {
                        return { id: id };
                    }));
                    $scope.versions = $scope.versions.union([container.versionId]);
                    $scope.containers.push({
                        name: container.id,
                        alive: container.alive,
                        version: container.versionId,
                        profileIds: container.profileIds
                    });
                });
                Core.$apply($scope);
            }
        }
        var mbean = Insight.getInsightMetricsCollectorMBean(workspace);
        $scope.metrics = {};
        if (mbean) {
            $scope.metrics = jQuery.parseJSON(jolokia.getAttribute(mbean, "Metrics"));
        }
        var jreq = { type: 'exec', mbean: 'org.elasticsearch:service=restjmx', operation: 'exec', arguments: ['GET', '/_all/_mapping', ''] };
        jolokia.request(jreq, { success: function (response) {
            var data = jQuery.parseJSON(response.value);
            var roots = {};
            var children = [];
            for (var index in data) {
                if (index.startsWith("insight-")) {
                    for (var mapping in data[index]) {
                        if (mapping.startsWith("sta-")) {
                            var name = mapping.substring(4);
                            if (!roots[name]) {
                                roots[name] = true;
                                children.push({
                                    title: name,
                                    expand: true,
                                    children: Insight.getChildren(data[index][mapping], name, "", data[index][mapping]["properties"]["host"] !== undefined)
                                });
                            }
                        }
                    }
                }
            }
            $("#insighttree").dynatree({
                checkbox: true,
                selectMode: 2,
                onSelect: onSelect,
                onClick: onClick,
                onKeydown: onKeydown,
                children: children
            });
        } });
        $scope.set_timespan = function (t) {
            $scope.timespan = t;
            rebuildCharts();
        };
        $scope.profile_changed = function () {
            rebuildCharts();
        };
        function onSelect(flag, node) {
            var selNodes = node.tree.getSelectedNodes();
            $scope.chartsMeta = selNodes.map(function (node) {
                var data = node.data;
                return { name: data["field"], field: data["field"], type: data["type"], host: data["hasHost"] };
            });
            rebuildCharts();
        }
        function onClick(node, event) {
            if (node.getEventTargetType(event) === "title") {
                node.toggleSelect();
            }
            return true;
        }
        function onKeydown(node, event) {
            if (event.which === 32) {
                node.toggleSelect();
                return false;
            }
        }
        function rebuildCharts() {
            var chartsDef = [];
            $scope.chartsMeta.forEach(function (meta) {
                var metadata = $scope.metrics[meta.type] !== undefined ? $scope.metrics[meta.type][meta.field] : undefined;
                if (meta.host) {
                    $scope.containers.forEach(function (container) {
                        if ($scope.profile === Insight.allContainers || $.inArray($scope.profile.id, container.profileIds) >= 0) {
                            chartsDef.push({
                                name: (metadata !== undefined ? metadata['description'] : meta.name) + " [" + container.name + "]",
                                type: "sta-" + meta.type,
                                field: meta.field,
                                query: "host: \"" + container.name + "\"",
                                meta: metadata
                            });
                        }
                    });
                }
                else {
                    chartsDef.push({
                        name: metadata !== undefined ? metadata['description'] : meta.name,
                        type: "sta-" + meta.type,
                        field: meta.field,
                        meta: metadata
                    });
                }
            });
            Insight.createCharts($scope, chartsDef, "#charts", jolokia);
        }
    }]);
})(Insight || (Insight = {}));
var Insight;
(function (Insight) {
    Insight._module.controller("Insight.ElasticSearchController", ["$scope", "jolokia", "localStorage", function ($scope, jolokia, localStorage) {
        $scope.time_options = ['1m', '5m', '15m', '1h', '6h', '12h'];
        $scope.timespan = '1m';
        $scope.metrics = [];
        $scope.updateRate = parseInt(localStorage['updateRate']);
        $scope.data = [];
        var chartsDef = [{ name: "active primary shards", type: "sta-elasticsearch", field: "active_primary_shards" }, { name: "active shards", type: "sta-elasticsearch", field: "active_shards" }, { name: "relocating shards", type: "sta-elasticsearch", field: "relocating_shards" }, { name: "initializing shards", type: "sta-elasticsearch", field: "initializing_shards" }, { name: "unassigned shards", type: "sta-elasticsearch", field: "unassigned_shards" }];
        var mainDiv = "#charts";
        $scope.set_timespan = function (t) {
            $scope.timespan = t;
            rebuildCharts();
        };
        rebuildCharts();
        function rebuildCharts() {
            Insight.createCharts($scope, chartsDef, mainDiv, jolokia);
        }
    }]);
})(Insight || (Insight = {}));
var Insight;
(function (Insight) {
    Insight._module.controller("JVMsController", ["$scope", "jolokia", "localStorage", function ($scope, jolokia, localStorage) {
        $scope.time_options = ['1m', '5m', '15m', '1h', '6h', '12h'];
        $scope.timespan = '1m';
        $scope.containers = [];
        $scope.profiles = [Insight.allContainers];
        $scope.versions = [];
        $scope.profile = Insight.allContainers;
        $scope.metrics = [];
        $scope.updateRate = parseInt(localStorage['updateRate']);
        $scope.data = [];
        var chartsMeta = [{ name: "threads", type: "sta-jvm", field: "threads.count" }, { name: "mem", type: "sta-jvm", field: "mem.heap_used" }];
        var mainDiv = "#charts";
        $scope.set_timespan = function (t) {
            $scope.timespan = t;
            rebuildCharts();
        };
        $scope.profile_changed = function () {
            rebuildCharts();
        };
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Insight.managerMBean,
            operation: 'containers()',
            arguments: []
        }, onSuccess(onContainers));
        function onContainers(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.containers = [];
                $scope.profiles = [Insight.allContainers];
                $scope.versions = [];
                $scope.result.forEach(function (container) {
                    $scope.profiles = $scope.profiles.union(container.profileIds.map(function (id) {
                        return { id: id };
                    }));
                    $scope.versions = $scope.versions.union([container.versionId]);
                    $scope.containers.push({
                        name: container.id,
                        alive: container.alive,
                        version: container.versionId,
                        profileIds: container.profileIds
                    });
                });
                Core.$apply($scope);
                rebuildCharts();
            }
        }
        function rebuildCharts() {
            var chartsDef = [];
            chartsMeta.forEach(function (meta) {
                $scope.containers.forEach(function (container) {
                    if ($scope.profile === Insight.allContainers || $.inArray($scope.profile.id, container.profileIds) >= 0) {
                        chartsDef.push({
                            name: meta.name + " [" + container.name + "]",
                            type: meta.type,
                            field: meta.field,
                            query: "host: \"" + container.name + "\""
                        });
                    }
                });
            });
            Insight.createCharts($scope, chartsDef, mainDiv, jolokia);
        }
    }]);
})(Insight || (Insight = {}));
var JBoss;
(function (JBoss) {
    function cleanWebAppName(name) {
        if (name && name.lastIndexOf(".war") > -1) {
            return name.replace(".war", "");
        }
        else {
            return name;
        }
    }
    JBoss.cleanWebAppName = cleanWebAppName;
    function cleanContextPath(contextPath) {
        if (contextPath) {
            return "/" + cleanWebAppName(contextPath);
        }
        else {
            return "";
        }
    }
    JBoss.cleanContextPath = cleanContextPath;
    function iconClass(state) {
        if (state) {
            switch (state.toString().toLowerCase()) {
                case 'started':
                    return "green icon-play-circle";
                case 'ok':
                    return "green icon-play-circle";
                case 'true':
                    return "green icon-play-circle";
            }
        }
        return "orange icon-off";
    }
    JBoss.iconClass = iconClass;
})(JBoss || (JBoss = {}));
var JBoss;
(function (JBoss) {
    var pluginName = 'jboss';
    JBoss._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ui.bootstrap.dialog', 'hawtioCore']);
    JBoss._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/jboss/server', { templateUrl: 'app/jboss/html/server.html' }).when('/jboss/applications', { templateUrl: 'app/jboss/html/applications.html' }).when('/jboss/dmr', { templateUrl: 'app/jboss/html/dmr.html' }).when('/jboss/connectors', { templateUrl: 'app/jboss/html/connectors.html' });
    }]);
    JBoss._module.filter('jbossIconClass', function () { return JBoss.iconClass; });
    JBoss._module.run(["$location", "workspace", "viewRegistry", "helpRegistry", function ($location, workspace, viewRegistry, helpRegistry) {
        viewRegistry['jboss'] = "app/jboss/html/layoutJBossTabs.html";
        helpRegistry.addUserDoc(pluginName, 'app/' + pluginName + '/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties("jboss.as") || workspace.treeContainsDomainAndProperties("jboss.jta") || workspace.treeContainsDomainAndProperties("jboss.modules");
        });
        workspace.topLevelTabs.push({
            id: "jboss",
            content: "JBoss",
            title: "Manage your JBoss container",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties("jboss.as") || workspace.treeContainsDomainAndProperties("jboss.jta") || workspace.treeContainsDomainAndProperties("jboss.modules"); },
            href: function () { return "#/jboss/applications"; },
            isActive: function (workspace) { return workspace.isTopTabActive("jboss"); }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(JBoss || (JBoss = {}));
var JBoss;
(function (JBoss) {
    JBoss._module.controller("JBoss.ConnectorsController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(col.field) | jbossIconClass}}"></i></div>';
        $scope.connectors = [];
        var columnDefs = [
            {
                field: 'bound',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'name',
                displayName: 'Name',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'port',
                displayName: 'Port',
                cellFilter: null,
                width: "*",
                resizable: true
            },
        ];
        $scope.gridOptions = {
            data: 'connectors',
            displayFooter: false,
            displaySelectionCheckbox: false,
            canSelectRows: false,
            columnDefs: columnDefs,
            filterOptions: {
                filterText: ''
            }
        };
        function render(response) {
            $scope.connectors = [];
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    obj.mbean = response.request.mbean;
                    if (!obj.port) {
                        obj.port = obj.boundPort;
                    }
                    if (!obj.name) {
                        obj.name = "mail-smtp";
                    }
                    $scope.connectors.push(obj);
                    Core.$apply($scope);
                }
            }
            angular.forEach(response, function (value, key) {
                var mbean = value;
                if (mbean.toString() !== "jboss.as:socket-binding-group=standard-sockets") {
                    if (mbean.toString().lastIndexOf("management") > 0) {
                        jolokia.request({ type: "read", mbean: mbean, attribute: ["boundPort", "name", "bound"] }, onSuccess(onAttributes));
                    }
                    else if (mbean.toString().lastIndexOf("mail-smtp") > 0) {
                        jolokia.request({ type: "read", mbean: mbean, attribute: ["port"] }, onSuccess(onAttributes));
                    }
                    else {
                        jolokia.request({ type: "read", mbean: mbean, attribute: ["port", "name", "bound"] }, onSuccess(onAttributes));
                    }
                }
            });
            Core.$apply($scope);
        }
        ;
        $scope.$on('jmxTreeUpdated', reloadFunction);
        $scope.$watch('workspace.tree', reloadFunction);
        function reloadFunction() {
            setTimeout(loadData, 50);
        }
        function loadData() {
            console.log("Loading JBoss connector data...");
            jolokia.search("jboss.as:socket-binding-group=standard-sockets,*", onSuccess(render));
        }
    }]);
})(JBoss || (JBoss = {}));
var JBoss;
(function (JBoss) {
    JBoss._module.controller("JBoss.DmrController", ["$scope", "$location", "workspace", function ($scope, $location, workspace) {
        var search = $location.search();
        var connectUrl = Core.url("/proxy/localhost/9990/management");
        var user = search["_user"] || "";
        var pwd = search["_pwd"] || "";
        if (user) {
            connectUrl += "?_user=" + user;
            if (pwd) {
                connectUrl += "&_pwd=" + pwd;
            }
        }
        var isDmr = "dmr" === search["_format"];
        var data = null;
        var format = "application/dmr-encoded";
        if (isDmr) {
            var op = new dmr.ModelNode();
            op.get("operation").set("read-attribute");
            op.get("address").setEmptyList();
            op.get("name").set("release-version");
            data = op.toBase64String();
        }
        else {
            format = "application/json";
            var request = {
                "operation": "read-resource"
            };
            data = JSON.stringify(request);
        }
        console.log("Using dmr: " + isDmr + " with content type: " + format + " and data " + data);
        $.ajax({
            url: connectUrl,
            data: data,
            processData: false,
            type: "POST",
            dataType: "text",
            contentType: format,
            accepts: format,
            headers: {
                "Content-type": format,
                "Accept": format
            }
        }).done(onData);
        function onData(data) {
            if (data) {
                var json = null;
                if (isDmr) {
                    var response = dmr.ModelNode.fromBase64(data);
                    var jsonText = response.toJSONString();
                    json = JSON.parse(jsonText);
                }
                else {
                    json = JSON.parse(data);
                    json = json.result;
                }
                $scope.row = json;
                Core.$apply($scope);
                console.log("Response: " + JSON.stringify(json, null, "  "));
            }
        }
    }]);
})(JBoss || (JBoss = {}));
var JBoss;
(function (JBoss) {
    JBoss._module.controller("JBoss.JBossController", ["$scope", "$location", "jolokia", function ($scope, $location, jolokia) {
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(col.field) | jbossIconClass}}"></i></div>';
        var urlTemplate = '<div class="ngCellText" title="{{row.getProperty(col.field)}}">' + '<a ng-href="{{row.getProperty(col.field)}}" target="_blank">{{row.getProperty(col.field)}}</a>' + '</div>';
        $scope.uninstallDialog = new UI.Dialog();
        $scope.httpPort;
        $scope.httpScheme = "http";
        $scope.webapps = [];
        $scope.selected = [];
        var columnDefs = [
            {
                field: 'status',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'name',
                displayName: 'Name',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'contextPath',
                displayName: 'Context-Path',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'url',
                displayName: 'Url',
                cellTemplate: urlTemplate,
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        $scope.gridOptions = {
            data: 'webapps',
            displayFooter: true,
            selectedItems: $scope.selected,
            selectWithCheckboxOnly: true,
            columnDefs: columnDefs,
            filterOptions: {
                filterText: ''
            }
        };
        function render(response) {
            $scope.webapps = [];
            $scope.mbeanIndex = {};
            $scope.selected.length = 0;
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    obj.mbean = response.request.mbean;
                    var mbean = obj.mbean;
                    if (mbean) {
                        obj.name = JBoss.cleanWebAppName(obj.name);
                        obj.contextPath = JBoss.cleanContextPath(obj.name);
                        var hostname = Core.extractTargetUrl($location, $scope.httpScheme, $scope.httpPort);
                        function updateUrl() {
                            obj.url = hostname + obj['contextPath'];
                        }
                        updateUrl();
                        var undertowMBean = mbean + ",subsystem=undertow";
                        jolokia.request({ type: "read", mbean: undertowMBean, attribute: ["contextRoot"] }, onSuccess(function (response) {
                            var value = response.value;
                            if (value) {
                                var contextPath = value["contextRoot"];
                                if (contextPath) {
                                    obj.contextPath = contextPath;
                                    updateUrl();
                                    Core.$apply($scope);
                                }
                            }
                        }));
                        var idx = $scope.mbeanIndex[mbean];
                        if (angular.isDefined(idx)) {
                            $scope.webapps[mbean] = obj;
                        }
                        else {
                            $scope.mbeanIndex[mbean] = $scope.webapps.length;
                            $scope.webapps.push(obj);
                        }
                        Core.$apply($scope);
                    }
                }
            }
            angular.forEach(response, function (value, key) {
                var mbean = value;
                jolokia.request({ type: "read", mbean: mbean, attribute: ["name", "status"] }, onSuccess(onAttributes));
            });
            Core.$apply($scope);
        }
        ;
        $scope.controlWebApps = function (op) {
            var mbeanNames = $scope.selected.map(function (b) {
                return b.mbean;
            });
            if (!angular.isArray(mbeanNames)) {
                mbeanNames = [mbeanNames];
            }
            var lastIndex = (mbeanNames.length || 1) - 1;
            angular.forEach(mbeanNames, function (mbean, idx) {
                var onResponse = (idx >= lastIndex) ? $scope.onLastResponse : $scope.onResponse;
                jolokia.request({
                    type: 'exec',
                    mbean: mbean,
                    operation: op,
                    arguments: null
                }, onSuccess(onResponse, { error: onResponse }));
            });
        };
        $scope.start = function () {
            $scope.controlWebApps('deploy');
        };
        $scope.stop = function () {
            $scope.controlWebApps('undeploy');
        };
        $scope.reload = function () {
            $scope.controlWebApps('redeploy');
        };
        $scope.uninstall = function () {
            $scope.controlWebApps('remove');
            $scope.uninstallDialog.close();
        };
        $scope.onLastResponse = function (response) {
            $scope.onResponse(response);
            loadData();
        };
        $scope.onResponse = function (response) {
        };
        $scope.$on('jmxTreeUpdated', reloadFunction);
        $scope.$watch('workspace.tree', reloadFunction);
        function reloadFunction() {
            setTimeout(loadData, 50);
        }
        function loadData() {
            console.log("Loading JBoss webapp data...");
            var connectors = jolokia.search("jboss.as:socket-binding-group=standard-sockets,*");
            if (connectors) {
                var found = false;
                angular.forEach(connectors, function (key, value) {
                    var mbean = key;
                    if (!found) {
                        var data = jolokia.request({ type: "read", mbean: mbean, attribute: ["port", "name"] });
                        if (data && data.value && data.value.name && data.value.name.toString().toLowerCase() === 'http') {
                            found = true;
                            $scope.httpPort = data.value.port;
                            $scope.httpScheme = "http";
                        }
                    }
                });
            }
            jolokia.search("jboss.as:deployment=*", onSuccess(render));
        }
        $scope.jbossServerVersion = "";
        $scope.jbossServerName = "";
        $scope.jbossServerLaunchType = "";
        var servers = jolokia.search("jboss.as:management-root=*");
        if (servers && servers.length === 1) {
            $scope.jbossServerVersion = jolokia.getAttribute(servers[0], "releaseVersion");
            $scope.jbossServerName = jolokia.getAttribute(servers[0], "name");
            $scope.jbossServerLaunchType = jolokia.getAttribute(servers[0], "launchType");
        }
        else {
            var wildflyMBean = 'jboss.as:management-root=server';
            var response = jolokia.request({ type: "read", mbean: wildflyMBean, attribute: ["releaseVersion", "name", "launchType"] });
            if (response) {
                var obj = response.value;
                if (obj) {
                    $scope.jbossServerVersion = obj.releaseVersion;
                    $scope.jbossServerName = obj.name;
                    $scope.jbossServerLaunchType = obj.launchType;
                }
            }
            else {
                console.log("Cannot find JBoss/Wildfly server or there was more than one server");
            }
        }
    }]);
})(JBoss || (JBoss = {}));
var Jclouds;
(function (Jclouds) {
    Array.prototype.unique = function () {
        var a = [], l = this.length;
        for (var i = 0; i < l; i++) {
            for (var j = i + 1; j < l; j++)
                if (this[i] === this[j])
                    j = ++i;
            a.push(this[i]);
        }
        return a;
    };
    function setSelect(selection, group) {
        if (!angular.isDefined(selection)) {
            return group[0];
        }
        var answer = group.findIndex(function (item) {
            return item === selection;
        });
        if (answer !== -1) {
            return group[answer];
        }
        else {
            return group[0];
        }
    }
    Jclouds.setSelect = setSelect;
    function findContextByName(workspace, name) {
        var jcloudsMBean = getSelectionJcloudsMBean(workspace);
        var response = workspace.jolokia.request({ type: 'read', mbean: jcloudsMBean });
        return response.value["Contexts"].find(function (context) {
            return context.name === name;
        });
    }
    Jclouds.findContextByName = findContextByName;
    function populateTypeForApis(apis) {
        angular.forEach(apis, function (api) {
            populateTypeForApi(api);
        });
    }
    Jclouds.populateTypeForApis = populateTypeForApis;
    function populateTypeForApi(api) {
        var views = api["views"];
        var found = false;
        angular.forEach(views, function (view) {
            if (!found) {
                if (view.has("blob")) {
                    api["type"] = "blobstore";
                    found = true;
                }
                else if (view.has("compute")) {
                    api["type"] = "compute";
                    found = true;
                }
            }
        });
    }
    Jclouds.populateTypeForApi = populateTypeForApi;
    function filterImages(images, operatingSystemFamily) {
        if (operatingSystemFamily === "") {
            return images;
        }
        else {
            return images.findAll(function (image) {
                return image["operatingSystem"]["family"] === operatingSystemFamily;
            });
        }
    }
    Jclouds.filterImages = filterImages;
    function filterNodes(nodes, group, location) {
        var filteredNodes = [];
        if (group === "") {
            filteredNodes = nodes;
        }
        else {
            filteredNodes = nodes.findAll(function (node) {
                return node.group === group;
            });
        }
        if (location === "") {
            return filteredNodes;
        }
        else {
            return filteredNodes.findAll(function (node) {
                return node.locationId === location;
            });
        }
    }
    Jclouds.filterNodes = filterNodes;
    function resumeNode(workspace, jolokia, compute, id, success, error) {
        jolokia.request({
            type: 'exec',
            mbean: getSelectionJcloudsComputeMBean(workspace, compute),
            operation: 'resumeNode(java.lang.String)',
            arguments: [id]
        }, onSuccess(success, { error: error }));
    }
    Jclouds.resumeNode = resumeNode;
    function suspendNode(workspace, jolokia, compute, id, success, error) {
        jolokia.request({
            type: 'exec',
            mbean: getSelectionJcloudsComputeMBean(workspace, compute),
            operation: 'suspendNode(java.lang.String)',
            arguments: [id]
        }, onSuccess(success, { error: error }));
    }
    Jclouds.suspendNode = suspendNode;
    function rebootNode(workspace, jolokia, compute, id, success, error) {
        jolokia.request({
            type: 'exec',
            mbean: getSelectionJcloudsComputeMBean(workspace, compute),
            operation: 'rebootNode(java.lang.String)',
            arguments: [id]
        }, onSuccess(success, { error: error }));
    }
    Jclouds.rebootNode = rebootNode;
    function destroyNode(workspace, jolokia, compute, id, success, error) {
        jolokia.request({
            type: 'exec',
            mbean: getSelectionJcloudsComputeMBean(workspace, compute),
            operation: 'destroyNode(java.lang.String)',
            arguments: [id]
        }, onSuccess(success, { error: error }));
    }
    Jclouds.destroyNode = destroyNode;
    function apisOfType(apis, type) {
        if (type === "") {
            return apis;
        }
        return apis.findAll(function (api) {
            return api.type === type;
        });
    }
    Jclouds.apisOfType = apisOfType;
    function populateTypeForProviders(providers) {
        angular.forEach(providers, function (provider) {
            populateTypeForProvider(provider);
        });
    }
    Jclouds.populateTypeForProviders = populateTypeForProviders;
    function populateTypeForProvider(provider) {
        var views = provider["api"]["views"];
        var found = false;
        angular.forEach(views, function (view) {
            if (!found) {
                if (view.has("blob")) {
                    provider["type"] = "blobstore";
                    found = true;
                }
                else if (view.has("compute")) {
                    provider["type"] = "compute";
                    found = true;
                }
            }
        });
    }
    Jclouds.populateTypeForProvider = populateTypeForProvider;
    function providersOfType(providers, type) {
        if (type === "") {
            return providers;
        }
        return providers.findAll(function (provider) {
            return provider.type === type;
        });
    }
    Jclouds.providersOfType = providersOfType;
    function findFirstObjectName(node) {
        if (node) {
            var answer = node.objectName;
            if (answer) {
                return answer;
            }
            else {
                var children = node.children;
                if (children && children.length) {
                    return findFirstObjectName(children[0]);
                }
            }
        }
        return null;
    }
    Jclouds.findFirstObjectName = findFirstObjectName;
    function childsOfType(node) {
        var types = [];
        angular.forEach(node.children, function (child) {
            types.push(child.title);
        });
        return types;
    }
    Jclouds.childsOfType = childsOfType;
    function listJcloudsMBeanNameOfType(workspace, type) {
        if (workspace) {
            var folder = workspace.tree.navigate("org.jclouds", type);
            return childsOfType(folder);
        }
        return null;
    }
    Jclouds.listJcloudsMBeanNameOfType = listJcloudsMBeanNameOfType;
    function getSelectionJcloudsMBean(workspace) {
        if (workspace) {
            var folder = workspace.tree.navigate("org.jclouds", "management", "core");
            return findFirstObjectName(folder);
        }
        return null;
    }
    Jclouds.getSelectionJcloudsMBean = getSelectionJcloudsMBean;
    function getSelectionJcloudsComputeMBean(workspace, name) {
        if (workspace) {
            var folder = workspace.tree.navigate("org.jclouds", "compute", name);
            return findFirstObjectName(folder);
        }
        return null;
    }
    Jclouds.getSelectionJcloudsComputeMBean = getSelectionJcloudsComputeMBean;
    function getSelectionJcloudsBlobstoreMBean(workspace, name) {
        if (workspace) {
            var folder = workspace.tree.navigate("org.jclouds", "blobstore", name);
            return findFirstObjectName(folder);
        }
        return null;
    }
    Jclouds.getSelectionJcloudsBlobstoreMBean = getSelectionJcloudsBlobstoreMBean;
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    var pluginName = 'jclouds';
    Jclouds._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ngGrid', 'hawtioCore']);
    Jclouds._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/jclouds/api', { templateUrl: 'app/jclouds/html/api-list.html' }).when('/jclouds/api/:apiId', { templateUrl: 'app/jclouds/html/api.html' }).when('/jclouds/provider', { templateUrl: 'app/jclouds/html/provider-list.html' }).when('/jclouds/provider/:providerId', { templateUrl: 'app/jclouds/html/provider.html' }).when('/jclouds/compute/service', { templateUrl: 'app/jclouds/html/compute/compute-service-list.html' }).when('/jclouds/compute/service/:computeId', { templateUrl: 'app/jclouds/html/compute/compute-service.html' }).when('/jclouds/compute/node/:computeId', { templateUrl: 'app/jclouds/html/compute/node-list.html' }).when('/jclouds/compute/node/:computeId/*nodeId', { templateUrl: 'app/jclouds/html/compute/node.html' }).when('/jclouds/compute/image/:computeId', { templateUrl: 'app/jclouds/html/compute/image-list.html' }).when('/jclouds/compute/image/:computeId/*imageId', { templateUrl: 'app/jclouds/html/compute/image.html' }).when('/jclouds/compute/hardware/:computeId', { templateUrl: 'app/jclouds/html/compute/hardware-list.html' }).when('/jclouds/compute/hardware/:computeId/*hardwareId', { templateUrl: 'app/jclouds/html/compute/hardware.html' }).when('/jclouds/compute/location/:computeId', { templateUrl: 'app/jclouds/html/compute/location-list.html' }).when('/jclouds/compute/location/:computeId/*locationId', { templateUrl: 'app/jclouds/html/compute/location.html' }).when('/jclouds/blobstore/service', { templateUrl: 'app/jclouds/html/blobstore/blobstore-service-list.html' }).when('/jclouds/blobstore/service/:blobstoreId', { templateUrl: 'app/jclouds/html/blobstore/blobstore-service.html' }).when('/jclouds/blobstore/location/:blobstoreId', { templateUrl: 'app/jclouds/html/blobstore/location-list.html' }).when('/jclouds/blobstore/location/:blobstoreId/*locationId', { templateUrl: 'app/jclouds/html/blobstore/location.html' }).when('/jclouds/blobstore/container/:blobstoreId', { templateUrl: 'app/jclouds/html/blobstore/container-list.html' }).when('/jclouds/blobstore/container/:blobstoreId/:containerId', { templateUrl: 'app/jclouds/html/blobstore/container.html' }).when('/jclouds/blobstore/container/:blobstoreId/:containerId/*directory', { templateUrl: 'app/jclouds/html/blobstore/container.html' });
    }]);
    Jclouds._module.run(["workspace", "viewRegistry", "helpRegistry", function (workspace, viewRegistry, helpRegistry) {
        viewRegistry['jclouds'] = "app/jclouds/html/layoutJclouds.html";
        helpRegistry.addUserDoc('jclouds', 'app/' + 'jclouds' + '/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties("org.jclouds");
        });
        workspace.topLevelTabs.push({
            id: "jclouds",
            content: "jclouds",
            title: "Visualise and manage the Jclouds Compute/BlobStore providers and apis",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties("org.jclouds"); },
            href: function () { return "#/jclouds/api"; },
            isActive: function (workspace) { return workspace.isLinkActive("jclouds"); }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.ApiListController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.result = {};
        $scope.apis = [];
        $scope.type = "";
        $scope.types = ["", "blobstore", "compute", "loadbalancer"];
        var key = $location.search()['type'];
        if (key) {
            $scope.type = key;
        }
        $scope.selectedApis = [];
        $scope.apiTable = {
            data: 'apis',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedApis,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'Id',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/api/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'name',
                    displayName: 'Name',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 350
                },
                {
                    field: 'type',
                    displayName: 'Type',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 100
                }
            ]
        };
        Core.register(jolokia, $scope, {
            type: 'read',
            mbean: Jclouds.getSelectionJcloudsMBean(workspace)
        }, onSuccess(render));
        function render(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.apis = $scope.result["Apis"];
                Jclouds.populateTypeForApis($scope.apis);
                Core.$apply($scope);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("JClouds.ApiController", ["$scope", "$filter", "workspace", "$routeParams", function ($scope, $filter, workspace, $routeParams) {
        $scope.apiId = $routeParams.apiId;
        updateTableContents();
        function setApi(api) {
            Jclouds.populateTypeForApi(api);
            $scope.row = api;
            Core.$apply($scope);
        }
        ;
        function updateTableContents() {
            var jcloudsCoreMbean = Jclouds.getSelectionJcloudsMBean(workspace);
            var jolokia = workspace.jolokia;
            if (jcloudsCoreMbean) {
                setApi(jolokia.request({ type: 'exec', mbean: Jclouds.getSelectionJcloudsMBean(workspace), operation: 'findApiById(java.lang.String)', arguments: [$scope.apiId] }).value);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.BlobstoreNavigationController", ["$scope", "$routeParams", "workspace", function ($scope, $routeParams, workspace) {
        $scope.blobstoreId = $routeParams.blobstoreId;
        $scope.isActive = function (nav) {
            if (angular.isString(nav))
                return workspace.isLinkActive(nav);
            var fn = nav.isActive;
            if (fn) {
                return fn(workspace);
            }
            return workspace.isLinkActive(nav.href());
        };
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.BlobstoreListController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.result = {};
        $scope.blobstoreServiceIds = [];
        $scope.blobstoreServices = [];
        $scope.blobstoreTable = {
            plugins: [],
            data: 'blobstoreServices',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedBlobstoreServices,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'name',
                    displayName: 'Service Name',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/blobstore/service/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'providerId',
                    displayName: 'Proivder',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'identity',
                    displayName: 'Identity',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                }
            ]
        };
        render(Jclouds.listJcloudsMBeanNameOfType(workspace, "blobstore"));
        function render(response) {
            if (!Object.equal($scope.result, response)) {
                $scope.result = response;
                $scope.blobstoreServiceIds = $scope.result;
                var blobstoreServices = [];
                angular.forEach($scope.blobstoreServiceIds, function (id) {
                    blobstoreServices.push(Jclouds.findContextByName(workspace, id));
                });
                $scope.blobstoreServices = blobstoreServices;
                Core.$apply($scope);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.BlobstoreContainerListController", ["$scope", "$location", "workspace", "jolokia", "$routeParams", function ($scope, $location, workspace, jolokia, $routeParams) {
        $scope.blobstoreId = $routeParams.blobstoreId;
        $scope.result = {};
        $scope.containers = [];
        $scope.selectedContainers = [];
        $scope.containerTable = {
            plugins: [],
            data: 'containers',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedContainers,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'name',
                    displayName: 'Name',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/blobstore/container/{{blobstoreId}}/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'creationDate',
                    displayName: 'Created',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                }
            ]
        };
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Jclouds.getSelectionJcloudsBlobstoreMBean(workspace, $scope.blobstoreId),
            operation: 'list()'
        }, onSuccess(render));
        function render(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.containers = $scope.result;
                Core.$apply($scope);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.BlobstoreContainerController", ["$scope", "$filter", "workspace", "$routeParams", function ($scope, $filter, workspace, $routeParams) {
        $scope.blobstoreId = $routeParams.blobstoreId;
        $scope.containerId = $routeParams.containerId;
        $scope.directory = $routeParams.directory;
        $scope.contents = [];
        $scope.breadcrumbs = loadBreadcrumbs($scope.blobstoreId, $scope.containerId, $scope.directory);
        $scope.contentTable = {
            data: 'contents',
            displayFooter: false,
            columnDefs: [
                {
                    field: 'name',
                    displayName: 'Content',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/blobstore/container/{{blobstoreId}}/{{containerId}}/{{row.entity.fullpath}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    cellFilter: ""
                },
                {
                    field: 'createdDate',
                    displayName: 'Created',
                    cellFilter: "date:'EEE, MMM d, y : hh:mm:ss a'"
                },
                {
                    field: 'lastModifiedDate',
                    displayName: 'Modified',
                    cellFilter: "date:'EEE, MMM d, y : hh:mm:ss a'"
                }
            ]
        };
        updateTableContents();
        function setContainers(containers) {
            $scope.contents = populatePathAndName(filterContainers(containers, $scope.directory), $scope.directory);
            Core.$apply($scope);
        }
        ;
        function updateTableContents() {
            var jolokia = workspace.jolokia;
            var blobstoreMbean = Jclouds.getSelectionJcloudsBlobstoreMBean(workspace, $scope.blobstoreId);
            if (blobstoreMbean) {
                if ($scope.directory) {
                    setContainers(jolokia.request({ type: 'exec', mbean: blobstoreMbean, operation: 'list(java.lang.String, java.lang.String)', arguments: [$scope.containerId, $scope.directory] }).value);
                }
                else {
                    setContainers(jolokia.request({ type: 'exec', mbean: blobstoreMbean, operation: 'list(java.lang.String)', arguments: [$scope.containerId] }).value);
                }
            }
        }
        function filterContainers(containers, directory) {
            return containers.filter(function (container) {
                return container.name !== directory;
            });
        }
        function populatePathAndName(containers, directory) {
            var updatedContainers = [];
            angular.forEach(containers, function (container) {
                var updateContainer = container;
                updateContainer.fullpath = container.name;
                if (updateContainer.name.startsWith(directory)) {
                    updateContainer.name = updateContainer.name.substring(directory.length + 1);
                }
                updatedContainers.push(updateContainer);
            });
            return updatedContainers;
        }
        $scope.isBlob = function (container) {
            return container.type === 'BLOB';
        };
        function loadBreadcrumbs(blobstore, container, directory) {
            var href = "#/jclouds/blobstore/container/" + blobstore + "/" + container;
            var breadcrumbs = [
                { href: href, name: "/" + container }
            ];
            var array = directory ? directory.split("/") : [];
            angular.forEach(array, function (name) {
                if (!name.startsWith("/") && !href.endsWith("/")) {
                    href += "/";
                }
                href += name;
                breadcrumbs.push({ href: href, name: name });
            });
            return breadcrumbs;
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.BlobstoreLocationListController", ["$scope", "$location", "workspace", "jolokia", "$routeParams", function ($scope, $location, workspace, jolokia, $routeParams) {
        $scope.blobstoreId = $routeParams.blobstoreId;
        $scope.result = {};
        $scope.locations = [];
        $scope.selectedLocations = [];
        $scope.locationTable = {
            plugins: [],
            data: 'locations',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedLocations,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'Id',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/blobstore/location/{{blobstoreId}}/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'description',
                    displayName: 'Description',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                }
            ]
        };
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Jclouds.getSelectionJcloudsBlobstoreMBean(workspace, $scope.blobstoreId),
            operation: 'listAssignableLocations()'
        }, onSuccess(render));
        function render(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.locations = $scope.result;
                Core.$apply($scope);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.BlobstoreLocationController", ["$scope", "$filter", "workspace", "$routeParams", function ($scope, $filter, workspace, $routeParams) {
        $scope.blobstoreId = $routeParams.blobstoreId;
        $scope.locationId = $routeParams.locationId;
        updateTableContents();
        function setLocationProfiles(locationProfiles) {
            $scope.row = findLocationById(locationProfiles, $scope.locationId);
            Core.$apply($scope);
        }
        ;
        function updateTableContents() {
            var jolokia = workspace.jolokia;
            var blobstoreMbean = Jclouds.getSelectionJcloudsBlobstoreMBean(workspace, $scope.blobstoreId);
            if (blobstoreMbean) {
                setLocationProfiles(jolokia.request({ type: 'exec', mbean: blobstoreMbean, operation: 'listAssignableLocations()' }).value);
            }
        }
        function findLocationById(locationProfiles, id) {
            return locationProfiles.find(function (location) {
                return location.id === id;
            });
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.ComputeNavigationController", ["$scope", "$routeParams", "workspace", function ($scope, $routeParams, workspace) {
        $scope.computeId = $routeParams.computeId;
        $scope.isActive = function (nav) {
            if (angular.isString(nav))
                return workspace.isLinkActive(nav);
            var fn = nav.isActive;
            if (fn) {
                return fn(workspace);
            }
            return workspace.isLinkActive(nav.href());
        };
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.ComputeListController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.result = {};
        $scope.computeServiceIds = [];
        $scope.computeServices = [];
        $scope.computeTable = {
            plugins: [],
            data: 'computeServices',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedComputeServices,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'name',
                    displayName: 'Service Name',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/compute/service/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'providerId',
                    displayName: 'Proivder',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'identity',
                    displayName: 'Identity',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                }
            ]
        };
        render(Jclouds.listJcloudsMBeanNameOfType(workspace, "compute"));
        function render(response) {
            if (!Object.equal($scope.result, response)) {
                $scope.result = response;
                $scope.computeServiceIds = $scope.result;
                var computeServices = [];
                angular.forEach($scope.computeServiceIds, function (id) {
                    computeServices.push(Jclouds.findContextByName(workspace, id));
                });
                $scope.computeServices = computeServices;
                Core.$apply($scope);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.HardwareListController", ["$scope", "$location", "workspace", "jolokia", "$routeParams", function ($scope, $location, workspace, jolokia, $routeParams) {
        $scope.computeId = $routeParams.computeId;
        $scope.result = {};
        $scope.hardwares = [];
        $scope.selectedHardwares = [];
        $scope.hardwareTable = {
            plugins: [],
            data: 'hardwares',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedHardwares,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'Id',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/compute/hardware/{{computeId}}/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'name',
                    displayName: 'Name',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'ram',
                    displayName: 'Ram',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'hypervisor',
                    displayName: 'Hypervisor',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                }
            ]
        };
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Jclouds.getSelectionJcloudsComputeMBean(workspace, $scope.computeId),
            operation: 'listHardwareProfiles()'
        }, onSuccess(render));
        function render(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.hardwares = $scope.result;
                Core.$apply($scope);
            }
        }
        $scope.is64BitIcon = function (is64bit) {
            if (is64bit) {
                return 'icon-thumbs-up';
            }
            else {
                return 'icon-thumbs-down';
            }
        };
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.HardwareController", ["$scope", "$filter", "workspace", "$routeParams", function ($scope, $filter, workspace, $routeParams) {
        $scope.computeId = $routeParams.computeId;
        $scope.hardwareId = $routeParams.hardwareId;
        updateTableContents();
        $scope.processorsTable = {
            plugins: [],
            data: 'processors',
            showFilter: false,
            displayFooter: false,
            displaySelectionCheckbox: false,
            showColumnMenu: false,
            rowHeight: 32,
            columnDefs: [
                {
                    field: 'cores',
                    displayName: 'Cores',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 50,
                    resizable: false
                },
                {
                    field: 'speed',
                    displayName: 'Speed',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 100,
                    resizable: false
                }
            ]
        };
        $scope.volumesTable = {
            plugins: [],
            data: 'volumes',
            showFilter: false,
            displayFooter: false,
            displaySelectionCheckbox: false,
            showColumnMenu: false,
            rowHeight: 32,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'Id',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 100,
                    resizable: false
                },
                {
                    field: 'type',
                    displayName: 'Type',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 100,
                    resizable: false
                },
                {
                    field: 'device',
                    displayName: 'Device',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 100,
                    resizable: false
                },
                {
                    field: 'size',
                    displayName: 'Size',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 100,
                    resizable: false
                },
                {
                    field: 'bootDevice',
                    displayName: 'Boot Device',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 100,
                    resizable: false
                },
                {
                    field: 'durable',
                    displayName: 'Durable',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 100,
                    resizable: false
                }
            ]
        };
        function setHardwareProfiles(hardwareProfiles) {
            $scope.row = findHardwareById(hardwareProfiles, $scope.hardwareId);
            $scope.processors = $scope.row["processors"];
            $scope.volumes = $scope.row["volumes"];
            Core.$apply($scope);
        }
        ;
        function updateTableContents() {
            var jolokia = workspace.jolokia;
            var computeMbean = Jclouds.getSelectionJcloudsComputeMBean(workspace, $scope.computeId);
            if (computeMbean) {
                setHardwareProfiles(jolokia.request({ type: 'exec', mbean: computeMbean, operation: 'listHardwareProfiles()' }).value);
            }
        }
        function findHardwareById(hardwareProfiles, id) {
            return hardwareProfiles.find(function (hardware) {
                return hardware.id === id;
            });
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.ImageListController", ["$scope", "$location", "workspace", "jolokia", "$routeParams", function ($scope, $location, workspace, jolokia, $routeParams) {
        $scope.computeId = $routeParams.computeId;
        $scope.result = {};
        $scope.images = [];
        $scope.operatingSystemFamily = "";
        $scope.operatingSystemFamilies = [];
        var os = $location.search()['os'];
        if (os) {
            $scope.operatingSystemFamily = os;
        }
        $scope.selectedImages = [];
        $scope.imageTable = {
            data: 'images',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedImages,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'Id',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/compute/image/{{computeId}}/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'name',
                    displayName: 'Name',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'operatingSystem.family',
                    displayName: 'Operating System',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200
                },
                {
                    field: 'operatingSystem.is64Bit',
                    displayName: '64 bit',
                    cellTemplate: '<div class="ngCellText pagination-centered"><i class="icon1point5x {{is64BitIcon(row.getProperty(col.field))}}"></i></div>',
                    width: 200
                },
                {
                    field: 'status',
                    displayName: 'Status',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 300
                }
            ]
        };
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Jclouds.getSelectionJcloudsComputeMBean(workspace, $scope.computeId),
            operation: 'listImages()'
        }, onSuccess(render));
        function render(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.images = $scope.result;
                $scope.operatingSystemFamilies = extractOperatingSystemFamilies($scope.images);
                Core.$apply($scope);
            }
        }
        function extractOperatingSystemFamilies(images) {
            var operatingSystemFamilies = [];
            operatingSystemFamilies.push("");
            angular.forEach(images, function (image) {
                var operatingSystemFamily = image["operatingSystem"]["family"];
                operatingSystemFamilies.push(operatingSystemFamily);
            });
            return operatingSystemFamilies.unique();
        }
        $scope.is64BitIcon = function (is64bit) {
            if (is64bit) {
                return 'icon-thumbs-up';
            }
            else {
                return 'icon-thumbs-down';
            }
        };
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.ImageController", ["$scope", "$filter", "workspace", "$routeParams", function ($scope, $filter, workspace, $routeParams) {
        $scope.computeId = $routeParams.computeId;
        $scope.imageId = $routeParams.imageId;
        updateTableContents();
        function setImage(api) {
            $scope.row = api;
            Core.$apply($scope);
        }
        ;
        function updateTableContents() {
            var jolokia = workspace.jolokia;
            var computeMbean = Jclouds.getSelectionJcloudsComputeMBean(workspace, $scope.computeId);
            if (computeMbean) {
                setImage(jolokia.request({ type: 'exec', mbean: computeMbean, operation: 'getImage(java.lang.String)', arguments: [$scope.imageId] }).value);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.ComputeLocationListController", ["$scope", "$location", "workspace", "jolokia", "$routeParams", function ($scope, $location, workspace, jolokia, $routeParams) {
        $scope.computeId = $routeParams.computeId;
        $scope.result = {};
        $scope.locations = [];
        $scope.selectedLocations = [];
        $scope.locationTable = {
            plugins: [],
            data: 'locations',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedLocations,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'Id',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/compute/location/{{computeId}}/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'description',
                    displayName: 'Description',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200,
                    resizable: false
                }
            ]
        };
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Jclouds.getSelectionJcloudsComputeMBean(workspace, $scope.computeId),
            operation: 'listAssignableLocations()'
        }, onSuccess(render));
        function render(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.locations = $scope.result;
                Core.$apply($scope);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.ComputeLocationController", ["$scope", "$filter", "workspace", "$routeParams", function ($scope, $filter, workspace, $routeParams) {
        $scope.computeId = $routeParams.computeId;
        $scope.locationId = $routeParams.locationId;
        updateTableContents();
        function setLocationProfiles(locationProfiles) {
            $scope.row = findLocationById(locationProfiles, $scope.locationId);
            Core.$apply($scope);
        }
        ;
        function updateTableContents() {
            var jolokia = workspace.jolokia;
            var computeMbean = Jclouds.getSelectionJcloudsComputeMBean(workspace, $scope.computeId);
            if (computeMbean) {
                setLocationProfiles(jolokia.request({ type: 'exec', mbean: computeMbean, operation: 'listAssignableLocations()' }).value);
            }
        }
        function findLocationById(locationProfiles, id) {
            return locationProfiles.find(function (location) {
                return location.id === id;
            });
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.NodeListController", ["$scope", "$location", "workspace", "jolokia", "$routeParams", function ($scope, $location, workspace, jolokia, $routeParams) {
        $scope.computeId = $routeParams.computeId;
        $scope.result = {};
        $scope.nodes = [];
        $scope.group = "";
        $scope.groups = [];
        $scope.location = "";
        $scope.locations = [];
        var grp = $location.search()['group'];
        if (grp) {
            $scope.group = grp;
        }
        var loc = $location.search()['location'];
        if (loc) {
            $scope.location = loc;
        }
        $scope.selectedNodes = [];
        $scope.nodeTable = {
            data: 'nodes',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedNodes,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'Id',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/compute/node/{{computeId}}/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'group',
                    displayName: 'Group',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/compute/node/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'operatingSystem.family',
                    displayName: 'Operating System',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200
                },
                {
                    field: 'locationId',
                    displayName: 'Location',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200
                },
                {
                    field: 'hostname',
                    displayName: 'Host Name',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 300
                }
            ]
        };
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Jclouds.getSelectionJcloudsComputeMBean(workspace, $scope.computeId),
            operation: 'listNodes()'
        }, onSuccess(render));
        function render(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.nodes = $scope.result;
                $scope.locations = extractLocations($scope.nodes);
                $scope.groups = extractGroups($scope.nodes);
                Core.$apply($scope);
            }
        }
        function extractGroups(nodes) {
            var groups = [];
            groups.push("");
            angular.forEach(nodes, function (node) {
                var group = node["group"];
                groups.push(group);
            });
            return groups.unique();
        }
        function extractLocations(nodes) {
            var locations = [];
            locations.push("");
            angular.forEach(nodes, function (node) {
                var location = node["locationId"];
                locations.push(location);
            });
            return locations.unique();
        }
        $scope.resume = function () {
            $scope.selectedNodes.forEach(function (node) {
                Jclouds.resumeNode(workspace, jolokia, $scope.computeId, node.id, function () {
                    console.log("Resumed!");
                }, function () {
                    console.log("Failed to resume!");
                });
            });
        };
        $scope.suspend = function () {
            $scope.selectedNodes.forEach(function (node) {
                Jclouds.suspendNode(workspace, jolokia, $scope.computeId, node.id, function () {
                    console.log("Suspended!");
                }, function () {
                    console.log("Failed to suspend!");
                });
            });
        };
        $scope.reboot = function () {
            $scope.selectedNodes.forEach(function (node) {
                Jclouds.rebootNode(workspace, jolokia, $scope.computeId, node.id, function () {
                    console.log("Rebooted!");
                }, function () {
                    console.log("Failed to reboot!");
                });
            });
        };
        $scope.destroy = function () {
            $scope.selectedNodes.forEach(function (node) {
                Jclouds.destroyNode(workspace, jolokia, $scope.computeId, node.id, function () {
                    console.log("Destroyed!");
                }, function () {
                    console.log("Failed to destroy!");
                });
            });
        };
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.NodeController", ["$scope", "$filter", "workspace", "$routeParams", function ($scope, $filter, workspace, $routeParams) {
        $scope.computeId = $routeParams.computeId;
        $scope.nodeId = $routeParams.nodeId;
        updateTableContents();
        function setNode(api) {
            $scope.row = api;
            Core.$apply($scope);
        }
        ;
        function updateTableContents() {
            var computeMbean = Jclouds.getSelectionJcloudsComputeMBean(workspace, $scope.computeId);
            var jolokia = workspace.jolokia;
            if (computeMbean) {
                setNode(jolokia.request({ type: 'exec', mbean: computeMbean, operation: 'getNode(java.lang.String)', arguments: [$scope.nodeId] }).value);
            }
        }
        $scope.resume = function () {
            Jclouds.resumeNode(workspace, workspace.jolokia, $scope.computeId, $scope.nodeId, function () {
                console.log("Resumed!");
            }, function () {
                console.log("Failed to resume!");
            });
        };
        $scope.suspend = function () {
            Jclouds.suspendNode(workspace, workspace.jolokia, $scope.computeId, $scope.nodeId, function () {
                console.log("Suspended!");
            }, function () {
                console.log("Failed to suspend!");
            });
        };
        $scope.reboot = function () {
            Jclouds.rebootNode(workspace, workspace.jolokia, $scope.computeId, $scope.nodeId, function () {
                console.log("Rebooted!");
            }, function () {
                console.log("Failed to reboot!");
            });
        };
        $scope.destroy = function () {
            Jclouds.destroyNode(workspace, workspace.jolokia, $scope.computeId, $scope.nodeId, function () {
                console.log("Destroyed!");
            }, function () {
                console.log("Failed to destroy!");
            });
        };
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.ProviderListController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.result = {};
        $scope.providers = [];
        $scope.type = "";
        $scope.types = ["", "blobstore", "compute", "loadbalancer"];
        var key = $location.search()['type'];
        if (key) {
            $scope.type = key;
        }
        $scope.selectedProviders = [];
        $scope.providerTable = {
            data: 'providers',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: true
            },
            selectedItems: $scope.selectedProviders,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'Id',
                    cellTemplate: '<div class="ngCellText"><a href="#/jclouds/provider/{{row.getProperty(col.field)}}{{hash}}">{{row.getProperty(col.field)}}</a></div>',
                    width: 200,
                    resizable: false
                },
                {
                    field: 'name',
                    displayName: 'Name',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 350
                },
                {
                    field: 'type',
                    displayName: 'Type',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 100
                }
            ]
        };
        Core.register(jolokia, $scope, {
            type: 'read',
            mbean: Jclouds.getSelectionJcloudsMBean(workspace)
        }, onSuccess(render));
        function render(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.result = response.value;
                $scope.providers = $scope.result["Providers"];
                Jclouds.populateTypeForProviders($scope.providers);
                Core.$apply($scope);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jclouds;
(function (Jclouds) {
    Jclouds._module.controller("Jclouds.ProviderController", ["$scope", "$filter", "workspace", "$routeParams", function ($scope, $filter, workspace, $routeParams) {
        $scope.providerId = $routeParams.providerId;
        updateTableContents();
        function setProvider(provider) {
            Jclouds.populateTypeForProvider(provider);
            $scope.row = provider;
            Core.$apply($scope);
        }
        ;
        function updateTableContents() {
            var jcloudsCoreMbean = Jclouds.getSelectionJcloudsMBean(workspace);
            var jolokia = workspace.jolokia;
            if (jcloudsCoreMbean) {
                setProvider(jolokia.request({ type: 'exec', mbean: Jclouds.getSelectionJcloudsMBean(workspace), operation: 'findProviderById(java.lang.String)', arguments: [$scope.providerId] }).value);
            }
        }
    }]);
})(Jclouds || (Jclouds = {}));
var Jetty;
(function (Jetty) {
    function iconClass(state) {
        if (state) {
            switch (state.toString().toLowerCase()) {
                case 'started':
                    return "green icon-play-circle";
                case 'true':
                    return "green icon-play-circle";
            }
        }
        return "orange icon-off";
    }
    Jetty.iconClass = iconClass;
    function isState(item, state) {
        var value = (item.state || "").toLowerCase();
        if (angular.isArray(state)) {
            return state.any(function (stateText) { return value.startsWith(stateText); });
        }
        else {
            return value.startsWith(state);
        }
    }
    Jetty.isState = isState;
})(Jetty || (Jetty = {}));
var Jetty;
(function (Jetty) {
    var pluginName = 'jetty';
    Jetty._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ui.bootstrap.dialog', 'hawtioCore']);
    Jetty._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/jetty/server', { templateUrl: 'app/jetty/html/server.html' }).when('/jetty/applications', { templateUrl: 'app/jetty/html/applications.html' }).when('/jetty/connectors', { templateUrl: 'app/jetty/html/connectors.html' }).when('/jetty/threadpools', { templateUrl: 'app/jetty/html/threadpools.html' });
    }]);
    Jetty._module.filter('jettyIconClass', function () { return Jetty.iconClass; });
    Jetty._module.run(["$location", "workspace", "viewRegistry", "helpRegistry", function ($location, workspace, viewRegistry, helpRegistry) {
        viewRegistry['jetty'] = "app/jetty/html/layoutJettyTabs.html";
        helpRegistry.addUserDoc('jetty', 'app/jetty/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties("org.eclipse.jetty.server");
        });
        workspace.topLevelTabs.push({
            id: "jetty",
            content: "Jetty",
            title: "Manage your Jetty container",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties("org.eclipse.jetty.server"); },
            href: function () { return "#/jetty/applications"; },
            isActive: function (workspace) { return workspace.isTopTabActive("jetty"); }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Jetty || (Jetty = {}));
var Jetty;
(function (Jetty) {
    Jetty._module.controller("Jetty.ConnectorsController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(col.field) | jettyIconClass}}"></i></div>';
        $scope.connectors = [];
        $scope.selected = [];
        var columnDefs = [
            {
                field: 'running',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'port',
                displayName: 'Port',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'protocols',
                displayName: 'Protocols',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'default',
                displayName: 'Default',
                cellFilter: null,
                width: "*",
                resizable: true
            },
        ];
        $scope.gridOptions = {
            data: 'connectors',
            displayFooter: true,
            selectedItems: $scope.selected,
            columnDefs: columnDefs,
            filterOptions: {
                filterText: ''
            },
            title: "Connectors"
        };
        $scope.controlConnectors = function (op) {
            var mbeanNames = $scope.selected.map(function (b) {
                return b.mbean;
            });
            if (!angular.isArray(mbeanNames)) {
                mbeanNames = [mbeanNames];
            }
            var lastIndex = (mbeanNames.length || 1) - 1;
            angular.forEach(mbeanNames, function (mbean, idx) {
                var onResponse = (idx >= lastIndex) ? $scope.onLastResponse : $scope.onResponse;
                jolokia.request({
                    type: 'exec',
                    mbean: mbean,
                    operation: op,
                    arguments: null
                }, onSuccess(onResponse, { error: onResponse }));
            });
        };
        $scope.stop = function () {
            $scope.controlConnectors('stop');
        };
        $scope.start = function () {
            $scope.controlConnectors('start');
        };
        $scope.anySelectionIsRunning = function () {
            var selected = $scope.selected || [];
            return selected.length && selected.any(function (s) { return s.running; });
        };
        $scope.everySelectionIsRunning = function (state) {
            var selected = $scope.selected || [];
            return selected.length && selected.every(function (s) { return s.running; });
        };
        function render78(response) {
            $scope.connectors = [];
            $scope.selected.length = 0;
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    obj.mbean = response.request.mbean;
                    obj.protocols = "[http]";
                    obj.default = "http";
                    obj.port = obj.port;
                    obj.running = obj['running'] !== undefined ? obj['running'] : true;
                    $scope.connectors.push(obj);
                    if (obj.confidentialPort) {
                        var copyObj = {
                            protocols: "[https]",
                            default: "https",
                            port: obj.confidentialPort,
                            running: obj.running,
                            mbean: obj.mbean
                        };
                        $scope.connectors.push(copyObj);
                    }
                    Core.$apply($scope);
                }
            }
            angular.forEach(response, function (value, key) {
                var mbean = value;
                jolokia.request({ type: "read", mbean: mbean, attribute: [] }, onSuccess(onAttributes));
            });
            Core.$apply($scope);
        }
        ;
        function render9(response) {
            $scope.connectors = [];
            $scope.selected.length = 0;
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    obj.mbean = response.request.mbean;
                    obj.protocols = obj['protocols'];
                    obj.default = obj['defaultProtocol'];
                    obj.port = obj.port;
                    obj.running = obj['state'] == "STARTED";
                    $scope.connectors.push(obj);
                    Core.$apply($scope);
                }
            }
            angular.forEach(response, function (value, key) {
                var mbean = value;
                jolokia.request({ type: "read", mbean: mbean, attribute: [] }, onSuccess(onAttributes));
            });
            Core.$apply($scope);
        }
        ;
        $scope.onLastResponse = function (response) {
            $scope.onResponse(response);
            loadData();
        };
        $scope.onResponse = function (response) {
        };
        $scope.$on('jmxTreeUpdated', reloadFunction);
        $scope.$watch('workspace.tree', reloadFunction);
        function reloadFunction() {
            setTimeout(loadData, 50);
        }
        function loadData() {
            console.log("Loading Jetty connector data...");
            var tree = workspace.tree;
            jolokia.search("org.eclipse.jetty.server.nio:type=selectchannelconnector,*", onSuccess(render78));
            jolokia.search("org.eclipse.jetty.server:type=serverconnector,*", onSuccess(render9));
        }
    }]);
})(Jetty || (Jetty = {}));
var Jetty;
(function (Jetty) {
    Jetty._module.controller("Jetty.JettyController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}">' + '<i class="{{row.getProperty(col.field) | jettyIconClass}}"></i>' + '</div>';
        var urlTemplate = '<div class="ngCellText" title="{{row.getProperty(col.field)}}">' + '<a ng-href="{{row.getProperty(col.field)}}" target="_blank">{{row.getProperty(col.field)}}</a>' + '</div>';
        $scope.uninstallDialog = new UI.Dialog();
        $scope.httpPort;
        $scope.httpScheme = "http";
        $scope.webapps = [];
        $scope.selected = [];
        var columnDefs = [
            {
                field: 'state',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'displayName',
                displayName: 'Name',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'contextPath',
                displayName: 'Context-Path',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'url',
                displayName: 'Url',
                cellTemplate: urlTemplate,
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        $scope.gridOptions = {
            data: 'webapps',
            displayFooter: true,
            selectedItems: $scope.selected,
            columnDefs: columnDefs,
            filterOptions: {
                filterText: ''
            },
            title: "Web applications"
        };
        $scope.controlWebApps = function (op) {
            var mbeanNames = $scope.selected.map(function (b) {
                return b.mbean;
            });
            if (!angular.isArray(mbeanNames)) {
                mbeanNames = [mbeanNames];
            }
            var lastIndex = (mbeanNames.length || 1) - 1;
            angular.forEach(mbeanNames, function (mbean, idx) {
                var onResponse = (idx >= lastIndex) ? $scope.onLastResponse : $scope.onResponse;
                jolokia.request({
                    type: 'exec',
                    mbean: mbean,
                    operation: op,
                    arguments: null
                }, onSuccess(onResponse, { error: onResponse }));
            });
        };
        $scope.stop = function () {
            $scope.controlWebApps('stop');
        };
        $scope.start = function () {
            $scope.controlWebApps('start');
        };
        $scope.uninstall = function () {
            $scope.controlWebApps('destroy');
            $scope.uninstallDialog.close();
        };
        $scope.anySelectionHasState = function (state) {
            var selected = $scope.selected || [];
            return selected.length && selected.any(function (s) { return Jetty.isState(s, state); });
        };
        $scope.everySelectionHasState = function (state) {
            var selected = $scope.selected || [];
            return selected.length && selected.every(function (s) { return Jetty.isState(s, state); });
        };
        $scope.onLastResponse = function (response) {
            $scope.onResponse(response);
            loadData();
        };
        $scope.onResponse = function (response) {
        };
        $scope.$on('jmxTreeUpdated', reloadFunction);
        $scope.$watch('workspace.tree', reloadFunction);
        $scope.jettyServerVersion = "";
        $scope.jettyServerStartupTime = "";
        var servers = jolokia.search("org.eclipse.jetty.server:type=server,*");
        if (servers && servers.length === 1) {
            $scope.jettyServerVersion = jolokia.getAttribute(servers[0], "version");
            $scope.jettyServerStartupTime = jolokia.getAttribute(servers[0], "startupTime");
        }
        else {
            console.log("Cannot find jetty server or there was more than one server. response is: " + servers);
        }
        function reloadFunction() {
            setTimeout(loadData, 50);
        }
        function loadData() {
            console.log("Loading Jetty webapp data...");
            var connectors = jolokia.search("org.eclipse.jetty.server.nio:type=selectchannelconnector,*");
            if (!connectors) {
                connectors = jolokia.search("org.eclipse.jetty.server:type=serverconnector,*");
            }
            if (connectors) {
                var found = false;
                angular.forEach(connectors, function (key, value) {
                    var mbean = key;
                    if (!found) {
                        var data = jolokia.request({ type: "read", mbean: mbean, attribute: ["port", "protocols"] });
                        if (data && data.value && data.value.protocols && data.value.protocols.toString().toLowerCase().startsWith("http")) {
                            found = true;
                            $scope.httpPort = data.value.port;
                            $scope.httpScheme = "http";
                        }
                    }
                });
            }
            jolokia.search("org.mortbay.jetty.plugin:type=jettywebappcontext,*", onSuccess(render));
            jolokia.search("org.eclipse.jetty.webapp:type=webappcontext,*", onSuccess(render));
            jolokia.search("org.eclipse.jetty.servlet:type=servletcontexthandler,*", onSuccess(render));
        }
        function render(response) {
            $scope.webapps = [];
            $scope.mbeanIndex = {};
            $scope.selected.length = 0;
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    obj.mbean = response.request.mbean;
                    if (!obj.state) {
                        obj.state = obj['running'] === undefined || obj['running'] ? "started" : "stopped";
                    }
                    var hostname = Core.extractTargetUrl($location, $scope.httpScheme, $scope.httpPort);
                    obj.url = hostname + obj['contextPath'];
                    var mbean = obj.mbean;
                    if (mbean) {
                        var idx = $scope.mbeanIndex[mbean];
                        if (angular.isDefined(idx)) {
                            $scope.webapps[mbean] = obj;
                        }
                        else {
                            $scope.mbeanIndex[mbean] = $scope.webapps.length;
                            $scope.webapps.push(obj);
                        }
                        Core.$apply($scope);
                    }
                }
            }
            angular.forEach(response, function (value, key) {
                var mbean = value;
                jolokia.request({ type: "read", mbean: mbean, attribute: [] }, onSuccess(onAttributes));
            });
            Core.$apply($scope);
        }
    }]);
})(Jetty || (Jetty = {}));
var Jetty;
(function (Jetty) {
    Jetty._module.controller("Jetty.ThreadPoolsController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(col.field) | jettyIconClass}}"></i></div>';
        $scope.threadpools = [];
        var columnDefs = [
            {
                field: 'running',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'threads',
                displayName: 'Threads',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'minThreads',
                displayName: 'Min Threads',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'maxThreads',
                displayName: 'Max Threads',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'idleThreads',
                displayName: 'Idle Threads',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'idleTimeout',
                displayName: 'Idle Timeout (ms)',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'name',
                displayName: 'Name',
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        $scope.gridOptions = {
            data: 'threadpools',
            displayFooter: true,
            canSelectRows: false,
            columnDefs: columnDefs,
            title: "Thread Pools"
        };
        function render78(response) {
            $scope.threadpools = [];
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    obj.running = obj['running'] !== undefined ? obj['running'] : obj['state'] == "STARTED";
                    obj.idleTimeout = obj['idleTimeout'] !== undefined ? obj['idleTimeout'] : obj['maxIdleTimeMs'];
                    $scope.threadpools.push(obj);
                }
            }
            angular.forEach(response, function (value, key) {
                var mbean = value;
                jolokia.request({ type: "read", mbean: mbean, attribute: [] }, onSuccess(onAttributes));
            });
            Core.$apply($scope);
        }
        ;
        $scope.$on('jmxTreeUpdated', reloadFunction);
        $scope.$watch('workspace.tree', reloadFunction);
        function reloadFunction() {
            setTimeout(loadData, 50);
        }
        function loadData() {
            console.log("Loading Jetty thread pool data...");
            var tree = workspace.tree;
            jolokia.search("org.eclipse.jetty.util.thread:type=queuedthreadpool,*", onSuccess(render78));
        }
    }]);
})(Jetty || (Jetty = {}));
var Jmx;
(function (Jmx) {
    function createDashboardLink(widgetType, widget) {
        var href = "#" + widgetType.route;
        var routeParams = angular.toJson(widget);
        var title = widget.title;
        var size = angular.toJson({
            size_x: widgetType.size_x,
            size_y: widgetType.size_y
        });
        return "/dashboard/add?tab=dashboard" + "&href=" + encodeURIComponent(href) + "&size=" + encodeURIComponent(size) + "&title=" + encodeURIComponent(title) + "&routeParams=" + encodeURIComponent(routeParams);
    }
    Jmx.createDashboardLink = createDashboardLink;
    function getWidgetType(widget) {
        return Jmx.jmxWidgetTypes.find(function (type) {
            return type.type === widget.type;
        });
    }
    Jmx.getWidgetType = getWidgetType;
    Jmx.jmxWidgetTypes = [
        {
            type: "donut",
            icon: "icon-smile",
            route: "/jmx/widget/donut",
            size_x: 2,
            size_y: 2,
            title: "Add Donut chart to Dashboard"
        },
        {
            type: "area",
            icon: "icon-bar-chart",
            route: "/jmx/widget/area",
            size_x: 4,
            size_y: 2,
            title: "Add Area chart to Dashboard"
        }
    ];
    Jmx.jmxWidgets = [
        {
            type: "donut",
            title: "Java Heap Memory",
            mbean: "java.lang:type=Memory",
            attribute: "HeapMemoryUsage",
            total: "Max",
            terms: "Used",
            remaining: "Free"
        },
        {
            type: "donut",
            title: "Java Non Heap Memory",
            mbean: "java.lang:type=Memory",
            attribute: "NonHeapMemoryUsage",
            total: "Max",
            terms: "Used",
            remaining: "Free"
        },
        {
            type: "donut",
            title: "File Descriptor Usage",
            mbean: "java.lang:type=OperatingSystem",
            total: "MaxFileDescriptorCount",
            terms: "OpenFileDescriptorCount",
            remaining: "Free"
        },
        {
            type: "donut",
            title: "Loaded Classes",
            mbean: "java.lang:type=ClassLoading",
            total: "TotalLoadedClassCount",
            terms: "LoadedClassCount,UnloadedClassCount",
            remaining: "-"
        },
        {
            type: "donut",
            title: "Swap Size",
            mbean: "java.lang:type=OperatingSystem",
            total: "TotalSwapSpaceSize",
            terms: "FreeSwapSpaceSize",
            remaining: "Used Swap"
        },
        {
            type: "area",
            title: "Process CPU Time",
            mbean: "java.lang:type=OperatingSystem",
            attribute: "ProcessCpuTime"
        },
        {
            type: "area",
            title: "Process CPU Load",
            mbean: "java.lang:type=OperatingSystem",
            attribute: "ProcessCpuLoad"
        },
        {
            type: "area",
            title: "System CPU Load",
            mbean: "java.lang:type=OperatingSystem",
            attribute: "SystemCpuLoad"
        },
        {
            type: "area",
            title: "System CPU Time",
            mbean: "java.lang:type=OperatingSystem",
            attribute: "SystemCpuTime"
        }
    ];
})(Jmx || (Jmx = {}));
var Jmx;
(function (Jmx) {
    var pluginName = 'jmx';
    Jmx.currentProcessId = '';
    Jmx._module = angular.module(pluginName, ['bootstrap', 'dangle', 'ui.bootstrap', 'ui.bootstrap.modal']);
    Jmx._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/jmx/attributes', { templateUrl: 'app/jmx/html/attributes.html' }).when('/jmx/operations', { templateUrl: 'app/jmx/html/operations.html' }).when('/jmx/charts', { templateUrl: 'app/jmx/html/charts.html' }).when('/jmx/chartEdit', { templateUrl: 'app/jmx/html/chartEdit.html' }).when('/jmx/help/:tabName', { templateUrl: 'app/core/html/help.html' }).when('/jmx/widget/donut', { templateUrl: 'app/jmx/html/donutChart.html' }).when('/jmx/widget/area', { templateUrl: 'app/jmx/html/areaChart.html' });
    }]);
    Jmx._module.factory('jmxWidgetTypes', function () {
        return Jmx.jmxWidgetTypes;
    });
    Jmx._module.factory('jmxWidgets', function () {
        return Jmx.jmxWidgets;
    });
    Jmx._module.run(["$location", "workspace", "viewRegistry", "layoutTree", "jolokia", "pageTitle", "helpRegistry", function ($location, workspace, viewRegistry, layoutTree, jolokia, pageTitle, helpRegistry) {
        viewRegistry['jmx'] = layoutTree;
        helpRegistry.addUserDoc('jmx', 'app/jmx/doc/help.md');
        pageTitle.addTitleElement(function () {
            if (Jmx.currentProcessId === '') {
                try {
                    Jmx.currentProcessId = jolokia.getAttribute('java.lang:type=Runtime', 'Name');
                }
                catch (e) {
                }
                if (Jmx.currentProcessId && Jmx.currentProcessId.has("@")) {
                    Jmx.currentProcessId = "pid:" + Jmx.currentProcessId.split("@")[0];
                }
            }
            return Jmx.currentProcessId;
        });
        workspace.topLevelTabs.push({
            id: "jmx",
            content: "JMX",
            title: "View the JMX MBeans in this process",
            isValid: function (workspace) { return workspace.hasMBeans(); },
            href: function () { return "#/jmx/attributes"; },
            isActive: function (workspace) { return workspace.isTopTabActive("jmx"); }
        });
        workspace.subLevelTabs.add({
            content: '<i class="icon-list"></i> Attributes',
            title: "View the attribute values on your selection",
            isValid: function (workspace) { return true; },
            href: function () { return "#/jmx/attributes"; },
            index: -1
        }, 0);
        workspace.subLevelTabs.push({
            content: '<i class="icon-leaf"></i> Operations',
            title: "Execute operations on your selection",
            isValid: function (workspace) { return true; },
            href: function () { return "#/jmx/operations"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-bar-chart"></i> Chart',
            title: "View a chart of the metrics on your selection",
            isValid: function (workspace) { return true; },
            href: function () { return "#/jmx/charts"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-cog"></i> Edit Chart',
            title: "Edit the chart configuration",
            isValid: function (workspace) { return workspace.isLinkActive("jmx/chart"); },
            href: function () { return "#/jmx/chartEdit"; }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Jmx || (Jmx = {}));
var Jmx;
(function (Jmx) {
    Jmx.AreaChartController = Jmx._module.controller("Jmx.AreaChartController", ["$scope", "$routeParams", "jolokia", "$templateCache", "localStorage", function ($scope, $routeParams, jolokia, $templateCache, localStorage) {
        $scope.mbean = $routeParams['mbean'];
        $scope.attribute = $routeParams['attribute'];
        $scope.duration = localStorage['updateRate'];
        $scope.width = 308;
        $scope.height = 296;
        $scope.template = "";
        $scope.entries = [];
        $scope.data = {
            entries: $scope.entries
        };
        $scope.req = [{ type: 'read', mbean: $scope.mbean, attribute: $scope.attribute }];
        $scope.render = function (response) {
            $scope.entries.push({
                time: response.timestamp,
                count: response.value
            });
            $scope.entries = $scope.entries.last(15);
            if ($scope.template === "") {
                $scope.template = $templateCache.get("areaChart");
            }
            $scope.data = {
                _type: "date_histogram",
                entries: $scope.entries
            };
            Core.$apply($scope);
        };
        Core.register(jolokia, $scope, $scope.req, onSuccess($scope.render));
    }]);
})(Jmx || (Jmx = {}));
var Jmx;
(function (Jmx) {
    Jmx._module.controller("Jmx.AttributeController", ["$scope", "jolokia", function ($scope, jolokia) {
        $scope.init = function (mbean, attribute) {
            $scope.mbean = mbean;
            $scope.attribute = attribute;
            if (angular.isDefined($scope.mbean) && angular.isDefined($scope.attribute)) {
                Core.register(jolokia, $scope, {
                    type: 'read',
                    mbean: $scope.mbean,
                    attribute: $scope.attribute
                }, onSuccess(render));
            }
        };
        function render(response) {
            if (!Object.equal($scope.data, response.value)) {
                $scope.data = safeNull(response.value);
                Core.$apply($scope);
            }
        }
    }]);
    Jmx._module.controller("Jmx.AttributeChartController", ["$scope", "jolokia", "$document", function ($scope, jolokia, $document) {
        $scope.init = function (mbean, attribute) {
            $scope.mbean = mbean;
            $scope.attribute = attribute;
            if (angular.isDefined($scope.mbean) && angular.isDefined($scope.attribute)) {
                Core.register(jolokia, $scope, {
                    type: 'read',
                    mbean: $scope.mbean,
                    attribute: $scope.attribute
                }, onSuccess(render));
            }
        };
        function render(response) {
            if (!angular.isDefined($scope.chart)) {
                $scope.chart = $($document.find("#" + $scope.attribute)[0]);
                if ($scope.chart) {
                    $scope.width = $scope.chart.width();
                }
            }
            if (!angular.isDefined($scope.context)) {
                console.log("Got: ", response);
                $scope.context = cubism.context().serverDelay(0).clientDelay(0).step(1000).size($scope.width);
                $scope.jcontext = $scope.context.jolokia(jolokia);
                $scope.metrics = [];
                Object.extended(response.value).keys(function (key, value) {
                    $scope.metrics.push($scope.jcontext.metric({
                        type: 'read',
                        mbean: $scope.mbean,
                        attribute: $scope.attribute,
                        path: key
                    }, $scope.attribute));
                });
                d3.select("#" + $scope.attribute).call(function (div) {
                    div.append("div").data($scope.metrics).call($scope.context.horizon());
                });
                Core.unregister(jolokia, $scope);
                Core.$apply($scope);
            }
        }
    }]);
})(Jmx || (Jmx = {}));
var Jmx;
(function (Jmx) {
    Jmx.propertiesColumnDefs = [
        {
            field: 'name',
            displayName: 'Property',
            width: "27%",
            cellTemplate: '<div class="ngCellText" title="{{row.entity.attrDesc}}" ' + 'data-placement="bottom"><div ng-show="!inDashboard" class="inline" compile="row.entity.getDashboardWidgets()"></div><a href="" ng-click="row.entity.onViewAttribute()">{{row.entity.name}}</a></div>'
        },
        {
            field: 'value',
            displayName: 'Value',
            width: "70%",
            cellTemplate: '<div class="ngCellText mouse-pointer" ng-click="row.entity.onViewAttribute()" title="{{row.entity.tooltip}}" ng-bind-html-unsafe="row.entity.summary"></div>'
        }
    ];
    Jmx.foldersColumnDefs = [
        {
            displayName: 'Name',
            cellTemplate: '<div class="ngCellText"><a href="{{row.entity.folderHref(row)}}"><i class="{{row.entity.folderIconClass(row)}}"></i> {{row.getProperty("title")}}</a></div>'
        }
    ];
    Jmx.AttributesController = Jmx._module.controller("Jmx.AttributesController", ["$scope", "$element", "$location", "workspace", "jolokia", "jmxWidgets", "jmxWidgetTypes", "$templateCache", "localStorage", "$browser", function ($scope, $element, $location, workspace, jolokia, jmxWidgets, jmxWidgetTypes, $templateCache, localStorage, $browser) {
        $scope.searchText = '';
        $scope.nid = 'empty';
        $scope.selectedItems = [];
        $scope.lastKey = null;
        $scope.attributesInfoCache = {};
        $scope.entity = {};
        $scope.attributeSchema = {};
        $scope.gridData = [];
        $scope.attributes = "";
        $scope.$watch('gridData.length', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue > 0) {
                    $scope.attributes = $templateCache.get('gridTemplate');
                }
                else {
                    $scope.attributes = "";
                }
            }
        });
        var attributeSchemaBasic = {
            properties: {
                'key': {
                    description: 'Key',
                    tooltip: 'Attribute key',
                    type: 'string',
                    readOnly: 'true'
                },
                'description': {
                    description: 'Description',
                    tooltip: 'Attribute description',
                    type: 'string',
                    formTemplate: "<textarea class='input-xlarge' rows='2' readonly='true'></textarea>"
                },
                'type': {
                    description: 'Type',
                    tooltip: 'Attribute type',
                    type: 'string',
                    readOnly: 'true'
                },
                'jolokia': {
                    description: 'Jolokia URL',
                    tooltip: 'Jolokia REST URL',
                    type: 'string',
                    readOnly: 'true'
                }
            }
        };
        $scope.gridOptions = {
            scope: $scope,
            selectedItems: [],
            showFilter: false,
            canSelectRows: false,
            enableRowSelection: false,
            enableRowClickSelection: false,
            keepLastSelected: false,
            multiSelect: true,
            showColumnMenu: true,
            displaySelectionCheckbox: false,
            filterOptions: {
                filterText: ''
            },
            data: 'gridData',
            columnDefs: Jmx.propertiesColumnDefs
        };
        $scope.$watch(function ($scope) {
            return $scope.gridOptions.selectedItems.map(function (item) {
                return item.key || item;
            });
        }, function (newValue, oldValue) {
            if (newValue !== oldValue) {
                Jmx.log.debug("Selected items: ", newValue);
                $scope.selectedItems = newValue;
            }
        }, true);
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            var currentUrl = $location.url();
            if (currentUrl.endsWith("/jmx/attributes")) {
                Jmx.log.debug("Reset selection in JMX plugin");
                workspace.selection = null;
                $scope.lastKey = null;
            }
            $scope.nid = $location.search()['nid'];
            Jmx.log.debug("nid: ", $scope.nid);
            setTimeout(updateTableContents, 50);
        });
        $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid()) {
                Core.unregister(jolokia, $scope);
                return;
            }
            setTimeout(function () {
                $scope.gridData = [];
                Core.$apply($scope);
                setTimeout(function () {
                    updateTableContents();
                }, 10);
            }, 10);
        });
        $scope.hasWidget = function (row) {
            return true;
        };
        $scope.onCancelAttribute = function () {
            $scope.entity = {};
        };
        $scope.onUpdateAttribute = function () {
            var value = $scope.entity["attrValueEdit"];
            var key = $scope.entity["key"];
            $scope.entity = {};
            var mbean = workspace.getSelectedMBeanName();
            if (mbean) {
                jolokia.setAttribute(mbean, key, value, onSuccess(function (response) {
                    Core.notification("success", "Updated attribute " + key);
                }));
            }
        };
        $scope.onViewAttribute = function (row) {
            if (!row.summary) {
                return;
            }
            $scope.entity = {};
            $scope.entity["key"] = row.key;
            $scope.entity["description"] = row.attrDesc;
            $scope.entity["type"] = row.type;
            var url = $location.protocol() + "://" + $location.host() + ":" + $location.port() + $browser.baseHref();
            $scope.entity["jolokia"] = url + localStorage["url"] + "/read/" + workspace.getSelectedMBeanName() + "/" + $scope.entity["key"];
            $scope.entity["rw"] = row.rw;
            var type = asJsonSchemaType(row.type, row.key);
            var readOnly = !row.rw;
            var len = row.summary.length;
            var rows = (len / 40) + 1;
            if (rows > 10) {
                rows = 10;
            }
            if (readOnly) {
                if (row.summary === '&nbsp;') {
                    $scope.entity["attrValueView"] = '';
                }
                else {
                    $scope.entity["attrValueView"] = row.summary;
                }
                $scope.attributeSchemaView = {};
                for (var i in attributeSchemaBasic) {
                    $scope.attributeSchemaView[i] = attributeSchemaBasic[i];
                }
                $scope.attributeSchemaView.properties.attrValueView = {
                    description: 'Value',
                    label: "Value",
                    tooltip: 'Attribute value',
                    type: 'string',
                    formTemplate: "<textarea class='input-xlarge' rows='" + rows + "' readonly='true'></textarea>"
                };
                if ($scope.attributeSchemaView) {
                    delete $scope.attributeSchemaView.properties.attrValueEdit;
                }
            }
            else {
                if (row.summary === '&nbsp;') {
                    $scope.entity["attrValueEdit"] = '';
                }
                else {
                    $scope.entity["attrValueEdit"] = row.summary;
                }
                $scope.attributeSchemaEdit = {};
                for (var i in attributeSchemaBasic) {
                    $scope.attributeSchemaEdit[i] = attributeSchemaBasic[i];
                }
                $scope.attributeSchemaEdit.properties.attrValueEdit = {
                    description: 'Value',
                    label: "Value",
                    tooltip: 'Attribute value',
                    type: 'string',
                    formTemplate: "<textarea class='input-xlarge' rows='" + rows + "'></textarea>"
                };
                if ($scope.attributeSchemaEdit) {
                    delete $scope.attributeSchemaEdit.properties.attrValueView;
                }
            }
            $scope.showAttributeDialog = true;
        };
        $scope.getDashboardWidgets = function (row) {
            var mbean = workspace.getSelectedMBeanName();
            if (!mbean) {
                return '';
            }
            var potentialCandidates = jmxWidgets.filter(function (widget) {
                return mbean === widget.mbean;
            });
            if (potentialCandidates.isEmpty()) {
                return '';
            }
            potentialCandidates = potentialCandidates.filter(function (widget) {
                return widget.attribute === row.key || widget.total === row.key;
            });
            if (potentialCandidates.isEmpty()) {
                return '';
            }
            row.addChartToDashboard = function (type) {
                $scope.addChartToDashboard(row, type);
            };
            var rc = [];
            potentialCandidates.forEach(function (widget) {
                var widgetType = Jmx.getWidgetType(widget);
                rc.push("<i class=\"" + widgetType['icon'] + " clickable\" title=\"" + widgetType['title'] + "\" ng-click=\"row.entity.addChartToDashboard('" + widgetType['type'] + "')\"></i>");
            });
            return rc.join() + "&nbsp;";
        };
        $scope.addChartToDashboard = function (row, widgetType) {
            var mbean = workspace.getSelectedMBeanName();
            var candidates = jmxWidgets.filter(function (widget) {
                return mbean === widget.mbean;
            });
            candidates = candidates.filter(function (widget) {
                return widget.attribute === row.key || widget.total === row.key;
            });
            candidates = candidates.filter(function (widget) {
                return widget.type === widgetType;
            });
            var widget = candidates.first();
            var type = Jmx.getWidgetType(widget);
            $location.url(Jmx.createDashboardLink(type, widget));
        };
        $scope.toolBarTemplate = function () {
            var answer = Jmx.getAttributeToolBar(workspace.selection);
            return answer;
        };
        $scope.invokeSelectedMBeans = function (operationName, completeFunction) {
            if (completeFunction === void 0) { completeFunction = null; }
            var queries = [];
            angular.forEach($scope.selectedItems || [], function (item) {
                var mbean = item["_id"];
                if (mbean) {
                    var opName = operationName;
                    if (angular.isFunction(operationName)) {
                        opName = operationName(item);
                    }
                    queries.push({ type: "exec", operation: opName, mbean: mbean });
                }
            });
            if (queries.length) {
                var callback = function () {
                    if (completeFunction) {
                        completeFunction();
                    }
                    else {
                        operationComplete();
                    }
                };
                jolokia.request(queries, onSuccess(callback, { error: callback }));
            }
        };
        $scope.folderHref = function (row) {
            if (!row.getProperty) {
                return "";
            }
            var key = row.getProperty("key");
            if (key) {
                return Core.createHref($location, "#" + $location.path() + "?nid=" + key, ["nid"]);
            }
            else {
                return "";
            }
        };
        $scope.folderIconClass = function (row) {
            if (!row.getProperty) {
                return "";
            }
            return row.getProperty("objectName") ? "icon-cog" : "icon-folder-close";
        };
        function operationComplete() {
            updateTableContents();
        }
        function updateTableContents() {
            Core.unregister(jolokia, $scope);
            $scope.gridData = [];
            $scope.mbeanIndex = null;
            var mbean = workspace.getSelectedMBeanName();
            var request = null;
            var node = workspace.selection;
            if (node === null || angular.isUndefined(node) || node.key !== $scope.lastKey) {
                $scope.attributesInfoCache = null;
                if (mbean == null) {
                    var _key = $location.search()['nid'];
                    var _node = workspace.keyToNodeMap[_key];
                    if (_node) {
                        mbean = _node.objectName;
                    }
                }
                if (mbean) {
                    var asQuery = function (node) {
                        var path = escapeMBeanPath(node);
                        var query = {
                            type: "LIST",
                            method: "post",
                            path: path,
                            ignoreErrors: true
                        };
                        return query;
                    };
                    var infoQuery = asQuery(mbean);
                    jolokia.request(infoQuery, onSuccess(function (response) {
                        $scope.attributesInfoCache = response.value;
                        Jmx.log.debug("Updated attributes info cache for mbean " + mbean);
                    }));
                }
            }
            if (mbean) {
                request = { type: 'read', mbean: mbean };
                if (node === null || angular.isUndefined(node) || node.key !== $scope.lastKey) {
                    $scope.gridOptions.columnDefs = Jmx.propertiesColumnDefs;
                    $scope.gridOptions.enableRowClickSelection = false;
                }
            }
            else if (node) {
                if (node.key !== $scope.lastKey) {
                    $scope.gridOptions.columnDefs = [];
                    $scope.gridOptions.enableRowClickSelection = true;
                }
                var children = node.children;
                if (children) {
                    var childNodes = children.map(function (child) { return child.objectName; });
                    var mbeans = childNodes.filter(function (mbean) { return mbean; });
                    if (mbeans) {
                        var typeNames = Jmx.getUniqueTypeNames(children);
                        if (typeNames.length <= 1) {
                            var query = mbeans.map(function (mbean) {
                                return { type: "READ", mbean: mbean, ignoreErrors: true };
                            });
                            if (query.length > 0) {
                                request = query;
                                $scope.mbeanIndex = {};
                                $scope.mbeanRowCounter = 0;
                                $scope.mbeanCount = mbeans.length;
                            }
                        }
                        else {
                            console.log("Too many type names " + typeNames);
                        }
                    }
                }
            }
            var callback = onSuccess(render);
            if (request) {
                $scope.request = request;
                Core.register(jolokia, $scope, request, callback);
            }
            else if (node) {
                if (node.key !== $scope.lastKey) {
                    $scope.gridOptions.columnDefs = Jmx.foldersColumnDefs;
                    $scope.gridOptions.enableRowClickSelection = true;
                }
                $scope.gridData = node.children;
                addHandlerFunctions($scope.gridData);
            }
            if (node) {
                $scope.lastKey = node.key;
            }
            Core.$apply($scope);
        }
        function render(response) {
            var data = response.value;
            var mbeanIndex = $scope.mbeanIndex;
            var mbean = response.request['mbean'];
            if (mbean) {
                data["_id"] = mbean;
            }
            if (mbeanIndex) {
                if (mbean) {
                    var idx = mbeanIndex[mbean];
                    if (!angular.isDefined(idx)) {
                        idx = $scope.mbeanRowCounter;
                        mbeanIndex[mbean] = idx;
                        $scope.mbeanRowCounter += 1;
                    }
                    if (idx === 0) {
                        $scope.selectedIndices = $scope.selectedItems.map(function (item) { return $scope.gridData.indexOf(item); });
                        $scope.gridData = [];
                        if (!$scope.gridOptions.columnDefs.length) {
                            var key = workspace.selectionConfigKey();
                            var defaultDefs = workspace.attributeColumnDefs[key] || [];
                            var defaultSize = defaultDefs.length;
                            var map = {};
                            angular.forEach(defaultDefs, function (value, key) {
                                var field = value.field;
                                if (field) {
                                    map[field] = value;
                                }
                            });
                            var extraDefs = [];
                            angular.forEach(data, function (value, key) {
                                if (includePropertyValue(key, value)) {
                                    if (!map[key]) {
                                        extraDefs.push({
                                            field: key,
                                            displayName: key === '_id' ? 'Object name' : Core.humanizeValue(key),
                                            visible: defaultSize === 0
                                        });
                                    }
                                }
                            });
                            extraDefs = extraDefs.sort(function (def, def2) {
                                if (def.field.startsWith('_')) {
                                    return 1;
                                }
                                else if (def2.field.startsWith('_')) {
                                    return -1;
                                }
                                return def.field.localeCompare(def2.field);
                            });
                            extraDefs.forEach(function (e) {
                                defaultDefs.push(e);
                            });
                            $scope.gridOptions.columnDefs = defaultDefs;
                            $scope.gridOptions.enableRowClickSelection = true;
                        }
                    }
                    $scope.gridData[idx] = data;
                    addHandlerFunctions($scope.gridData);
                    var count = $scope.mbeanCount;
                    if (!count || idx + 1 >= count) {
                        var newSelections = $scope.selectedIndices.map(function (idx) { return $scope.gridData[idx]; }).filter(function (row) { return row; });
                        $scope.selectedItems.splice(0, $scope.selectedItems.length);
                        $scope.selectedItems.push.apply($scope.selectedItems, newSelections);
                        Core.$apply($scope);
                    }
                }
                else {
                    console.log("No mbean name in request " + JSON.stringify(response.request));
                }
            }
            else {
                $scope.gridOptions.columnDefs = Jmx.propertiesColumnDefs;
                $scope.gridOptions.enableRowClickSelection = false;
                var showAllAttributes = true;
                if (angular.isObject(data)) {
                    var properties = Array();
                    angular.forEach(data, function (value, key) {
                        if (showAllAttributes || includePropertyValue(key, value)) {
                            if (!key.startsWith("_")) {
                                if (key === "ObjectName") {
                                    value = unwrapObjectName(value);
                                }
                                if (angular.isArray(value)) {
                                    value = value.map(function (v) {
                                        return unwrapObjectName(v);
                                    });
                                }
                                var type = lookupAttributeType(key);
                                var data = { key: key, name: Core.humanizeValue(key), value: safeNullAsString(value, type) };
                                generateSummaryAndDetail(key, data);
                                properties.push(data);
                            }
                        }
                    });
                    if (!properties.any(function (p) {
                        return p['key'] === 'ObjectName';
                    })) {
                        var objectName = {
                            key: "ObjectName",
                            name: "Object Name",
                            value: mbean
                        };
                        generateSummaryAndDetail(objectName.key, objectName);
                        properties.push(objectName);
                    }
                    properties = properties.sortBy("name");
                    $scope.selectedItems = [data];
                    data = properties;
                }
                $scope.gridData = data;
                addHandlerFunctions($scope.gridData);
                Core.$apply($scope);
            }
        }
        function addHandlerFunctions(data) {
            data.forEach(function (item) {
                item['inDashboard'] = $scope.inDashboard;
                item['getDashboardWidgets'] = function () {
                    return $scope.getDashboardWidgets(item);
                };
                item['onViewAttribute'] = function () {
                    $scope.onViewAttribute(item);
                };
                item['folderIconClass'] = function (row) {
                    return $scope.folderIconClass(row);
                };
                item['folderHref'] = function (row) {
                    return $scope.folderHref(row);
                };
            });
        }
        function unwrapObjectName(value) {
            if (!angular.isObject(value)) {
                return value;
            }
            var keys = Object.keys(value);
            if (keys.length === 1 && keys[0] === "objectName") {
                return value["objectName"];
            }
            return value;
        }
        function generateSummaryAndDetail(key, data) {
            var value = data.value;
            if (!angular.isArray(value) && angular.isObject(value)) {
                var detailHtml = "<table class='table table-striped'>";
                var summary = "";
                var object = value;
                var keys = Object.keys(value).sort();
                angular.forEach(keys, function (key) {
                    var value = object[key];
                    detailHtml += "<tr><td>" + Core.humanizeValue(key) + "</td><td>" + value + "</td></tr>";
                    summary += "" + Core.humanizeValue(key) + ": " + value + "  ";
                });
                detailHtml += "</table>";
                data.summary = summary;
                data.detailHtml = detailHtml;
                data.tooltip = summary;
            }
            else {
                var text = value;
                if (text === '') {
                    text = '&nbsp;';
                    data.tooltip = "";
                }
                else {
                    data.tooltip = text;
                }
                data.summary = "" + text + "";
                data.detailHtml = "<pre>" + text + "</pre>";
                if (angular.isArray(value)) {
                    var html = "<ul>";
                    angular.forEach(value, function (item) {
                        html += "<li>" + item + "</li>";
                    });
                    html += "</ul>";
                    data.detailHtml = html;
                }
            }
            data.rw = false;
            data.attrDesc = data.name;
            data.type = "string";
            if ($scope.attributesInfoCache != null && 'attr' in $scope.attributesInfoCache) {
                var info = $scope.attributesInfoCache.attr[key];
                if (angular.isDefined(info)) {
                    data.rw = info.rw;
                    data.attrDesc = info.desc;
                    data.type = info.type;
                }
            }
        }
        function lookupAttributeType(key) {
            if ($scope.attributesInfoCache != null && 'attr' in $scope.attributesInfoCache) {
                var info = $scope.attributesInfoCache.attr[key];
                if (angular.isDefined(info)) {
                    return info.type;
                }
            }
            return null;
        }
        function includePropertyValue(key, value) {
            return !angular.isObject(value);
        }
        function asJsonSchemaType(typeName, id) {
            if (typeName) {
                var lower = typeName.toLowerCase();
                if (lower.startsWith("int") || lower === "long" || lower === "short" || lower === "byte" || lower.endsWith("int")) {
                    return "integer";
                }
                if (lower === "double" || lower === "float" || lower === "bigdecimal") {
                    return "number";
                }
                if (lower === "boolean" || lower === "java.lang.boolean") {
                    return "boolean";
                }
                if (lower === "string" || lower === "java.lang.String") {
                    return "string";
                }
            }
            return "string";
        }
    }]);
})(Jmx || (Jmx = {}));
var Jmx;
(function (Jmx) {
    Jmx._module.controller("Jmx.ChartEditController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.selectedAttributes = [];
        $scope.selectedMBeans = [];
        $scope.metrics = {};
        $scope.mbeans = {};
        $scope.size = function (value) {
            if (angular.isObject(value)) {
                return Object.size(value);
            }
            else if (angular.isArray(value)) {
                return value.length;
            }
            else
                return 1;
        };
        $scope.canViewChart = function () {
            return $scope.selectedAttributes.length && $scope.selectedMBeans.length && $scope.size($scope.mbeans) > 0 && $scope.size($scope.metrics) > 0;
        };
        $scope.showAttributes = function () {
            return $scope.canViewChart() && $scope.size($scope.metrics) > 1;
        };
        $scope.showElements = function () {
            return $scope.canViewChart() && $scope.size($scope.mbeans) > 1;
        };
        $scope.viewChart = function () {
            var search = $location.search();
            if ($scope.selectedAttributes.length === $scope.size($scope.metrics)) {
                delete search["att"];
            }
            else {
                search["att"] = $scope.selectedAttributes;
            }
            if ($scope.selectedMBeans.length === $scope.size($scope.mbeans) && $scope.size($scope.mbeans) === 1) {
                delete search["el"];
            }
            else {
                search["el"] = $scope.selectedMBeans;
            }
            $location.search(search);
            $location.path("jmx/charts");
        };
        $scope.$watch('workspace.selection', render);
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(render, 50);
        });
        function render() {
            var node = workspace.selection;
            if (!angular.isDefined(node)) {
                return;
            }
            $scope.selectedAttributes = [];
            $scope.selectedMBeans = [];
            $scope.metrics = {};
            $scope.mbeans = {};
            var mbeanCounter = 0;
            var resultCounter = 0;
            var children = node.children;
            if (!children || !children.length || node.objectName) {
                children = [node];
            }
            if (children) {
                children.forEach(function (mbeanNode) {
                    var mbean = mbeanNode.objectName;
                    var name = mbeanNode.title;
                    if (name && mbean) {
                        mbeanCounter++;
                        $scope.mbeans[name] = name;
                        var asQuery = function (node) {
                            var path = escapeMBeanPath(node);
                            var query = {
                                type: "list",
                                path: path,
                                ignoreErrors: true
                            };
                            return query;
                        };
                        var infoQuery = asQuery(mbean);
                        jolokia.request(infoQuery, onSuccess(function (meta) {
                            var attributes = meta.value.attr;
                            if (attributes) {
                                for (var key in attributes) {
                                    var value = attributes[key];
                                    if (value) {
                                        var typeName = value['type'];
                                        if (isNumberTypeName(typeName)) {
                                            if (!$scope.metrics[key]) {
                                                $scope.metrics[key] = key;
                                            }
                                        }
                                    }
                                }
                                if (++resultCounter >= mbeanCounter) {
                                    var search = $location.search();
                                    var attributeNames = toSearchArgumentArray(search["att"]);
                                    var elementNames = toSearchArgumentArray(search["el"]);
                                    if (attributeNames && attributeNames.length) {
                                        attributeNames.forEach(function (name) {
                                            if ($scope.metrics[name]) {
                                                $scope.selectedAttributes.push(name);
                                            }
                                        });
                                    }
                                    if (elementNames && elementNames.length) {
                                        elementNames.forEach(function (name) {
                                            if ($scope.mbeans[name]) {
                                                $scope.selectedMBeans.push(name);
                                            }
                                        });
                                    }
                                    if ($scope.selectedMBeans.length < 1) {
                                        $scope.selectedMBeans = Object.keys($scope.mbeans);
                                    }
                                    if ($scope.selectedAttributes.length < 1) {
                                        var attrKeys = Object.keys($scope.metrics).sort();
                                        if ($scope.selectedMBeans.length > 1) {
                                            $scope.selectedAttributes = [attrKeys.first()];
                                        }
                                        else {
                                            $scope.selectedAttributes = attrKeys;
                                        }
                                    }
                                    $("#attributes").attr("size", Object.size($scope.metrics));
                                    $("#mbeans").attr("size", Object.size($scope.mbeans));
                                    Core.$apply($scope);
                                }
                            }
                            Core.$apply($scope);
                        }, { method: "post" }));
                    }
                });
            }
        }
    }]);
})(Jmx || (Jmx = {}));
var Jmx;
(function (Jmx) {
    Jmx._module.controller("Jmx.ChartController", ["$scope", "$element", "$location", "workspace", "localStorage", "jolokiaUrl", "jolokiaParams", function ($scope, $element, $location, workspace, localStorage, jolokiaUrl, jolokiaParams) {
        var log = Logger.get("JMX");
        $scope.metrics = [];
        $scope.updateRate = 1000;
        $scope.context = null;
        $scope.jolokia = null;
        $scope.charts = null;
        $scope.reset = function () {
            if ($scope.context) {
                $scope.context.stop();
                $scope.context = null;
            }
            if ($scope.jolokia) {
                $scope.jolokia.stop();
                $scope.jolokia = null;
            }
            if ($scope.charts) {
                $scope.charts.empty();
                $scope.charts = null;
            }
        };
        $scope.$on('$destroy', function () {
            try {
                $scope.deregRouteChange();
            }
            catch (error) {
            }
            try {
                $scope.dereg();
            }
            catch (error) {
            }
            $scope.reset();
        });
        $scope.errorMessage = function () {
            if ($scope.updateRate === 0) {
                return "updateRate";
            }
            if ($scope.metrics.length === 0) {
                return "metrics";
            }
        };
        var doRender = Core.throttled(render, 200);
        $scope.deregRouteChange = $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            doRender();
        });
        $scope.dereg = $scope.$watch('workspace.selection', function () {
            if (workspace.moveIfViewInvalid())
                return;
            doRender();
        });
        doRender();
        function render() {
            var node = workspace.selection;
            if (node == null) {
                return;
            }
            if (!angular.isDefined(node) || !angular.isDefined($scope.updateRate) || $scope.updateRate === 0) {
                setTimeout(doRender, 500);
                Core.$apply($scope);
                return;
            }
            var width = 594;
            var charts = $element.find('#charts');
            if (charts) {
                width = charts.width();
            }
            else {
                setTimeout(doRender, 500);
                Core.$apply($scope);
                return;
            }
            $scope.reset();
            $scope.charts = charts;
            $scope.jolokia = new Jolokia(jolokiaParams);
            $scope.jolokia.start($scope.updateRate);
            var mbean = node.objectName;
            $scope.metrics = [];
            var context = cubism.context().serverDelay($scope.updateRate).clientDelay($scope.updateRate).step($scope.updateRate).size(width);
            $scope.context = context;
            $scope.jolokiaContext = context.jolokia($scope.jolokia);
            var search = $location.search();
            var attributeNames = toSearchArgumentArray(search["att"]);
            if (mbean) {
                var asQuery = function (node) {
                    var path = escapeMBeanPath(node);
                    var query = {
                        type: "list",
                        path: path,
                        ignoreErrors: true
                    };
                    return query;
                };
                var infoQuery = asQuery(mbean);
                var meta = $scope.jolokia.request(infoQuery, { method: "post" });
                if (meta) {
                    Core.defaultJolokiaErrorHandler(meta, {});
                    var attributes = meta.value ? meta.value.attr : null;
                    if (attributes) {
                        var foundNames = [];
                        for (var key in attributes) {
                            var value = attributes[key];
                            if (value) {
                                var typeName = value['type'];
                                if (isNumberTypeName(typeName)) {
                                    foundNames.push(key);
                                }
                            }
                        }
                        if (attributeNames.length) {
                            var filtered = foundNames.filter(function (key) { return attributeNames.indexOf(key) >= 0; });
                            if (filtered.length) {
                                foundNames = filtered;
                            }
                        }
                        foundNames = foundNames.sort();
                        angular.forEach(foundNames, function (key) {
                            var metric = $scope.jolokiaContext.metric({
                                type: 'read',
                                mbean: mbean,
                                attribute: key
                            }, Core.humanizeValue(key));
                            if (metric) {
                                $scope.metrics.push(metric);
                            }
                        });
                    }
                }
            }
            else {
                var elementNames = toSearchArgumentArray(search["el"]);
                if (attributeNames && attributeNames.length && elementNames && elementNames.length) {
                    var mbeans = {};
                    elementNames.forEach(function (elementName) {
                        var child = node.get(elementName);
                        if (!child && node.children) {
                            child = node.children.find(function (n) { return elementName === n["title"]; });
                        }
                        if (child) {
                            var mbean = child.objectName;
                            if (mbean) {
                                mbeans[elementName] = mbean;
                            }
                        }
                    });
                    attributeNames = attributeNames.sort();
                    attributeNames.forEach(function (key) {
                        angular.forEach(mbeans, function (mbean, name) {
                            var attributeTitle = Core.humanizeValue(key);
                            var title = name + ": " + attributeTitle;
                            var metric = $scope.jolokiaContext.metric({
                                type: 'read',
                                mbean: mbean,
                                attribute: key
                            }, title);
                            if (metric) {
                                $scope.metrics.push(metric);
                            }
                        });
                    });
                }
                if (node.children.length && !$scope.metrics.length) {
                    $location.path("jmx/chartEdit");
                }
            }
            if ($scope.metrics.length > 0) {
                var d3Selection = d3.select(charts.get(0));
                var axisEl = d3Selection.selectAll(".axis");
                var bail = false;
                axisEl.data(["top", "bottom"]).enter().append("div").attr("class", function (d) {
                    return d + " axis";
                }).each(function (d) {
                    if (bail) {
                        return;
                    }
                    try {
                        d3.select(this).call(context.axis().ticks(12).orient(d));
                    }
                    catch (error) {
                        if (!bail) {
                            bail = true;
                        }
                    }
                });
                if (bail) {
                    $scope.reset();
                    setTimeout(doRender, 500);
                    Core.$apply($scope);
                    return;
                }
                d3Selection.append("div").attr("class", "rule").call(context.rule());
                context.on("focus", function (i) {
                    try {
                        d3Selection.selectAll(".value").style("right", i === null ? null : context.size() - i + "px");
                    }
                    catch (error) {
                        log.info("error: ", error);
                    }
                });
                $scope.metrics.forEach(function (metric) {
                    d3Selection.call(function (div) {
                        div.append("div").data([metric]).attr("class", "horizon").call(context.horizon());
                    });
                });
            }
            else {
                $scope.reset();
            }
            Core.$apply($scope);
        }
        ;
    }]);
})(Jmx || (Jmx = {}));
var Jmx;
(function (Jmx) {
    Jmx.DonutChartController = Jmx._module.controller("Jmx.DonutChartController", ["$scope", "$routeParams", "jolokia", "$templateCache", function ($scope, $routeParams, jolokia, $templateCache) {
        $scope.mbean = $routeParams['mbean'];
        $scope.total = $routeParams['total'];
        $scope.attribute = $routeParams['attribute'];
        $scope.terms = $routeParams['terms'];
        $scope.remainder = $routeParams['remaining'];
        $scope.template = "";
        $scope.termsArray = $scope.terms.split(",");
        $scope.data = {
            total: 0,
            terms: []
        };
        if (!$scope.attribute) {
            $scope.reqs = [{ type: 'read', mbean: $scope.mbean, attribute: $scope.total }];
            $scope.termsArray.forEach(function (term) {
                $scope.reqs.push({ type: 'read', mbean: $scope.mbean, attribute: term });
                $scope.data.terms.push({
                    term: term,
                    count: 0
                });
            });
        }
        else {
            var terms = $scope.termsArray.include($scope.total);
            $scope.reqs = [{ type: 'read', mbean: $scope.mbean, attribute: $scope.attribute, paths: terms.join(",") }];
            $scope.termsArray.forEach(function (term) {
                $scope.data.terms.push({
                    term: term,
                    count: 0
                });
            });
        }
        if ($scope.remainder && $scope.remainder !== "-") {
            $scope.data.terms.push({
                term: $scope.remainder,
                count: 0
            });
        }
        $scope.render = function (response) {
            var freeTerm = null;
            if ($scope.remainder && $scope.remainder !== "-") {
                freeTerm = $scope.data.terms.find(function (term) {
                    return term.term === $scope.remainder;
                });
            }
            if (!$scope.attribute) {
                if (response.request.attribute === $scope.total) {
                    $scope.data.total = response.value;
                }
                else {
                    var term = $scope.data.terms.find(function (term) {
                        return term.term === response.request.attribute;
                    });
                    if (term) {
                        term.count = response.value;
                    }
                    if (freeTerm) {
                        freeTerm.count = $scope.data.total;
                        $scope.data.terms.forEach(function (term) {
                            if (term.term !== $scope.remainder) {
                                freeTerm.count = freeTerm.count - term.count;
                            }
                        });
                    }
                }
            }
            else {
                if (response.request.attribute === $scope.attribute) {
                    $scope.data.total = response.value[$scope.total.toLowerCase()];
                    $scope.data.terms.forEach(function (term) {
                        if (term.term !== $scope.remainder) {
                            term.count = response.value[term.term.toLowerCase()];
                        }
                    });
                    if (freeTerm) {
                        freeTerm.count = $scope.data.total;
                        $scope.data.terms.forEach(function (term) {
                            if (term.term !== $scope.remainder) {
                                freeTerm.count = freeTerm.count - term.count;
                            }
                        });
                    }
                }
            }
            if ($scope.template === "") {
                $scope.template = $templateCache.get("donut");
            }
            $scope.data = Object.clone($scope.data);
            Core.$apply($scope);
        };
        Core.register(jolokia, $scope, $scope.reqs, onSuccess($scope.render));
    }]);
})(Jmx || (Jmx = {}));
var Tree;
(function (Tree) {
    Tree.pluginName = 'tree';
    Tree.log = Logger.get("Tree");
    function expandAll(el) {
        treeAction(el, true);
    }
    Tree.expandAll = expandAll;
    function contractAll(el) {
        treeAction(el, false);
    }
    Tree.contractAll = contractAll;
    function treeAction(el, expand) {
        $(el).dynatree("getRoot").visit(function (node) {
            node.expand(expand);
        });
    }
    function sanitize(tree) {
        if (!tree) {
            return;
        }
        if (angular.isArray(tree)) {
            tree.forEach(function (folder) {
                Tree.sanitize(folder);
            });
        }
        var title = tree['title'];
        if (title) {
            tree['title'] = title.unescapeHTML(true).escapeHTML();
        }
        if (tree.children) {
            Tree.sanitize(tree.children);
        }
    }
    Tree.sanitize = sanitize;
    Tree._module = angular.module(Tree.pluginName, ['bootstrap', 'ngResource', 'hawtioCore']);
    Tree._module.directive('hawtioTree', ["workspace", "$timeout", "$location", function (workspace, $timeout, $location) {
        return function (scope, element, attrs) {
            var tree = null;
            var data = null;
            var widget = null;
            var timeoutId = null;
            var onSelectFn = lookupFunction("onselect");
            var onDragStartFn = lookupFunction("ondragstart");
            var onDragEnterFn = lookupFunction("ondragenter");
            var onDropFn = lookupFunction("ondrop");
            function lookupFunction(attrName) {
                var answer = null;
                var fnName = attrs[attrName];
                if (fnName) {
                    answer = Core.pathGet(scope, fnName);
                    if (!angular.isFunction(answer)) {
                        answer = null;
                    }
                }
                return answer;
            }
            var data = attrs.hawtioTree;
            var queryParam = data;
            scope.$watch(data, onWidgetDataChange);
            scope.$on("hawtio.tree." + data, function (args) {
                var value = Core.pathGet(scope, data);
                onWidgetDataChange(value);
            });
            element.bind('$destroy', function () {
                $timeout.cancel(timeoutId);
            });
            updateLater();
            function updateWidget() {
                Core.$applyNowOrLater(scope);
            }
            function onWidgetDataChange(value) {
                tree = value;
                if (tree) {
                    Tree.sanitize(tree);
                }
                if (tree && !widget) {
                    var treeElement = $(element);
                    var children = Core.asArray(tree);
                    var hideRoot = attrs["hideroot"];
                    if ("true" === hideRoot) {
                        children = tree['children'];
                    }
                    var config = {
                        clickFolderMode: 3,
                        onActivate: function (node) {
                            var data = node.data;
                            if (onSelectFn) {
                                onSelectFn(data, node);
                            }
                            else {
                                workspace.updateSelectionNode(data);
                            }
                            Core.$apply(scope);
                        },
                        onClick: function (node, event) {
                            if (event["metaKey"]) {
                                event.preventDefault();
                                var url = $location.absUrl();
                                if (node && node.data) {
                                    var key = node.data["key"];
                                    if (key) {
                                        var hash = $location.search();
                                        hash[queryParam] = key;
                                        var idx = url.indexOf('?');
                                        if (idx <= 0) {
                                            url += "?";
                                        }
                                        else {
                                            url = url.substring(0, idx + 1);
                                        }
                                        url += $.param(hash);
                                    }
                                }
                                window.open(url, '_blank');
                                window.focus();
                                return false;
                            }
                            return true;
                        },
                        persist: false,
                        debugLevel: 0,
                        children: children,
                        dnd: {
                            onDragStart: onDragStartFn ? onDragStartFn : function (node) {
                                console.log("onDragStart!");
                                return true;
                            },
                            onDragEnter: onDragEnterFn ? onDragEnterFn : function (node, sourceNode) {
                                console.log("onDragEnter!");
                                return true;
                            },
                            onDrop: onDropFn ? onDropFn : function (node, sourceNode, hitMode) {
                                console.log("onDrop!");
                                sourceNode.move(node, hitMode);
                                return true;
                            }
                        }
                    };
                    if (!onDropFn && !onDragEnterFn && !onDragStartFn) {
                        delete config["dnd"];
                    }
                    widget = treeElement.dynatree(config);
                    var activatedNode = false;
                    var activateNodeName = attrs["activatenodes"];
                    if (activateNodeName) {
                        var values = scope[activateNodeName];
                        var tree = treeElement.dynatree("getTree");
                        if (values && tree) {
                            angular.forEach(Core.asArray(values), function (value) {
                                tree.activateKey(value);
                                activatedNode = true;
                            });
                        }
                    }
                    var root = treeElement.dynatree("getRoot");
                    if (root) {
                        var onRootName = attrs["onroot"];
                        if (onRootName) {
                            var fn = scope[onRootName];
                            if (fn) {
                                fn(root);
                            }
                        }
                        if (!activatedNode) {
                            var children = root['getChildren']();
                            if (children && children.length) {
                                var child = children[0];
                                child.expand(true);
                                child.activate(true);
                            }
                        }
                    }
                }
                updateWidget();
            }
            function updateLater() {
                timeoutId = $timeout(function () {
                    updateWidget();
                }, 300);
            }
        };
    }]);
    Tree._module.run(["helpRegistry", function (helpRegistry) {
        helpRegistry.addDevDoc(Tree.pluginName, 'app/tree/doc/developer.md');
    }]);
    hawtioPluginLoader.addModule(Tree.pluginName);
})(Tree || (Tree = {}));
var Jmx;
(function (Jmx) {
    Jmx._module.controller("Jmx.TreeHeaderController", ["$scope", function ($scope) {
        $scope.expandAll = function () {
            Tree.expandAll("#jmxtree");
        };
        $scope.contractAll = function () {
            Tree.contractAll("#jmxtree");
        };
    }]);
    Jmx._module.controller("Jmx.MBeansController", ["$scope", "$location", "workspace", function ($scope, $location, workspace) {
        $scope.num = 1;
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateSelectionFromURL, 50);
        });
        $scope.select = function (node) {
            $scope.workspace.updateSelectionNode(node);
            Core.$apply($scope);
        };
        function updateSelectionFromURL() {
            Jmx.updateTreeSelectionFromURL($location, $("#jmxtree"));
        }
        $scope.populateTree = function () {
            var treeElement = $("#jmxtree");
            $scope.tree = workspace.tree;
            Jmx.enableTree($scope, $location, workspace, treeElement, $scope.tree.children, true);
            setTimeout(updateSelectionFromURL, 50);
        };
        $scope.$on('jmxTreeUpdated', $scope.populateTree);
        $scope.populateTree();
    }]);
})(Jmx || (Jmx = {}));
var Jmx;
(function (Jmx) {
    Jmx._module.controller("Jmx.OperationController", ["$scope", "workspace", "jolokia", "$timeout", "$location", "localStorage", "$browser", function ($scope, workspace, jolokia, $timeout, $location, localStorage, $browser) {
        $scope.item = $scope.selectedOperation;
        $scope.title = $scope.item.humanReadable;
        $scope.desc = $scope.item.desc;
        $scope.operationResult = '';
        $scope.executeIcon = "icon-ok";
        $scope.mode = "text";
        $scope.entity = {};
        $scope.formConfig = {
            properties: {},
            description: $scope.objectName + "::" + $scope.item.name
        };
        var url = $location.protocol() + "://" + $location.host() + ":" + $location.port() + $browser.baseHref();
        $scope.jolokiaUrl = url + localStorage["url"] + "/exec/" + workspace.getSelectedMBeanName() + "/" + $scope.item.name;
        $scope.item.args.forEach(function (arg) {
            $scope.formConfig.properties[arg.name] = {
                type: arg.type,
                tooltip: arg.desc,
                help: "Type: " + arg.type
            };
        });
        $timeout(function () {
            $("html, body").animate({ scrollTop: 0 }, "medium");
        }, 250);
        var sanitize = function (args) {
            if (args) {
                args.forEach(function (arg) {
                    switch (arg.type) {
                        case "int":
                        case "long":
                            arg.formType = "number";
                            break;
                        default:
                            arg.formType = "text";
                    }
                });
            }
            return args;
        };
        $scope.args = sanitize($scope.item.args);
        $scope.dump = function (data) {
            console.log(data);
        };
        $scope.ok = function () {
            $scope.operationResult = '';
        };
        $scope.reset = function () {
            $scope.entity = {};
        };
        $scope.close = function () {
            $scope.$parent.showInvoke = false;
        };
        $scope.handleResponse = function (response) {
            $scope.executeIcon = "icon-ok";
            $scope.operationStatus = "success";
            if (response === null || 'null' === response) {
                $scope.operationResult = "Operation Succeeded!";
            }
            else if (typeof response === 'string') {
                $scope.operationResult = response;
            }
            else {
                $scope.operationResult = angular.toJson(response, true);
            }
            $scope.mode = CodeEditor.detectTextFormat($scope.operationResult);
            Core.$apply($scope);
        };
        $scope.onSubmit = function (json, form) {
            Jmx.log.debug("onSubmit: json:", json, " form: ", form);
            Jmx.log.debug("$scope.item.args: ", $scope.item.args);
            angular.forEach(json, function (value, key) {
                $scope.item.args.find(function (arg) {
                    return arg['name'] === key;
                }).value = value;
            });
            $scope.execute();
        };
        $scope.execute = function () {
            var node = workspace.selection;
            if (!node) {
                return;
            }
            var objectName = node.objectName;
            if (!objectName) {
                return;
            }
            var args = [objectName, $scope.item.name];
            if ($scope.item.args) {
                $scope.item.args.forEach(function (arg) {
                    args.push(arg.value);
                });
            }
            args.push(onSuccess($scope.handleResponse, {
                error: function (response) {
                    $scope.executeIcon = "icon-ok";
                    $scope.operationStatus = "error";
                    var error = response.error;
                    $scope.operationResult = error;
                    var stacktrace = response.stacktrace;
                    if (stacktrace) {
                        $scope.operationResult = stacktrace;
                    }
                    Core.$apply($scope);
                }
            }));
            $scope.executeIcon = "icon-spinner icon-spin";
            var fn = jolokia.execute;
            fn.apply(jolokia, args);
        };
    }]);
    Jmx._module.controller("Jmx.OperationsController", ["$scope", "workspace", "jolokia", "rbacACLMBean", "$templateCache", function ($scope, workspace, jolokia, rbacACLMBean, $templateCache) {
        $scope.operations = {};
        $scope.objectName = '';
        $scope.methodFilter = '';
        $scope.workspace = workspace;
        $scope.selectedOperation = null;
        $scope.showInvoke = false;
        $scope.template = "";
        $scope.invokeOp = function (operation) {
            if (!$scope.canInvoke(operation)) {
                return;
            }
            $scope.selectedOperation = operation;
            $scope.showInvoke = true;
        };
        $scope.getJson = function (operation) {
            return angular.toJson(operation, true);
        };
        $scope.cancel = function () {
            $scope.selectedOperation = null;
            $scope.showInvoke = false;
        };
        $scope.$watch('showInvoke', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue) {
                    $scope.template = $templateCache.get("operationTemplate");
                }
                else {
                    $scope.template = "";
                }
            }
        });
        var fetch = Core.throttled(function () {
            var node = workspace.selection;
            if (!node) {
                return;
            }
            $scope.objectName = node.objectName;
            if (!$scope.objectName) {
                return;
            }
            jolokia.request({
                type: 'list',
                path: escapeMBeanPath($scope.objectName)
            }, onSuccess(render));
        }, 500);
        function getArgs(args) {
            return "(" + args.map(function (arg) {
                return arg.type;
            }).join() + ")";
        }
        function sanitize(value) {
            for (var item in value) {
                item = "" + item;
                value[item].name = item;
                value[item].humanReadable = Core.humanizeValue(item);
            }
            return value;
        }
        $scope.isOperationsEmpty = function () {
            return $.isEmptyObject($scope.operations);
        };
        $scope.doFilter = function (item) {
            if (Core.isBlank($scope.methodFilter)) {
                return true;
            }
            if (item.name.toLowerCase().has($scope.methodFilter.toLowerCase()) || item.humanReadable.toLowerCase().has($scope.methodFilter.toLowerCase())) {
                return true;
            }
            return false;
        };
        $scope.canInvoke = function (operation) {
            if (!('canInvoke' in operation)) {
                return true;
            }
            else {
                return operation['canInvoke'];
            }
        };
        $scope.getClass = function (operation) {
            if ($scope.canInvoke(operation)) {
                return 'can-invoke';
            }
            else {
                return 'cant-invoke';
            }
        };
        $scope.$watch('workspace.selection', function (newValue, oldValue) {
            if (!workspace.selection || workspace.moveIfViewInvalid()) {
                return;
            }
            fetch();
        });
        function fetchPermissions(objectName, operations) {
            var map = {};
            map[objectName] = [];
            angular.forEach(operations, function (value, key) {
                map[objectName].push(value.name);
            });
            rbacACLMBean.then(function (rbacACLMBean) {
                jolokia.request({
                    type: 'exec',
                    mbean: rbacACLMBean,
                    operation: 'canInvoke(java.util.Map)',
                    arguments: [map]
                }, onSuccess(function (response) {
                    var map = response.value;
                    angular.forEach(map[objectName], function (value, key) {
                        operations[key]['canInvoke'] = value['CanInvoke'];
                    });
                    Jmx.log.debug("Got operations: ", $scope.operations);
                    Core.$apply($scope);
                }, {
                    error: function (response) {
                        Jmx.log.debug("Failed to fetch ACL for operations: ", response);
                        Core.$apply($scope);
                    }
                }));
            });
        }
        function render(response) {
            var ops = response.value.op;
            var answer = {};
            angular.forEach(ops, function (value, key) {
                if (angular.isArray(value)) {
                    angular.forEach(value, function (value, index) {
                        answer[key + getArgs(value.args)] = value;
                    });
                }
                else {
                    answer[key + getArgs(value.args)] = value;
                }
            });
            $scope.operations = sanitize(answer);
            if ($scope.isOperationsEmpty()) {
                Core.$apply($scope);
            }
            else {
                fetchPermissions($scope.objectName, $scope.operations);
                Core.$apply($scope);
            }
        }
    }]);
})(Jmx || (Jmx = {}));
var JUnit;
(function (JUnit) {
    JUnit.log = Logger.get("JUnit");
    function isJUnitPluginEnabled(workspace) {
        return getIntrospectorMBean(workspace) && getJUnitMBean(workspace);
    }
    JUnit.isJUnitPluginEnabled = isJUnitPluginEnabled;
    function getJUnitMBean(workspace) {
        return Core.getMBeanTypeObjectName(workspace, "hawtio", "JUnitFacade");
    }
    JUnit.getJUnitMBean = getJUnitMBean;
    function getIntrospectorMBean(workspace) {
        return Core.getMBeanTypeObjectName(workspace, "hawtio", "Introspector");
    }
    JUnit.getIntrospectorMBean = getIntrospectorMBean;
})(JUnit || (JUnit = {}));
var JUnit;
(function (JUnit) {
    var pluginName = 'junit';
    JUnit._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ngGrid', 'datatable', 'hawtioCore']);
    JUnit._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/junit/tests', { templateUrl: 'app/junit/html/tests.html', reloadOnSearch: false });
    }]);
    JUnit._module.factory('inProgressStatus', function () {
        return {
            jhandle: null,
            data: null,
            result: null,
            alertClass: "success"
        };
    });
    JUnit._module.run(["$location", "workspace", "viewRegistry", "layoutFull", "helpRegistry", function ($location, workspace, viewRegistry, layoutFull, helpRegistry) {
        viewRegistry['junit'] = 'app/junit/html/layoutJUnitTree.html';
        helpRegistry.addUserDoc('junit', 'app/junit/doc/help.md', function () {
            return JUnit.isJUnitPluginEnabled(workspace);
        });
        workspace.topLevelTabs.push({
            id: "junit",
            content: "JUnit",
            title: "View and run test cases in this process",
            isValid: function (workspace) { return JUnit.isJUnitPluginEnabled(workspace); },
            href: function () { return "#/junit/tests"; }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(JUnit || (JUnit = {}));
var JUnit;
(function (JUnit) {
    JUnit._module.controller("JUnit.TreeController", ["$scope", "$location", "workspace", "jolokia", "inProgressStatus", function ($scope, $location, workspace, jolokia, inProgressStatus) {
        var log = Logger.get("JUnit");
        $scope.inProgressData = null;
        $scope.alertClass = "success";
        $scope.testClasses = [];
        $scope.testClassMap = {};
        $scope.gridOptions = {
            selectedItems: [],
            data: 'selectedTests',
            displayFooter: false,
            showFilter: false,
            filterOptions: {
                filterText: ''
            },
            showSelectionCheckbox: true,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'Test Class'
                }
            ]
        };
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateSelectionFromURL, 50);
        });
        $scope.$on('jmxTreeUpdated', function () {
            reloadTree();
        });
        $scope.runAllTests = function () {
            runTests($scope.testClasses);
        };
        $scope.runTests = function () {
            var tests = ($scope.gridOptions.selectedItems || []).map(function (o) { return o.id; });
            runTests(tests);
        };
        $scope.runTest = function (className) {
            if (className) {
                runTests([className]);
            }
        };
        $scope.clearResults = function () {
            $scope.testResults = null;
            $scope.alertClass = "success";
            inProgressStatus.data = null;
            inProgressStatus.result = null;
            inProgressStatus.alertClass = "success";
        };
        function updateSelectionFromURL() {
            Jmx.updateTreeSelectionFromURL($location, $("#junittree"), true);
        }
        reloadTree();
        function selectionChanged(data) {
            var selectionKey = data ? data.key : null;
            log.debug("Selection is now: " + selectionKey);
            var selectedTests = $scope.testClasses;
            $scope.selectionKey = selectionKey;
            if (selectionKey) {
                selectedTests = $scope.testClassMap[selectionKey] || [selectionKey];
            }
            $scope.selectedTests = selectedTests.map(function (t) {
                return { id: t };
            });
            Core.$apply($scope);
        }
        function reloadTree() {
            var mbean = JUnit.getIntrospectorMBean(workspace);
            var domain = "org.unit";
            var rootFolder = new Folder("Test Cases");
            rootFolder.addClass = "testCases";
            rootFolder.typeName = "testCases";
            rootFolder.domain = domain;
            rootFolder.key = "";
            var children = [rootFolder];
            if (mbean) {
                function render(results) {
                    $scope.testClasses = results;
                    $scope.testClassMap = {};
                    angular.forEach(results, function (className) {
                        var paths = className.split(".");
                        var last = paths.length - 1;
                        var folder = rootFolder;
                        var prefix = "";
                        for (var i = 0; i < last; i++) {
                            var path = paths[i];
                            if (prefix) {
                                prefix += ".";
                            }
                            prefix += path;
                            var list = $scope.testClassMap[prefix];
                            if (!list) {
                                list = [];
                                $scope.testClassMap[prefix] = list;
                            }
                            list.push(className);
                            folder = workspace.folderGetOrElse(folder, path);
                            folder.key = prefix;
                        }
                        var lastPath = paths[last];
                        var testClass = new Folder(lastPath);
                        testClass.addClass = "testClass";
                        testClass.domain = domain;
                        testClass.key = className;
                        folder.children.push(testClass);
                    });
                    Core.$apply($scope);
                    var treeElement = $("#junittree");
                    Jmx.enableTree($scope, $location, workspace, treeElement, children, true, function (selectedNode) {
                        var data = selectedNode.data;
                        selectionChanged(data);
                        Core.$apply($scope);
                    });
                    setTimeout(updateSelectionFromURL, 50);
                }
                jolokia.execute(mbean, "findJUnitTestClassNames", onSuccess(render));
            }
        }
        $scope.runningTests = function () {
            if (inProgressStatus.data !== null && inProgressStatus.data.running) {
                $scope.inProgressData = inProgressStatus.data;
                $scope.alertClass = inProgressStatus.alertClass;
                return true;
            }
            else {
                return false;
            }
        };
        $scope.hasTestResults = function () {
            if (inProgressStatus.result !== null) {
                $scope.testResults = inProgressStatus.result;
                $scope.alertClass = inProgressStatus.alertClass;
                return true;
            }
            else {
                return false;
            }
        };
        var renderInProgress = function (response) {
            var result = response.value;
            if (result) {
                log.info("Render inProgress: " + result);
                inProgressStatus.data = result;
                $scope.inProgressData = inProgressStatus.data;
                var alertClass = "success";
                if (result.failureCount > 0) {
                    alertClass = "error";
                }
                inProgressStatus.alertClass = alertClass;
                $scope.alertClass = inProgressStatus.alertClass;
                if (!result.running && inProgressStatus.jhandle !== null) {
                    log.info("Unit test done, unreigster jolokia handle");
                    jolokia.unregister(inProgressStatus.jhandle);
                    inProgressStatus.jhandle = null;
                }
                Core.$apply($scope);
            }
        };
        var renderResults = function (result) {
            if (result) {
                log.info("Render results: " + result);
                inProgressStatus.data = null;
                inProgressStatus.alertClass = null;
                inProgressStatus.result = result;
                var alertClass = "success";
                var notificationClass = "success";
                var message = "JUnit testing succeded with " + result.runCount + " runs.";
                if (result.failureCount > 0) {
                    alertClass = "error";
                    notificationClass = "warning";
                    message = "JUnit testing failed with " + result.failureCount + " failures.";
                }
                $scope.alertClass = alertClass;
                $scope.testResults = inProgressStatus.result;
                Core.notification(notificationClass, message);
                Core.$apply($scope);
            }
        };
        function runTests(listOfClassNames) {
            $scope.clearResults();
            var mbean = JUnit.getJUnitMBean(workspace);
            if (mbean && listOfClassNames && listOfClassNames.length) {
                if (inProgressStatus.jhandle === null) {
                    log.info("Registering jolokia handle");
                    inProgressStatus.jhandle = jolokia.register(renderInProgress, {
                        type: 'exec',
                        mbean: mbean,
                        operation: 'inProgress()',
                        ignoreErrors: true,
                        arguments: []
                    });
                    jolokia.execute(mbean, "runTestClasses", listOfClassNames, onSuccess(renderResults));
                }
            }
        }
    }]);
})(JUnit || (JUnit = {}));
var JVM;
(function (JVM) {
    JVM.log = Logger.get("JVM");
    JVM.connectControllerKey = "jvmConnectSettings";
    JVM.connectionSettingsKey = Core.connectionSettingsKey;
    JVM.logoPath = 'img/icons/jvm/';
    JVM.logoRegistry = {
        'jetty': JVM.logoPath + 'jetty-logo-80x22.png',
        'tomcat': JVM.logoPath + 'tomcat-logo.gif',
        'generic': JVM.logoPath + 'java-logo.svg'
    };
    function configureScope($scope, $location, workspace) {
        $scope.isActive = function (href) {
            var tidy = Core.trimLeading(href, "#");
            var loc = $location.path();
            return loc === tidy;
        };
        $scope.isValid = function (link) {
            return link && link.isValid(workspace);
        };
        $scope.hasLocalMBean = function () {
            return JVM.hasLocalMBean(workspace);
        };
        $scope.breadcrumbs = [
            {
                content: '<i class=" icon-signin"></i> Remote',
                title: "Connect to a remote JVM running Jolokia",
                isValid: function (workspace) { return true; },
                href: "#/jvm/connect"
            },
            {
                content: '<i class="icon-list-ul"></i> Local',
                title: "View a diagram of the route",
                isValid: function (workspace) { return hasLocalMBean(workspace); },
                href: "#/jvm/local"
            },
            {
                content: '<i class="icon-signin"></i> Discovery',
                title: "Discover",
                isValid: function (workspace) { return hasDiscoveryMBean(workspace); },
                href: "#/jvm/discover"
            }
        ];
    }
    JVM.configureScope = configureScope;
    function hasLocalMBean(workspace) {
        return workspace.treeContainsDomainAndProperties('hawtio', { type: 'JVMList' });
    }
    JVM.hasLocalMBean = hasLocalMBean;
    function hasDiscoveryMBean(workspace) {
        return workspace.treeContainsDomainAndProperties('jolokia', { type: 'Discovery' });
    }
    JVM.hasDiscoveryMBean = hasDiscoveryMBean;
})(JVM || (JVM = {}));
var JVM;
(function (JVM) {
    JVM.rootPath = 'app/jvm';
    JVM.templatePath = JVM.rootPath + '/html/';
    JVM.pluginName = 'jvm';
    JVM._module = angular.module(JVM.pluginName, ['bootstrap', 'ngResource', 'datatable', 'hawtioCore', 'hawtio-forms', 'ui']);
    JVM._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/jvm/discover', { templateUrl: JVM.templatePath + 'discover.html' }).when('/jvm/connect', { templateUrl: JVM.templatePath + 'connect.html' }).when('/jvm/local', { templateUrl: JVM.templatePath + 'local.html' });
    }]);
    JVM._module.constant('mbeanName', 'hawtio:type=JVMList');
    JVM._module.run(["$location", "workspace", "viewRegistry", "layoutFull", "helpRegistry", "preferencesRegistry", "ConnectOptions", function ($location, workspace, viewRegistry, layoutFull, helpRegistry, preferencesRegistry, connectOptions) {
        viewRegistry[JVM.pluginName] = JVM.templatePath + 'layoutConnect.html';
        helpRegistry.addUserDoc('jvm', 'app/jvm/doc/help.md');
        preferencesRegistry.addTab("Connect", 'app/jvm/html/reset.html');
        workspace.topLevelTabs.push({
            id: "connect",
            content: "Connect",
            title: "Connect to other JVMs",
            isValid: function (workspace) {
                return connectOptions == null || connectOptions.name == null;
            },
            href: function () {
                return '#/jvm/connect';
            },
            isActive: function (workspace) { return workspace.isLinkActive("jvm"); }
        });
    }]);
    hawtioPluginLoader.addModule(JVM.pluginName);
})(JVM || (JVM = {}));
var JVM;
(function (JVM) {
    JVM.ConnectController = JVM._module.controller("JVM.ConnectController", ["$scope", "$location", "localStorage", "workspace", function ($scope, $location, localStorage, workspace) {
        function newConfig() {
            return Core.createConnectOptions({
                scheme: 'http',
                host: 'localhost',
                path: 'jolokia',
                port: 8181,
                userName: '',
                password: ''
            });
        }
        $scope.forms = {};
        var hasMBeans = workspace && workspace.tree && workspace.tree.children && workspace.tree.children.length;
        $scope.disableProxy = !hasMBeans || Core.isChromeApp();
        $scope.lastConnection = '';
        if (JVM.connectControllerKey in localStorage) {
            try {
                $scope.lastConnection = angular.fromJson(localStorage[JVM.connectControllerKey]);
            }
            catch (e) {
                $scope.lastConnection = '';
                delete localStorage[JVM.connectControllerKey];
            }
        }
        $scope.connectionConfigs = Core.loadConnectionMap();
        if (!Core.isBlank($scope.lastConnection)) {
            $scope.currentConfig = $scope.connectionConfigs[$scope.lastConnection];
        }
        else {
            $scope.currentConfig = newConfig();
        }
        $scope.formConfig = {
            properties: {
                name: {
                    type: "java.lang.String",
                    tooltip: "Name for this connection",
                    required: true,
                    "input-attributes": {
                        "placeholder": "Unnamed..."
                    }
                },
                scheme: {
                    type: "java.lang.String",
                    tooltip: "HTTP or HTTPS",
                    enum: ["http", "https"],
                    required: true
                },
                host: {
                    type: "java.lang.String",
                    tooltip: "Target host to connect to",
                    required: true
                },
                port: {
                    type: "java.lang.Integer",
                    tooltip: "The HTTP port used to connect to the server",
                    "input-attributes": {
                        "min": "0"
                    },
                    required: true
                },
                path: {
                    type: "java.lang.String",
                    tooltip: "The URL path used to connect to Jolokia on the remote server"
                },
                userName: {
                    type: "java.lang.String",
                    tooltip: "The user name to be used when connecting to Jolokia"
                },
                password: {
                    type: "password",
                    tooltip: "The password to be used when connecting to Jolokia"
                }
            }
        };
        $scope.newConnection = function () {
            $scope.lastConnection = '';
        };
        $scope.deleteConnection = function () {
            delete $scope.connectionConfigs[$scope.lastConnection];
            Core.saveConnectionMap($scope.connectionConfigs);
            var keys = Object.extended($scope.connectionConfigs).keys();
            if (keys.length === 0) {
                $scope.lastConnection = '';
            }
            else {
                $scope.lastConnection = keys[0];
            }
        };
        $scope.$watch('lastConnection', function (newValue, oldValue) {
            JVM.log.debug("lastConnection: ", newValue);
            if (newValue !== oldValue) {
                if (Core.isBlank(newValue)) {
                    $scope.currentConfig = newConfig();
                }
                else {
                    $scope.currentConfig = $scope.connectionConfigs[newValue];
                }
                localStorage[JVM.connectControllerKey] = angular.toJson(newValue);
            }
        }, true);
        $scope.save = function () {
            $scope.gotoServer($scope.currentConfig, null, true);
        };
        $scope.gotoServer = function (connectOptions, form, saveOnly) {
            if (!connectOptions) {
                connectOptions = Core.getConnectOptions($scope.lastConnection);
            }
            var name = connectOptions.name;
            $scope.connectionConfigs[name] = connectOptions;
            $scope.lastConnection = name;
            if (saveOnly === true) {
                Core.saveConnectionMap($scope.connectionConfigs);
                $scope.connectionConfigs = Core.loadConnectionMap();
                angular.extend($scope.currentConfig, $scope.connectionConfigs[$scope.lastConnection]);
                Core.$apply($scope);
                return;
            }
            var view = (connectOptions.view || '#/');
            connectOptions.view = view;
            Core.connectToServer(localStorage, connectOptions);
            $scope.connectionConfigs = Core.loadConnectionMap();
            angular.extend($scope.currentConfig, $scope.connectionConfigs[$scope.lastConnection]);
            Core.$apply($scope);
        };
    }]);
})(JVM || (JVM = {}));
var JVM;
(function (JVM) {
    JVM._module.controller("JVM.DiscoveryController", ["$scope", "localStorage", "jolokia", function ($scope, localStorage, jolokia) {
        $scope.discovering = true;
        $scope.agents = undefined;
        $scope.$watch('agents', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.selectedAgent = $scope.agents.find(function (a) { return a['selected']; });
            }
        }, true);
        $scope.closePopover = function ($event) {
            $($event.currentTarget).parents('.popover').prev().popover('hide');
        };
        function doConnect(agent) {
            if (!agent.url) {
                Core.notification('warning', 'No URL available to connect to agent');
                return;
            }
            var options = Core.createConnectOptions();
            options.name = agent.agent_description;
            var urlObject = Core.parseUrl(agent.url);
            angular.extend(options, urlObject);
            options.userName = agent.username;
            options.password = agent.password;
            Core.connectToServer(localStorage, options);
        }
        ;
        $scope.connectWithCredentials = function ($event, agent) {
            $scope.closePopover($event);
            doConnect(agent);
        };
        $scope.gotoServer = function ($event, agent) {
            if (agent.secured) {
                $($event.currentTarget).popover('show');
            }
            else {
                doConnect(agent);
            }
        };
        $scope.getElementId = function (agent) {
            return agent.agent_id.dasherize().replace(/\./g, "-");
        };
        $scope.getLogo = function (agent) {
            if (agent.server_product) {
                return JVM.logoRegistry[agent.server_product];
            }
            return JVM.logoRegistry['generic'];
        };
        $scope.filterMatches = function (agent) {
            if (Core.isBlank($scope.filter)) {
                return true;
            }
            else {
                return angular.toJson(agent).toLowerCase().has($scope.filter.toLowerCase());
            }
        };
        $scope.getAgentIdClass = function (agent) {
            if ($scope.hasName(agent)) {
                return "";
            }
            return "strong";
        };
        $scope.hasName = function (agent) {
            if (agent.server_vendor && agent.server_product && agent.server_version) {
                return true;
            }
            return false;
        };
        $scope.render = function (response) {
            $scope.discovering = false;
            if (response) {
                var responseJson = angular.toJson(response, true);
                if ($scope.responseJson !== responseJson) {
                    $scope.responseJson = responseJson;
                    $scope.agents = response;
                }
            }
            Core.$apply($scope);
        };
        $scope.fetch = function () {
            $scope.discovering = true;
            jolokia.execute('jolokia:type=Discovery', 'lookupAgentsWithTimeout(int)', 10 * 1000, onSuccess($scope.render));
        };
        $scope.fetch();
    }]);
})(JVM || (JVM = {}));
var JVM;
(function (JVM) {
    JVM._module.controller("JVM.JVMsController", ["$scope", "$window", "$location", "localStorage", "workspace", "jolokia", "mbeanName", function ($scope, $window, $location, localStorage, workspace, jolokia, mbeanName) {
        JVM.configureScope($scope, $location, workspace);
        $scope.data = [];
        $scope.deploying = false;
        $scope.status = '';
        $scope.initDone = false;
        $scope.filter = '';
        $scope.filterMatches = function (jvm) {
            if (Core.isBlank($scope.filter)) {
                return true;
            }
            else {
                return jvm.alias.toLowerCase().has($scope.filter.toLowerCase());
            }
        };
        $scope.fetch = function () {
            jolokia.request({
                type: 'exec',
                mbean: mbeanName,
                operation: 'listLocalJVMs()',
                arguments: []
            }, {
                success: render,
                error: function (response) {
                    $scope.data = [];
                    $scope.initDone = true;
                    $scope.status = 'Could not discover local JVM processes: ' + response.error;
                    Core.$apply($scope);
                }
            });
        };
        $scope.stopAgent = function (pid) {
            jolokia.request({
                type: 'exec',
                mbean: mbeanName,
                operation: 'stopAgent(java.lang.String)',
                arguments: [pid]
            }, onSuccess(function () {
                $scope.fetch();
            }));
        };
        $scope.startAgent = function (pid) {
            jolokia.request({
                type: 'exec',
                mbean: mbeanName,
                operation: 'startAgent(java.lang.String)',
                arguments: [pid]
            }, onSuccess(function () {
                $scope.fetch();
            }));
        };
        $scope.connectTo = function (url, scheme, host, port, path) {
            var options = {};
            options["scheme"] = scheme;
            options["host"] = host;
            options["port"] = port;
            options["path"] = path;
            options["userName"] = "";
            options["password"] = "";
            options["view"] = "#/";
            var con = Core.createConnectToServerOptions(options);
            con.name = "local";
            JVM.log.debug("Connecting to local JVM agent: " + url);
            Core.connectToServer(localStorage, con);
            Core.$apply($scope);
        };
        function render(response) {
            $scope.initDone = true;
            $scope.data = response.value;
            if ($scope.data.length === 0) {
                $scope.status = 'Could not discover local JVM processes';
            }
            Core.$apply($scope);
        }
        $scope.fetch();
    }]);
})(JVM || (JVM = {}));
var JVM;
(function (JVM) {
    JVM._module.controller("JVM.NavController", ["$scope", "$location", "workspace", function ($scope, $location, workspace) {
        JVM.configureScope($scope, $location, workspace);
    }]);
})(JVM || (JVM = {}));
var JVM;
(function (JVM) {
    JVM._module.controller("JVM.ResetController", ["$scope", "localStorage", function ($scope, localStorage) {
        $scope.doClearConnectSettings = function () {
            var doReset = function () {
                delete localStorage[JVM.connectControllerKey];
                delete localStorage[JVM.connectionSettingsKey];
                setTimeout(function () {
                    window.location.reload();
                }, 10);
            };
            doReset();
        };
    }]);
})(JVM || (JVM = {}));
var Karaf;
(function (Karaf) {
    Karaf.log = Logger.get("Karaf");
    function setSelect(selection, group) {
        if (!angular.isDefined(selection)) {
            return group[0];
        }
        var answer = group.findIndex(function (item) {
            return item.id === selection.id;
        });
        if (answer !== -1) {
            return group[answer];
        }
        else {
            return group[0];
        }
    }
    Karaf.setSelect = setSelect;
    function installRepository(workspace, jolokia, uri, success, error) {
        Karaf.log.info("installing URI: ", uri);
        jolokia.request({
            type: 'exec',
            mbean: getSelectionFeaturesMBean(workspace),
            operation: 'addRepository(java.lang.String)',
            arguments: [uri]
        }, onSuccess(success, { error: error }));
    }
    Karaf.installRepository = installRepository;
    function uninstallRepository(workspace, jolokia, uri, success, error) {
        Karaf.log.info("uninstalling URI: ", uri);
        jolokia.request({
            type: 'exec',
            mbean: getSelectionFeaturesMBean(workspace),
            operation: 'removeRepository(java.lang.String)',
            arguments: [uri]
        }, onSuccess(success, { error: error }));
    }
    Karaf.uninstallRepository = uninstallRepository;
    function installFeature(workspace, jolokia, feature, version, success, error) {
        jolokia.request({
            type: 'exec',
            mbean: getSelectionFeaturesMBean(workspace),
            operation: 'installFeature(java.lang.String, java.lang.String)',
            arguments: [feature, version]
        }, onSuccess(success, { error: error }));
    }
    Karaf.installFeature = installFeature;
    function uninstallFeature(workspace, jolokia, feature, version, success, error) {
        jolokia.request({
            type: 'exec',
            mbean: getSelectionFeaturesMBean(workspace),
            operation: 'uninstallFeature(java.lang.String, java.lang.String)',
            arguments: [feature, version]
        }, onSuccess(success, { error: error }));
    }
    Karaf.uninstallFeature = uninstallFeature;
    function toCollection(values) {
        var collection = values;
        if (!angular.isArray(values)) {
            collection = [values];
        }
        return collection;
    }
    Karaf.toCollection = toCollection;
    function featureLinks(workspace, name, version) {
        return "<a href='" + Core.url("#/karaf/feature/" + name + "/" + version + workspace.hash()) + "'>" + version + "</a>";
    }
    Karaf.featureLinks = featureLinks;
    function extractFeature(attributes, name, version) {
        var features = [];
        var repos = [];
        populateFeaturesAndRepos(attributes, features, repos);
        return features.find(function (feature) {
            return feature.Name == name && feature.Version == version;
        });
    }
    Karaf.extractFeature = extractFeature;
    var platformBundlePatterns = [
        "^org.apache.aries",
        "^org.apache.karaf",
        "^activemq-karaf",
        "^org.apache.commons",
        "^org.apache.felix",
        "^io.fabric8",
        "^io.fabric8.fab",
        "^io.fabric8.insight",
        "^io.fabric8.mq",
        "^io.fabric8.patch",
        "^io.fabric8.runtime",
        "^io.fabric8.security",
        "^org.apache.geronimo.specs",
        "^org.apache.servicemix.bundles",
        "^org.objectweb.asm",
        "^io.hawt",
        "^javax.mail",
        "^javax",
        "^org.jvnet",
        "^org.mvel2",
        "^org.apache.mina.core",
        "^org.apache.sshd.core",
        "^org.apache.neethi",
        "^org.apache.servicemix.specs",
        "^org.apache.xbean",
        "^org.apache.santuario.xmlsec",
        "^biz.aQute.bndlib",
        "^groovy-all",
        "^com.google.guava",
        "jackson-\\w+-asl",
        "^com.fasterxml.jackson",
        "^org.ops4j",
        "^org.springframework",
        "^bcprov$",
        "^jline$",
        "scala-library$",
        "^org.scala-lang",
        "^stax2-api$",
        "^woodstox-core-asl",
        "^org.jboss.amq.mq-fabric",
        "^gravia-",
        "^joda-time$",
        "^org.apache.ws",
        "-commands$",
        "patch.patch",
        "org.fusesource.insight",
        "activeio-core",
        "activemq-osgi",
        "^org.eclipse.jetty",
        "org.codehaus.jettison.jettison",
        "org.jledit.core",
        "org.fusesource.jansi",
        "org.eclipse.equinox.region"
    ];
    var platformBundleRegex = new RegExp(platformBundlePatterns.join('|'));
    var camelBundlePatterns = ["^org.apache.camel", "camel-karaf-commands$", "activemq-camel$"];
    var camelBundleRegex = new RegExp(camelBundlePatterns.join('|'));
    var cxfBundlePatterns = ["^org.apache.cxf"];
    var cxfBundleRegex = new RegExp(cxfBundlePatterns.join('|'));
    var activemqBundlePatterns = ["^org.apache.activemq", "activemq-camel$"];
    var activemqBundleRegex = new RegExp(activemqBundlePatterns.join('|'));
    function isPlatformBundle(symbolicName) {
        return platformBundleRegex.test(symbolicName);
    }
    Karaf.isPlatformBundle = isPlatformBundle;
    function isActiveMQBundle(symbolicName) {
        return activemqBundleRegex.test(symbolicName);
    }
    Karaf.isActiveMQBundle = isActiveMQBundle;
    function isCamelBundle(symbolicName) {
        return camelBundleRegex.test(symbolicName);
    }
    Karaf.isCamelBundle = isCamelBundle;
    function isCxfBundle(symbolicName) {
        return cxfBundleRegex.test(symbolicName);
    }
    Karaf.isCxfBundle = isCxfBundle;
    function populateFeaturesAndRepos(attributes, features, repositories) {
        var fullFeatures = attributes["Features"];
        angular.forEach(attributes["Repositories"], function (repo) {
            repositories.push({
                id: repo["Name"],
                uri: repo["Uri"]
            });
            if (!fullFeatures) {
                return;
            }
            angular.forEach(repo["Features"], function (feature) {
                angular.forEach(feature, function (entry) {
                    if (fullFeatures[entry['Name']] !== undefined) {
                        var f = Object.extended(fullFeatures[entry['Name']][entry['Version']]).clone();
                        f["Id"] = entry["Name"] + "/" + entry["Version"];
                        f["RepositoryName"] = repo["Name"];
                        f["RepositoryURI"] = repo["Uri"];
                        features.push(f);
                    }
                });
            });
        });
    }
    Karaf.populateFeaturesAndRepos = populateFeaturesAndRepos;
    function createFabricScrComponentsView(components) {
        var result = [];
        angular.forEach(components, function (component) {
            result.push({
                Name: component.name,
                State: component.statusName
            });
        });
        return result;
    }
    Karaf.createFabricScrComponentsView = createFabricScrComponentsView;
    function createScrComponentsView(workspace, jolokia, components) {
        var result = [];
        angular.forEach(components, function (component) {
            result.push({
                Name: component,
                State: getComponentStateDescription(getComponentState(workspace, jolokia, component))
            });
        });
        return result;
    }
    Karaf.createScrComponentsView = createScrComponentsView;
    function getComponentStateDescription(state) {
        switch (state) {
            case 2:
                return "Enabled";
            case 4:
                return "Unsatisfied";
            case 8:
                return "Activating";
            case 16:
                return "Active";
            case 32:
                return "Registered";
            case 64:
                return "Factory";
            case 128:
                return "Deactivating";
            case 256:
                return "Destroying";
            case 1024:
                return "Disabling";
            case 2048:
                return "Disposing";
        }
        return "Unknown";
    }
    Karaf.getComponentStateDescription = getComponentStateDescription;
    ;
    function getAllComponents(workspace, jolokia) {
        var scrMBean = getSelectionScrMBean(workspace);
        var response = jolokia.request({
            type: 'read',
            mbean: scrMBean,
            arguments: []
        });
        if (!('Components' in response.value)) {
            response = jolokia.request({
                type: 'exec',
                mbean: scrMBean,
                operation: 'listComponents()'
            });
            return createScrComponentsView(workspace, jolokia, response.value);
        }
        return response.value['Components'].values;
    }
    Karaf.getAllComponents = getAllComponents;
    function getComponentByName(workspace, jolokia, componentName) {
        var components = getAllComponents(workspace, jolokia);
        return components.find(function (c) {
            return c.Name == componentName;
        });
    }
    Karaf.getComponentByName = getComponentByName;
    function isComponentActive(workspace, jolokia, component) {
        var response = jolokia.request({
            type: 'exec',
            mbean: getSelectionScrMBean(workspace),
            operation: 'isComponentActive(java.lang.String)',
            arguments: [component]
        });
        return response.value;
    }
    Karaf.isComponentActive = isComponentActive;
    function getComponentState(workspace, jolokia, component) {
        var response = jolokia.request({
            type: 'exec',
            mbean: getSelectionScrMBean(workspace),
            operation: 'componentState(java.lang.String)',
            arguments: [component]
        });
        return response.value;
    }
    Karaf.getComponentState = getComponentState;
    function activateComponent(workspace, jolokia, component, success, error) {
        jolokia.request({
            type: 'exec',
            mbean: getSelectionScrMBean(workspace),
            operation: 'activateComponent(java.lang.String)',
            arguments: [component]
        }, onSuccess(success, { error: error }));
    }
    Karaf.activateComponent = activateComponent;
    function deactivateComponent(workspace, jolokia, component, success, error) {
        jolokia.request({
            type: 'exec',
            mbean: getSelectionScrMBean(workspace),
            operation: 'deactiveateComponent(java.lang.String)',
            arguments: [component]
        }, onSuccess(success, { error: error }));
    }
    Karaf.deactivateComponent = deactivateComponent;
    function populateDependencies(attributes, dependencies, features) {
        angular.forEach(dependencies, function (feature) {
            angular.forEach(feature, function (entry) {
                var enhancedFeature = extractFeature(attributes, entry["Name"], entry["Version"]);
                enhancedFeature["id"] = entry["Name"] + "/" + entry["Version"];
                features.push(enhancedFeature);
            });
        });
    }
    Karaf.populateDependencies = populateDependencies;
    function getSelectionFeaturesMBean(workspace) {
        var featureName = "features";
        if (workspace) {
            var featuresStuff = workspace.mbeanTypesToDomain[featureName];
            if (!featuresStuff) {
                featureName = "feature";
                featuresStuff = workspace.mbeanTypesToDomain[featureName] || {};
            }
            var karaf = featuresStuff["org.apache.karaf"] || {};
            var mbean = karaf.objectName;
            if (mbean) {
                return mbean;
            }
            var folder = workspace.tree.navigate("org.apache.karaf", featureName);
            if (!folder) {
                folder = workspace.tree.navigate("org.apache.karaf");
                if (folder) {
                    var children = folder.children;
                    folder = null;
                    angular.forEach(children, function (child) {
                        if (!folder) {
                            folder = child.navigate(featureName);
                        }
                    });
                }
            }
            if (folder) {
                var children = folder.children;
                if (children) {
                    var node = children[0];
                    if (node) {
                        return node.objectName;
                    }
                }
                return folder.objectName;
            }
        }
        return null;
    }
    Karaf.getSelectionFeaturesMBean = getSelectionFeaturesMBean;
    function getSelectionFabricScrMBean(workspace) {
        if (workspace) {
            var scrStuff = workspace.mbeanServicesToDomain["Scr"] || {};
            var karaf = scrStuff["io.fabric8"] || {};
            var mbean = karaf.objectName;
            if (mbean) {
                return mbean;
            }
        }
        return null;
    }
    Karaf.getSelectionFabricScrMBean = getSelectionFabricScrMBean;
    function getSelectionScrMBean(workspace) {
        if (workspace) {
            var scrStuff = workspace.mbeanTypesToDomain["scr"] || {};
            var karaf = scrStuff["org.apache.karaf"] || {};
            var mbean = karaf.objectName;
            if (mbean) {
                return mbean;
            }
            var folder = workspace.tree.navigate("org.apache.karaf", "scr");
            if (!folder) {
                folder = workspace.tree.navigate("org.apache.karaf");
                if (folder) {
                    var children = folder.children;
                    folder = null;
                    angular.forEach(children, function (child) {
                        if (!folder) {
                            folder = child.navigate("scr");
                        }
                    });
                }
            }
            if (folder) {
                var children = folder.children;
                if (children) {
                    var node = children[0];
                    if (node) {
                        return node.objectName;
                    }
                }
                return folder.objectName;
            }
        }
        return null;
    }
    Karaf.getSelectionScrMBean = getSelectionScrMBean;
})(Karaf || (Karaf = {}));
var Karaf;
(function (Karaf) {
    var pluginName = 'karaf';
    Karaf._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'hawtioCore']);
    Karaf._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/osgi/server', { templateUrl: 'app/karaf/html/server.html' }).when('/osgi/features', { templateUrl: 'app/karaf/html/features.html', reloadOnSearch: false }).when('/osgi/scr-components', { templateUrl: 'app/karaf/html/scr-components.html' }).when('/osgi/scr-component/:name', { templateUrl: 'app/karaf/html/scr-component.html' }).when('/osgi/feature/:name/:version', { templateUrl: 'app/karaf/html/feature.html' });
    }]);
    Karaf._module.run(["workspace", "viewRegistry", "helpRegistry", function (workspace, viewRegistry, helpRegistry) {
        helpRegistry.addUserDoc('karaf', 'app/karaf/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties('org.apache.karaf');
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Karaf || (Karaf = {}));
var Karaf;
(function (Karaf) {
    Karaf._module.controller("Karaf.FeatureController", ["$scope", "jolokia", "workspace", "$routeParams", function ($scope, jolokia, workspace, $routeParams) {
        $scope.hasFabric = Fabric.hasFabric(workspace);
        $scope.name = $routeParams.name;
        $scope.version = $routeParams.version;
        $scope.bundlesByLocation = {};
        $scope.props = "properties";
        updateTableContents();
        $scope.install = function () {
            Karaf.installFeature(workspace, jolokia, $scope.name, $scope.version, function () {
                Core.notification('success', 'Installed feature ' + $scope.name);
            }, function (response) {
                Core.notification('error', 'Failed to install feature ' + $scope.name + ' due to ' + response.error);
            });
        };
        $scope.uninstall = function () {
            Karaf.uninstallFeature(workspace, jolokia, $scope.name, $scope.version, function () {
                Core.notification('success', 'Uninstalled feature ' + $scope.name);
            }, function (response) {
                Core.notification('error', 'Failed to uninstall feature ' + $scope.name + ' due to ' + response.error);
            });
        };
        $scope.toProperties = function (elements) {
            var answer = '';
            angular.forEach(elements, function (value, name) {
                answer += value['Key'] + " = " + value['Value'] + "\n";
            });
            return answer.trim();
        };
        function populateTable(response) {
            $scope.row = Karaf.extractFeature(response.value, $scope.name, $scope.version);
            if ($scope.row) {
                addBundleDetails($scope.row);
                var dependencies = [];
                angular.forEach($scope.row.Dependencies, function (version, name) {
                    angular.forEach(version, function (data, version) {
                        dependencies.push({
                            Name: name,
                            Version: version
                        });
                    });
                });
                $scope.row.Dependencies = dependencies;
            }
            Core.$apply($scope);
        }
        function setBundles(response) {
            var bundleMap = {};
            Osgi.defaultBundleValues(workspace, $scope, response.values);
            angular.forEach(response.value, function (bundle) {
                var location = bundle["Location"];
                $scope.bundlesByLocation[location] = bundle;
            });
        }
        ;
        function updateTableContents() {
            var featureMbean = Karaf.getSelectionFeaturesMBean(workspace);
            var bundleMbean = Osgi.getSelectionBundleMBean(workspace);
            var jolokia = workspace.jolokia;
            if (bundleMbean) {
                setBundles(jolokia.request({ type: 'exec', mbean: bundleMbean, operation: 'listBundles()' }));
            }
            if (featureMbean) {
                jolokia.request({ type: 'read', mbean: featureMbean }, onSuccess(populateTable));
            }
        }
        function addBundleDetails(feature) {
            var bundleDetails = [];
            angular.forEach(feature["Bundles"], function (bundleLocation) {
                var bundle = $scope.bundlesByLocation[bundleLocation];
                if (bundle) {
                    bundle["Installed"] = true;
                    bundleDetails.push(bundle);
                }
                else {
                    bundleDetails.push({
                        "Location": bundleLocation,
                        "Installed": false
                    });
                }
            });
            feature["BundleDetails"] = bundleDetails;
        }
    }]);
})(Karaf || (Karaf = {}));
var Karaf;
(function (Karaf) {
    Karaf._module.controller("Karaf.FeaturesController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.hasFabric = Fabric.hasFabric(workspace);
        $scope.responseJson = '';
        $scope.filter = '';
        $scope.installedFeatures = [];
        $scope.features = [];
        $scope.repositories = [];
        $scope.selectedRepositoryId = '';
        $scope.selectedRepository = {};
        $scope.newRepositoryURI = '';
        $scope.init = function () {
            var selectedRepositoryId = $location.search()['repositoryId'];
            if (selectedRepositoryId) {
                $scope.selectedRepositoryId = selectedRepositoryId;
            }
            var filter = $location.search()['filter'];
            if (filter) {
                $scope.filter = filter;
            }
        };
        $scope.init();
        $scope.$watch('selectedRepository', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (!newValue) {
                    $scope.selectedRepositoryId = '';
                }
                else {
                    $scope.selectedRepositoryId = newValue['repository'];
                }
                $location.search('repositoryId', $scope.selectedRepositoryId);
            }
        }, true);
        $scope.$watch('filter', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $location.search('filter', newValue);
            }
        });
        var featuresMBean = Karaf.getSelectionFeaturesMBean(workspace);
        Karaf.log.debug("Features mbean: ", featuresMBean);
        if (featuresMBean) {
            Core.register(jolokia, $scope, {
                type: 'read',
                mbean: featuresMBean
            }, onSuccess(render));
        }
        $scope.inSelectedRepository = function (feature) {
            if (!$scope.selectedRepository || !('repository' in $scope.selectedRepository)) {
                return "";
            }
            if (!feature || !('RepositoryName' in feature)) {
                return "";
            }
            if (feature['RepositoryName'] === $scope.selectedRepository['repository']) {
                return "in-selected-repository";
            }
            return "";
        };
        $scope.isValidRepository = function () {
            return Core.isBlank($scope.newRepositoryURI);
        };
        $scope.installRepository = function () {
            var repoURL = $scope.newRepositoryURI;
            Core.notification('info', 'Adding feature repository URL');
            Karaf.installRepository(workspace, jolokia, repoURL, function () {
                Core.notification('success', 'Added feature repository URL');
                $scope.selectedRepository = {};
                $scope.selectedRepositoryId = '';
                $scope.responseJson = null;
                $scope.triggerRefresh();
            }, function (response) {
                Karaf.log.error('Failed to add feature repository URL ', repoURL, ' due to ', response.error);
                Karaf.log.info('stack trace: ', response.stacktrace);
                Core.$apply($scope);
            });
        };
        $scope.uninstallRepository = function () {
            var repoURI = $scope.selectedRepository['uri'];
            Core.notification('info', 'Removing feature repository ' + repoURI);
            Karaf.uninstallRepository(workspace, jolokia, repoURI, function () {
                Core.notification('success', 'Removed feature repository ' + repoURI);
                $scope.responseJson = null;
                $scope.selectedRepositoryId = '';
                $scope.selectedRepository = {};
                $scope.triggerRefresh();
            }, function (response) {
                Karaf.log.error('Failed to remove feature repository ', repoURI, ' due to ', response.error);
                Karaf.log.info('stack trace: ', response.stacktrace);
                Core.$apply($scope);
            });
        };
        $scope.triggerRefresh = function () {
            jolokia.request({
                type: 'read',
                method: 'POST',
                mbean: featuresMBean
            }, onSuccess(render));
        };
        $scope.install = function (feature) {
            if ($scope.hasFabric) {
                return;
            }
            Core.notification('info', 'Installing feature ' + feature.Name);
            Karaf.installFeature(workspace, jolokia, feature.Name, feature.Version, function () {
                Core.notification('success', 'Installed feature ' + feature.Name);
                $scope.installedFeatures.add(feature);
                $scope.responseJson = null;
                $scope.triggerRefresh();
            }, function (response) {
                Karaf.log.error('Failed to install feature ', feature.Name, ' due to ', response.error);
                Karaf.log.info('stack trace: ', response.stacktrace);
                Core.$apply($scope);
            });
        };
        $scope.uninstall = function (feature) {
            if ($scope.hasFabric) {
                return;
            }
            Core.notification('info', 'Uninstalling feature ' + feature.Name);
            Karaf.uninstallFeature(workspace, jolokia, feature.Name, feature.Version, function () {
                Core.notification('success', 'Uninstalled feature ' + feature.Name);
                $scope.installedFeatures.remove(feature);
                $scope.responseJson = null;
                $scope.triggerRefresh();
            }, function (response) {
                Karaf.log.error('Failed to uninstall feature ', feature.Name, ' due to ', response.error);
                Karaf.log.info('stack trace: ', response.stacktrace);
                Core.$apply($scope);
            });
        };
        $scope.filteredRows = ['Bundles', 'Configurations', 'Configuration Files', 'Dependencies'];
        $scope.showRow = function (key, value) {
            if ($scope.filteredRows.any(key)) {
                return false;
            }
            if (angular.isArray(value)) {
                if (value.length === 0) {
                    return false;
                }
            }
            if (angular.isString(value)) {
                if (Core.isBlank(value)) {
                    return false;
                }
            }
            if (angular.isObject(value)) {
                if (!value || Object.equal(value, {})) {
                    return false;
                }
            }
            return true;
        };
        $scope.installed = function (installed) {
            var answer = Core.parseBooleanValue(installed);
            return answer;
        };
        $scope.showValue = function (value) {
            if (angular.isArray(value)) {
                var answer = ['<ul class="zebra-list">'];
                value.forEach(function (v) {
                    answer.push('<li>' + v + '</li>');
                });
                answer.push('</ul>');
                return answer.join('\n');
            }
            if (angular.isObject(value)) {
                var answer = ['<table class="table">', '<tbody>'];
                angular.forEach(value, function (value, key) {
                    answer.push('<tr>');
                    answer.push('<td>' + key + '</td>');
                    answer.push('<td>' + value + '</td>');
                    answer.push('</tr>');
                });
                answer.push('</tbody>');
                answer.push('</table>');
                return answer.join('\n');
            }
            return "" + value;
        };
        $scope.getStateStyle = function (feature) {
            if (Core.parseBooleanValue(feature.Installed)) {
                return "badge badge-success";
            }
            return "badge";
        };
        $scope.filterFeature = function (feature) {
            if (Core.isBlank($scope.filter)) {
                return true;
            }
            if (feature.Id.has($scope.filter)) {
                return true;
            }
            return false;
        };
        function render(response) {
            var responseJson = angular.toJson(response.value);
            if ($scope.responseJson !== responseJson) {
                $scope.responseJson = responseJson;
                if (response['value']['Features'] === null) {
                    $scope.featuresError = true;
                }
                else {
                    $scope.featuresError = false;
                }
                $scope.features = [];
                $scope.repositories = [];
                var features = [];
                var repositories = [];
                Karaf.populateFeaturesAndRepos(response.value, features, repositories);
                var installedFeatures = features.filter(function (f) {
                    return Core.parseBooleanValue(f.Installed);
                });
                var uninstalledFeatures = features.filter(function (f) {
                    return !Core.parseBooleanValue(f.Installed);
                });
                $scope.installedFeatures = installedFeatures.sortBy(function (f) {
                    return f['Name'];
                });
                uninstalledFeatures = uninstalledFeatures.sortBy(function (f) {
                    return f['Name'];
                });
                repositories.sortBy('id').forEach(function (repo) {
                    $scope.repositories.push({
                        repository: repo['id'],
                        uri: repo['uri'],
                        features: uninstalledFeatures.filter(function (f) {
                            return f['RepositoryName'] === repo['id'];
                        })
                    });
                });
                if (!Core.isBlank($scope.newRepositoryURI)) {
                    var selectedRepo = repositories.find(function (r) {
                        return r['uri'] === $scope.newRepositoryURI;
                    });
                    if (selectedRepo) {
                        $scope.selectedRepositoryId = selectedRepo['id'];
                    }
                    $scope.newRepositoryURI = '';
                }
                if (Core.isBlank($scope.selectedRepositoryId)) {
                    $scope.selectedRepository = $scope.repositories.first();
                }
                else {
                    $scope.selectedRepository = $scope.repositories.find(function (r) {
                        return r.repository === $scope.selectedRepositoryId;
                    });
                }
                Core.$apply($scope);
            }
        }
    }]);
})(Karaf || (Karaf = {}));
var Karaf;
(function (Karaf) {
    Karaf._module.controller("Karaf.NavBarController", ["$scope", "workspace", function ($scope, workspace) {
        $scope.hash = workspace.hash();
        $scope.isKarafEnabled = workspace.treeContainsDomainAndProperties("org.apache.karaf");
        $scope.isFeaturesEnabled = Karaf.getSelectionFeaturesMBean(workspace);
        $scope.isScrEnabled = Karaf.getSelectionScrMBean(workspace);
        $scope.$on('$routeChangeSuccess', function () {
            $scope.hash = workspace.hash();
        });
        $scope.isActive = function (nav) {
            return workspace.isLinkActive(nav);
        };
        $scope.isPrefixActive = function (nav) {
            return workspace.isLinkPrefixActive(nav);
        };
    }]);
})(Karaf || (Karaf = {}));
var Karaf;
(function (Karaf) {
    Karaf._module.controller("Karaf.ScrComponentController", ["$scope", "$location", "workspace", "jolokia", "$routeParams", function ($scope, $location, workspace, jolokia, $routeParams) {
        $scope.name = $routeParams.name;
        populateTable();
        function populateTable() {
            $scope.row = Karaf.getComponentByName(workspace, jolokia, $scope.name);
            Core.$apply($scope);
        }
        $scope.activate = function () {
            Karaf.activateComponent(workspace, jolokia, $scope.row['Name'], function () {
                console.log("Activated!");
            }, function () {
                console.log("Failed to activate!");
            });
        };
        $scope.deactivate = function () {
            Karaf.deactivateComponent(workspace, jolokia, $scope.row['Name'], function () {
                console.log("Deactivated!");
            }, function () {
                console.log("Failed to deactivate!");
            });
        };
    }]);
})(Karaf || (Karaf = {}));
var Karaf;
(function (Karaf) {
    Karaf.ScrComponentsController = Karaf._module.controller("Karaf.ScrComponentsController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.component = empty();
        $scope.result = [];
        $scope.components = [];
        $scope.selectedComponents = [];
        $scope.scrOptions = {
            data: 'components',
            showFilter: false,
            showColumnMenu: false,
            filterOptions: {
                useExternalFilter: false
            },
            sortInfo: { fields: ['Name'], directions: ['asc'] },
            selectedItems: $scope.selectedComponents,
            rowHeight: 32,
            selectWithCheckboxOnly: true,
            columnDefs: [
                {
                    field: 'Name',
                    displayName: 'Name',
                    cellTemplate: '<div class="ngCellText"><a href="#/osgi/scr-component/{{row.entity.Name}}?p=container">{{row.getProperty(col.field)}}</a></div>',
                    width: 600
                },
                {
                    field: 'State',
                    displayName: 'State',
                    cellTemplate: '<div class="ngCellText">{{row.getProperty(col.field)}}</div>',
                    width: 200
                }
            ]
        };
        var scrMBean = Karaf.getSelectionFabricScrMBean(workspace);
        if (scrMBean) {
            Core.register(jolokia, $scope, {
                type: 'exec',
                mbean: scrMBean,
                operation: 'listComponents()'
            }, onSuccess(function (response) {
                var components = response.value || [];
                render(Karaf.createFabricScrComponentsView(response.value));
            }));
        }
        else {
            scrMBean = Karaf.getSelectionScrMBean(workspace);
            if (scrMBean) {
                render(Karaf.getAllComponents(workspace, jolokia));
            }
        }
        $scope.activate = function () {
            $scope.selectedComponents.forEach(function (component) {
                Karaf.activateComponent(workspace, jolokia, component.Name, function () {
                    console.log("Activated!");
                }, function () {
                    console.log("Failed to activate!");
                });
            });
            $scope.selectedComponents.splice(0, $scope.selectedComponents.length);
        };
        $scope.deactivate = function () {
            $scope.selectedComponents.forEach(function (component) {
                Karaf.deactivateComponent(workspace, jolokia, component.Name, function () {
                    console.log("Deactivated!");
                }, function () {
                    console.log("Failed to deactivate!");
                });
            });
            $scope.selectedComponents.splice(0, $scope.selectedComponents.length);
        };
        function empty() {
            return [
                { Name: "", Status: false }
            ];
        }
        function render(components) {
            if (!Object.equal($scope.result, components)) {
                $scope.components = components;
                $scope.result = $scope.components;
                Core.$apply($scope);
            }
        }
    }]);
})(Karaf || (Karaf = {}));
var Karaf;
(function (Karaf) {
    Karaf._module.controller("Karaf.ServerController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var log = Logger.get("Karaf");
        var karaf2x = true;
        var karaf3x = true;
        $scope.data = {
            name: "",
            version: "",
            state: "",
            root: "",
            startLevel: "",
            framework: "",
            frameworkVersion: "",
            location: "",
            sshPort: "",
            rmiRegistryPort: "",
            rmiServerPort: "",
            pid: ""
        };
        $scope.$on('jmxTreeUpdated', reloadFunction);
        $scope.$watch('workspace.tree', reloadFunction);
        function reloadFunction() {
            setTimeout(loadData, 50);
        }
        function loadData() {
            log.info("Loading Karaf data...");
            if (karaf2x) {
                jolokia.search("org.apache.karaf:type=admin,*", onSuccess(render2x));
            }
            if (karaf3x) {
                jolokia.search("org.apache.karaf:type=instance,*", onSuccess(render3x));
            }
        }
        function render2x(response) {
            if (angular.isArray(response)) {
                var mbean = response[0];
                if (mbean) {
                    log.debug("Karaf 2.x detected");
                    jolokia.getAttribute(mbean, "Instances", onSuccess(function (response) {
                        onInstances(response, mbean);
                    }));
                }
            }
            else {
                karaf2x = false;
            }
        }
        function render3x(response) {
            if (angular.isArray(response)) {
                var mbean = response[0];
                if (mbean) {
                    log.debug("Karaf 3.x detected");
                    jolokia.getAttribute(mbean, "Instances", onSuccess(function (response) {
                        onInstances(response, mbean);
                    }));
                }
            }
            else {
                karaf3x = false;
            }
        }
        function onInstances(instances, mbean) {
            if (instances) {
                var parsedMBean = Core.parseMBean(mbean);
                var instanceName = 'root';
                if ('attributes' in parsedMBean) {
                    if ('name' in parsedMBean['attributes']) {
                        instanceName = parsedMBean['attributes']['name'];
                    }
                }
                if (log.enabledFor(Logger.DEBUG)) {
                    log.debug("mbean: ", Core.parseMBean(mbean));
                    log.debug("Instances: ", instances);
                }
                var rootInstance = instances[instanceName];
                $scope.data.name = rootInstance.Name;
                $scope.data.state = rootInstance.State;
                $scope.data.root = rootInstance["Is Root"];
                $scope.data.location = rootInstance.Location;
                $scope.data.sshPort = rootInstance["SSH Port"];
                $scope.data.rmiRegistryPort = rootInstance["RMI Registry Port"];
                $scope.data.rmiServerPort = rootInstance["RMI Server Port"];
                $scope.data.pid = rootInstance.Pid;
                $scope.data.version = "?";
                $scope.data.startLevel = "?";
                $scope.data.framework = "?";
                $scope.data.frameworkVersion = "?";
                var systemMbean = "org.apache.karaf:type=system,name=" + rootInstance.Name;
                var response = jolokia.request({ type: "read", mbean: systemMbean, attribute: ["StartLevel", "Framework", "Version"] }, onSuccess(null));
                var obj = response.value;
                if (obj) {
                    $scope.data.version = obj.Version;
                    $scope.data.startLevel = obj.StartLevel;
                    $scope.data.framework = obj.Framework;
                }
                var response2 = jolokia.search("osgi.core:type=bundleState,*", onSuccess(null));
                if (angular.isArray(response2)) {
                    var mbean = response2[0];
                    if (mbean) {
                        var response3 = jolokia.request({ type: 'exec', mbean: mbean, operation: 'getVersion(long)', arguments: [0] }, onSuccess(null));
                        var obj3 = response3.value;
                        if (obj3) {
                            $scope.data.frameworkVersion = obj3;
                        }
                    }
                }
            }
            Core.$apply($scope);
        }
    }]);
})(Karaf || (Karaf = {}));
var Kubernetes;
(function (Kubernetes) {
    Kubernetes._module = angular.module(Kubernetes.pluginName, ['hawtioCore', 'ngResource']);
    Kubernetes.controller = PluginHelpers.createControllerFunction(Kubernetes._module, Kubernetes.pluginName);
    Kubernetes.route = PluginHelpers.createRoutingFunction(Kubernetes.templatePath);
    Kubernetes._module.config(['$routeProvider', function ($routeProvider) {
        $routeProvider.when(UrlHelpers.join(Kubernetes.context, '/pods'), Kubernetes.route('pods.html', false)).when(UrlHelpers.join(Kubernetes.context, '/namespace/:namespace/pods'), Kubernetes.route('pods.html', false)).when(UrlHelpers.join(Kubernetes.context, 'replicationControllers'), Kubernetes.route('replicationControllers.html', false)).when(UrlHelpers.join(Kubernetes.context, '/namespace/:namespace/replicationControllers'), Kubernetes.route('replicationControllers.html', false)).when(UrlHelpers.join(Kubernetes.context, 'services'), Kubernetes.route('services.html', false)).when(UrlHelpers.join(Kubernetes.context, '/namespace/:namespace/services'), Kubernetes.route('services.html', false)).when(UrlHelpers.join(Kubernetes.context, 'apps'), Kubernetes.route('apps.html', false)).when(UrlHelpers.join(Kubernetes.context, 'apps/:namespace'), Kubernetes.route('apps.html', false)).when(UrlHelpers.join(Kubernetes.context, 'overview'), Kubernetes.route('overview.html', false));
    }]);
    Kubernetes._module.factory('KubernetesApiURL', ['jolokiaUrl', 'jolokia', '$q', '$rootScope', function (jolokiaUrl, jolokia, $q, $rootScope) {
        var answer = $q.defer();
        jolokia.getAttribute(Kubernetes.mbean, 'KubernetesAddress', undefined, onSuccess(function (response) {
            var proxified = UrlHelpers.maybeProxy(jolokiaUrl, response);
            Kubernetes.log.debug("discovered API URL:", proxified);
            answer.resolve(proxified);
            Core.$apply($rootScope);
        }, {
            error: function (response) {
                Kubernetes.log.debug("error fetching API URL: ", response);
                answer.reject(response);
                Core.$apply($rootScope);
            }
        }));
        return answer.promise;
    }]);
    function createResource(deferred, thing, urlTemplate) {
        var $rootScope = Core.injector.get("$rootScope");
        var $resource = Core.injector.get("$resource");
        var KubernetesApiURL = Core.injector.get("KubernetesApiURL");
        KubernetesApiURL.then(function (KubernetesApiURL) {
            var url = UrlHelpers.escapeColons(KubernetesApiURL);
            Kubernetes.log.debug("Url for ", thing, ": ", url);
            var resource = $resource(UrlHelpers.join(url, urlTemplate), null, {
                query: { method: 'GET', isArray: false },
                save: { method: 'PUT', params: { id: '@id' } }
            });
            deferred.resolve(resource);
            Core.$apply($rootScope);
        }, function (response) {
            Kubernetes.log.debug("Failed to get rest API URL, can't create " + thing + " resource: ", response);
            deferred.reject(response);
            Core.$apply($rootScope);
        });
    }
    Kubernetes._module.factory('KubernetesVersion', ['$q', function ($q) {
        var answer = $q.defer();
        createResource(answer, 'pods', '/version');
        return answer.promise;
    }]);
    Kubernetes._module.factory('KubernetesPods', ['$q', function ($q) {
        var answer = $q.defer();
        createResource(answer, 'pods', '/kubernetes/api/v1beta2/pods/:id');
        return answer.promise;
    }]);
    Kubernetes._module.factory('KubernetesReplicationControllers', ['$q', function ($q) {
        var answer = $q.defer();
        createResource(answer, 'replication controllers', '/kubernetes/api/v1beta2/replicationControllers/:id');
        return answer.promise;
    }]);
    Kubernetes._module.factory('KubernetesServices', ['$q', function ($q) {
        var answer = $q.defer();
        createResource(answer, 'services', '/kubernetes/api/v1beta2/services/:id');
        return answer.promise;
    }]);
    Kubernetes._module.factory('KubernetesState', [function () {
        return {
            namespaces: [],
            selectedNamespace: null
        };
    }]);
    Kubernetes._module.run(['viewRegistry', 'workspace', 'ServiceRegistry', function (viewRegistry, workspace, ServiceRegistry) {
        Kubernetes.log.debug("Running");
        viewRegistry['kubernetes'] = Kubernetes.templatePath + 'layoutKubernetes.html';
        workspace.topLevelTabs.push({
            id: 'kubernetes',
            content: 'Kubernetes',
            isValid: function (workspace) { return Kubernetes.isKubernetes(workspace); },
            isActive: function (workspace) { return workspace.isLinkActive('kubernetes'); },
            href: function () { return Kubernetes.defaultRoute; }
        });
        workspace.topLevelTabs.push({
            id: 'kibana',
            content: 'Logs',
            title: 'View and search all logs across all containers using Kibana and ElasticSearch',
            isValid: function (workspace) { return Service.hasService(ServiceRegistry, "kibana-service"); },
            href: function () { return Kubernetes.kibanaLogsLink(ServiceRegistry); },
            isActive: function (workspace) { return false; }
        });
        workspace.topLevelTabs.push({
            id: 'grafana',
            content: 'Metrics',
            title: 'Views metrics across all containers using Grafana and InfluxDB',
            isValid: function (workspace) { return Service.hasService(ServiceRegistry, "grafana-service"); },
            href: function () { return Service.serviceLink(ServiceRegistry, "grafana-service"); },
            isActive: function (workspace) { return false; }
        });
    }]);
    hawtioPluginLoader.addModule(Kubernetes.pluginName);
})(Kubernetes || (Kubernetes = {}));
var Kubernetes;
(function (Kubernetes) {
    Kubernetes.Apps = Kubernetes.controller("Apps", ["$scope", "KubernetesServices", "KubernetesReplicationControllers", "KubernetesPods", "KubernetesState", "KubernetesApiURL", "$templateCache", "$location", "$routeParams", "$http", "$dialog", "$timeout", "workspace", "jolokia", function ($scope, KubernetesServices, KubernetesReplicationControllers, KubernetesPods, KubernetesState, KubernetesApiURL, $templateCache, $location, $routeParams, $http, $dialog, $timeout, workspace, jolokia) {
        $scope.namespace = $routeParams.namespace;
        $scope.apps = [];
        $scope.allApps = [];
        $scope.kubernetes = KubernetesState;
        $scope.fetched = false;
        $scope.json = '';
        ControllerHelpers.bindModelToSearchParam($scope, $location, 'id', '_id', undefined);
        ControllerHelpers.bindModelToSearchParam($scope, $location, 'appSelectorShow', 'openApp', undefined);
        ControllerHelpers.bindModelToSearchParam($scope, $location, 'mode', 'mode', 'list');
        var branch = $scope.branch || "master";
        var namespace = null;
        var defaultIconUrl = Core.url("/img/icons/kubernetes.svg");
        function appMatches(app) {
            var filterText = $scope.appSelector.filterText;
            if (filterText) {
                return Core.matchFilterIgnoreCase(app.groupId, filterText) || Core.matchFilterIgnoreCase(app.artifactId, filterText) || Core.matchFilterIgnoreCase(app.name, filterText) || Core.matchFilterIgnoreCase(app.description, filterText);
            }
            else {
                return true;
            }
        }
        function appRunning(app) {
            return $scope.apps.any(function (running) { return running.appPath === app.appPath; });
        }
        $scope.tableConfig = {
            data: 'apps',
            showSelectionCheckbox: true,
            enableRowClickSelection: false,
            multiSelect: true,
            selectedItems: [],
            filterOptions: {
                filterText: $location.search()["q"] || ''
            },
            columnDefs: [
                { field: 'icon', displayName: 'App', cellTemplate: $templateCache.get("appIconTemplate.html") },
                { field: 'services', displayName: 'Services', cellTemplate: $templateCache.get("appServicesTemplate.html") },
                { field: 'replicationControllers', displayName: 'Controllers', cellTemplate: $templateCache.get("appReplicationControllerTemplate.html") },
                { field: '$podsLink', displayName: 'Pods', cellTemplate: $templateCache.get("appPodCountsAndLinkTemplate.html") },
                { field: '$deployedText', displayName: 'Deployed', cellTemplate: $templateCache.get("appDeployedTemplate.html") },
                { field: 'namespace', displayName: 'Namespace' }
            ]
        };
        Kubernetes.initShared($scope, $location);
        $scope.expandedPods = [];
        $scope.podExpanded = function (pod) {
            var id = (pod || {}).id;
            return id && ($scope.expandedPods || []).indexOf(id) >= 0;
        };
        $scope.expandPod = function (pod) {
            var id = pod.id;
            if (id) {
                $scope.expandedPods.push(id);
            }
        };
        $scope.collapsePod = function (pod) {
            var id = pod.id;
            if (id) {
                $scope.expandedPods = $scope.expandedPods.remove(function (v) { return id === v; });
            }
        };
        $scope.$on('$routeUpdate', function ($event) {
            Kubernetes.setJson($scope, $location.search()['_id'], $scope.apps);
        });
        if (Kubernetes.isKubernetes(workspace)) {
            Core.register(jolokia, $scope, { type: 'exec', mbean: Kubernetes.mbean, operation: "findApps", arguments: [branch] }, onSuccess(onAppData));
        }
        if (Kubernetes.isAppView(workspace)) {
            Core.register(jolokia, $scope, { type: 'exec', mbean: Kubernetes.appViewMBean, operation: "findAppSummariesJson" }, onSuccess(onAppViewData));
        }
        function deleteApp(app, onCompleteFn) {
            function deleteServices(services, service, onCompletedFn) {
                if (!service || !services) {
                    return onCompletedFn();
                }
                var id = service.id;
                if (!id) {
                    Kubernetes.log.warn("No ID for service " + angular.toJson(service));
                }
                else {
                    KubernetesServices.then(function (KubernetesServices) {
                        KubernetesServices.delete({
                            id: id
                        }, undefined, function () {
                            Kubernetes.log.debug("Deleted service: ", id);
                            deleteServices(services, services.shift(), onCompletedFn);
                        }, function (error) {
                            Kubernetes.log.debug("Error deleting service: ", error);
                            deleteServices(services, services.shift(), onCompletedFn);
                        });
                    });
                }
            }
            function deleteReplicationControllers(replicationControllers, replicationController, onCompletedFn) {
                if (!replicationController || !replicationControllers) {
                    return onCompletedFn();
                }
                var id = replicationController.id;
                if (!id) {
                    Kubernetes.log.warn("No ID for replicationController " + angular.toJson(replicationController));
                }
                else {
                    KubernetesReplicationControllers.then(function (KubernetesReplicationControllers) {
                        KubernetesReplicationControllers.delete({
                            id: id
                        }, undefined, function () {
                            Kubernetes.log.debug("Deleted replicationController: ", id);
                            deleteReplicationControllers(replicationControllers, replicationControllers.shift(), onCompletedFn);
                        }, function (error) {
                            Kubernetes.log.debug("Error deleting replicationController: ", error);
                            deleteReplicationControllers(replicationControllers, replicationControllers.shift(), onCompletedFn);
                        });
                    });
                }
            }
            function deletePods(pods, pod, onCompletedFn) {
                if (!pod || !pods) {
                    return onCompletedFn();
                }
                var id = pod.id;
                if (!id) {
                    Kubernetes.log.warn("No ID for pod " + angular.toJson(pod));
                }
                else {
                    KubernetesPods.then(function (KubernetesPods) {
                        KubernetesPods.delete({
                            id: id
                        }, undefined, function () {
                            Kubernetes.log.debug("Deleted pod: ", id);
                            deletePods(pods, pods.shift(), onCompletedFn);
                        }, function (error) {
                            Kubernetes.log.debug("Error deleting pod: ", error);
                            deletePods(pods, pods.shift(), onCompletedFn);
                        });
                    });
                }
            }
            var services = [].concat(app.services);
            deleteServices(services, services.shift(), function () {
                var replicationControllers = [].concat(app.replicationControllers);
                deleteReplicationControllers(replicationControllers, replicationControllers.shift(), function () {
                    var pods = [].concat(app.pods);
                    deletePods(pods, pods.shift(), onCompleteFn);
                });
            });
        }
        $scope.deletePrompt = function (selected) {
            if (angular.isString(selected)) {
                selected = [{
                    id: selected
                }];
            }
            UI.multiItemConfirmActionDialog({
                collection: selected,
                index: '$name',
                onClose: function (result) {
                    if (result) {
                        function deleteSelected(selected, next) {
                            if (next) {
                                var id = next.name;
                                Kubernetes.log.debug("deleting: ", id);
                                deleteApp(next, function () {
                                    Kubernetes.log.debug("deleted: ", id);
                                    deleteSelected(selected, selected.shift());
                                });
                            }
                        }
                        deleteSelected(selected, selected.shift());
                    }
                },
                title: 'Delete Apps?',
                action: 'The following Apps will be deleted:',
                okText: 'Delete',
                okClass: 'btn-danger',
                custom: "This operation is permanent once completed!",
                customClass: "alert alert-warning"
            }).open();
        };
        $scope.appSelector = {
            filterText: "",
            folders: [],
            selectedApps: [],
            isOpen: function (folder) {
                if ($scope.appSelector.filterText !== '' || folder.expanded) {
                    return "opened";
                }
                return "closed";
            },
            getSelectedClass: function (app) {
                if (app.abstract) {
                    return "abstract";
                }
                if (app.selected) {
                    return "selected";
                }
                return "";
            },
            showApp: function (app) {
                return appMatches(app) && !appRunning(app);
            },
            showFolder: function (folder) {
                return !$scope.appSelector.filterText || folder.apps.some(function (app) { return appMatches(app) && !appRunning(app); });
            },
            clearSelected: function () {
                angular.forEach($scope.appSelector.folders, function (folder) {
                    angular.forEach(folder.apps, function (app) {
                        app.selected = false;
                    });
                });
                $scope.appSelector.selectedApps = [];
                Core.$apply($scope);
            },
            updateSelected: function () {
                var selectedApps = [];
                angular.forEach($scope.appSelector.folders, function (folder) {
                    var apps = folder.apps.filter(function (app) { return app.selected; });
                    if (apps) {
                        selectedApps = selectedApps.concat(apps);
                    }
                });
                $scope.appSelector.selectedApps = selectedApps.sortBy("name");
            },
            select: function (app, flag) {
                app.selected = flag;
                $scope.appSelector.updateSelected();
            },
            hasSelection: function () {
                return $scope.appSelector.folders.any(function (folder) { return folder.apps.any(function (app) { return app.selected; }); });
            },
            runSelectedApps: function () {
                angular.forEach($scope.appSelector.selectedApps, function (app) {
                    var name = app.name;
                    var metadataPath = app.metadataPath;
                    if (metadataPath) {
                        var url = Wiki.gitRelativeURL(branch, metadataPath);
                        if (url) {
                            $http.get(url).success(function (data, status, headers, config) {
                                if (data) {
                                    var json = angular.toJson(data);
                                    var fn = function () {
                                    };
                                    Kubernetes.runApp($location, jolokia, $scope, json, name, fn, namespace);
                                }
                            }).error(function (data, status, headers, config) {
                                $scope.summaryHtml = null;
                                Kubernetes.log.warn("Failed to load " + url + " " + data + " " + status);
                            });
                        }
                    }
                });
                $scope.appSelector.clearSelected();
                $scope.appSelectorShow = false;
            }
        };
        $scope.resizeDialog = {
            dialog: new UI.Dialog(),
            onOk: function () {
                $scope.resizeDialog.dialog.close();
                Kubernetes.resizeController($http, KubernetesApiURL, $scope.resize.controller.id, $scope.resize.newReplicas, function () {
                    $scope.resize.controller.replicas = $scope.resize.newReplicas;
                    Core.$apply($scope);
                });
            },
            open: function () {
                $scope.resizeDialog.dialog.open();
            },
            close: function () {
                $scope.resizeDialog.dialog.close();
            }
        };
        function updateData() {
            if ($scope.appInfos && $scope.appViews) {
                $scope.fetched = true;
                var folderMap = {};
                var folders = [];
                var appMap = {};
                angular.forEach($scope.appInfos, function (appInfo) {
                    var appPath = appInfo.appPath;
                    var iconPath = appInfo.iconPath;
                    if (iconPath) {
                        appInfo.$iconUrl = Wiki.gitRelativeURL(branch, iconPath);
                    }
                    else {
                        appInfo.$iconUrl = defaultIconUrl;
                    }
                    if (appPath) {
                        appMap[appPath] = appInfo;
                        var idx = appPath.lastIndexOf("/");
                        var folderPath = "";
                        if (idx >= 0) {
                            folderPath = appPath.substring(0, idx);
                        }
                        folderPath = Core.trimLeading(folderPath, "/");
                        var folder = folderMap[folderPath];
                        if (!folder) {
                            folder = {
                                path: folderPath,
                                expanded: true,
                                apps: []
                            };
                            folders.push(folder);
                            folderMap[folderPath] = folder;
                        }
                        folder.apps.push(appInfo);
                    }
                });
                $scope.appSelector.folders = folders.sortBy("path");
                var apps = [];
                var defaultInfo = {
                    $iconUrl: defaultIconUrl,
                    name: ""
                };
                angular.forEach($scope.appViews, function (appView) {
                    var appPath = appView.appPath;
                    appView.$info = defaultInfo;
                    appView.$select = function () {
                        Kubernetes.setJson($scope, appView.id, $scope.apps);
                    };
                    var appInfo = defaultInfo;
                    if (appPath) {
                        appInfo = appMap[appPath] || defaultInfo;
                    }
                    appView.$info = appInfo;
                    appView.id = appPath;
                    appView.$name = appInfo.name;
                    appView.$iconUrl = appInfo.$iconUrl;
                    appView.$appUrl = Wiki.viewLink(branch, appPath, $location);
                    appView.$openResizeControllerDialog = function (controller) {
                        $scope.resize = {
                            controller: controller,
                            newReplicas: controller.replicas
                        };
                        $scope.resizeDialog.dialog.open();
                        $timeout(function () {
                            $('#replicas').focus();
                        }, 50);
                    };
                    apps.push(appView);
                    appView.$podCounters = createAppViewPodCounters(appView);
                    appView.$serviceViews = createAppViewServiceViews(appView);
                });
                $scope.apps = apps;
                Core.$apply($scope);
            }
        }
        function createAppViewPodCounters(appView) {
            var array = [];
            var map = {};
            var pods = appView.pods;
            var lowestDate = null;
            angular.forEach(pods, function (pod) {
                var selector = pod.labels;
                var selectorText = Kubernetes.labelsToString(selector, " ");
                var answer = map[selector];
                if (!answer) {
                    answer = {
                        labelText: selectorText,
                        podsLink: Core.url("/kubernetes/pods?q=" + encodeURIComponent(selectorText)),
                        valid: 0,
                        waiting: 0,
                        error: 0
                    };
                    map[selector] = answer;
                    array.push(answer);
                }
                var status = pod.status;
                if ("OK" === status) {
                    answer.valid += 1;
                }
                else if ("WAIT" === status) {
                    answer.waiting += 1;
                }
                else {
                    answer.error += 1;
                }
                var creationTimestamp = pod.creationTimestamp;
                if (creationTimestamp) {
                    var d = new Date(creationTimestamp);
                    if (!lowestDate || d < lowestDate) {
                        lowestDate = d;
                    }
                }
            });
            appView.$creationDate = lowestDate;
            return array;
        }
        function createAppViewServiceViews(appView) {
            var array = [];
            var pods = appView.pods;
            angular.forEach(pods, function (pod) {
                var id = pod.id;
                if (id) {
                    var abbrev = id;
                    var idx = id.indexOf("-");
                    if (idx > 1) {
                        abbrev = id.substring(0, idx);
                    }
                    pod.idAbbrev = abbrev;
                }
                pod.statusClass = Kubernetes.statusTextToCssClass(pod.status);
            });
            var services = appView.services || [];
            var replicationControllers = appView.replicationControllers || [];
            var size = Math.max(services.length, replicationControllers.length, 1);
            var appName = appView.$info.name;
            for (var i = 0; i < size; i++) {
                var service = services[i];
                var replicationController = replicationControllers[i];
                var controllerId = (replicationController || {}).id;
                var name = (service || {}).id || controllerId;
                var address = (service || {}).portalIP;
                if (!name && pods.length) {
                    name = pods[0].idAbbrev;
                }
                if (!appView.$info.name) {
                    appView.$info.name = name;
                }
                if (!appView.id && pods.length) {
                    appView.id = pods[0].id;
                }
                if (i > 0) {
                    appName = name;
                }
                var podCount = pods.length;
                var podCountText = podCount + " pod" + (podCount > 1 ? "s" : "");
                var view = {
                    appName: appName || name,
                    name: name,
                    createdDate: appView.$creationDate,
                    podCountText: podCountText,
                    address: address,
                    controllerId: controllerId,
                    service: service,
                    replicationController: replicationController,
                    pods: pods
                };
                array.push(view);
            }
            return array;
        }
        function onAppData(response) {
            if (response) {
                var apps = response.value;
                var responseJson = angular.toJson(apps);
                if ($scope.responseAppJson === responseJson) {
                    return;
                }
                $scope.responseAppJson = responseJson;
                $scope.appInfos = apps;
                updateData();
            }
        }
        function onAppViewData(response) {
            if (response) {
                var responseJson = response.value;
                if ($scope.responseJson === responseJson) {
                    return;
                }
                var apps = [];
                if (responseJson) {
                    apps = JSON.parse(responseJson);
                }
                $scope.responseJson = responseJson;
                $scope.appViews = apps;
                updateData();
            }
        }
    }]);
})(Kubernetes || (Kubernetes = {}));
var Kubernetes;
(function (Kubernetes) {
    Kubernetes.KubernetesJsonDirective = Kubernetes._module.directive("kubernetesJson", [function () {
        return {
            restrict: 'A',
            replace: true,
            templateUrl: Kubernetes.templatePath + 'kubernetesJsonDirective.html',
            scope: {
                config: '=kubernetesJson'
            },
            controller: ["$scope", "$location", "$http", "jolokia", "marked", function ($scope, $location, $http, jolokia, marked) {
                $scope.$watch('config', function (config) {
                    if (config) {
                        if (config.error) {
                            Kubernetes.log.debug("Error parsing kubernetes config: ", config.error);
                        }
                        else {
                            Kubernetes.log.debug("Got kubernetes configuration: ", config);
                        }
                    }
                    else {
                        Kubernetes.log.debug("Kubernetes config unset");
                    }
                });
                $scope.$on('Wiki.ViewPage.Children', function ($event, pageId, children) {
                    $scope.appTitle = pageId;
                    if (children) {
                        var summaryFile = children.find(function (child) {
                            return child.name.toLowerCase() === "summary.md";
                        });
                        var summaryURL = null;
                        if (summaryFile) {
                            summaryURL = Wiki.gitRestURL(summaryFile.branch, summaryFile.path);
                            $http.get(summaryURL).success(function (data, status, headers, config) {
                                var summaryMarkdown = data;
                                if (summaryMarkdown) {
                                    $scope.summaryHtml = marked(summaryMarkdown);
                                }
                                else {
                                    $scope.summaryHtml = null;
                                }
                            }).error(function (data, status, headers, config) {
                                $scope.summaryHtml = null;
                                Kubernetes.log.warn("Failed to load " + summaryURL + " " + data + " " + status);
                            });
                        }
                        var iconFile = children.find(function (child) {
                            return child.name.toLowerCase().startsWith("icon");
                        });
                        if (iconFile) {
                            $scope.iconURL = Wiki.gitRestURL(iconFile.branch, iconFile.path);
                        }
                        var fabric8PropertiesFile = children.find(function (child) {
                            return child.name.toLowerCase() === "fabric8.properties";
                        });
                        var fabric8PropertiesURL = null;
                        if (fabric8PropertiesFile) {
                            fabric8PropertiesURL = Wiki.gitRestURL(fabric8PropertiesFile.branch, fabric8PropertiesFile.path);
                            $http.get(fabric8PropertiesURL).success(function (data, status, headers, config) {
                                var fabric8Properties = data;
                                if (fabric8Properties) {
                                    var nameRE = /(?:name)\s*=\s*(.+)[\n|$]/;
                                    var matches = fabric8Properties.match(nameRE);
                                    if (matches[1]) {
                                        $scope.displayName = matches[1].replace(/\\/g, '');
                                    }
                                }
                            }).error(function (data, status, headers, config) {
                                Kubernetes.log.warn("Failed to load " + fabric8PropertiesURL + " " + data + " " + status);
                            });
                        }
                    }
                });
                $scope.apply = function () {
                    var json = angular.toJson($scope.config);
                    var name = $scope.appTitle || "App";
                    Kubernetes.runApp($location, jolokia, $scope, json, name, function () {
                        $location.url("/kubernetes/apps");
                    });
                };
            }]
        };
    }]);
})(Kubernetes || (Kubernetes = {}));
var Kubernetes;
(function (Kubernetes) {
    Kubernetes.FileDropController = Kubernetes.controller("FileDropController", ["$scope", "jolokiaUrl", "jolokia", "FileUploader", function ($scope, jolokiaUrl, jolokia, FileUploader) {
        $scope.uploader = new FileUploader({
            autoUpload: true,
            removeAfterUpload: true,
            url: jolokiaUrl
        });
        FileUpload.useJolokiaTransport($scope.uploader, jolokia, function (json) {
            Kubernetes.log.debug("Json: ", json);
            return {
                'type': 'exec',
                mbean: Kubernetes.managerMBean,
                operation: 'apply',
                arguments: [json]
            };
        });
        $scope.uploader.onBeforeUploadItem = function (item) {
            Core.notification('info', 'Uploading ' + item);
        };
        $scope.uploader.onSuccessItem = function (item) {
            Kubernetes.log.debug("onSuccessItem: ", item);
        };
        $scope.uploader.onErrorItem = function (item, response, status) {
            Kubernetes.log.debug("Failed to apply, response: ", response, " status: ", status);
        };
    }]);
    Kubernetes.TopLevel = Kubernetes.controller("TopLevel", ["$scope", "workspace", "KubernetesVersion", "KubernetesState", function ($scope, workspace, KubernetesVersion, KubernetesState) {
        $scope.version = undefined;
        $scope.showAppView = Kubernetes.isAppView(workspace);
        $scope.isActive = function (href) {
            return workspace.isLinkActive(href);
        };
        $scope.kubernetes = KubernetesState;
        KubernetesVersion.then(function (KubernetesVersion) {
            KubernetesVersion.query(function (response) {
                $scope.version = response;
            });
        });
    }]);
})(Kubernetes || (Kubernetes = {}));
var Kubernetes;
(function (Kubernetes) {
    var OverviewDirective = Kubernetes._module.directive("kubernetesOverview", ["$templateCache", "$compile", "$interpolate", "$timeout", "$window", "KubernetesState", function ($templateCache, $compile, $interpolate, $timeout, $window, KubernetesState) {
        return {
            restrict: 'E',
            replace: true,
            link: function (scope, element, attr) {
                element.css({ visibility: 'hidden' });
                scope.getEntity = function (type, key) {
                    switch (type) {
                        case 'host':
                            return scope.hostsByKey[key];
                        case 'pod':
                            return scope.podsByKey[key];
                        case 'replicationController':
                            return scope.replicationControllersByKey[key];
                        case 'service':
                            return scope.servicesByKey[key];
                        default:
                            return undefined;
                    }
                };
                scope.kubernetes = KubernetesState;
                scope.customizeDefaultOptions = function (options) {
                    options.Endpoint = ['Blank', {}];
                };
                scope.mouseEnter = function ($event) {
                    if (scope.jsPlumb) {
                        angular.element($event.currentTarget).addClass("hovered");
                        scope.jsPlumb.getEndpoints($event.currentTarget).forEach(function (endpoint) {
                            endpoint.connections.forEach(function (connection) {
                                if (!connection.isHover()) {
                                    connection.setHover(true);
                                    connection.endpoints.forEach(function (e) {
                                        scope.mouseEnter({
                                            currentTarget: e.element
                                        });
                                    });
                                }
                            });
                        });
                    }
                };
                scope.mouseLeave = function ($event) {
                    if (scope.jsPlumb) {
                        angular.element($event.currentTarget).removeClass("hovered");
                        scope.jsPlumb.getEndpoints($event.currentTarget).forEach(function (endpoint) {
                            endpoint.connections.forEach(function (connection) {
                                if (connection.isHover()) {
                                    connection.setHover(false);
                                    connection.endpoints.forEach(function (e) {
                                        scope.mouseLeave({
                                            currentTarget: e.element
                                        });
                                    });
                                }
                            });
                        });
                    }
                };
                scope.customizeConnectionOptions = function (jsPlumb, edge, params, options) {
                    var type = edge.source.el.attr('data-type');
                    options.connector = ["Bezier", { curviness: 50, stub: 25, alwaysRespectStubs: true }];
                    switch (type) {
                        case 'pod':
                            break;
                        case 'service':
                            params.target = edge.target.el;
                            params.source = edge.source.el;
                            params.paintStyle = {
                                lineWidth: 2,
                                strokeStyle: '#5555cc'
                            };
                            params.anchors = [
                                ["ContinuousRight", {}],
                                ["ContinuousLeft", {}]
                            ];
                            break;
                        case 'replicationController':
                            params.paintStyle = {
                                lineWidth: 2,
                                dashstyle: '2 2',
                                strokeStyle: '#44aa44'
                            };
                            params.anchors = [
                                ["Perimeter", { shape: "Circle" }],
                                ["ContinuousRight", {}]
                            ];
                            break;
                    }
                    return options;
                };
                function interpolate(template, config) {
                    return $interpolate(template)(config);
                }
                function createElement(template, thingName, thing) {
                    var config = {};
                    config[thingName] = thing;
                    return interpolate(template, config);
                }
                function createElements(template, thingName, things) {
                    return things.map(function (thing) {
                        return createElement(template, thingName, thing);
                    });
                }
                function appendNewElements(parentEl, template, thingName, things) {
                    things.forEach(function (thing) {
                        var existing = parentEl.find("#" + thing['_key']);
                        if (!existing.length) {
                            parentEl.append($compile(createElement(template, thingName, thing))(scope));
                        }
                    });
                }
                function namespaceFilter(item) {
                    return item.namespace === scope.kubernetes.selectedNamespace;
                }
                function firstDraw() {
                    Kubernetes.log.debug("First draw");
                    var services = scope.services;
                    var replicationControllers = scope.replicationControllers;
                    var pods = scope.pods;
                    var hosts = scope.hosts;
                    var parentEl = angular.element($templateCache.get("overviewTemplate.html"));
                    var servicesEl = parentEl.find(".services");
                    var hostsEl = parentEl.find(".hosts");
                    var replicationControllersEl = parentEl.find(".replicationControllers");
                    servicesEl.append(createElements($templateCache.get("serviceTemplate.html"), 'service', services.filter(namespaceFilter)));
                    replicationControllersEl.append(createElements($templateCache.get("replicationControllerTemplate.html"), 'replicationController', replicationControllers.filter(namespaceFilter)));
                    hosts.forEach(function (host) {
                        var hostEl = angular.element(createElement($templateCache.get("hostTemplate.html"), 'host', host));
                        var podContainer = angular.element(hostEl.find('.pod-container'));
                        podContainer.append(createElements($templateCache.get("podTemplate.html"), "pod", host.pods.filter(namespaceFilter)));
                        hostsEl.append(hostEl);
                    });
                    element.append($compile(parentEl)(scope));
                    $timeout(function () {
                        element.css({ visibility: 'visible' });
                    }, 250);
                }
                function update() {
                    scope.$emit('jsplumbDoWhileSuspended', function () {
                        Kubernetes.log.debug("Update");
                        var services = scope.services.filter(namespaceFilter);
                        var replicationControllers = scope.replicationControllers.filter(namespaceFilter);
                        var pods = scope.pods.filter(namespaceFilter);
                        var hosts = scope.hosts;
                        var parentEl = element.find('[hawtio-jsplumb]');
                        var children = parentEl.find('.jsplumb-node');
                        children.each(function (index, c) {
                            var child = angular.element(c);
                            var key = child.attr('id');
                            if (Core.isBlank(key)) {
                                return;
                            }
                            var type = child.attr('data-type');
                            switch (type) {
                                case 'host':
                                    if (key in scope.hostsByKey) {
                                        return;
                                    }
                                    break;
                                case 'service':
                                    if (key in scope.servicesByKey && scope.servicesByKey[key].namespace == scope.kubernetes.selectedNamespace) {
                                        var service = scope.servicesByKey[key];
                                        child.attr('connect-to', service.connectTo);
                                        return;
                                    }
                                    break;
                                case 'pod':
                                    if (key in scope.podsByKey && scope.podsByKey[key].namespace == scope.kubernetes.selectedNamespace) {
                                        return;
                                    }
                                    break;
                                case 'replicationController':
                                    if (key in scope.replicationControllersByKey && scope.replicationControllersByKey[key].namespace == scope.kubernetes.selectedNamespace) {
                                        var replicationController = scope.replicationControllersByKey[key];
                                        child.attr('connect-to', replicationController.connectTo);
                                        return;
                                    }
                                    break;
                                default:
                                    Kubernetes.log.debug("Ignoring element with unknown type");
                                    return;
                            }
                            Kubernetes.log.debug("Removing: ", key);
                            child.remove();
                        });
                        var servicesEl = parentEl.find(".services");
                        var hostsEl = parentEl.find(".hosts");
                        var replicationControllersEl = parentEl.find(".replicationControllers");
                        appendNewElements(servicesEl, $templateCache.get("serviceTemplate.html"), "service", services.filter(namespaceFilter));
                        appendNewElements(replicationControllersEl, $templateCache.get("replicationControllerTemplate.html"), "replicationController", replicationControllers.filter(namespaceFilter));
                        appendNewElements(hostsEl, $templateCache.get("hostTemplate.html"), "host", hosts);
                        hosts.forEach(function (host) {
                            var hostEl = parentEl.find("#" + host._key);
                            appendNewElements(hostEl, $templateCache.get("podTemplate.html"), "pod", host.pods.filter(namespaceFilter));
                        });
                    });
                }
                scope.$watch('count', function (count) {
                    if (count > 0) {
                        if (element.children().length === 0) {
                            firstDraw();
                        }
                        else {
                            update();
                        }
                    }
                });
            }
        };
    }]);
    var OverviewBoxController = Kubernetes.controller("OverviewBoxController", ["$scope", "$location", function ($scope, $location) {
        $scope.viewDetails = function (path) {
            $location.path(UrlHelpers.join('/kubernetes/namespace', $scope.entity.namespace, path)).search({ '_id': $scope.entity.id });
        };
    }]);
    var scopeName = "OverviewController";
    var OverviewController = Kubernetes.controller(scopeName, ["$scope", "$location", "KubernetesServices", "KubernetesPods", "KubernetesReplicationControllers", "KubernetesState", function ($scope, $location, KubernetesServices, KubernetesPods, KubernetesReplicationControllers, KubernetesState) {
        $scope.name = scopeName;
        $scope.kubernetes = KubernetesState;
        $scope.services = null;
        $scope.replicationControllers = null;
        $scope.pods = null;
        $scope.hosts = null;
        $scope.count = 0;
        var redraw = false;
        var services = [];
        var replicationControllers = [];
        var pods = [];
        var hosts = [];
        var byId = function (thing) {
            return thing.id;
        };
        function populateKey(item) {
            var result = item;
            result['_key'] = item.namespace + "-" + item.id;
            return result;
        }
        function populateKeys(items) {
            var result = [];
            angular.forEach(items, function (item) {
                result.push(populateKey(item));
            });
            return result;
        }
        ControllerHelpers.bindModelToSearchParam($scope, $location, 'kubernetes.selectedNamespace', 'namespace', undefined);
        KubernetesServices.then(function (KubernetesServices) {
            KubernetesReplicationControllers.then(function (KubernetesReplicationControllers) {
                KubernetesPods.then(function (KubernetesPods) {
                    $scope.fetch = PollHelpers.setupPolling($scope, function (next) {
                        var ready = 0;
                        var numServices = 3;
                        function maybeNext(count) {
                            ready = count;
                            if (ready >= numServices) {
                                maybeInit();
                                next();
                            }
                        }
                        KubernetesServices.query(function (response) {
                            if (response) {
                                var items = populateKeys((response.items || []).sortBy(byId));
                                redraw = ArrayHelpers.sync(services, items, "_key");
                            }
                            maybeNext(ready + 1);
                        });
                        KubernetesReplicationControllers.query(function (response) {
                            if (response) {
                                var items = populateKeys((response.items || []).sortBy(byId));
                                redraw = ArrayHelpers.sync(replicationControllers, items, "_key");
                            }
                            maybeNext(ready + 1);
                        });
                        KubernetesPods.query(function (response) {
                            if (response) {
                                var items = populateKeys((response.items || []).sortBy(byId));
                                redraw = ArrayHelpers.sync(pods, items, "_key");
                            }
                            maybeNext(ready + 1);
                        });
                    });
                    $scope.fetch();
                });
            });
        });
        function selectPods(pods, namespace, labels) {
            if (labels) {
                var matchFunc = _.matches(labels);
                return pods.filter(function (pod) {
                    return pod.namespace === namespace && matchFunc(pod.labels, undefined, undefined);
                });
            }
            else {
                return [];
            }
        }
        function maybeInit() {
            if (services && replicationControllers && pods) {
                $scope.servicesByKey = {};
                $scope.podsByKey = {};
                $scope.replicationControllersByKey = {};
                $scope.kubernetes.namespaces = {};
                services.forEach(function (service) {
                    $scope.servicesByKey[service._key] = service;
                    var selectedPods = selectPods(pods, service.namespace, service.selector);
                    service.connectTo = selectedPods.map(function (pod) {
                        return pod._key;
                    }).join(',');
                });
                replicationControllers.forEach(function (replicationController) {
                    $scope.replicationControllersByKey[replicationController._key] = replicationController;
                    var selectedPods = selectPods(pods, replicationController.namespace, replicationController.desiredState.replicaSelector);
                    replicationController.connectTo = selectedPods.map(function (pod) {
                        return pod._key;
                    }).join(',');
                });
                var hostsByKey = {};
                pods.forEach(function (pod) {
                    $scope.podsByKey[pod._key] = pod;
                    var host = pod.currentState.host;
                    hostsByKey[host] = hostsByKey[host] || [];
                    hostsByKey[host].push(pod);
                });
                var tmpHosts = [];
                var oldHostsLength = hosts.length;
                for (var hostKey in hostsByKey) {
                    tmpHosts.push({
                        id: hostKey,
                        pods: hostsByKey[hostKey]
                    });
                }
                redraw = ArrayHelpers.removeElements(hosts, tmpHosts);
                tmpHosts.forEach(function (newHost) {
                    var oldHost = hosts.find(function (h) {
                        return h.id === newHost.id;
                    });
                    if (!oldHost) {
                        redraw = true;
                        hosts.push(newHost);
                    }
                    else {
                        redraw = ArrayHelpers.sync(oldHost.pods, newHost.pods);
                    }
                });
                Kubernetes.updateNamespaces($scope.kubernetes, pods, replicationControllers, services);
                $scope.hosts = hosts;
                $scope.hostsByKey = hostsByKey;
                $scope.pods = pods;
                $scope.services = services;
                $scope.replicationControllers = replicationControllers;
                if (redraw) {
                    Kubernetes.log.debug("Redrawing");
                    $scope.count = $scope.count + 1;
                    redraw = false;
                }
            }
        }
    }]);
})(Kubernetes || (Kubernetes = {}));
var Service;
(function (Service) {
    Service.pluginName = 'Service';
    Service.log = Logger.get(Service.pluginName);
    Service.pollServices = false;
    function hasService(ServiceRegistry, serviceName) {
        if (!ServiceRegistry || !serviceName) {
            return false;
        }
        var answer = false;
        angular.forEach(ServiceRegistry.services, function (service) {
            if (serviceName === service.id) {
                answer = true;
            }
        });
        return answer;
    }
    Service.hasService = hasService;
    function findService(ServiceRegistry, serviceName) {
        var answer = null;
        if (ServiceRegistry && serviceName) {
            angular.forEach(ServiceRegistry.services, function (service) {
                if (serviceName === service.id) {
                    answer = service;
                }
            });
        }
        return answer;
    }
    Service.findService = findService;
    function serviceLink(ServiceRegistry, serviceName) {
        var service = findService(ServiceRegistry, serviceName);
        if (service) {
            var portalIP = service.portalIP;
            var port = service.port;
            var protocol = "http://";
            if (portalIP) {
                if (port) {
                    return protocol + portalIP + ":" + port + "/";
                }
                else {
                    return protocol + portalIP;
                }
            }
        }
        return "";
    }
    Service.serviceLink = serviceLink;
})(Service || (Service = {}));
var Kubernetes;
(function (Kubernetes) {
    Kubernetes.EnvItem = Kubernetes.controller("EnvItem", ["$scope", function ($scope) {
        var parts = $scope.data.split('=');
        $scope.key = parts.shift();
        $scope.value = parts.join('=');
    }]);
    Kubernetes.Pods = Kubernetes.controller("Pods", ["$scope", "KubernetesPods", "KubernetesState", "ServiceRegistry", "$dialog", "$window", "$templateCache", "$routeParams", "jolokia", "$location", "localStorage", function ($scope, KubernetesPods, KubernetesState, ServiceRegistry, $dialog, $window, $templateCache, $routeParams, jolokia, $location, localStorage) {
        $scope.namespace = $routeParams.namespace;
        $scope.pods = undefined;
        var pods = [];
        $scope.fetched = false;
        $scope.json = '';
        $scope.itemSchema = Forms.createFormConfiguration();
        $scope.kubernetes = KubernetesState;
        $scope.hasService = function (name) { return Service.hasService(ServiceRegistry, name); };
        $scope.tableConfig = {
            data: 'pods',
            showSelectionCheckbox: true,
            enableRowClickSelection: false,
            multiSelect: true,
            selectedItems: [],
            filterOptions: {
                filterText: $location.search()["q"] || ''
            },
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'ID',
                    defaultSort: true,
                    cellTemplate: $templateCache.get("idTemplate.html")
                },
                {
                    field: 'currentState.status',
                    displayName: 'Status',
                    cellTemplate: $templateCache.get("statusTemplate.html")
                },
                {
                    field: 'containerImages',
                    displayName: 'Images',
                    cellTemplate: $templateCache.get("imageTemplate.html")
                },
                {
                    field: 'currentState.host',
                    displayName: 'Host'
                },
                {
                    field: 'currentState.podIP',
                    displayName: 'Pod IP'
                },
                {
                    field: 'labels',
                    displayName: 'Labels',
                    cellTemplate: $templateCache.get("labelTemplate.html")
                },
                {
                    field: 'namespace',
                    displayName: 'Namespace'
                }
            ]
        };
        $scope.podDetail = {
            properties: {
                'manifest/containers/image$': {
                    template: $templateCache.get('imageTemplate.html')
                },
                'currentState/status': {
                    template: $templateCache.get('statusTemplate.html')
                },
                '\\/Env\\/': {
                    template: $templateCache.get('envItemTemplate.html')
                },
                '^\\/labels$': {
                    template: $templateCache.get('labelTemplate.html')
                },
                '\\/env\\/key$': {
                    hidden: true
                }
            }
        };
        ControllerHelpers.bindModelToSearchParam($scope, $location, 'id', '_id', undefined);
        $scope.openLogs = function () {
            var pods = $scope.tableConfig.selectedItems;
            if (!pods || !pods.length) {
                if ($scope.id) {
                    var item = $scope.item;
                    if (item) {
                        pods = [item];
                    }
                }
            }
            Kubernetes.openLogsForPods(ServiceRegistry, $window, pods);
        };
        $scope.$on('kubeSelectedId', function ($event, id) {
            Kubernetes.setJson($scope, id, $scope.pods);
        });
        $scope.$on('$routeUpdate', function ($event) {
            Kubernetes.setJson($scope, $location.search()['_id'], $scope.pods);
        });
        jolokia.getAttribute(Kubernetes.mbean, 'DockerIp', undefined, onSuccess(function (results) {
            Kubernetes.log.info("got Docker IP: " + results);
            if (results) {
                $scope.dockerIp = results;
            }
            Core.$apply($scope);
        }, {
            error: function (response) {
                Kubernetes.log.debug("error fetching API URL: ", response);
            }
        }));
        jolokia.getAttribute(Kubernetes.mbean, 'HostName', undefined, onSuccess(function (results) {
            Kubernetes.log.info("got hostname: " + results);
            if (results) {
                $scope.hostName = results;
            }
            Core.$apply($scope);
        }, {
            error: function (response) {
                Kubernetes.log.debug("error fetching API URL: ", response);
            }
        }));
        Kubernetes.initShared($scope, $location);
        $scope.connect = {
            dialog: new UI.Dialog(),
            saveCredentials: false,
            userName: null,
            password: null,
            jolokiaUrl: null,
            containerName: null,
            view: null,
            onOK: function () {
                var userName = $scope.connect.userName;
                var password = $scope.connect.password;
                var userDetails = Core.injector.get('userDetails');
                if (!userDetails.password) {
                    userDetails.password = password;
                }
                if ($scope.connect.saveCredentials) {
                    $scope.connect.saveCredentials = false;
                    if (userName) {
                        localStorage['kuberentes.userName'] = userName;
                    }
                    if (password) {
                        localStorage['kuberentes.password'] = password;
                    }
                }
                Kubernetes.log.info("Connecting to " + $scope.connect.jolokiaUrl + " for container: " + $scope.connect.containerName + " user: " + $scope.connect.userName);
                var options = Core.createConnectOptions({
                    jolokiaUrl: $scope.connect.jolokiaUrl,
                    userName: userName,
                    password: password,
                    useProxy: true,
                    view: $scope.connect.view,
                    name: $scope.connect.containerName
                });
                Core.connectToServer(localStorage, options);
                setTimeout(function () {
                    $scope.connect.dialog.close();
                    Core.$apply($scope);
                }, 100);
            },
            doConnect: function (entity) {
                var userDetails = Core.injector.get('userDetails');
                if (userDetails) {
                    $scope.connect.userName = userDetails.username;
                    $scope.connect.password = userDetails.password;
                }
                $scope.connect.jolokiaUrl = entity.$jolokiaUrl;
                $scope.connect.containerName = entity.id;
                var alwaysPrompt = localStorage['fabricAlwaysPrompt'];
                if ((alwaysPrompt && alwaysPrompt !== "false") || !$scope.connect.userName || !$scope.connect.password) {
                    $scope.connect.dialog.open();
                }
                else {
                    $scope.connect.onOK();
                }
            }
        };
        KubernetesPods.then(function (KubernetesPods) {
            $scope.deletePrompt = function (selected) {
                if (angular.isString(selected)) {
                    selected = [{
                        id: selected
                    }];
                }
                UI.multiItemConfirmActionDialog({
                    collection: selected,
                    index: 'id',
                    onClose: function (result) {
                        if (result) {
                            function deleteSelected(selected, next) {
                                if (!next) {
                                    if (!jolokia.isRunning()) {
                                        $scope.fetch();
                                    }
                                }
                                else {
                                    Kubernetes.log.debug("deleting: ", next.id);
                                    KubernetesPods.delete({
                                        id: next.id
                                    }, undefined, function () {
                                        Kubernetes.log.debug("deleted: ", next.id);
                                        deleteSelected(selected, selected.shift());
                                    }, function (error) {
                                        Kubernetes.log.debug("Error deleting: ", error);
                                        deleteSelected(selected, selected.shift());
                                    });
                                }
                            }
                            deleteSelected(selected, selected.shift());
                        }
                    },
                    title: 'Delete pods?',
                    action: 'The following pods will be deleted:',
                    okText: 'Delete',
                    okClass: 'btn-danger',
                    custom: "This operation is permanent once completed!",
                    customClass: "alert alert-warning"
                }).open();
            };
            $scope.fetch = PollHelpers.setupPolling($scope, function (next) {
                KubernetesPods.query(function (response) {
                    $scope.fetched = true;
                    var redraw = ArrayHelpers.sync(pods, (response['items'] || []).sortBy(function (pod) {
                        return pod.id;
                    }).filter(function (pod) {
                        return pod.id && (!$scope.namespace || $scope.namespace === pod.namespace);
                    }));
                    angular.forEach(pods, function (entity) {
                        entity.$labelsText = Kubernetes.labelsToString(entity.labels);
                        var info = Core.pathGet(entity, ["currentState", "info"]);
                        var hostPort = null;
                        var currentState = entity.currentState || {};
                        var desiredState = entity.desiredState || {};
                        var host = currentState["host"];
                        var podIP = currentState["podIP"];
                        var hasDocker = false;
                        var foundContainerPort = null;
                        if (currentState && !podIP) {
                            angular.forEach(info, function (containerInfo, containerName) {
                                if (!hostPort) {
                                    var jolokiaHostPort = Core.pathGet(containerInfo, ["detailInfo", "HostConfig", "PortBindings", "8778/tcp"]);
                                    if (jolokiaHostPort) {
                                        var hostPorts = jolokiaHostPort.map("HostPort");
                                        if (hostPorts && hostPorts.length > 0) {
                                            hostPort = hostPorts[0];
                                            hasDocker = true;
                                        }
                                    }
                                }
                            });
                        }
                        if (desiredState && !hostPort) {
                            var containers = Core.pathGet(desiredState, ["manifest", "containers"]);
                            angular.forEach(containers, function (container) {
                                if (!hostPort) {
                                    var ports = container.ports;
                                    angular.forEach(ports, function (port) {
                                        if (!hostPort) {
                                            var containerPort = port.containerPort;
                                            var portName = port.name;
                                            var containerHostPort = port.hostPort;
                                            if (containerPort === 8778 || "jolokia" === portName) {
                                                if (containerPort) {
                                                    if (podIP) {
                                                        foundContainerPort = containerPort;
                                                    }
                                                    if (containerHostPort) {
                                                        hostPort = containerHostPort;
                                                    }
                                                }
                                            }
                                        }
                                    });
                                }
                            });
                        }
                        if (podIP && foundContainerPort) {
                            host = podIP;
                            hostPort = foundContainerPort;
                            hasDocker = false;
                        }
                        if (hostPort) {
                            if (!host) {
                                host = "localhost";
                            }
                            if ($scope.dockerIp && hasDocker) {
                                if (host === "localhost" || host === "127.0.0.1" || host === $scope.hostName) {
                                    host = $scope.dockerIp;
                                }
                            }
                            if (Kubernetes.isRunning(currentState)) {
                                entity.$jolokiaUrl = "http://" + host + ":" + hostPort + "/jolokia/";
                                entity.$connect = $scope.connect;
                            }
                        }
                    });
                    Kubernetes.setJson($scope, $scope.id, pods);
                    $scope.pods = pods.filter(function (item) {
                        return item.namespace === $scope.kubernetes.selectedNamespace;
                    });
                    Kubernetes.updateNamespaces($scope.kubernetes, pods);
                    $scope.$broadcast("hawtio.datatable.pods");
                    next();
                });
            });
            $scope.fetch();
        });
    }]);
})(Kubernetes || (Kubernetes = {}));
var Kubernetes;
(function (Kubernetes) {
    Kubernetes.DesiredReplicas = Kubernetes.controller("DesiredReplicas", ["$scope", function ($scope) {
        var watch = null;
        var originalValue = null;
        $scope.$watch('row.entity', function (entity) {
            if (watch && angular.isFunction(watch)) {
                originalValue = null;
                watch();
            }
            watch = $scope.$watch('row.entity.desiredState.replicas', function (replicas) {
                if (originalValue === null && replicas !== undefined) {
                    originalValue = replicas;
                }
                if (replicas < 0) {
                    $scope.row.entity.desiredState.replicas = 0;
                }
                if (replicas !== originalValue) {
                    $scope.$emit('kubernetes.dirtyController', $scope.row.entity);
                }
                else {
                    $scope.$emit('kubernetes.cleanController', $scope.row.entity);
                }
                Core.$apply($scope);
            });
        });
        $scope.$on('kubernetes.resetReplicas', function ($event) {
            $scope.row.entity.desiredState.replicas = originalValue;
        });
    }]);
    Kubernetes.ReplicationControllers = Kubernetes.controller("ReplicationControllers", ["$scope", "KubernetesReplicationControllers", "KubernetesPods", "KubernetesState", "$templateCache", "$location", "$routeParams", "jolokia", function ($scope, KubernetesReplicationControllers, KubernetesPods, KubernetesState, $templateCache, $location, $routeParams, jolokia) {
        $scope.namespace = $routeParams.namespace;
        $scope.kubernetes = KubernetesState;
        $scope.replicationControllers = [];
        $scope.allReplicationControllers = [];
        var pods = [];
        $scope.fetched = false;
        $scope.json = '';
        ControllerHelpers.bindModelToSearchParam($scope, $location, 'id', '_id', undefined);
        $scope.detailConfig = {
            properties: {
                '^\\/labels$': {
                    template: $templateCache.get('labelTemplate.html')
                }
            }
        };
        $scope.tableConfig = {
            data: 'replicationControllers',
            showSelectionCheckbox: true,
            enableRowClickSelection: false,
            multiSelect: true,
            selectedItems: [],
            filterOptions: {
                filterText: $location.search()["q"] || ''
            },
            columnDefs: [
                { field: 'icon', displayName: '', cellTemplate: $templateCache.get("iconCellTemplate.html") },
                { field: 'id', displayName: 'ID', cellTemplate: $templateCache.get("idTemplate.html") },
                { field: 'currentState.replicas', displayName: 'Pods', cellTemplate: $templateCache.get("podCountsAndLinkTemplate.html") },
                { field: 'desiredState.replicas', displayName: 'Replicas', cellTemplate: $templateCache.get("desiredReplicas.html") },
                { field: 'labelsText', displayName: 'Labels', cellTemplate: $templateCache.get("labelTemplate.html") },
                { field: 'namespace', displayName: 'Namespace' }
            ]
        };
        Kubernetes.initShared($scope, $location);
        function updatePodCounts() {
            angular.forEach($scope.replicationControllers, function (replicationController) {
                var selector = (replicationController.desiredState || {}).replicaSelector;
                replicationController.$podCounters = selector ? Kubernetes.createPodCounters(selector, pods) : null;
            });
            Kubernetes.updateNamespaces($scope.kubernetes, pods, $scope.allReplicationControllers);
        }
        $scope.$on('kubernetes.dirtyController', function ($event, replicationController) {
            replicationController.$dirty = true;
        });
        $scope.$on('kubernetes.cleanController', function ($event, replicationController) {
            replicationController.$dirty = false;
        });
        $scope.anyDirty = function () {
            return $scope.replicationControllers.any(function (controller) {
                return controller.$dirty;
            });
        };
        $scope.undo = function () {
            $scope.$broadcast('kubernetes.resetReplicas');
        };
        $scope.$on('kubeSelectedId', function ($event, id) {
            Kubernetes.setJson($scope, id, $scope.replicationControllers);
        });
        $scope.$on('$routeUpdate', function ($event) {
            Kubernetes.setJson($scope, $location.search()['_id'], $scope.pods);
        });
        KubernetesReplicationControllers.then(function (KubernetesReplicationControllers) {
            KubernetesPods.then(function (KubernetesPods) {
                $scope.save = function () {
                    var dirtyControllers = $scope.replicationControllers.filter(function (controller) {
                        return controller.$dirty;
                    });
                    if (dirtyControllers.length) {
                        dirtyControllers.forEach(function (replicationController) {
                            var apiVersion = replicationController["apiVersion"];
                            if (!apiVersion) {
                                replicationController["apiVersion"] = Kubernetes.defaultApiVersion;
                            }
                            KubernetesReplicationControllers.save(undefined, replicationController, function () {
                                replicationController.$dirty = false;
                                Kubernetes.log.debug("Updated ", replicationController.id);
                            }, function (error) {
                                replicationController.$dirty = false;
                                Kubernetes.log.debug("Failed to update ", replicationController.id, " error: ", error);
                            });
                        });
                    }
                };
                $scope.deletePrompt = function (selected) {
                    if (angular.isString(selected)) {
                        selected = [{
                            id: selected
                        }];
                    }
                    UI.multiItemConfirmActionDialog({
                        collection: selected,
                        index: 'id',
                        onClose: function (result) {
                            if (result) {
                                function deleteSelected(selected, next) {
                                    if (!next) {
                                        if (!jolokia.isRunning()) {
                                            $scope.fetch();
                                        }
                                    }
                                    else {
                                        Kubernetes.log.debug("deleting: ", next.id);
                                        KubernetesReplicationControllers.delete({
                                            id: next.id
                                        }, undefined, function () {
                                            Kubernetes.log.debug("deleted: ", next.id);
                                            deleteSelected(selected, selected.shift());
                                        }, function (error) {
                                            Kubernetes.log.debug("Error deleting: ", error);
                                            deleteSelected(selected, selected.shift());
                                        });
                                    }
                                }
                                deleteSelected(selected, selected.shift());
                            }
                        },
                        title: 'Delete replication controllers?',
                        action: 'The following replication controllers will be deleted:',
                        okText: 'Delete',
                        okClass: 'btn-danger',
                        custom: "This operation is permanent once completed!",
                        customClass: "alert alert-warning"
                    }).open();
                };
                $scope.fetch = PollHelpers.setupPolling($scope, function (next) {
                    var ready = 0;
                    var numServices = 2;
                    function maybeNext(count) {
                        ready = count;
                        if (ready >= numServices) {
                            maybeInit();
                            next();
                        }
                    }
                    KubernetesReplicationControllers.query(function (response) {
                        $scope.fetched = true;
                        if ($scope.anyDirty()) {
                            Kubernetes.log.debug("Table has been changed, not updating local view");
                            next();
                            return;
                        }
                        $scope.allReplicationControllers = (response['items'] || []).sortBy(function (item) {
                            return item.id;
                        });
                        $scope.replicationControllers = $scope.allReplicationControllers.filter(function (item) {
                            return !$scope.kubernetes.selectedNamespace || $scope.kubernetes.selectedNamespace === item.namespace;
                        });
                        angular.forEach($scope.replicationControllers, function (entity) {
                            entity.$labelsText = Kubernetes.labelsToString(entity.labels);
                            var desiredState = entity.desiredState || {};
                            var replicaSelector = desiredState.replicaSelector;
                            if (replicaSelector) {
                                entity.podsLink = Core.url("/kubernetes/pods?q=" + encodeURIComponent(Kubernetes.labelsToString(replicaSelector, " ")));
                            }
                        });
                        Kubernetes.setJson($scope, $scope.id, $scope.replicationControllers);
                        updatePodCounts();
                        maybeNext(ready + 1);
                    });
                    KubernetesPods.query(function (response) {
                        ArrayHelpers.sync(pods, (response['items'] || []).filter(function (pod) {
                            return pod.id && (!$scope.namespace || $scope.namespace === pod.namespace);
                        }));
                        updatePodCounts();
                        maybeNext(ready + 1);
                    });
                });
                $scope.fetch();
            });
        });
        function maybeInit() {
        }
    }]);
})(Kubernetes || (Kubernetes = {}));
var Kubernetes;
(function (Kubernetes) {
    Kubernetes.Services = Kubernetes.controller("Services", ["$scope", "KubernetesServices", "KubernetesPods", "KubernetesState", "$templateCache", "$location", "$routeParams", "jolokia", function ($scope, KubernetesServices, KubernetesPods, KubernetesState, $templateCache, $location, $routeParams, jolokia) {
        $scope.namespace = $routeParams.namespace;
        $scope.services = [];
        $scope.allServices = [];
        $scope.kubernetes = KubernetesState;
        var pods = [];
        $scope.fetched = false;
        $scope.json = '';
        ControllerHelpers.bindModelToSearchParam($scope, $location, 'id', '_id', undefined);
        $scope.tableConfig = {
            data: 'services',
            showSelectionCheckbox: true,
            enableRowClickSelection: false,
            multiSelect: true,
            selectedItems: [],
            filterOptions: {
                filterText: $location.search()["q"] || ''
            },
            columnDefs: [
                { field: 'icon', displayName: '', cellTemplate: $templateCache.get("iconCellTemplate.html") },
                { field: 'id', displayName: 'ID', cellTemplate: $templateCache.get("idTemplate.html") },
                { field: '$podsLink', displayName: 'Pods', cellTemplate: $templateCache.get("podCountsAndLinkTemplate.html") },
                { field: 'selector', displayName: 'Selector', cellTemplate: $templateCache.get("selectorTemplate.html") },
                { field: 'portalIP', displayName: 'Address', cellTemplate: $templateCache.get("portalAddress.html") },
                { field: 'labelsText', displayName: 'Labels', cellTemplate: $templateCache.get("labelTemplate.html") },
                { field: 'namespace', displayName: 'Namespace' }
            ]
        };
        Kubernetes.initShared($scope, $location);
        $scope.$on('kubeSelectedId', function ($event, id) {
            Kubernetes.setJson($scope, id, $scope.services);
        });
        $scope.$on('$routeUpdate', function ($event) {
            Kubernetes.setJson($scope, $location.search()['_id'], $scope.pods);
        });
        function updatePodCounts() {
            angular.forEach($scope.services, function (service) {
                var selector = service.selector;
                service.$podCounters = selector ? Kubernetes.createPodCounters(selector, pods) : null;
            });
            Kubernetes.updateNamespaces($scope.kubernetes, pods, [], $scope.allServices);
        }
        KubernetesServices.then(function (KubernetesServices) {
            KubernetesPods.then(function (KubernetesPods) {
                $scope.deletePrompt = function (selected) {
                    if (angular.isString(selected)) {
                        selected = [{
                            id: selected
                        }];
                    }
                    UI.multiItemConfirmActionDialog({
                        collection: selected,
                        index: 'id',
                        onClose: function (result) {
                            if (result) {
                                function deleteSelected(selected, next) {
                                    if (!next) {
                                        if (!jolokia.isRunning()) {
                                            $scope.fetch();
                                        }
                                    }
                                    else {
                                        Kubernetes.log.debug("deleting: ", next.id);
                                        KubernetesServices.delete({
                                            id: next.id
                                        }, undefined, function () {
                                            Kubernetes.log.debug("deleted: ", next.id);
                                            deleteSelected(selected, selected.shift());
                                        }, function (error) {
                                            Kubernetes.log.debug("Error deleting: ", error);
                                            deleteSelected(selected, selected.shift());
                                        });
                                    }
                                }
                                deleteSelected(selected, selected.shift());
                            }
                        },
                        title: 'Delete services?',
                        action: 'The following services will be deleted:',
                        okText: 'Delete',
                        okClass: 'btn-danger',
                        custom: "This operation is permanent once completed!",
                        customClass: "alert alert-warning"
                    }).open();
                };
                $scope.fetch = PollHelpers.setupPolling($scope, function (next) {
                    var ready = 0;
                    var numServices = 2;
                    function maybeNext(count) {
                        ready = count;
                        if (ready >= numServices) {
                            maybeInit();
                            next();
                        }
                    }
                    KubernetesServices.query(function (response) {
                        $scope.fetched = true;
                        $scope.allServices = (response['items'] || []).sortBy(function (item) {
                            return item.id;
                        });
                        $scope.services = $scope.allServices.filter(function (item) {
                            return !$scope.kubernetes.selectedNamespace || $scope.kubernetes.selectedNamespace === item.namespace;
                        });
                        Kubernetes.setJson($scope, $scope.id, $scope.services);
                        angular.forEach($scope.services, function (entity) {
                            entity.$labelsText = Kubernetes.labelsToString(entity.labels);
                        });
                        updatePodCounts();
                        maybeNext(ready + 1);
                    });
                    KubernetesPods.query(function (response) {
                        ArrayHelpers.sync(pods, (response['items'] || []).filter(function (pod) {
                            return pod.id && (!$scope.namespace || $scope.namespace === pod.namespace);
                        }));
                        updatePodCounts();
                        maybeNext(ready + 1);
                    });
                });
                $scope.fetch();
            });
        });
        function maybeInit() {
        }
    }]);
})(Kubernetes || (Kubernetes = {}));
var Kubernetes;
(function (Kubernetes) {
    var ReplicationControllerIcon = Kubernetes.controller("ReplicationControllerIcon", ["$scope", "jolokia", function ($scope, jolokia) {
        $scope.iconUrl = 'img/icons/kubernetes.svg';
        jolokia.request({
            type: 'exec',
            mbean: Kubernetes.mbean,
            operation: "iconPath(java.lang.String,java.lang.String)",
            arguments: ['master', $scope.entity.id]
        }, onSuccess(function (response) {
            if (response.value) {
                $scope.iconUrl = Wiki.gitRelativeURL('master', response.value);
                Core.$apply($scope);
            }
        }));
    }]);
    Kubernetes.IDSelector = Kubernetes.controller("IDSelector", ["$scope", function ($scope) {
        $scope.select = function (id) {
            $scope.$emit('kubeSelectedId', id);
        };
    }]);
    Kubernetes.PodStatus = Kubernetes.controller("PodStatus", ["$scope", function ($scope) {
        $scope.statusMapping = function (text) {
            return Kubernetes.statusTextToCssClass(text);
        };
    }]);
    Kubernetes.Labels = Kubernetes.controller("Labels", ["$scope", "workspace", "jolokia", "$location", function ($scope, workspace, jolokia, $location) {
        $scope.labels = [];
        var labelKeyWeights = {
            "name": 1,
            "replicationController": 2,
            "group": 3
        };
        $scope.$watch('entity', function (newValue, oldValue) {
            if (newValue) {
                $scope.labels = [];
                angular.forEach($scope.entity.labels, function (value, key) {
                    if (key === 'fabric8') {
                        return;
                    }
                    $scope.labels.push({
                        key: key,
                        title: value
                    });
                });
                $scope.labels = $scope.labels.sort(function (a, b) {
                    function getWeight(key) {
                        return labelKeyWeights[key] || 1000;
                    }
                    var n1 = a["key"];
                    var n2 = b["key"];
                    var w1 = getWeight(n1);
                    var w2 = getWeight(n2);
                    var diff = w1 - w2;
                    if (diff < 0) {
                        return -1;
                    }
                    else if (diff > 0) {
                        return 1;
                    }
                    if (n1 && n2) {
                        if (n1 > n2) {
                            return 1;
                        }
                        else if (n1 < n2) {
                            return -1;
                        }
                        else {
                            return 0;
                        }
                    }
                    else {
                        if (n1 === n2) {
                            return 0;
                        }
                        else if (n1) {
                            return 1;
                        }
                        else {
                            return -1;
                        }
                    }
                });
            }
        });
        $scope.handleClick = function (entity, labelType, value) {
            var filterTextSection = labelType + "=" + value.title;
            $scope.$emit('labelFilterUpdate', filterTextSection);
        };
        var labelColors = {
            'version': 'background-blue',
            'name': 'background-light-green',
            'container': 'background-light-grey'
        };
        $scope.labelClass = function (labelType) {
            if (!(labelType in labelColors)) {
                return 'mouse-pointer';
            }
            else
                return labelColors[labelType] + ' mouse-pointer';
        };
    }]);
})(Kubernetes || (Kubernetes = {}));
var Log;
(function (Log) {
    var pluginName = 'log';
    var hasMBean = false;
    Log._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ngGrid', 'datatable', 'hawtioCore']);
    Log._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/logs', { templateUrl: 'app/log/html/logs.html', reloadOnSearch: false }).when('/openlogs', { redirectTo: function () {
            if (hasMBean) {
                return '/logs';
            }
            else {
                return '/home';
            }
        }, reloadOnSearch: false });
    }]);
    Log._module.run(["$location", "workspace", "viewRegistry", "layoutFull", "helpRegistry", "preferencesRegistry", function ($location, workspace, viewRegistry, layoutFull, helpRegistry, preferencesRegistry) {
        hasMBean = Log.treeContainsLogQueryMBean(workspace);
        viewRegistry['log'] = layoutFull;
        helpRegistry.addUserDoc('log', 'app/log/doc/help.md', function () {
            return Log.treeContainsLogQueryMBean(workspace);
        });
        preferencesRegistry.addTab("Server Logs", "app/log/html/preferences.html", function () {
            return Log.treeContainsLogQueryMBean(workspace);
        });
        workspace.topLevelTabs.push({
            id: "logs",
            content: "Logs",
            title: "View and search the logs of this container",
            isValid: function (workspace) { return Log.treeContainsLogQueryMBean(workspace); },
            href: function () { return "#/logs"; }
        });
        workspace.subLevelTabs.push({
            content: '<i class="icon-list-alt"></i> Log',
            title: "View the logs in this process",
            isValid: function (workspace) { return Log.isSelectionLogQueryMBean(workspace); },
            href: function () { return "#/logs"; }
        });
    }]);
    Log._module.filter('logDateFilter', ["$filter", function ($filter) {
        var standardDateFilter = $filter('date');
        return function (log) {
            if (!log) {
                return null;
            }
            if (log.timestampMs) {
                return standardDateFilter(log.timestampMs, 'yyyy-MM-dd HH:mm:ss.sss');
            }
            else {
                return standardDateFilter(log.timestamp, 'yyyy-MM-dd HH:mm:ss');
            }
        };
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Log || (Log = {}));
var Log;
(function (Log) {
    var log = Logger.get("Log");
    Log._module.controller("Log.LogController", ["$scope", "$routeParams", "$location", "localStorage", "workspace", "jolokia", "$window", "$document", "$templateCache", function ($scope, $routeParams, $location, localStorage, workspace, jolokia, $window, $document, $templateCache) {
        $scope.sortAsc = true;
        var value = localStorage["logSortAsc"];
        if (angular.isString(value)) {
            $scope.sortAsc = "true" === value;
        }
        $scope.autoScroll = true;
        value = localStorage["logAutoScroll"];
        if (angular.isString(value)) {
            $scope.autoScroll = "true" === value;
        }
        value = localStorage["logBatchSize"];
        $scope.logBatchSize = angular.isNumber(value) ? value : 20;
        $scope.logs = [];
        $scope.showRowDetails = false;
        $scope.showRaw = {
            expanded: false
        };
        var logQueryMBean = Log.findLogQueryMBean(workspace);
        $scope.init = function () {
            $scope.searchText = $routeParams['s'];
            if (!angular.isDefined($scope.searchText)) {
                $scope.searchText = '';
            }
            $scope.filter = {
                logLevelQuery: $routeParams['l'],
                logLevelExactMatch: Core.parseBooleanValue($routeParams['e']),
                messageOnly: Core.parseBooleanValue($routeParams['o'])
            };
            if (!angular.isDefined($scope.filter.logLevelQuery)) {
                $scope.filter.logLevelQuery = '';
            }
            if (!angular.isDefined($scope.filter.logLevelExactMatch)) {
                $scope.filter.logLevelExactMatch = false;
            }
            if (!angular.isDefined($scope.filter.messageOnly)) {
                $scope.filter.messageOnly = false;
            }
        };
        $scope.$on('$routeUpdate', $scope.init);
        $scope.$watch('searchText', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $location.search('s', newValue);
            }
        });
        $scope.$watch('filter.logLevelQuery', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $location.search('l', newValue);
            }
        });
        $scope.$watch('filter.logLevelExactMatch', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $location.search('e', newValue);
            }
        });
        $scope.$watch('filter.messageOnly', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $location.search('o', newValue);
            }
        });
        $scope.init();
        $scope.toTime = 0;
        $scope.logFilter = {
            afterTimestamp: $scope.toTime,
            count: $scope.logBatchSize
        };
        $scope.logFilterJson = JSON.stringify($scope.logFilter);
        $scope.queryJSON = { type: "EXEC", mbean: logQueryMBean, operation: "jsonQueryLogResults", arguments: [$scope.logFilterJson], ignoreErrors: true };
        $scope.logLevels = ["TRACE", "DEBUG", "INFO", "WARN", "ERROR"];
        $scope.logLevelMap = {};
        $scope.skipFields = ['seq'];
        angular.forEach($scope.logLevels, function (name, idx) {
            $scope.logLevelMap[name] = idx;
            $scope.logLevelMap[name.toLowerCase()] = idx;
        });
        $scope.selectedClass = function ($index) {
            if ($index === $scope.selectedRowIndex) {
                return 'selected';
            }
            return '';
        };
        $scope.$watch('selectedRowIndex', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue < 0 || newValue > $scope.logs.length) {
                    $scope.selectedRow = null;
                    $scope.showRowDetails = false;
                    return;
                }
                Log.log.debug("New index: ", newValue);
                $scope.selectedRow = $scope.logs[newValue];
                if (!$scope.showRowDetails) {
                    $scope.showRowDetails = true;
                }
            }
        });
        $scope.hasOSGiProps = function (row) {
            if (!row) {
                return false;
            }
            if (!('properties' in row)) {
                return false;
            }
            var props = row.properties;
            var answer = Object.extended(props).keys().any(function (key) {
                return key.startsWith('bundle');
            });
            return answer;
        };
        $scope.selectRow = function ($index) {
            if ($scope.selectedRowIndex == $index) {
                $scope.showRowDetails = true;
                return;
            }
            $scope.selectedRowIndex = $index;
        };
        $scope.getSelectedRowJson = function () {
            return angular.toJson($scope.selectedRow, true);
        };
        $scope.logClass = function (log) {
            if (!log) {
                return '';
            }
            return logLevelClass(log['level']);
        };
        $scope.logIcon = function (log) {
            if (!log) {
                return '';
            }
            var style = $scope.logClass(log);
            if (style === "error") {
                return "red icon-warning-sign";
            }
            if (style === "warning") {
                return "orange icon-exclamation-sign";
            }
            if (style === "info") {
                return "icon-info-sign";
            }
            return "icon-cog";
        };
        $scope.logSourceHref = Log.logSourceHref;
        $scope.hasLogSourceHref = function (row) {
            if (!row) {
                return false;
            }
            return Log.hasLogSourceHref(row);
        };
        $scope.hasLogSourceLineHref = function (row) {
            if (!row) {
                return false;
            }
            return Log.hasLogSourceLineHref(row);
        };
        $scope.dateFormat = 'yyyy-MM-dd HH:mm:ss';
        $scope.formatException = function (line) {
            return Log.formatStackLine(line);
        };
        $scope.getSupport = function () {
            if (!$scope.selectedRow) {
                return;
            }
            var uri = "https://access.redhat.com/knowledge/solutions";
            var text = $scope.selectedRow.message;
            var logger = $scope.selectedRow.logger;
            uri = uri + "?logger=" + logger + "&text=" + text;
            window.location.href = uri;
        };
        $scope.addToDashboardLink = function () {
            var href = "#/logs";
            var routeParams = angular.toJson($routeParams);
            var size = angular.toJson({
                size_x: 8,
                size_y: 3
            });
            var title = "Logs";
            if ($scope.filter.logLevelQuery !== "") {
                title = title + " LogLevel: " + $scope.filter.logLevelQuery;
            }
            if ($scope.filter.logLevelExactMatch) {
                title = title + " Exact Match";
            }
            if ($scope.searchText !== "") {
                title = title + " Filter: " + $scope.searchText;
            }
            if ($scope.filter.messageOnly) {
                title = title + " Message Only";
            }
            return "#/dashboard/add?tab=dashboard" + "&href=" + encodeURIComponent(href) + "&routeParams=" + encodeURIComponent(routeParams) + "&title=" + encodeURIComponent(title) + "&size=" + encodeURIComponent(size);
        };
        $scope.isInDashboardClass = function () {
            if (angular.isDefined($scope.inDashboard && $scope.inDashboard)) {
                return "log-table-dashboard";
            }
            return "";
        };
        $scope.sortIcon = function () {
            if ($scope.sortAsc) {
                return "icon-arrow-down";
            }
            else {
                return "icon-arrow-up";
            }
        };
        $scope.filterLogMessage = function (log) {
            var messageOnly = $scope.filter.messageOnly;
            if ($scope.filter.logLevelQuery !== "") {
                var logLevelExactMatch = $scope.filter.logLevelExactMatch;
                var logLevelQuery = $scope.filter.logLevelQuery;
                var logLevelQueryOrdinal = (logLevelExactMatch) ? 0 : $scope.logLevelMap[logLevelQuery];
                if (logLevelExactMatch) {
                    if (log.level !== logLevelQuery) {
                        return false;
                    }
                }
                else {
                    var idx = $scope.logLevelMap[log.level];
                    if (!(idx >= logLevelQueryOrdinal || idx < 0)) {
                        return false;
                    }
                }
            }
            if ($scope.searchText.startsWith("l=")) {
                return log.logger.has($scope.searchText.last($scope.searchText.length - 2));
            }
            if ($scope.searchText.startsWith("m=")) {
                return log.message.has($scope.searchText.last($scope.searchText.length - 2));
            }
            if (messageOnly) {
                return log.message.has($scope.searchText);
            }
            return log.logger.has($scope.searchText) || log.message.has($scope.searchText);
        };
        $scope.formatStackTrace = function (exception) {
            if (!exception) {
                return "";
            }
            var answer = '<ul class="unstyled">\n';
            exception.forEach(function (line) {
                answer = answer + '<li>' + $scope.formatException(line) + '</li>';
            });
            answer += '\n</ul>';
            return answer;
        };
        var updateValues = function (response) {
            var scrollToTopOrBottom = false;
            if (!$scope.inDashboard) {
                var window = $($window);
                if ($scope.logs.length === 0) {
                    scrollToTopOrBottom = true;
                }
                if ($scope.sortAsc) {
                    var pos = window.scrollTop() + window.height();
                    var threshold = Core.getDocHeight() - 100;
                }
                else {
                    var pos = window.scrollTop() + window.height();
                    var threshold = 100;
                }
                if (pos > threshold) {
                    scrollToTopOrBottom = true;
                }
            }
            var logs = response.events;
            var toTime = response.toTimestamp;
            if (toTime && angular.isNumber(toTime)) {
                if (toTime < 0) {
                    console.log("ignoring dodgy value of toTime: " + toTime);
                }
                else {
                    $scope.toTime = toTime;
                    $scope.logFilter.afterTimestamp = $scope.toTime;
                    $scope.logFilterJson = JSON.stringify($scope.logFilter);
                    $scope.queryJSON.arguments = [$scope.logFilterJson];
                }
            }
            if (logs) {
                var maxSize = Log.getLogCacheSize(localStorage);
                if ($scope.inDashboard) {
                    maxSize = 50;
                }
                var counter = 0;
                logs.forEach(function (log) {
                    if (log) {
                        if (!$scope.logs.any(function (key, item) { return item.message === log.message && item.seq === log.message && item.timestamp === log.timestamp; })) {
                            counter += 1;
                            if (log.seq != null) {
                                log['timestampMs'] = log.seq;
                            }
                            if ($scope.sortAsc) {
                                $scope.logs.push(log);
                            }
                            else {
                                $scope.logs.unshift(log);
                            }
                        }
                    }
                });
                if (maxSize > 0) {
                    var size = $scope.logs.length;
                    if (size > maxSize) {
                        var count = size - maxSize;
                        var pos = 0;
                        if (!$scope.sortAsc) {
                            pos = size - count;
                        }
                        $scope.logs.splice(pos, count);
                        if ($scope.showRowDetails) {
                            if ($scope.sortAsc) {
                                $scope.selectedRowIndex -= count;
                            }
                            else {
                                $scope.selectedRowIndex += count;
                            }
                        }
                    }
                }
                if (counter) {
                    if ($scope.autoScroll && scrollToTopOrBottom) {
                        setTimeout(function () {
                            var pos = 0;
                            if ($scope.sortAsc) {
                                pos = $document.height() - window.height();
                            }
                            log.debug("Scrolling to position: " + pos);
                            $document.scrollTop(pos);
                        }, 20);
                    }
                    Core.$apply($scope);
                }
            }
        };
        var asyncUpdateValues = function (response) {
            var value = response.value;
            if (value) {
                updateValues(value);
            }
            else {
                Core.notification("error", "Failed to get a response! " + JSON.stringify(response, null, 4));
            }
        };
        var callbackOptions = onSuccess(asyncUpdateValues, {
            error: function (response) {
                asyncUpdateValues(response);
            },
            silent: true
        });
        if (logQueryMBean) {
            var firstCallback = function (results) {
                updateValues(results);
                Core.register(jolokia, $scope, $scope.queryJSON, callbackOptions);
            };
            jolokia.execute(logQueryMBean, "getLogResults(int)", 1000, onSuccess(firstCallback));
        }
    }]);
})(Log || (Log = {}));
var Log;
(function (Log) {
    Log._module.controller("Log.PreferencesController", ["$scope", "localStorage", function ($scope, localStorage) {
        Core.initPreferenceScope($scope, localStorage, {
            'logCacheSize': {
                'value': 1000,
                'converter': parseInt
            },
            'logSortAsc': {
                'value': true,
                'converter': Core.parseBooleanValue
            },
            'logAutoScroll': {
                'value': true,
                'converter': Core.parseBooleanValue
            },
            'logBatchSize': {
                'value': 20,
                'converter': parseInt
            }
        });
    }]);
})(Log || (Log = {}));
var Maven;
(function (Maven) {
    var pluginName = 'maven';
    Maven._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'datatable', 'tree', 'hawtioCore', 'hawtio-ui']);
    Maven._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/maven/search', { templateUrl: 'app/maven/html/search.html' }).when('/maven/advancedSearch', { templateUrl: 'app/maven/html/advancedSearch.html' }).when('/maven/artifact/:group/:artifact/:version/:classifier/:packaging', { templateUrl: 'app/maven/html/artifact.html' }).when('/maven/artifact/:group/:artifact/:version/:classifier', { templateUrl: 'app/maven/html/artifact.html' }).when('/maven/artifact/:group/:artifact/:version', { templateUrl: 'app/maven/html/artifact.html' }).when('/maven/dependencies/:group/:artifact/:version/:classifier/:packaging', { templateUrl: 'app/maven/html/dependencies.html' }).when('/maven/dependencies/:group/:artifact/:version/:classifier', { templateUrl: 'app/maven/html/dependencies.html' }).when('/maven/dependencies/:group/:artifact/:version', { templateUrl: 'app/maven/html/dependencies.html' }).when('/maven/versions/:group/:artifact/:classifier/:packaging', { templateUrl: 'app/maven/html/versions.html' }).when('/maven/view/:group/:artifact/:version/:classifier/:packaging', { templateUrl: 'app/maven/html/view.html' }).when('/maven/test', { templateUrl: 'app/maven/html/test.html' });
    }]);
    Maven._module.run(["$location", "workspace", "viewRegistry", "helpRegistry", function ($location, workspace, viewRegistry, helpRegistry) {
        viewRegistry['maven'] = "app/maven/html/layoutMaven.html";
        workspace.topLevelTabs.push({
            id: "maven",
            content: "Maven",
            title: "Search maven repositories for artifacts",
            isValid: function (workspace) { return Maven.getMavenIndexerMBean(workspace); },
            href: function () { return "#/maven/search"; },
            isActive: function (workspace) { return workspace.isLinkActive("/maven"); }
        });
        helpRegistry.addUserDoc('maven', 'app/maven/doc/help.md', function () {
            return Maven.getMavenIndexerMBean(workspace) !== null;
        });
        helpRegistry.addDevDoc("maven", 'app/maven/doc/developer.md');
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Maven || (Maven = {}));
var Maven;
(function (Maven) {
    Maven._module.controller("Maven.ArtifactController", ["$scope", "$routeParams", "workspace", "jolokia", function ($scope, $routeParams, workspace, jolokia) {
        $scope.row = {
            groupId: $routeParams["group"] || "",
            artifactId: $routeParams["artifact"] || "",
            version: $routeParams["version"] || "",
            classifier: $routeParams["classifier"] || "",
            packaging: $routeParams["packaging"] || ""
        };
        var row = $scope.row;
        $scope.id = Maven.getName(row);
        Maven.addMavenFunctions($scope, workspace);
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateTableContents, 50);
        });
        $scope.$watch('workspace.selection', function () {
            updateTableContents();
        });
        function updateTableContents() {
            var mbean = Maven.getMavenIndexerMBean(workspace);
            if (mbean) {
                jolokia.execute(mbean, "search", row.groupId, row.artifactId, row.version, row.packaging, row.classifier, "", onSuccess(render));
            }
            else {
                console.log("No MavenIndexerMBean!");
            }
        }
        function render(response) {
            if (response && response.length) {
                var first = response[0];
                row.name = first.name;
                row.description = first.description;
            }
            Core.$apply($scope);
        }
    }]);
})(Maven || (Maven = {}));
var Maven;
(function (Maven) {
    Maven._module.controller("Maven.DependenciesController", ["$scope", "$routeParams", "$location", "workspace", "jolokia", function ($scope, $routeParams, $location, workspace, jolokia) {
        $scope.artifacts = [];
        $scope.group = $routeParams["group"] || "";
        $scope.artifact = $routeParams["artifact"] || "";
        $scope.version = $routeParams["version"] || "";
        $scope.classifier = $routeParams["classifier"] || "";
        $scope.packaging = $routeParams["packaging"] || "";
        $scope.dependencyTree = null;
        Maven.addMavenFunctions($scope, workspace);
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateTableContents, 50);
        });
        $scope.$watch('workspace.selection', function () {
            updateTableContents();
        });
        $scope.onSelectNode = function (node) {
            $scope.selected = node;
        };
        $scope.onRootNode = function (rootNode) {
        };
        $scope.validSelection = function () {
            return $scope.selected && $scope.selected !== $scope.rootDependency;
        };
        $scope.viewDetails = function () {
            var dependency = Core.pathGet($scope.selected, ["dependency"]);
            var link = $scope.detailLink(dependency);
            if (link) {
                var path = Core.trimLeading(link, "#");
                console.log("going to view " + path);
                $location.path(path);
            }
        };
        function updateTableContents() {
            var mbean = Maven.getAetherMBean(workspace);
            if (mbean) {
                jolokia.execute(mbean, "resolveJson(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)", $scope.group, $scope.artifact, $scope.version, $scope.packaging, $scope.classifier, onSuccess(render));
            }
            else {
                console.log("No AetherMBean!");
            }
        }
        function render(response) {
            if (response) {
                var json = JSON.parse(response);
                if (json) {
                    $scope.dependencyTree = new Folder("Dependencies");
                    $scope.dependencyActivations = [];
                    addChildren($scope.dependencyTree, json);
                    $scope.dependencyActivations.reverse();
                    $scope.rootDependency = $scope.dependencyTree.children[0];
                }
            }
            Core.$apply($scope);
        }
        function addChildren(folder, dependency) {
            var name = Maven.getName(dependency);
            var node = new Folder(name);
            node.key = name.replace(/\//g, '_');
            node["dependency"] = dependency;
            $scope.dependencyActivations.push(node.key);
            folder.children.push(node);
            var children = dependency["children"];
            angular.forEach(children, function (child) {
                addChildren(node, child);
            });
        }
    }]);
})(Maven || (Maven = {}));
var Maven;
(function (Maven) {
    Maven._module.controller("Maven.PomXmlController", ["$scope", function ($scope) {
        $scope.mavenPomXml = "\n" + "  <dependency>\n" + "    <groupId>" + orBlank($scope.row.groupId) + "</groupId>\n" + "    <artifactId>" + orBlank($scope.row.artifactId) + "</artifactId>\n" + "    <version>" + orBlank($scope.row.version) + "</version>\n" + "  </dependency>\n";
        function orBlank(text) {
            return text || "";
        }
    }]);
})(Maven || (Maven = {}));
var Maven;
(function (Maven) {
    Maven._module.controller("Maven.SearchController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var log = Logger.get("Maven");
        $scope.artifacts = [];
        $scope.selected = [];
        $scope.done = false;
        $scope.inProgress = false;
        $scope.form = {
            searchText: ""
        };
        $scope.search = "";
        $scope.searchForm = 'app/maven/html/searchForm.html';
        Maven.addMavenFunctions($scope, workspace);
        var columnDefs = [
            {
                field: 'groupId',
                displayName: 'Group'
            },
            {
                field: 'artifactId',
                displayName: 'Artifact',
                cellTemplate: '<div class="ngCellText" title="Name: {{row.entity.name}}">{{row.entity.artifactId}}</div>'
            },
            {
                field: 'version',
                displayName: 'Version',
                cellTemplate: '<div class="ngCellText" title="Name: {{row.entity.name}}"><a ng-href="{{detailLink(row.entity)}}">{{row.entity.version}}</a</div>'
            }
        ];
        $scope.gridOptions = {
            data: 'artifacts',
            displayFooter: true,
            selectedItems: $scope.selected,
            selectWithCheckboxOnly: true,
            columnDefs: columnDefs,
            rowDetailTemplateId: "artifactDetailTemplate",
            filterOptions: {
                filterText: 'search'
            }
        };
        $scope.hasAdvancedSearch = function (form) {
            return form.searchGroup || form.searchArtifact || form.searchVersion || form.searchPackaging || form.searchClassifier || form.searchClassName;
        };
        $scope.doSearch = function () {
            $scope.done = false;
            $scope.inProgress = true;
            $scope.artifacts = [];
            setTimeout(function () {
                Core.$apply($scope);
            }, 50);
            var mbean = Maven.getMavenIndexerMBean(workspace);
            var form = $scope.form;
            if (mbean) {
                var searchText = form.searchText;
                var kind = form.artifactType;
                if (kind) {
                    if (kind === "className") {
                        log.debug("Search for: " + form.searchText + " className");
                        jolokia.execute(mbean, "searchClasses", searchText, onSuccess(render));
                    }
                    else {
                        var paths = kind.split('/');
                        var packaging = paths[0];
                        var classifier = paths[1];
                        log.debug("Search for: " + form.searchText + " packaging " + packaging + " classifier " + classifier);
                        jolokia.execute(mbean, "searchTextAndPackaging", searchText, packaging, classifier, onSuccess(render));
                    }
                }
                else if (searchText) {
                    log.debug("Search text is: " + form.searchText);
                    jolokia.execute(mbean, "searchText", form.searchText, onSuccess(render));
                }
                else if ($scope.hasAdvancedSearch(form)) {
                    log.debug("Searching for " + form.searchGroup + "/" + form.searchArtifact + "/" + form.searchVersion + "/" + form.searchPackaging + "/" + form.searchClassifier + "/" + form.searchClassName);
                    jolokia.execute(mbean, "search", form.searchGroup || "", form.searchArtifact || "", form.searchVersion || "", form.searchPackaging || "", form.searchClassifier || "", form.searchClassName || "", onSuccess(render));
                }
            }
            else {
                Core.notification("error", "Cannot find the Maven Indexer MBean!");
            }
        };
        var RESPONSE_LIMIT = 1000;
        var SERVER_RESPONSE_LIMIT = (10 * RESPONSE_LIMIT) + 1;
        function render(response) {
            log.debug("Search done, preparing result.");
            $scope.done = true;
            $scope.inProgress = false;
            if (response.length > RESPONSE_LIMIT) {
                var serverLimit = response.length === SERVER_RESPONSE_LIMIT;
                if (serverLimit) {
                    $scope.tooManyResponses = "This search returned more than " + (SERVER_RESPONSE_LIMIT - 1) + " artifacts, showing the first " + RESPONSE_LIMIT + ", please refine your search";
                }
                else {
                    $scope.tooManyResponses = "This search returned " + response.length + " artifacts, showing the first " + RESPONSE_LIMIT + ", please refine your search";
                }
            }
            else {
                $scope.tooManyResponses = "";
            }
            $scope.artifacts = response.first(RESPONSE_LIMIT);
            Core.$apply($scope);
        }
    }]);
})(Maven || (Maven = {}));
var Maven;
(function (Maven) {
    Maven._module.controller("Maven.TestController", ["$scope", "workspace", "jolokia", "$q", "$templateCache", function ($scope, workspace, jolokia, $q, $templateCache) {
        $scope.html = "text/html";
        $scope.someUri = '';
        $scope.uriParts = [];
        $scope.mavenCompletion = $templateCache.get("mavenCompletionTemplate");
        $scope.$watch('someUri', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.uriParts = newValue.split("/");
            }
        });
        $scope.$watch('uriParts', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue.length === 1 && newValue.length < oldValue.length) {
                    if (oldValue.last() !== '' && newValue.first().has(oldValue.last())) {
                        var merged = oldValue.first(oldValue.length - 1).include(newValue.first());
                        $scope.someUri = merged.join('/');
                    }
                }
            }
        }, true);
        $scope.doCompletionMaven = function (something) {
            return Maven.completeMavenUri($q, $scope, workspace, jolokia, something);
        };
    }]);
})(Maven || (Maven = {}));
var Maven;
(function (Maven) {
    Maven._module.controller("Maven.VersionsController", ["$scope", "$routeParams", "workspace", "jolokia", function ($scope, $routeParams, workspace, jolokia) {
        $scope.artifacts = [];
        $scope.group = $routeParams["group"] || "";
        $scope.artifact = $routeParams["artifact"] || "";
        $scope.version = "";
        $scope.classifier = $routeParams["classifier"] || "";
        $scope.packaging = $routeParams["packaging"] || "";
        var id = $scope.group + "/" + $scope.artifact;
        if ($scope.classifier) {
            id += "/" + $scope.classifier;
        }
        if ($scope.packaging) {
            id += "/" + $scope.packaging;
        }
        var columnTitle = id + " versions";
        var columnDefs = [
            {
                field: 'version',
                displayName: columnTitle,
                cellTemplate: '<div class="ngCellText"><a href="#/maven/artifact/{{row.entity.groupId}}/{{row.entity.artifactId}}/{{row.entity.version}}">{{row.entity.version}}</a></div>',
            }
        ];
        $scope.gridOptions = {
            data: 'artifacts',
            displayFooter: true,
            selectedItems: $scope.selected,
            selectWithCheckboxOnly: true,
            columnDefs: columnDefs,
            rowDetailTemplateId: "artifactDetailTemplate",
            sortInfo: { field: 'versionNumber', direction: 'DESC' },
            filterOptions: {
                filterText: 'search'
            }
        };
        Maven.addMavenFunctions($scope, workspace);
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateTableContents, 50);
        });
        $scope.$watch('workspace.selection', function () {
            updateTableContents();
        });
        function updateTableContents() {
            var mbean = Maven.getMavenIndexerMBean(workspace);
            if (mbean) {
                jolokia.execute(mbean, "versionComplete", $scope.group, $scope.artifact, $scope.version, $scope.packaging, $scope.classifier, onSuccess(render));
            }
            else {
                console.log("No MavenIndexerMBean!");
            }
        }
        function render(response) {
            $scope.artifacts = [];
            angular.forEach(response, function (version) {
                var versionNumberArray = Core.parseVersionNumbers(version);
                var versionNumber = 0;
                for (var i = 0; i <= 4; i++) {
                    var num = (i >= versionNumberArray.length) ? 0 : versionNumberArray[i];
                    versionNumber *= 1000;
                    versionNumber += num;
                }
                $scope.artifacts.push({
                    groupId: $scope.group,
                    artifactId: $scope.artifact,
                    packaging: $scope.packaging,
                    classifier: $scope.classifier,
                    version: version,
                    versionNumber: versionNumber
                });
            });
            Core.$apply($scope);
        }
    }]);
})(Maven || (Maven = {}));
var Maven;
(function (Maven) {
    Maven._module.controller("Maven.ViewController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        $scope.$watch('workspace.tree', function () {
            setTimeout(loadData, 50);
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(loadData, 50);
        });
        function loadData() {
        }
    }]);
})(Maven || (Maven = {}));
var OpenEJB;
(function (OpenEJB) {
    var pluginName = 'openejb';
    OpenEJB._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'hawtioCore']);
    OpenEJB._module.config(["$routeProvider", function ($routeProvider) {
    }]);
    OpenEJB._module.run(["$location", "workspace", "viewRegistry", "helpRegistry", function ($location, workspace, viewRegistry, helpRegistry) {
        viewRegistry['openojb'] = "app/openejb/html/layoutOpenEJBTree.html";
        helpRegistry.addUserDoc('openejb', 'app/openejb/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties("openejb");
        });
        workspace.topLevelTabs.push({
            id: "openejb",
            content: "OpenEJB",
            title: "Manage your OpenEJB resources",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties("openejb"); },
            href: function () { return "#/jmx/attributes?tab=openejb"; },
            isActive: function (workspace) { return workspace.isTopTabActive("openejb"); }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(OpenEJB || (OpenEJB = {}));
var OpenEJB;
(function (OpenEJB) {
    OpenEJB._module.controller("OpenEJB.TreeController", ["$scope", "$location", "workspace", function ($scope, $location, workspace) {
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateSelectionFromURL, 50);
        });
        $scope.$watch('workspace.tree', function () {
            if (workspace.moveIfViewInvalid())
                return;
            var children = [];
            var tree = workspace.tree;
            if (tree) {
                var nodes = tree.children;
                angular.forEach(nodes, function (node) {
                    var nodeChildren = node.children;
                    if (node.title.startsWith("openejb") && nodeChildren) {
                        children = children.concat(nodeChildren);
                    }
                });
            }
            var treeElement = $("#openejbTree");
            Jmx.enableTree($scope, $location, workspace, treeElement, children, true);
            setTimeout(updateSelectionFromURL, 50);
        });
        function updateSelectionFromURL() {
            Jmx.updateTreeSelectionFromURL($location, $("#openejbTree"), true);
        }
    }]);
})(OpenEJB || (OpenEJB = {}));
var Osgi;
(function (Osgi) {
    var pluginName = 'osgi';
    Osgi._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ngGrid', 'hawtioCore', 'hawtio-ui']);
    Osgi._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/osgi/bundle-list', { templateUrl: 'app/osgi/html/bundle-list.html' }).when('/osgi/bundles', { templateUrl: 'app/osgi/html/bundles.html' }).when('/osgi/bundle/:bundleId', { templateUrl: 'app/osgi/html/bundle.html' }).when('/osgi/services', { templateUrl: 'app/osgi/html/services.html' }).when('/osgi/packages', { templateUrl: 'app/osgi/html/packages.html' }).when('/osgi/package/:package/:version', { templateUrl: 'app/osgi/html/package.html' }).when('/osgi/configurations', { templateUrl: 'app/osgi/html/configurations.html' }).when('/osgi/pid/:pid/:factoryPid', { templateUrl: 'app/osgi/html/pid.html' }).when('/osgi/pid/:pid', { templateUrl: 'app/osgi/html/pid.html' }).when('/osgi/fwk', { templateUrl: 'app/osgi/html/framework.html' }).when('/osgi/dependencies', { templateUrl: 'app/osgi/html/svc-dependencies.html', reloadOnSearch: false });
    }]);
    Osgi._module.run(["workspace", "viewRegistry", "helpRegistry", function (workspace, viewRegistry, helpRegistry) {
        viewRegistry['osgi'] = "app/osgi/html/layoutOsgi.html";
        helpRegistry.addUserDoc('osgi', 'app/osgi/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties("osgi.core");
        });
        workspace.topLevelTabs.push({
            id: "osgi",
            content: "OSGi",
            title: "Visualise and manage the bundles and services in this OSGi container",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties("osgi.core"); },
            href: function () { return "#/osgi/bundle-list"; },
            isActive: function (workspace) { return workspace.isLinkActive("osgi"); }
        });
    }]);
    Osgi._module.factory('osgiDataService', ["workspace", "jolokia", function (workspace, jolokia) {
        return new Osgi.OsgiDataService(workspace, jolokia);
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.BundleListController", ["$scope", "workspace", "jolokia", "localStorage", function ($scope, workspace, jolokia, localStorage) {
        $scope.result = {};
        $scope.bundles = [];
        $scope.bundleUrl = "";
        $scope.display = {
            bundleField: "Name",
            sortField: "Identifier",
            bundleFilter: "",
            startLevelFilter: 0,
            showActiveMQBundles: false,
            showCamelBundles: false,
            showCxfBundles: false,
            showPlatformBundles: false
        };
        if ('bundleList' in localStorage) {
            $scope.display = angular.fromJson(localStorage['bundleList']);
        }
        $scope.$watch('display', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                localStorage['bundleList'] = angular.toJson(newValue);
            }
        }, true);
        $scope.installDisabled = function () {
            return $scope.bundleUrl === "";
        };
        $scope.install = function () {
            jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionFrameworkMBean(workspace),
                operation: "installBundle(java.lang.String)",
                arguments: [$scope.bundleUrl]
            }, {
                success: function (response) {
                    var bundleID = response.value;
                    jolokia.request({
                        type: 'exec',
                        mbean: Osgi.getSelectionBundleMBean(workspace),
                        operation: "isFragment(long)",
                        arguments: [bundleID]
                    }, {
                        success: function (response) {
                            var isFragment = response.value;
                            if (isFragment) {
                                Core.notification("success", "Fragment installed successfully.");
                                $scope.bundleUrl = "";
                                Core.$apply($scope);
                            }
                            else {
                                jolokia.request({
                                    type: 'exec',
                                    mbean: Osgi.getSelectionFrameworkMBean(workspace),
                                    operation: "startBundle(long)",
                                    arguments: [bundleID]
                                }, {
                                    success: function (response) {
                                        Core.notification("success", "Bundle installed and started successfully.");
                                        $scope.bundleUrl = "";
                                        Core.$apply($scope);
                                    },
                                    error: function (response) {
                                        Core.notification("error", response.error);
                                    }
                                });
                            }
                        },
                        error: function (response) {
                            Core.notification("error", response.error);
                        }
                    });
                },
                error: function (response) {
                    Core.notification("error", response.error);
                }
            });
        };
        $scope.$watch('display.sortField', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.bundles = $scope.bundles.sortBy(newValue);
            }
        });
        $scope.getStateStyle = function (state) {
            return Osgi.getStateStyle("badge", state);
        };
        $scope.getLabel = function (bundleObject) {
            var labelText;
            if ($scope.display.bundleField === "Name") {
                labelText = bundleObject.Name;
                if (labelText === "") {
                    labelText = bundleObject.SymbolicName;
                }
            }
            else {
                labelText = bundleObject.SymbolicName;
            }
            return labelText;
        };
        $scope.filterBundle = function (bundle) {
            if ($scope.display.startLevelFilter > 0 && bundle.StartLevel < $scope.display.startLevelFilter) {
                return false;
            }
            var labelText = $scope.getLabel(bundle);
            if ($scope.display.bundleFilter) {
                if (!labelText.toLowerCase().has($scope.display.bundleFilter.toLowerCase())) {
                    return false;
                }
                else {
                    if ($scope.display.showActiveMQBundles || $scope.display.showPlatformBundles || $scope.display.showCxfBundles || $scope.display.showCamelBundles) {
                        if ((matchesCheckedBundle(bundle))) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        return true;
                    }
                }
            }
            else {
                if (matchesCheckedBundle(bundle)) {
                    return true;
                }
                else {
                    return false;
                }
            }
            return true;
        };
        function matchesCheckedBundle(bundle) {
            if (($scope.display.showPlatformBundles && Karaf.isPlatformBundle(bundle['SymbolicName'])) || ($scope.display.showActiveMQBundles && Karaf.isActiveMQBundle(bundle['SymbolicName'])) || ($scope.display.showCxfBundles && Karaf.isCxfBundle(bundle['SymbolicName'])) || ($scope.display.showCamelBundles && Karaf.isCamelBundle(bundle['SymbolicName']))) {
                return true;
            }
            else {
                return false;
            }
        }
        ;
        function processResponse(response) {
            var value = response['value'];
            var responseJson = angular.toJson(value);
            if ($scope.responseJson !== responseJson) {
                $scope.responseJson = responseJson;
                $scope.bundles = [];
                angular.forEach(value, function (value, key) {
                    var obj = {
                        Identifier: value.Identifier,
                        Name: "",
                        SymbolicName: value.SymbolicName,
                        Fragment: value.Fragment,
                        State: value.State,
                        Version: value.Version,
                        LastModified: new Date(Number(value.LastModified)),
                        Location: value.Location,
                        StartLevel: undefined
                    };
                    if (value.Headers['Bundle-Name']) {
                        obj.Name = value.Headers['Bundle-Name']['Value'];
                    }
                    $scope.bundles.push(obj);
                });
                $scope.bundles = $scope.bundles.sortBy($scope.display.sortField);
                Core.$apply($scope);
                setTimeout(function () {
                    var requests = [];
                    for (var i = 0; i < $scope.bundles.length; i++) {
                        var b = $scope.bundles[i];
                        requests.push({
                            type: 'exec',
                            mbean: Osgi.getSelectionBundleMBean(workspace),
                            operation: 'getStartLevel(long)',
                            arguments: [b.Identifier]
                        });
                    }
                    var outstanding = requests.length;
                    jolokia.request(requests, onSuccess(function (response) {
                        var id = response['request']['arguments'].first();
                        if (angular.isDefined(id)) {
                            var bundle = $scope.bundles[id];
                            if (bundle) {
                                Osgi.log.debug("Setting bundle: ", bundle['Identifier'], " start level to: ", response['value']);
                                bundle['StartLevel'] = response['value'];
                            }
                        }
                        outstanding = outstanding - 1;
                        Osgi.log.debug("oustanding responses: ", outstanding);
                        if (outstanding === 0) {
                            Osgi.log.debug("Updating page...");
                            Core.$apply($scope);
                        }
                    }, { error: function (response) {
                    } }));
                }, 500);
            }
        }
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Osgi.getSelectionBundleMBean(workspace),
            operation: 'listBundles()'
        }, onSuccess(processResponse));
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    function readBSNHeaderData(header) {
        var idx = header.indexOf(";");
        if (idx <= 0) {
            return "";
        }
        return header.substring(idx + 1).trim();
    }
    Osgi.readBSNHeaderData = readBSNHeaderData;
    function formatAttributesAndDirectivesForPopover(data, skipVersion) {
        var str = "";
        if (!data) {
            return str;
        }
        var sortedKeys = Object.keys(data).sort();
        for (var i = 0; i < sortedKeys.length; i++) {
            var da = sortedKeys[i];
            var type = da.charAt(0);
            var separator = "";
            var txtClass;
            if (type === "A") {
                separator = "=";
                txtClass = "text-info";
            }
            if (type === "D") {
                separator = ":=";
                txtClass = "muted";
            }
            if (separator !== "") {
                if (skipVersion) {
                    if (da === "Aversion") {
                        continue;
                    }
                }
                var value = data[da];
                if (value.length > 15) {
                    value = value.replace(/[,]/g, ",<br/>&nbsp;&nbsp;");
                }
                str += "<tr><td><strong class='" + txtClass + "'>" + da.substring(1) + "</strong>" + separator + value + "</td></tr>";
            }
        }
        return str;
    }
    Osgi.formatAttributesAndDirectivesForPopover = formatAttributesAndDirectivesForPopover;
    function formatServiceName(objClass) {
        if (Object.isArray(objClass)) {
            return formatServiceNameArray(objClass);
        }
        var name = objClass.toString();
        var idx = name.lastIndexOf('.');
        return name.substring(idx + 1);
    }
    Osgi.formatServiceName = formatServiceName;
    function formatServiceNameArray(objClass) {
        var rv = [];
        for (var i = 0; i < objClass.length; i++) {
            rv.add(formatServiceName(objClass[i]));
        }
        rv = rv.filter(function (elem, pos, self) {
            return self.indexOf(elem) === pos;
        });
        rv.sort();
        return rv.toString();
    }
    Osgi._module.controller("Osgi.BundleController", ["$scope", "$location", "workspace", "$routeParams", "jolokia", function ($scope, $location, workspace, $routeParams, jolokia) {
        $scope.bundleId = $routeParams.bundleId;
        updateTableContents();
        $scope.showValue = function (key) {
            switch (key) {
                case "Bundle-Name":
                case "Bundle-SymbolicName":
                case "Bundle-Version":
                case "Export-Package":
                case "Import-Package":
                    return false;
                default:
                    return true;
            }
        };
        $scope.executeLoadClass = function (clazz) {
            var mbean = Osgi.getHawtioOSGiToolsMBean(workspace);
            if (mbean) {
                jolokia.request({ type: 'exec', mbean: mbean, operation: 'getLoadClassOrigin', arguments: [$scope.bundleId, clazz] }, {
                    success: function (response) {
                        var divEl = document.getElementById("loadClassResult");
                        var resultBundle = response.value;
                        var style;
                        var resultTxt;
                        if (resultBundle === -1) {
                            style = "";
                            resultTxt = "Class can not be loaded from this bundle.";
                        }
                        else {
                            style = "alert-success";
                            resultTxt = "Class is served from Bundle " + Osgi.bundleLinks(workspace, resultBundle);
                        }
                        divEl.innerHTML += "<div class='alert " + style + "'>" + "<button type='button' class='close' data-dismiss='alert'>&times;</button>" + "Loading class <strong>" + clazz + "</strong> in Bundle " + $scope.bundleId + ". " + resultTxt + "</div>";
                    },
                    error: function (response) {
                        inspectReportError(response);
                    }
                });
            }
            else {
                inspectReportNoMBeanFound();
            }
        };
        $scope.executeFindResource = function (resource) {
            var mbean = Osgi.getHawtioOSGiToolsMBean(workspace);
            if (mbean) {
                jolokia.request({ type: 'exec', mbean: mbean, operation: 'getResourceURL', arguments: [$scope.bundleId, resource] }, {
                    success: function (response) {
                        var divEl = document.getElementById("loadClassResult");
                        var resultURL = response.value;
                        var style;
                        var resultTxt;
                        if (resultURL === null) {
                            style = "";
                            resultTxt = "Resource can not be found from this bundle.";
                        }
                        else {
                            style = "alert-success";
                            resultTxt = "Resource is available from: " + resultURL;
                        }
                        divEl.innerHTML += "<div class='alert " + style + "'>" + "<button type='button' class='close' data-dismiss='alert'>&times;</button>" + "Finding resource <strong>" + resource + "</strong> in Bundle " + $scope.bundleId + ". " + resultTxt + "</div>";
                    },
                    error: function (response) {
                        inspectReportError(response);
                    }
                });
            }
            else {
                inspectReportNoMBeanFound();
            }
        };
        $scope.mavenLink = function (row) {
            if (angular.isObject(row)) {
                return Maven.mavenLink(row.Location);
            }
            return "";
        };
        $scope.startBundle = function (bundleId) {
            jolokia.request([
                { type: 'exec', mbean: Osgi.getSelectionFrameworkMBean(workspace), operation: 'startBundle', arguments: [bundleId] }
            ], onSuccess(updateTableContents));
        };
        $scope.stopBundle = function (bundleId) {
            jolokia.request([
                { type: 'exec', mbean: Osgi.getSelectionFrameworkMBean(workspace), operation: 'stopBundle', arguments: [bundleId] }
            ], onSuccess(updateTableContents));
        };
        $scope.updatehBundle = function (bundleId) {
            jolokia.request([
                { type: 'exec', mbean: Osgi.getSelectionFrameworkMBean(workspace), operation: 'updateBundle', arguments: [bundleId] }
            ], onSuccess(updateTableContents));
        };
        $scope.refreshBundle = function (bundleId) {
            jolokia.request([
                { type: 'exec', mbean: Osgi.getSelectionFrameworkMBean(workspace), operation: 'refreshBundle', arguments: [bundleId] }
            ], onSuccess(updateTableContents));
        };
        $scope.uninstallBundle = function (bundleId) {
            jolokia.request([{
                type: 'exec',
                mbean: Osgi.getSelectionFrameworkMBean(workspace),
                operation: 'uninstallBundle',
                arguments: [bundleId]
            }], onSuccess(function () {
                $location.path("/osgi/bundle-list");
                Core.$apply($scope);
            }));
        };
        function inspectReportNoMBeanFound() {
            var divEl = document.getElementById("loadClassResult");
            divEl.innerHTML += "<div class='alert alert-error'>" + "<button type='button' class='close' data-dismiss='alert'>&times;</button>" + "The hawtio.OSGiTools MBean is not available. Please contact technical support." + "</div>";
        }
        function inspectReportError(response) {
            var divEl = document.getElementById("loadClassResult");
            divEl.innerHTML += "<div class='alert alert-error'>" + "<button type='button' class='close' data-dismiss='alert'>&times;</button>" + "Problem invoking hawtio.OSGiTools MBean. " + response + "</div>";
        }
        function populateTable(response) {
            var values = response.value;
            $scope.bundles = values;
            Osgi.defaultBundleValues(workspace, $scope, values);
            $scope.row = Osgi.findBundle($scope.bundleId, values);
            Core.$apply($scope);
            $('.accordion-body.collapse').hover(function () {
                $(this).css('overflow', 'visible');
            }, function () {
                $(this).css('overflow', 'hidden');
            });
            $("#bsn").tooltip({ title: readBSNHeaderData($scope.row.Headers["Bundle-SymbolicName"].Value), placement: "right" });
            createImportPackageSection();
            createExportPackageSection();
            populateServicesSection();
        }
        function createImportPackageSection() {
            var importPackageHeaders = Osgi.parseManifestHeader($scope.row.Headers, "Import-Package");
            for (var pkg in $scope.row.ImportData) {
                var data = importPackageHeaders[pkg];
                var po = "<small><table>" + "<tr><td><strong>Imported Version=</strong>" + $scope.row.ImportData[pkg].ReportedVersion + "</td></tr>";
                if (data !== undefined) {
                    po += formatAttributesAndDirectivesForPopover(data, false);
                    if (importPackageHeaders[pkg]["Dresolution"] !== "optional") {
                        $(document.getElementById("import." + pkg)).addClass("badge-info");
                    }
                }
                else {
                    $(document.getElementById("import." + pkg)).addClass("badge-important");
                    var reason = $scope.row.Headers["DynamicImport-Package"];
                    if (reason !== undefined) {
                        reason = reason.Value;
                        po += "<tr><td>Dynamic Import. Imported due to:</td></tr>";
                        po += "<tr><td><strong>DynamicImport-Package=</strong>" + reason + "</td></tr>";
                    }
                }
                po += "</table></small>";
                $(document.getElementById("import." + pkg)).popover({ title: "attributes and directives", content: po, trigger: "hover", html: true });
                importPackageHeaders[pkg] = undefined;
            }
            var unsatisfied = "";
            for (var pkg in importPackageHeaders) {
                if (importPackageHeaders[pkg] === undefined) {
                    continue;
                }
                if ($scope.row.ExportData[pkg] !== undefined) {
                    continue;
                }
                unsatisfied += "<tr><td><div class='less-big badge badge-warning' id='unsatisfied." + pkg + "'>" + pkg + "</div></td></tr>";
            }
            if (unsatisfied !== "") {
                unsatisfied = "<p/><p class='text-warning'>The following optional imports were not satisfied:<table>" + unsatisfied + "</table></p>";
                document.getElementById("unsatisfiedOptionalImports").innerHTML = unsatisfied;
            }
            for (var pkg in importPackageHeaders) {
                if (importPackageHeaders[pkg] === undefined) {
                    continue;
                }
                var po = "<small><table>";
                po += formatAttributesAndDirectivesForPopover(importPackageHeaders[pkg], false);
                po += "</table></small>";
                $(document.getElementById("unsatisfied." + pkg)).popover({ title: "attributes and directives", content: po, trigger: "hover", html: true });
            }
        }
        function createExportPackageSection() {
            var exportPackageHeaders = Osgi.parseManifestHeader($scope.row.Headers, "Export-Package");
            for (var pkg in $scope.row.ExportData) {
                var po = "<small><table>" + "<tr><td><strong>Exported Version=</strong>" + $scope.row.ExportData[pkg].ReportedVersion + "</td></tr>";
                po += formatAttributesAndDirectivesForPopover(exportPackageHeaders[pkg], true);
                po += "</table></small>";
                $(document.getElementById("export." + pkg)).popover({ title: "attributes and directives", content: po, trigger: "hover", html: true });
            }
        }
        function populateServicesSection() {
            if (($scope.row.RegisteredServices === undefined || $scope.row.RegisteredServices.length === 0) && ($scope.row.ServicesInUse === undefined || $scope.row.ServicesInUse === 0)) {
                return;
            }
            var mbean = Osgi.getSelectionServiceMBean(workspace);
            if (mbean) {
                jolokia.request({ type: 'exec', mbean: mbean, operation: 'listServices()' }, onSuccess(updateServices));
            }
        }
        function updateServices(result) {
            var data = result.value;
            for (var id in data) {
                var reg = document.getElementById("registers.service." + id);
                var uses = document.getElementById("uses.service." + id);
                if ((reg === undefined || reg === null) && (uses === undefined || uses === null)) {
                    continue;
                }
                jolokia.request({
                    type: 'exec',
                    mbean: Osgi.getSelectionServiceMBean(workspace),
                    operation: 'getProperties',
                    arguments: [id]
                }, onSuccess(function (svcId, regEl, usesEl) {
                    return function (resp) {
                        var props = resp.value;
                        var sortedKeys = Object.keys(props).sort();
                        var po = "<small><table>";
                        for (var i = 0; i < sortedKeys.length; i++) {
                            var value = props[sortedKeys[i]];
                            if (value !== undefined) {
                                var fval = value.Value;
                                if (fval.length > 15) {
                                    fval = fval.replace(/[,]/g, ",<br/>&nbsp;&nbsp;");
                                }
                                po += "<tr><td valign='top'>" + sortedKeys[i] + "</td><td>" + fval + "</td></tr>";
                            }
                        }
                        var regBID = data[svcId].BundleIdentifier;
                        po += "<tr><td>Registered&nbsp;by</td><td>Bundle " + regBID + " <div class='less-big label'>" + $scope.bundles[regBID].SymbolicName + "</div></td></tr>";
                        po += "</table></small>";
                        if (regEl !== undefined && regEl !== null) {
                            regEl.innerText = " " + formatServiceName(data[svcId].objectClass);
                            $(regEl).popover({ title: "service properties", content: po, trigger: "hover", html: true });
                        }
                        if (usesEl !== undefined && usesEl !== null) {
                            usesEl.innerText = " " + formatServiceName(data[svcId].objectClass);
                            $(usesEl).popover({ title: "service properties", content: po, trigger: "hover", html: true });
                        }
                    };
                }(id, reg, uses)));
            }
        }
        function updateTableContents() {
            var mbean = Osgi.getSelectionBundleMBean(workspace);
            if (mbean) {
                jolokia.request({ type: 'exec', mbean: mbean, operation: 'listBundles()' }, onSuccess(populateTable));
            }
        }
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.BundlesController", ["$scope", "workspace", "jolokia", function ($scope, workspace, jolokia) {
        $scope.result = {};
        $scope.bundles = [];
        $scope.selected = [];
        $scope.loading = true;
        $scope.bundleUrl = "";
        $scope.installDisabled = function () {
            return $scope.bundleUrl === "";
        };
        var columnDefs = [
            {
                field: 'Identifier',
                displayName: 'Identifier',
                width: "48",
                headerCellTemplate: '<div ng-click="col.sort()" class="ngHeaderSortColumn {{col.headerClass}}" ng-style="{\'cursor\': col.cursor}" ng-class="{ \'ngSorted\': !noSortVisible }"><div class="ngHeaderText colt{{$index}} pagination-centered" title="Identifier"><i class="icon-tag"></i></div><div class="ngSortButtonDown" ng-show="col.showSortButtonDown()"></div><div class="ngSortButtonUp" ng-show="col.showSortButtonUp()"></div></div>',
            },
            {
                field: 'State',
                displayName: 'Bundle State',
                width: "24",
                headerCellTemplate: '<div ng-click="col.sort()" class="ngHeaderSortColumn {{col.headerClass}}" ng-style="{\'cursor\': col.cursor}" ng-class="{ \'ngSorted\': !noSortVisible }"><div class="ngHeaderText colt{{$index}} pagination-centered" title="State"><i class="icon-tasks"></i></div><div class="ngSortButtonDown" ng-show="col.showSortButtonDown()"></div><div class="ngSortButtonUp" ng-show="col.showSortButtonUp()"></div></div>',
                cellTemplate: '<div class="ngCellText" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(col.field)}}"></i></div>'
            },
            {
                field: 'Name',
                displayName: 'Name',
                width: "***",
                cellTemplate: '<div class="ngCellText"><a href="#/osgi/bundle/{{row.entity.Identifier}}?p=container">{{row.getProperty(col.field)}}</a></div>'
            },
            {
                field: 'SymbolicName',
                displayName: 'Symbolic Name',
                width: "***",
                cellTemplate: '<div class="ngCellText"><a href="#/osgi/bundle/{{row.entity.Identifier}}?p=container">{{row.getProperty(col.field)}}</a></div>'
            },
            {
                field: 'Version',
                displayName: 'Version',
                width: "**"
            },
            {
                field: 'Location',
                displayName: 'Update Location',
                width: "***"
            }
        ];
        $scope.gridOptions = {
            data: 'bundles',
            showFilter: false,
            selectedItems: $scope.selected,
            selectWithCheckboxOnly: true,
            columnDefs: columnDefs,
            filterOptions: {
                filterText: ''
            }
        };
        $scope.onResponse = function () {
            jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionBundleMBean(workspace),
                operation: 'listBundles()'
            }, {
                success: render,
                error: render
            });
        };
        $scope.controlBundles = function (op) {
            var startBundle = function (response) {
            };
            var ids = $scope.selected.map(function (b) {
                return b.Identifier;
            });
            if (!angular.isArray(ids)) {
                ids = [ids];
            }
            jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionFrameworkMBean(workspace),
                operation: op,
                arguments: [ids]
            }, {
                success: $scope.onResponse,
                error: $scope.onResponse
            });
        };
        $scope.stop = function () {
            $scope.controlBundles('stopBundles([J)');
        };
        $scope.start = function () {
            $scope.controlBundles('startBundles([J)');
        };
        $scope.update = function () {
            $scope.controlBundles('updateBundles([J)');
        };
        $scope.refresh = function () {
            $scope.controlBundles('refreshBundles([J)');
        };
        $scope.uninstall = function () {
            $scope.controlBundles('uninstallBundles([J)');
        };
        $scope.install = function () {
            jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionFrameworkMBean(workspace),
                operation: "installBundle(java.lang.String)",
                arguments: [$scope.bundleUrl]
            }, {
                success: function (response) {
                    console.log("Got: ", response);
                    $scope.bundleUrl = "";
                    jolokia.request({
                        type: 'exec',
                        mbean: Osgi.getSelectionFrameworkMBean(workspace),
                        operation: "startBundle(long)",
                        arguments: [response.value]
                    }, {
                        success: $scope.onResponse,
                        error: $scope.onResponse
                    });
                },
                error: function (response) {
                    $scope.bundleUrl = "";
                    $scope.onResponse();
                }
            });
        };
        function render(response) {
            if (!Object.equal($scope.result, response.value)) {
                $scope.selected.length = 0;
                $scope.result = response.value;
                $scope.bundles = [];
                angular.forEach($scope.result, function (value, key) {
                    var obj = {
                        Identifier: value.Identifier,
                        Name: "",
                        SymbolicName: value.SymbolicName,
                        State: value.State,
                        Version: value.Version,
                        LastModified: value.LastModified,
                        Location: value.Location
                    };
                    if (value.Headers['Bundle-Name']) {
                        obj.Name = value.Headers['Bundle-Name']['Value'];
                    }
                    $scope.bundles.push(obj);
                });
                $scope.loading = false;
                Core.$apply($scope);
            }
        }
        Core.register(jolokia, $scope, {
            type: 'exec',
            mbean: Osgi.getSelectionBundleMBean(workspace),
            operation: 'listBundles()'
        }, onSuccess(render));
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi.configuration = {
        pidMetadata: {
            "io.fabric8.container.java": {
                name: "Java Container"
            },
            "io.fabric8.container.process": {
                name: "Process Container"
            },
            "io.fabric8.container.process.overlay.resources": {
                name: "Container Overlay Resources",
                description: "The resources overlaid over the distribution of the process",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "io.fabric8.dosgi": {
                name: "Fabric8 DOSGi",
                description: "The configuration for the Distributed OSGi implementation in Fabric8"
            },
            "io.fabric8.environment": {
                name: "Environment Variables",
                description: "The operating system Environment Variables which are exported into any child processes",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "io.fabric8.fab.osgi.url": {
                name: "FAB URL",
                description: "Configures the 'fab:' URL handler for deploying JARs as bundles"
            },
            "io.fabric8.mq.fabric.server": {
                name: "ActiveMQ Broker",
                description: "The configuration of the Apache ActiveMQ server configured via the fabric"
            },
            "io.fabric8.openshift": {
                name: "OpenShift"
            },
            "io.fabric8.ports": {
                name: "Ports",
                description: "The network ports exported by the container",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "io.fabric8.system": {
                name: "System Properties",
                description: "The Java System Properties which are exported into any child Java processes",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "io.fabric8.version": {
                name: "Versions",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "org.ops4j.pax.logging": {
                name: "Logging",
                description: "The configuration of the logging subsystem"
            },
            "org.ops4j.pax.url.mvn": {
                name: "Maven URL",
                description: "Configures the Maven 'mvn:' URL handler for referencing maven artifacts"
            },
            "org.ops4j.pax.url.war": {
                name: "WAR URL",
                description: "Configures the 'war:' URL handler for referencing WAR deployments"
            },
            "org.ops4j.pax.url.wrap": {
                name: "Wrap URL",
                description: "Configures the 'wrap:' URL handler for wrapping JARs as bundles"
            }
        },
        ignorePids: [
            "jmx.acl",
            "io.fabric8.agent",
            "io.fabric8.git",
            "io.fabric8.mq.fabric.template",
            "io.fabric8.openshift.agent",
            "io.fabric8.service.ZkDataStoreImpl",
            "org.apache.felix.fileinstall",
            "org.apache.karaf.command.acl.",
            "org.apache.karaf.service.acl."
        ],
        tabs: {
            "fabric8": {
                label: "Fabric8",
                description: "Configuration options for the Fabric8 services",
                pids: ["io.fabric8"]
            },
            "karaf": {
                label: "Karaf",
                description: "Configuration options for the Apache Karaf container and subsystem",
                pids: ["org.apache.karaf"]
            }
        }
    };
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.ConfigurationsController", ["$scope", "$routeParams", "$location", "workspace", "jolokia", function ($scope, $routeParams, $location, workspace, jolokia) {
        $scope.selectedItems = [];
        $scope.grid = {
            data: 'configurations',
            showFilter: false,
            showColumnMenu: false,
            multiSelect: false,
            filterOptions: {
                filterText: "",
                useExternalFilter: false
            },
            selectedItems: $scope.selectedItems,
            showSelectionCheckbox: false,
            displaySelectionCheckbox: false,
            columnDefs: [
                {
                    field: 'Pid',
                    displayName: 'Configuration',
                    cellTemplate: '<div class="ngCellText"><a ng-href="{{row.entity.pidLink}}" title="{{row.entity.description}}">{{row.entity.name}}</a></div>'
                }
            ]
        };
        var configKinds = {
            factory: {
                class: "badge badge-info",
                title: "Configuration factory used to create separate instances of the configuration"
            },
            pid: {
                class: "badge badge-success",
                title: "Configuration which has a set of properties associated with it"
            },
            pidNoValue: {
                class: "badge badge-warning",
                title: "Configuration which does not yet have any bound values"
            }
        };
        $scope.addPidDialog = new UI.Dialog();
        Osgi.initProfileScope($scope, $routeParams, $location, localStorage, jolokia, workspace, function () {
            $scope.$watch('workspace.selection', function () {
                updateTableContents();
            });
            updateTableContents();
        });
        $scope.addPid = function (newPid) {
            if ($scope.configurations.any(function (c) { return c['pid'] == newPid; })) {
                Core.notification("error", "pid \"" + newPid + "\" already exists.");
                return;
            }
            $scope.addPidDialog.close();
            var mbean = Osgi.getHawtioConfigAdminMBean($scope.workspace);
            if (mbean && newPid) {
                var json = JSON.stringify({});
                $scope.jolokia.execute(mbean, "configAdminUpdate", newPid, json, onSuccess(function (response) {
                    Core.notification("success", "Successfully created pid: " + newPid);
                    updateTableContents();
                }));
            }
        };
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateTableContents, 50);
        });
        function onConfigPids(response) {
            var pids = {};
            angular.forEach(response, function (row) {
                var pid = row[0];
                var bundle = row[1];
                var config = createPidConfig(pid, bundle);
                if (!ignorePid(pid)) {
                    config["hasValue"] = true;
                    config["kind"] = configKinds.pid;
                    pids[pid] = config;
                }
            });
            $scope.pids = pids;
            var mbean = Osgi.getSelectionConfigAdminMBean($scope.workspace);
            if (mbean) {
                $scope.jolokia.execute(mbean, 'getConfigurations', '(service.factoryPid=*)', onSuccess(onConfigFactoryPids, errorHandler("Failed to load factory PID configurations: ")));
            }
            loadMetaType();
        }
        function onConfigFactoryPids(response) {
            var mbean = Osgi.getSelectionConfigAdminMBean($scope.workspace);
            var pids = $scope.pids;
            if (pids && mbean) {
                angular.forEach(response, function (row) {
                    var pid = row[0];
                    var bundle = row[1];
                    if (pid && !ignorePid(pid)) {
                        var config = pids[pid];
                        if (config) {
                            config["isFactoryInstance"] = true;
                            $scope.jolokia.execute(mbean, 'getFactoryPid', pid, onSuccess(function (factoryPid) {
                                config["factoryPid"] = factoryPid;
                                config["name"] = Osgi.removeFactoryPidPrefix(pid, factoryPid);
                                if (factoryPid) {
                                    var factoryConfig = getOrCreatePidConfig(factoryPid, bundle, pids);
                                    if (factoryConfig) {
                                        configureFactoryPidConfig(pid, factoryConfig, config);
                                        if ($scope.inFabricProfile) {
                                            Osgi.getConfigurationProperties($scope.workspace, $scope.jolokia, pid, function (configValues) {
                                                var zkPid = Core.pathGet(configValues, ["fabric.zookeeper.pid", "Value"]);
                                                if (zkPid) {
                                                    config["name"] = Osgi.removeFactoryPidPrefix(zkPid, factoryPid);
                                                    config["zooKeeperPid"] = zkPid;
                                                    Core.$apply($scope);
                                                }
                                            });
                                        }
                                        Core.$apply($scope);
                                    }
                                }
                            }));
                        }
                    }
                });
            }
            updateMetaType();
        }
        function onMetaType(response) {
            $scope.metaType = response;
            updateMetaType();
        }
        function updateConfigurations() {
            var pids = $scope.pids;
            var configurations = [];
            angular.forEach(pids, function (config, pid) {
                if (!config["isFactoryInstance"]) {
                    configurations.push(config);
                }
            });
            $scope.configurations = configurations.sortBy("name");
            Core.$apply($scope);
        }
        function updateMetaType(lazilyCreateConfigs) {
            if (lazilyCreateConfigs === void 0) { lazilyCreateConfigs = true; }
            var metaType = $scope.metaType;
            if (metaType) {
                var pidMetadata = Osgi.configuration.pidMetadata;
                var pids = $scope.pids || {};
                angular.forEach(metaType.pids, function (value, pid) {
                    var bundle = null;
                    var config = lazilyCreateConfigs ? getOrCreatePidConfig(pid, bundle) : pids[pid];
                    if (config) {
                        var factoryPidBundleIds = value.factoryPidBundleIds;
                        if (factoryPidBundleIds && factoryPidBundleIds.length) {
                            setFactoryPid(config);
                        }
                        config["name"] = Core.pathGet(pidMetadata, [pid, "name"]) || trimUnnecessaryPrefixes(value.name) || pid;
                        var description = Core.pathGet(pidMetadata, [pid, "description"]) || value.description;
                        config["description"] = description;
                    }
                });
            }
            updateConfigurations();
        }
        function loadMetaType() {
            if ($scope.pids) {
                if ($scope.profileNotRunning && $scope.profileMetadataMBean && $scope.versionId && $scope.profileId) {
                    jolokia.execute($scope.profileMetadataMBean, "metaTypeSummary", $scope.versionId, $scope.profileId, onSuccess(onMetaType));
                }
                else {
                    var metaTypeMBean = Osgi.getMetaTypeMBean($scope.workspace);
                    if (metaTypeMBean) {
                        $scope.jolokia.execute(metaTypeMBean, "metaTypeSummary", onSuccess(onMetaType));
                    }
                }
            }
        }
        function updateTableContents() {
            $scope.configurations = [];
            if ($scope.profileNotRunning && $scope.profileMetadataMBean && $scope.versionId && $scope.profileId) {
                jolokia.execute($scope.profileMetadataMBean, "metaTypeSummary", $scope.versionId, $scope.profileId, onSuccess(onProfileMetaType, { silent: true }));
            }
            else {
                if ($scope.jolokia) {
                    var mbean = Osgi.getSelectionConfigAdminMBean($scope.workspace);
                    if (mbean) {
                        $scope.jolokia.execute(mbean, 'getConfigurations', '(service.pid=*)', onSuccess(onConfigPids, errorHandler("Failed to load PID configurations: ")));
                    }
                }
            }
        }
        function onProfileMetaType(response) {
            var metaType = response;
            if (metaType) {
                var pids = {};
                angular.forEach(metaType.pids, function (value, pid) {
                    if (value && !ignorePid(pid)) {
                        var bundle = "mvn:" + pid;
                        var config = {
                            pid: pid,
                            name: value.name,
                            class: 'pid',
                            description: value.description,
                            bundle: bundle,
                            kind: configKinds.pid,
                            pidLink: createPidLink(pid)
                        };
                        pids[pid] = config;
                    }
                });
                angular.forEach(pids, function (config, pid) {
                    var idx = pid.indexOf('-');
                    if (idx > 0) {
                        var factoryPid = pid.substring(0, idx);
                        var name = pid.substring(idx + 1, pid.length);
                        var factoryConfig = pids[factoryPid];
                        if (!factoryConfig) {
                            var bundle = config.bundle;
                            factoryConfig = getOrCreatePidConfig(factoryPid, bundle, pids);
                        }
                        if (factoryConfig) {
                            configureFactoryPidConfig(pid, factoryConfig, config, factoryPid);
                            config.name = name;
                            pids[factoryPid] = factoryConfig;
                            delete pids[pid];
                        }
                    }
                });
                $scope.pids = pids;
            }
            $scope.metaType = metaType;
            updateMetaType(false);
        }
        function trimUnnecessaryPrefixes(name) {
            angular.forEach(["Fabric8 ", "Apache "], function (prefix) {
                if (name && name.startsWith(prefix) && name.length > prefix.length) {
                    name = name.substring(prefix.length);
                }
            });
            return name;
        }
        function pidBundleDescription(pid, bundle) {
            var pidMetadata = Osgi.configuration.pidMetadata;
            return Core.pathGet(pidMetadata, [pid, "description"]) || "pid: " + pid + "\nbundle: " + bundle;
        }
        function createPidConfig(pid, bundle) {
            var pidMetadata = Osgi.configuration.pidMetadata;
            var config = {
                pid: pid,
                name: Core.pathGet(pidMetadata, [pid, "name"]) || pid,
                class: 'pid',
                description: Core.pathGet(pidMetadata, [pid, "description"]) || pidBundleDescription(pid, bundle),
                bundle: bundle,
                kind: configKinds.pidNoValue,
                pidLink: createPidLink(pid)
            };
            return config;
        }
        function ignorePid(pid) {
            var answer = false;
            angular.forEach(Osgi.configuration.ignorePids, function (pattern) {
                if (pid.startsWith(pattern)) {
                    answer = true;
                }
            });
            return answer;
        }
        function getOrCreatePidConfig(pid, bundle, pids) {
            if (pids === void 0) { pids = null; }
            if (ignorePid(pid)) {
                Osgi.log.info("ignoring pid " + pid);
                return null;
            }
            else {
                if (!pids) {
                    pids = $scope.pids;
                }
                var factoryConfig = pids[pid];
                if (!factoryConfig) {
                    factoryConfig = createPidConfig(pid, bundle);
                    pids[pid] = factoryConfig;
                    updateConfigurations();
                }
                return factoryConfig;
            }
        }
        function configureFactoryPidConfig(pid, factoryConfig, config, factoryPid) {
            if (factoryPid === void 0) { factoryPid = null; }
            setFactoryPid(factoryConfig, factoryPid, pid);
            var children = factoryConfig.children;
            if (factoryPid) {
                factoryConfig.pidLink = createPidLink(factoryPid, true);
            }
            if (!children) {
                children = {};
                factoryConfig["children"] = children;
            }
            children[pid] = config;
        }
        function setFactoryPid(factoryConfig, factoryPid, pid) {
            if (factoryPid === void 0) { factoryPid = null; }
            if (pid === void 0) { pid = null; }
            factoryConfig["isFactory"] = true;
            factoryConfig["class"] = "factoryPid";
            factoryConfig["kind"] = configKinds.factory;
            if (!factoryPid) {
                factoryPid = factoryConfig["factoryPid"] || "";
            }
            if (!pid) {
                pid = factoryConfig["pid"] || "";
            }
            if (!factoryPid) {
                factoryPid = pid;
                pid = null;
            }
            factoryConfig["pidLink"] = createPidLink(factoryPid);
        }
        function createPidLink(pid, isFactory) {
            if (isFactory === void 0) { isFactory = false; }
            return Osgi.createConfigPidLink($scope, workspace, pid, isFactory);
        }
        function errorHandler(message) {
            return {
                error: function (response) {
                    Core.notification("error", message + response['error'] || response);
                    Core.defaultJolokiaErrorHandler(response);
                }
            };
        }
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.FrameworkController", ["$scope", "$dialog", "workspace", function ($scope, $dialog, workspace) {
        $scope.editDialog = new UI.Dialog();
        updateContents();
        $scope.edit = function (attr, displayName) {
            $scope.editAttr = attr;
            $scope.editDisplayName = displayName;
            $scope.editDialog.open();
        };
        $scope.edited = function (name, displayName, res) {
            $scope.editDialog.close();
            if (angular.isNumber(res)) {
                var mbean = Osgi.getSelectionFrameworkMBean(workspace);
                if (mbean) {
                    var jolokia = workspace.jolokia;
                    jolokia.request({
                        type: 'write',
                        mbean: mbean,
                        attribute: name,
                        value: res
                    }, {
                        error: function (response) {
                            editWritten("error", response.error);
                        },
                        success: function (response) {
                            editWritten("success", displayName + " changed to " + res);
                        }
                    });
                }
            }
        };
        function editWritten(status, message) {
            Core.notification(status, message);
            updateContents();
        }
        function populatePage(response) {
            $scope.startLevel = response.value.FrameworkStartLevel;
            $scope.initialBundleStartLevel = response.value.InitialBundleStartLevel;
            Core.$apply($scope);
        }
        function updateContents() {
            var mbean = Osgi.getSelectionFrameworkMBean(workspace);
            if (mbean) {
                var jolokia = workspace.jolokia;
                jolokia.request({ type: 'read', mbean: mbean }, onSuccess(populatePage));
            }
        }
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    var OsgiDataService = (function () {
        function OsgiDataService(workspace, jolokia) {
            this.jolokia = jolokia;
            this.workspace = workspace;
        }
        OsgiDataService.prototype.getBundles = function () {
            var bundles = {};
            var response = this.jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionBundleMBean(this.workspace),
                operation: 'listBundles()'
            }, onSuccess(null));
            angular.forEach(response.value, function (value, key) {
                var obj = {
                    Identifier: value.Identifier,
                    Name: "",
                    SymbolicName: value.SymbolicName,
                    Fragment: value.Fragment,
                    State: value.State,
                    Version: value.Version,
                    LastModified: new Date(Number(value.LastModified)),
                    Location: value.Location,
                    StartLevel: undefined,
                    RegisteredServices: value.RegisteredServices,
                    ServicesInUse: value.ServicesInUse
                };
                if (value.Headers['Bundle-Name']) {
                    obj.Name = value.Headers['Bundle-Name']['Value'];
                }
                bundles[value.Identifier] = obj;
            });
            return bundles;
        };
        OsgiDataService.prototype.getServices = function () {
            var services = {};
            var response = this.jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionServiceMBean(this.workspace),
                operation: 'listServices()'
            }, onSuccess(null));
            var answer = response.value;
            angular.forEach(answer, function (value, key) {
                services[value.Identifier] = value;
            });
            return services;
        };
        OsgiDataService.prototype.getPackages = function () {
            var packages = {};
            var response = this.jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionPackageMBean(this.workspace),
                operation: 'listPackages()'
            }, onSuccess(null));
            var answer = response.value.values;
            answer.forEach(function (value) {
                packages[value.Name + "-" + value.Version] = value;
            });
            return packages;
        };
        return OsgiDataService;
    })();
    Osgi.OsgiDataService = OsgiDataService;
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    var OsgiGraphBuilder = (function () {
        function OsgiGraphBuilder(osgiDataService, bundleFilter, packageFilter, showServices, showPackages, hideUnused) {
            this.filteredBundles = {};
            this.bundles = null;
            this.services = null;
            this.packages = null;
            this.PREFIX_BUNDLE = "Bundle-";
            this.PREFIX_SVC = "Service-";
            this.PREFIX_PKG = "Package-";
            this.osgiDataService = osgiDataService;
            this.bundleFilter = bundleFilter;
            this.packageFilter = packageFilter;
            this.showServices = showServices;
            this.showPackages = showPackages;
            this.hideUnused = hideUnused;
            this.graphBuilder = new ForceGraph.GraphBuilder();
        }
        OsgiGraphBuilder.prototype.getBundles = function () {
            if (this.bundles == null) {
                this.bundles = this.osgiDataService.getBundles();
            }
            return this.bundles;
        };
        OsgiGraphBuilder.prototype.getServices = function () {
            if (this.services == null) {
                this.services = this.osgiDataService.getServices();
            }
            return this.services;
        };
        OsgiGraphBuilder.prototype.getPackages = function () {
            if (this.packages == null) {
                this.packages = this.osgiDataService.getPackages();
            }
            return this.packages;
        };
        OsgiGraphBuilder.prototype.bundleNodeId = function (bundle) {
            return this.PREFIX_BUNDLE + bundle.Identifier;
        };
        OsgiGraphBuilder.prototype.serviceNodeId = function (service) {
            return this.PREFIX_SVC + service.Identifier;
        };
        OsgiGraphBuilder.prototype.pkgNodeId = function (pkg) {
            return this.PREFIX_PKG + pkg.Name + "-" + pkg.Version;
        };
        OsgiGraphBuilder.prototype.buildSvcNode = function (service) {
            return {
                id: this.serviceNodeId(service),
                name: "" + service.Identifier,
                type: "service",
                used: false,
                popup: {
                    title: "Service [" + service.Identifier + "]",
                    content: (function () {
                        var result = "";
                        if (service != null) {
                            service.objectClass.forEach(function (clazz) {
                                if (result.length > 0) {
                                    result = result + "<br/>";
                                }
                                result = result + clazz;
                            });
                        }
                        return result;
                    })
                }
            };
        };
        OsgiGraphBuilder.prototype.buildBundleNode = function (bundle) {
            return {
                id: this.bundleNodeId(bundle),
                name: bundle.SymbolicName,
                type: "bundle",
                used: false,
                navUrl: "#/osgi/bundle/" + bundle.Identifier,
                popup: {
                    title: "Bundle [" + bundle.Identifier + "]",
                    content: "<p>" + bundle.SymbolicName + "<br/>Version " + bundle.Version + "</p>"
                }
            };
        };
        OsgiGraphBuilder.prototype.buildPackageNode = function (pkg) {
            return {
                id: this.pkgNodeId(pkg),
                name: pkg.Name,
                type: "package",
                used: false,
                popup: {
                    title: "Package [" + pkg.Name + "]",
                    content: "<p>" + pkg.Version + "</p>"
                }
            };
        };
        OsgiGraphBuilder.prototype.exportingBundle = function (pkg) {
            var _this = this;
            var result = null;
            pkg.ExportingBundles.forEach(function (bundleId) {
                if (_this.filteredBundles[_this.PREFIX_BUNDLE + bundleId] != null) {
                    result = bundleId;
                }
            });
            return result;
        };
        OsgiGraphBuilder.prototype.addFilteredBundles = function () {
            var _this = this;
            d3.values(this.getBundles()).forEach(function (bundle) {
                if (_this.bundleFilter == null || _this.bundleFilter == "" || bundle.SymbolicName.startsWith(_this.bundleFilter)) {
                    var bundleNode = _this.buildBundleNode(bundle);
                    _this.filteredBundles[bundleNode.id] = bundle;
                    bundleNode.used = true;
                    _this.graphBuilder.addNode(bundleNode);
                    if (_this.showServices) {
                        var services = _this.getServices();
                        bundle.RegisteredServices.forEach(function (sid) {
                            var svc = services[sid];
                            if (svc) {
                                var svcNode = _this.buildSvcNode(services[sid]);
                                _this.graphBuilder.addNode(svcNode);
                                _this.graphBuilder.addLink(bundleNode.id, svcNode.id, "registered");
                            }
                        });
                    }
                }
            });
        };
        OsgiGraphBuilder.prototype.addFilteredServices = function () {
            var _this = this;
            if (this.showServices) {
                d3.values(this.getBundles()).forEach(function (bundle) {
                    bundle.ServicesInUse.forEach(function (sid) {
                        var svcNodeId = _this.PREFIX_SVC + sid;
                        if (_this.graphBuilder.getNode(svcNodeId) != null) {
                            _this.graphBuilder.getNode(svcNodeId).used = true;
                            var bundleNode = _this.graphBuilder.getNode(_this.bundleNodeId(bundle)) || _this.buildBundleNode(bundle);
                            bundleNode.used = true;
                            _this.graphBuilder.addNode(bundleNode);
                            _this.graphBuilder.addLink(svcNodeId, bundleNode.id, "inuse");
                        }
                    });
                });
            }
        };
        OsgiGraphBuilder.prototype.addFilteredPackages = function () {
            var _this = this;
            if (this.showPackages) {
                d3.values(this.getPackages()).forEach(function (pkg) {
                    if (_this.packageFilter == null || _this.packageFilter == "" || pkg.Name.startsWith(_this.packageFilter)) {
                        var exportingId = _this.exportingBundle(pkg);
                        if (exportingId != null) {
                            var bundleNode = _this.graphBuilder.getNode(_this.PREFIX_BUNDLE + exportingId);
                            bundleNode.used = true;
                            var pkgNode = _this.buildPackageNode(pkg);
                            _this.graphBuilder.addNode(pkgNode);
                            _this.graphBuilder.addLink(bundleNode.id, pkgNode.id, "registered");
                            pkg.ImportingBundles.forEach(function (bundleId) {
                                var bundleNode = _this.graphBuilder.getNode(_this.PREFIX_BUNDLE + bundleId) || _this.buildBundleNode(_this.getBundles()[bundleId]);
                                bundleNode.used = true;
                                pkgNode.used = true;
                                _this.graphBuilder.addNode(bundleNode);
                                _this.graphBuilder.addLink(bundleNode.id, pkgNode.id, "inuse");
                            });
                        }
                    }
                });
            }
        };
        OsgiGraphBuilder.prototype.buildGraph = function () {
            var _this = this;
            this.addFilteredBundles();
            this.addFilteredServices();
            this.addFilteredPackages();
            if (this.hideUnused) {
                this.graphBuilder.filterNodes(function (node) {
                    return node.used;
                });
                this.graphBuilder.filterNodes(function (node) {
                    return _this.graphBuilder.hasLinks(node.id);
                });
            }
            return this.graphBuilder.buildGraph();
        };
        return OsgiGraphBuilder;
    })();
    Osgi.OsgiGraphBuilder = OsgiGraphBuilder;
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi.TopLevelController = Osgi._module.controller("Osgi.TopLevelController", ["$scope", "workspace", function ($scope, workspace) {
        $scope.frameworkMBean = Osgi.getSelectionFrameworkMBean(workspace);
        $scope.bundleMBean = Osgi.getSelectionBundleMBean(workspace);
        $scope.serviceMBean = Osgi.getSelectionServiceMBean(workspace);
        $scope.packageMBean = Osgi.getSelectionPackageMBean(workspace);
        $scope.configAdminMBean = Osgi.getSelectionConfigAdminMBean(workspace);
        $scope.metaTypeMBean = Osgi.getMetaTypeMBean(workspace);
        $scope.osgiToolsMBean = Osgi.getHawtioOSGiToolsMBean(workspace);
        $scope.hawtioConfigAdminMBean = Osgi.getHawtioConfigAdminMBean(workspace);
        $scope.scrMBean = Karaf.getSelectionScrMBean(workspace);
        $scope.featuresMBean = Karaf.getSelectionFeaturesMBean(workspace);
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.PackageController", ["$scope", "$filter", "workspace", "$routeParams", function ($scope, $filter, workspace, $routeParams) {
        $scope.package = $routeParams.package;
        $scope.version = $routeParams.version;
        updateTableContents();
        function populateTable(response) {
            var packages = Osgi.defaultPackageValues(workspace, $scope, response.value);
            $scope.row = packages.filter({ "Name": $scope.package, "Version": $scope.version })[0];
            Core.$apply($scope);
        }
        ;
        function updateTableContents() {
            var mbean = Osgi.getSelectionPackageMBean(workspace);
            if (mbean) {
                var jolokia = workspace.jolokia;
                jolokia.request({ type: 'exec', mbean: mbean, operation: 'listPackages' }, onSuccess(populateTable));
            }
        }
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi.PackagesController = Osgi._module.controller("Osgi.PackagesController", ["$scope", "$filter", "workspace", "$templateCache", "$compile", function ($scope, $filter, workspace, $templateCache, $compile) {
        var dateFilter = $filter('date');
        $scope.widget = new DataTable.TableWidget($scope, $templateCache, $compile, [
            {
                "mDataProp": null,
                "sClass": "control center",
                "sDefaultContent": '<i class="icon-plus"></i>'
            },
            { "mDataProp": "Name" },
            { "mDataProp": "VersionLink" },
            { "mDataProp": "RemovalPending" }
        ], {
            rowDetailTemplateId: 'packageBundlesTemplate',
            disableAddColumns: true
        });
        $scope.$watch('workspace.selection', function () {
            updateTableContents();
        });
        function populateTable(response) {
            var packages = Osgi.defaultPackageValues(workspace, $scope, response.value);
            augmentPackagesInfo(packages);
        }
        function augmentPackagesInfo(packages) {
            var bundleMap = {};
            var createBundleMap = function (response) {
                angular.forEach(response.value, function (value, key) {
                    var obj = {
                        Identifier: value.Identifier,
                        Name: "",
                        SymbolicName: value.SymbolicName,
                        State: value.State,
                        Version: value.Version,
                        LastModified: value.LastModified,
                        Location: value.Location
                    };
                    if (value.Headers['Bundle-Name']) {
                        obj.Name = value.Headers['Bundle-Name']['Value'];
                    }
                    bundleMap[obj.Identifier] = obj;
                });
                angular.forEach(packages, function (p, key) {
                    angular.forEach(p["ExportingBundles"], function (b, key) {
                        p["ExportingBundles"][key] = bundleMap[b];
                    });
                    angular.forEach(p["ImportingBundles"], function (b, key) {
                        p["ImportingBundles"][key] = bundleMap[b];
                    });
                });
                $scope.widget.populateTable(packages);
                Core.$apply($scope);
            };
            workspace.jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionBundleMBean(workspace),
                operation: 'listBundles()'
            }, {
                success: createBundleMap,
                error: createBundleMap
            });
        }
        function updateTableContents() {
            var mbean = Osgi.getSelectionPackageMBean(workspace);
            if (mbean) {
                var jolokia = workspace.jolokia;
                jolokia.request({
                    type: 'exec',
                    mbean: mbean,
                    operation: 'listPackages'
                }, onSuccess(populateTable));
            }
        }
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.PidController", ["$scope", "$timeout", "$routeParams", "$location", "workspace", "jolokia", function ($scope, $timeout, $routeParams, $location, workspace, jolokia) {
        $scope.deletePropDialog = new UI.Dialog();
        $scope.deletePidDialog = new UI.Dialog();
        $scope.addPropertyDialog = new UI.Dialog();
        $scope.factoryPid = $routeParams.factoryPid;
        $scope.pid = $routeParams.pid;
        $scope.createForm = {
            pidInstanceName: null
        };
        $scope.newPid = $scope.factoryPid && !$scope.pid;
        if ($scope.newPid) {
            $scope.editMode = true;
        }
        if ($scope.pid && !$scope.factoryPid) {
            var idx = $scope.pid.indexOf("-");
            if (idx > 0) {
                $scope.factoryPid = $scope.pid.substring(0, idx);
                $scope.factoryInstanceName = $scope.pid.substring(idx + 1, $scope.pid.length);
            }
        }
        $scope.selectValues = {};
        $scope.modelLoaded = false;
        $scope.canSave = false;
        $scope.setEditMode = function (flag) {
            $scope.editMode = flag;
            $scope.formMode = flag ? "edit" : "view";
            if (!flag || !$scope.entity) {
                $scope.entity = {};
                updateTableContents();
            }
        };
        var startInEditMode = $scope.factoryPid && !$routeParams.pid;
        $scope.setEditMode(startInEditMode);
        $scope.$on("hawtio.form.modelChange", function () {
            if ($scope.modelLoaded) {
                enableCanSave();
                Core.$apply($scope);
            }
        });
        Osgi.initProfileScope($scope, $routeParams, $location, localStorage, jolokia, workspace, function () {
            updateTableContents();
        });
        function updatePid(mbean, pid, data) {
            var completeFn = function (response) {
                Core.notification("success", "Successfully updated pid: " + pid);
                if (pid && $scope.factoryPid && $scope.newPid) {
                    var newPath = Osgi.createConfigPidPath($scope, pid);
                    $location.path(newPath);
                }
                else {
                    $scope.setEditMode(false);
                    $scope.canSave = false;
                    $scope.saved = true;
                }
            };
            var callback = onSuccess(completeFn, errorHandler("Failed to update: " + pid));
            if ($scope.inFabricProfile) {
                jolokia.execute(Fabric.managerMBean, "setProfileProperties", $scope.versionId, $scope.profileId, pid, data, callback);
            }
            else {
                var json = JSON.stringify(data);
                $scope.jolokia.execute(mbean, "configAdminUpdate", pid, json, callback);
            }
        }
        $scope.pidSave = function () {
            var data = {};
            angular.forEach($scope.entity, function (value, key) {
                var text = undefined;
                if (angular.isString(value)) {
                    text = value;
                }
                else if (angular.isDefined(value)) {
                    text = value.toString();
                }
                if (angular.isDefined(text)) {
                    data[decodeKey(key, $scope.pid)] = text;
                }
            });
            var mbean = Osgi.getHawtioConfigAdminMBean(workspace);
            if (mbean || $scope.inFabricProfile) {
                var pidMBean = Osgi.getSelectionConfigAdminMBean($scope.workspace);
                var pid = $scope.pid;
                var zkPid = $scope.zkPid;
                var factoryPid = $scope.factoryPid;
                if (!$scope.inFabricProfile && factoryPid && pidMBean && !zkPid) {
                    $scope.jolokia.execute(pidMBean, "createFactoryConfiguration", factoryPid, onSuccess(function (response) {
                        pid = response;
                        if (pid) {
                            updatePid(mbean, pid, data);
                        }
                    }, errorHandler("Failed to create new PID: ")));
                }
                else {
                    if ($scope.newPid) {
                        var pidInstanceName = $scope.createForm.pidInstanceName;
                        if (!pidInstanceName || !factoryPid) {
                            return;
                        }
                        pid = factoryPid + "-" + pidInstanceName;
                    }
                    else if (zkPid) {
                        pid = zkPid;
                    }
                    updatePid(mbean, pid, data);
                }
            }
        };
        function errorHandler(message) {
            return {
                error: function (response) {
                    Core.notification("error", message + "\n" + response['error'] || response);
                    Core.defaultJolokiaErrorHandler(response);
                }
            };
        }
        function enableCanSave() {
            if ($scope.editMode) {
                $scope.canSave = true;
            }
        }
        $scope.addPropertyConfirmed = function (key, value) {
            $scope.addPropertyDialog.close();
            $scope.configValues[key] = {
                Key: key,
                Value: value,
                Type: "String"
            };
            enableCanSave();
            updateSchema();
        };
        $scope.deletePidProp = function (e) {
            $scope.deleteKey = e.Key;
            $scope.deletePropDialog.open();
        };
        $scope.deletePidPropConfirmed = function () {
            $scope.deletePropDialog.close();
            var cell = document.getElementById("pid." + $scope.deleteKey);
            cell.parentElement.remove();
            enableCanSave();
        };
        $scope.deletePidConfirmed = function () {
            $scope.deletePidDialog.close();
            function errorFn(response) {
                Core.notification("error", response.error);
            }
            function successFn(response) {
                Core.notification("success", "Successfully deleted pid: " + $scope.pid);
                $location.path($scope.configurationsLink);
            }
            if ($scope.inFabricProfile) {
                if ($scope.pid) {
                    var configFile = $scope.pid + ".properties";
                    jolokia.execute(Fabric.managerMBean, "deleteConfigurationFile", $scope.versionId, $scope.profileId, configFile, onSuccess(successFn, { error: errorFn }));
                }
            }
            else {
                var mbean = Osgi.getSelectionConfigAdminMBean($scope.workspace);
                if (mbean) {
                    $scope.jolokia.request({
                        type: "exec",
                        mbean: mbean,
                        operation: 'delete',
                        arguments: [$scope.pid]
                    }, {
                        error: errorFn,
                        success: successFn
                    });
                }
            }
        };
        function populateTable(response) {
            $scope.modelLoaded = true;
            var configValues = response || {};
            $scope.configValues = configValues;
            $scope.zkPid = Core.pathGet(configValues, ["fabric.zookeeper.pid", "Value"]);
            if ($scope.zkPid && $scope.saved) {
                function onProfileProperties(gitProperties) {
                    angular.forEach(gitProperties, function (value, key) {
                        var configProperty = configValues[key];
                        if (configProperty) {
                            configProperty.Value = value;
                        }
                    });
                    updateSchemaAndLoadMetaType();
                    Core.$apply($scope);
                }
                jolokia.execute(Fabric.managerMBean, "getProfileProperties", $scope.versionId, $scope.profileId, $scope.zkPid, onSuccess(onProfileProperties));
            }
            else {
                updateSchemaAndLoadMetaType();
            }
        }
        function updateSchemaAndLoadMetaType() {
            updateSchema();
            var configValues = $scope.configValues;
            if (configValues) {
                if ($scope.profileNotRunning && $scope.profileMetadataMBean && $scope.versionId && $scope.profileId) {
                    var pid = $scope.factoryPid || $scope.pid;
                    jolokia.execute($scope.profileMetadataMBean, "getPidMetaTypeObject", $scope.versionId, $scope.profileId, pid, onSuccess(onMetaType));
                }
                else {
                    var locale = null;
                    var pid = null;
                    var factoryId = configValues["service.factoryPid"];
                    if (factoryId && !pid) {
                        pid = factoryId["Value"];
                    }
                    var metaTypeMBean = Osgi.getMetaTypeMBean($scope.workspace);
                    if (metaTypeMBean) {
                        $scope.jolokia.execute(metaTypeMBean, "getPidMetaTypeObject", pid, locale, onSuccess(onMetaType));
                    }
                }
            }
            Core.$apply($scope);
        }
        function onMetaType(response) {
            $scope.metaType = response;
            updateSchema();
            Core.$apply($scope);
        }
        function updateSchema() {
            var properties = {};
            var required = [];
            $scope.defaultValues = {};
            var schema = {
                type: "object",
                required: required,
                properties: properties
            };
            var inputClass = "span12";
            var labelClass = "control-label";
            var inputClassArray = "";
            var labelClassArray = labelClass;
            var metaType = $scope.metaType;
            if (metaType) {
                var pidMetadata = Osgi.configuration.pidMetadata;
                var pid = metaType.id;
                schema["id"] = pid;
                schema["name"] = Core.pathGet(pidMetadata, [pid, "name"]) || metaType.name;
                schema["description"] = Core.pathGet(pidMetadata, [pid, "description"]) || metaType.description;
                var disableHumanizeLabel = Core.pathGet(pidMetadata, [pid, "schemaExtensions", "disableHumanizeLabel"]);
                angular.forEach(metaType.attributes, function (attribute) {
                    var id = attribute.id;
                    if (isValidProperty(id)) {
                        var key = encodeKey(id, pid);
                        var typeName = asJsonSchemaType(attribute.typeName, attribute.id);
                        var attributeProperties = {
                            title: attribute.name,
                            tooltip: attribute.description,
                            'input-attributes': {
                                class: inputClass
                            },
                            'label-attributes': {
                                class: labelClass
                            },
                            type: typeName
                        };
                        if (disableHumanizeLabel) {
                            attributeProperties.title = id;
                        }
                        if (attribute.typeName === "char") {
                            attributeProperties["maxLength"] = 1;
                            attributeProperties["minLength"] = 1;
                        }
                        var cardinality = attribute.cardinality;
                        if (cardinality) {
                            attributeProperties['input-attributes']['class'] = null;
                            attributeProperties.type = "array";
                            attributeProperties["items"] = {
                                'input-attributes': {
                                    class: inputClassArray
                                },
                                'label-attributes': {
                                    class: labelClassArray
                                },
                                "type": typeName
                            };
                        }
                        if (attribute.required) {
                            required.push(id);
                        }
                        var defaultValue = attribute.defaultValue;
                        if (defaultValue) {
                            if (angular.isArray(defaultValue) && defaultValue.length === 1) {
                                defaultValue = defaultValue[0];
                            }
                            $scope.defaultValues[key] = defaultValue;
                        }
                        var optionLabels = attribute.optionLabels;
                        var optionValues = attribute.optionValues;
                        if (optionLabels && optionLabels.length && optionValues && optionValues.length) {
                            var enumObject = {};
                            for (var i = 0; i < optionLabels.length; i++) {
                                var label = optionLabels[i];
                                var value = optionValues[i];
                                enumObject[value] = label;
                            }
                            $scope.selectValues[key] = enumObject;
                            Core.pathSet(attributeProperties, ['input-element'], "select");
                            Core.pathSet(attributeProperties, ['input-attributes', "ng-options"], "key as value for (key, value) in selectValues." + key);
                        }
                        properties[key] = attributeProperties;
                    }
                });
                var schemaExtensions = Core.pathGet(Osgi.configuration.pidMetadata, [pid, "schemaExtensions"]);
                if (schemaExtensions) {
                    overlayProperties(schema, schemaExtensions);
                }
            }
            var entity = {};
            angular.forEach($scope.configValues, function (value, rawKey) {
                if (isValidProperty(rawKey)) {
                    var key = encodeKey(rawKey, pid);
                    var attrValue = value;
                    var attrType = "string";
                    if (angular.isObject(value)) {
                        attrValue = value.Value;
                        attrType = asJsonSchemaType(value.Type, rawKey);
                    }
                    var property = properties[key];
                    if (!property) {
                        property = {
                            'input-attributes': {
                                class: inputClass
                            },
                            'label-attributes': {
                                class: labelClass
                            },
                            type: attrType
                        };
                        properties[key] = property;
                        if (rawKey == 'org.osgi.service.http.port') {
                            properties[key]['input-attributes']['disabled'] = 'disabled';
                            properties[key]['input-attributes']['title'] = 'Changing port of OSGi http service is not possible from Hawtio';
                        }
                    }
                    else {
                        var propertyType = property["type"];
                        if ("array" === propertyType) {
                            if (!angular.isArray(attrValue)) {
                                attrValue = attrValue ? attrValue.split(",") : [];
                            }
                        }
                    }
                    if (disableHumanizeLabel) {
                        property.title = rawKey;
                    }
                    key = key.replace(/-/g, "_");
                    entity[key] = attrValue;
                }
            });
            angular.forEach($scope.defaultValues, function (value, key) {
                var current = entity[key];
                if (!angular.isDefined(current)) {
                    entity[key] = value;
                }
            });
            $scope.entity = entity;
            $scope.schema = schema;
            $scope.fullSchema = schema;
        }
        function overlayProperties(object, overlay) {
            if (angular.isObject(object)) {
                if (angular.isObject(overlay)) {
                    angular.forEach(overlay, function (value, key) {
                        if (angular.isObject(value)) {
                            var child = object[key];
                            if (!child) {
                                child = {};
                                object[key] = child;
                            }
                            overlayProperties(child, value);
                        }
                        else {
                            object[key] = value;
                        }
                    });
                }
            }
        }
        var ignorePropertyIds = ["service.pid", "service.factoryPid", "fabric.zookeeper.pid"];
        function isValidProperty(id) {
            return id && ignorePropertyIds.indexOf(id) < 0;
        }
        function encodeKey(key, pid) {
            return key.replace(/\./g, "__");
        }
        function decodeKey(key, pid) {
            return key.replace(/__/g, ".");
        }
        function asJsonSchemaType(typeName, id) {
            if (typeName) {
                var lower = typeName.toLowerCase();
                if (lower.startsWith("int") || lower === "long" || lower === "short" || lower === "byte" || lower.endsWith("int")) {
                    return "integer";
                }
                if (lower === "double" || lower === "float" || lower === "bigdecimal") {
                    return "number";
                }
                if (lower === "string") {
                    if (id && id.endsWith("password")) {
                        return "password";
                    }
                    return "string";
                }
                return typeName;
            }
            else {
                return "string";
            }
        }
        function onProfilePropertiesLoaded(response) {
            $scope.modelLoaded = true;
            var configValues = {};
            $scope.configValues = configValues;
            angular.forEach(response, function (value, oKey) {
                var key = oKey.replace(/:/g, '_').replace(/\//g, '_');
                configValues[key] = {
                    Key: key,
                    Value: value
                };
            });
            $scope.zkPid = Core.pathGet(configValues, ["fabric.zookeeper.pid", "Value"]);
            updateSchemaAndLoadMetaType();
            Core.$apply($scope);
        }
        function updateTableContents() {
            $scope.modelLoaded = false;
            if ($scope.inFabricProfile || $scope.profileNotRunning) {
                jolokia.execute(Fabric.managerMBean, "getOverlayProfileProperties", $scope.versionId, $scope.profileId, $scope.pid, onSuccess(onProfilePropertiesLoaded));
            }
            else {
                Osgi.getConfigurationProperties($scope.workspace, $scope.jolokia, $scope.pid, populateTable);
            }
        }
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi.ServiceController = Osgi._module.controller("Osgi.ServiceController", ["$scope", "$filter", "workspace", "$templateCache", "$compile", function ($scope, $filter, workspace, $templateCache, $compile) {
        var dateFilter = $filter('date');
        $scope.widget = new DataTable.TableWidget($scope, $templateCache, $compile, [
            {
                "mDataProp": null,
                "sClass": "control center",
                "sDefaultContent": '<i class="icon-plus"></i>'
            },
            { "mDataProp": "Identifier" },
            { "mDataProp": "BundleIdentifier" },
            { "mDataProp": "objectClass" }
        ], {
            rowDetailTemplateId: 'osgiServiceTemplate',
            disableAddColumns: true
        });
        $scope.$watch('workspace.selection', function () {
            var mbean = Osgi.getSelectionServiceMBean(workspace);
            if (mbean) {
                var jolokia = workspace.jolokia;
                jolokia.request({
                    type: 'exec',
                    mbean: mbean,
                    operation: 'listServices()'
                }, onSuccess(populateTable));
            }
        });
        var populateTable = function (response) {
            var services = Osgi.defaultServiceValues(workspace, $scope, response.value);
            augmentServicesInfo(services);
        };
        function augmentServicesInfo(services) {
            var bundleMap = {};
            var createBundleMap = function (response) {
                angular.forEach(response.value, function (value, key) {
                    var obj = {
                        Identifier: value.Identifier,
                        Name: "",
                        SymbolicName: value.SymbolicName,
                        State: value.State,
                        Version: value.Version,
                        LastModified: value.LastModified,
                        Location: value.Location
                    };
                    if (value.Headers['Bundle-Name']) {
                        obj.Name = value.Headers['Bundle-Name']['Value'];
                    }
                    bundleMap[obj.Identifier] = obj;
                });
                angular.forEach(services, function (s, key) {
                    angular.forEach(s["UsingBundles"], function (b, key) {
                        s["UsingBundles"][key] = bundleMap[b];
                    });
                });
                $scope.widget.populateTable(services);
                Core.$apply($scope);
            };
            workspace.jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionBundleMBean(workspace),
                operation: 'listBundles()'
            }, {
                success: createBundleMap,
                error: createBundleMap
            });
        }
    }]);
})(Osgi || (Osgi = {}));
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.ServiceDependencyController", ["$scope", "$location", "$routeParams", "workspace", "osgiDataService", function ($scope, $location, $routeParams, workspace, osgiDataService) {
        $scope.init = function () {
            if ($routeParams["bundleFilter"]) {
                $scope.bundleFilter = $routeParams["bundleFilter"];
            }
            else {
                $scope.bundleFilter = "";
            }
            if ($routeParams["pkgFilter"]) {
                $scope.packageFilter = $routeParams["pkgFilter"];
            }
            else {
                $scope.packageFilter = "";
            }
            if ($routeParams["view"] == "packages") {
                $scope.selectView = "packages";
            }
            else {
                $scope.selectView = "services";
            }
            if ($routeParams['hideUnused']) {
                $scope.hideUnused = $routeParams['hideUnused'] == "true";
            }
            else {
                $scope.hideUnused = true;
            }
        };
        $scope.updateLink = function () {
            var search = $location.search;
            if ($scope.bundleFilter && $scope.bundleFilter != "") {
                search["bundleFilter"] = $scope.bundleFilter;
            }
            else {
                delete search["bundleFilter"];
            }
            if ($scope.packageFilter && $scope.packageFilter != "") {
                search["pkgFilter"] = $scope.packageFilter;
            }
            else {
                delete search["pkgFilter"];
            }
            search["view"] = $scope.selectView;
            if ($scope.hideUnused) {
                search["hideUnused"] = "true";
            }
            else {
                search["hideUnused"] = "false";
            }
            $location.search(search);
        };
        $scope.addToDashboardLink = function () {
            var routeParams = angular.toJson($routeParams);
            var href = "#/osgi/dependencies";
            var title = "OSGi dependencies";
            var size = angular.toJson({
                size_x: 2,
                size_y: 2
            });
            var addLink = "#/dashboard/add?tab=dashboard" + "&href=" + encodeURIComponent(href) + "&routeParams=" + encodeURIComponent(routeParams) + "&size=" + encodeURIComponent(size) + "&title=" + encodeURIComponent(title);
            return addLink;
        };
        $scope.$on('$routeUpdate', function () {
            var search = $location.search;
            if (search["bundleFilter"]) {
                $scope.bundleFilter = $routeParams["bundleFilter"];
            }
            else {
                $scope.bundleFilter = "";
            }
            if (search["pkgFilter"]) {
                $scope.packageFilter = $routeParams["pkgFilter"];
            }
            else {
                $scope.packageFilter = "";
            }
            if (search["view"] == "packages") {
                $scope.selectView = "packages";
            }
            else {
                $scope.selectView = "services";
            }
            if (search['hideUnused']) {
                $scope.hideUnused = $routeParams['hideUnused'] == "true";
            }
            else {
                $scope.hideUnused = true;
            }
            $scope.updateLink();
            $scope.updateGraph();
        });
        $scope.updateGraph = function () {
            $scope.updateLink();
            $scope.updatePkgFilter();
            var graphBuilder = new Osgi.OsgiGraphBuilder(osgiDataService, $scope.bundleFilter, $scope.packageFilter, $scope.selectView == "services", $scope.selectView == "packages", $scope.hideUnused);
            $scope.graph = graphBuilder.buildGraph();
            Core.$apply($scope);
        };
        $scope.updatePkgFilter = function () {
            if ($scope.packageFilter == null || $scope.packageFilter == "") {
                $scope.selectView = "services";
                $scope.disablePkg = true;
            }
            else {
                $scope.disablePkg = false;
            }
        };
        $scope.init();
        $scope.updateGraph();
    }]);
})(Osgi || (Osgi = {}));
var Perspective;
(function (Perspective) {
    var pluginName = 'perspective';
    Perspective._module = angular.module(pluginName, ['hawtioCore']);
    Perspective._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/perspective/defaultPage', {
            templateUrl: 'app/perspective/html/defaultPage.html'
        }).otherwise({
            redirectTo: function (parameters, path, search) {
                return '/perspective/defaultPage';
            }
        });
    }]);
    Perspective._module.run(["viewRegistry", "layoutFull", "locationChangeStartTasks", function (viewRegistry, layoutFull, locationChangeStartTasks) {
        viewRegistry['perspective'] = layoutFull;
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Perspective || (Perspective = {}));
var Perspective;
(function (Perspective) {
    function DefaultPageController($scope, $location, localStorage, workspace, jolokia) {
        var params = $location.search();
        var url = Perspective.defaultPage($location, workspace, jolokia, localStorage);
        var path = Core.trimLeading(url, "#");
        if (path) {
            Perspective.log.debug("Redirecting to default page: ", path, " page params: ", params);
            $location.url(path);
        }
        else {
            Perspective.log.debug("No default page could be chosen");
        }
    }
    Perspective.DefaultPageController = DefaultPageController;
    Perspective._module.controller("Perspective.DefaultPageController", ["$scope", "$location", "localStorage", "workspace", "jolokia", DefaultPageController]);
})(Perspective || (Perspective = {}));
var Quartz;
(function (Quartz) {
    Quartz.log = Logger.get("Quartz");
    function iconClass(state) {
        if (state) {
            switch (state.toString().toLowerCase()) {
                case 'true':
                    return "green icon-play-circle";
                case 'normal':
                    return "green icon-play-circle";
                case 'paused':
                    return "orange icon-off";
            }
        }
        return "orange icon-off";
    }
    Quartz.iconClass = iconClass;
    function misfireText(val) {
        if (val) {
            switch (val) {
                case -1:
                    return "ignore";
                case 0:
                    return "smart";
                case 1:
                    return "fire once now";
                case 2:
                    return "do nothing";
            }
        }
        return "unknown";
    }
    Quartz.misfireText = misfireText;
    function jobDataClassText(text) {
        return "<i class='icon-info-sign'> " + text + "</i>";
    }
    Quartz.jobDataClassText = jobDataClassText;
    function isState(item, state) {
        var value = item.Started;
        if (angular.isArray(state)) {
            return state.any(function (stateText) { return value.startsWith(stateText); });
        }
        else {
            return value.startsWith(state);
        }
    }
    Quartz.isState = isState;
    function isQuartzPluginEnabled(workspace) {
        return getQuartzMBean(workspace);
    }
    Quartz.isQuartzPluginEnabled = isQuartzPluginEnabled;
    function getQuartzMBean(workspace) {
        return Core.getMBeanTypeObjectName(workspace, "quartz", "QuartzScheduler");
    }
    Quartz.getQuartzMBean = getQuartzMBean;
    function isScheduler(workspace) {
        return workspace.hasDomainAndProperties('quartz', { type: 'QuartzScheduler' });
    }
    Quartz.isScheduler = isScheduler;
    function getSelectedSchedulerName(workspace) {
        var selection = workspace.selection;
        if (selection && selection.domain === Quartz.jmxDomain) {
            return selection.entries["name"];
        }
        return null;
    }
    Quartz.getSelectedSchedulerName = getSelectedSchedulerName;
})(Quartz || (Quartz = {}));
var Quartz;
(function (Quartz) {
    var pluginName = 'quartz';
    Quartz.jmxDomain = 'quartz';
    Quartz._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'hawtioCore']);
    Quartz._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/quartz/scheduler', { templateUrl: 'app/quartz/html/scheduler.html' }).when('/quartz/triggers', { templateUrl: 'app/quartz/html/triggers.html' }).when('/quartz/jobs', { templateUrl: 'app/quartz/html/jobs.html' });
    }]);
    Quartz._module.filter('quartzIconClass', function () { return Quartz.iconClass; });
    Quartz._module.filter('quartzMisfire', function () { return Quartz.misfireText; });
    Quartz._module.filter('quartzJobDataClassText', function () { return Quartz.jobDataClassText; });
    Quartz._module.run(["$location", "workspace", "viewRegistry", "layoutFull", "helpRegistry", function ($location, workspace, viewRegistry, layoutFull, helpRegistry) {
        viewRegistry['quartz'] = 'app/quartz/html/layoutQuartzTree.html';
        helpRegistry.addUserDoc('quartz', 'app/quartz/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties(Quartz.jmxDomain);
        });
        workspace.topLevelTabs.push({
            id: "quartz",
            content: "Quartz",
            title: "Quartz Scheduler",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties(Quartz.jmxDomain); },
            href: function () { return "#/quartz/scheduler"; },
            isActive: function (workspace) { return workspace.isTopTabActive("quartz"); }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Quartz || (Quartz = {}));
var Quartz;
(function (Quartz) {
    Quartz._module.controller("Quartz.QuartzController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var log = Logger.get("Quartz");
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.entity.state}}"><i class="{{row.entity.state | quartzIconClass}}"></i></div>';
        var misfireTemplate = '<div class="ngCellText" title="{{row.entity.misfireInstruction}}">{{row.entity.misfireInstruction | quartzMisfire}}</div>';
        $scope.valueDetails = new UI.Dialog();
        $scope.selectedScheduler = null;
        $scope.selectedSchedulerMBean = null;
        $scope.triggers = [];
        $scope.jobs = [];
        $scope.misfireInstructions = [
            { id: '-1', title: 'Ignore' },
            { id: '0', title: 'Smart' },
            { id: '1', title: 'Fire once now' },
            { id: '2', title: 'Do nothing' }
        ];
        $scope.updatedTrigger = {};
        $scope.triggerSchema = {
            properties: {
                'cron': {
                    description: 'Cron expression',
                    label: 'Cron expression',
                    tooltip: 'Specify a cron expression for the trigger',
                    type: 'string',
                    hidden: false
                },
                'repeatCount': {
                    description: 'Repeat count',
                    tooltip: 'Number of times to repeat. Use -1 for forever.',
                    type: 'integer',
                    hidden: false
                },
                'repeatInterval': {
                    description: 'Repeat interval',
                    tooltip: 'Elapsed time in millis between triggering',
                    type: 'integer',
                    hidden: false
                },
                'misfireInstruction': {
                    description: 'Misfire instruction',
                    tooltip: 'What to do when misfiring happens',
                    type: 'string',
                    hidden: false,
                    'input-element': 'select',
                    'input-attributes': {
                        'ng-options': "mi.id as mi.title for mi in misfireInstructions"
                    }
                }
            }
        };
        $scope.gridOptions = {
            selectedItems: [],
            data: 'triggers',
            showFilter: true,
            filterOptions: {
                filterText: ''
            },
            showSelectionCheckbox: false,
            enableRowClickSelection: true,
            multiSelect: false,
            primaryKeyFn: function (entity, idx) {
                return entity.group + "/" + entity.name;
            },
            columnDefs: [
                {
                    field: 'state',
                    displayName: 'State',
                    cellTemplate: stateTemplate,
                    width: 56,
                    minWidth: 56,
                    maxWidth: 56,
                    resizable: false
                },
                {
                    field: 'group',
                    displayName: 'Group',
                    resizable: true,
                    width: 150
                },
                {
                    field: 'name',
                    displayName: 'Name',
                    resizable: true,
                    width: 150
                },
                {
                    field: 'type',
                    displayName: 'Type',
                    resizable: false,
                    width: 70
                },
                {
                    field: 'expression',
                    displayName: 'Expression',
                    resizable: true,
                    width: 180
                },
                {
                    field: 'misfireInstruction',
                    displayName: 'Misfire Instruction',
                    cellTemplate: misfireTemplate,
                    width: 150
                },
                {
                    field: 'previousFireTime',
                    displayName: 'Previous Fire'
                },
                {
                    field: 'nextFireTime',
                    displayName: 'Next Fire'
                },
                {
                    field: 'finalFireTime',
                    displayName: 'Final Fire'
                }
            ]
        };
        $scope.jobsGridOptions = {
            selectedItems: [],
            data: 'jobs',
            showFilter: true,
            filterOptions: {
                filterText: ''
            },
            showSelectionCheckbox: false,
            enableRowClickSelection: true,
            multiSelect: false,
            primaryKeyFn: function (entity, idx) {
                return entity.group + "/" + entity.name;
            },
            columnDefs: [
                {
                    field: 'group',
                    displayName: 'Group',
                    resizable: true,
                    width: 150
                },
                {
                    field: 'name',
                    displayName: 'Name',
                    resizable: true,
                    width: 150
                },
                {
                    field: 'durability',
                    displayName: 'Durable',
                    width: 70,
                    resizable: false
                },
                {
                    field: 'shouldRecover',
                    displayName: 'Recover',
                    width: 70,
                    resizable: false
                },
                {
                    field: 'jobClass',
                    displayName: 'Job ClassName',
                    width: 350
                },
                {
                    field: 'description',
                    displayName: 'Description',
                    resizable: true
                }
            ]
        };
        $scope.openJobDetailView = function () {
            if ($scope.jobsGridOptions.selectedItems.length === 1) {
                $scope.valueDetails.open();
            }
        };
        $scope.renderIcon = function (state) {
            return Quartz.iconClass(state);
        };
        $scope.renderQuartz = function (response) {
            $scope.selectedSchedulerDetails = [];
            log.debug("Selected scheduler mbean " + $scope.selectedScheduler);
            var obj = response.value;
            if (obj) {
                $scope.selectedScheduler = obj;
                $scope.triggers = [];
                $scope.job = [];
                obj.AllTriggers.forEach(function (t) {
                    var state = jolokia.request({ type: "exec", mbean: $scope.selectedSchedulerMBean, operation: "getTriggerState", arguments: [t.name, t.group] });
                    if (state) {
                        t.state = state.value;
                    }
                    else {
                        t.state = "unknown";
                    }
                    t.id = t.name + "/" + t.group;
                    var job = obj.AllJobDetails[t.jobName];
                    if (job) {
                        job = job[t.group];
                        if (job) {
                            var repeatCounter;
                            var repeatInterval;
                            var jobDataMap = job.jobDataMap || {};
                            t.type = jobDataMap["CamelQuartzTriggerType"];
                            if (t.type && t.type == "cron") {
                                t.expression = jobDataMap["CamelQuartzTriggerCronExpression"];
                            }
                            else if (t.type && t.type == "simple") {
                                t.expression = "every " + jobDataMap["CamelQuartzTriggerSimpleRepeatInterval"] + " ms.";
                                repeatCounter = jobDataMap["CamelQuartzTriggerSimpleRepeatCounter"];
                                repeatInterval = jobDataMap["CamelQuartzTriggerSimpleRepeatInterval"];
                                if (repeatCounter > 0) {
                                    t.expression += " (" + repeatCounter + " times)";
                                }
                                else {
                                    t.expression += " (forever)";
                                }
                                t.repeatCounter = repeatCounter;
                                t.repeatInterval = repeatInterval;
                            }
                            else {
                                var uri = jobDataMap["CamelQuartzEndpoint"];
                                if (uri) {
                                    var cron = Core.getQueryParameterValue(uri, "cron");
                                    if (cron) {
                                        t.type = "cron";
                                        cron = cron.replace(/\++/g, ' ');
                                        t.expression = cron;
                                    }
                                    repeatCounter = Core.getQueryParameterValue(uri, "trigger.repeatCount");
                                    repeatInterval = Core.getQueryParameterValue(uri, "trigger.repeatInterval");
                                    if (repeatCounter || repeatInterval) {
                                        t.type = "simple";
                                        t.expression = "every " + repeatInterval + " ms.";
                                        if (repeatCounter && repeatCounter > 0) {
                                            t.expression += " (" + repeatCounter + " times)";
                                        }
                                        else {
                                            t.expression += " (forever)";
                                        }
                                        t.repeatCounter = repeatCounter;
                                        t.repeatInterval = repeatInterval;
                                    }
                                }
                            }
                        }
                    }
                    $scope.triggers.push(t);
                });
                $scope.jobs = [];
                $scope.triggers.forEach(function (t) {
                    var job = obj.AllJobDetails[t.jobName];
                    if (job) {
                        job = job[t.group];
                        if (job) {
                            generateJobDataMapDetails(job);
                            job.id = job.jobName + "/" + job.group;
                            $scope.jobs.push(job);
                        }
                    }
                });
            }
            Core.$apply($scope);
        };
        function generateJobDataMapDetails(data) {
            var value = data.jobDataMap;
            if (!angular.isArray(value) && angular.isObject(value)) {
                var detailHtml = "<table class='table table-striped'>";
                detailHtml += "<thead><th>Key</th><th>Value</th></thead>";
                var object = value;
                var keys = Object.keys(value).sort();
                angular.forEach(keys, function (key) {
                    var value = object[key];
                    detailHtml += "<tr><td>" + safeNull(key) + "</td><td>" + safeNull(value) + "</td></tr>";
                });
                detailHtml += "</table>";
                data.detailHtml = detailHtml;
            }
        }
        $scope.pauseScheduler = function () {
            if ($scope.selectedSchedulerMBean) {
                jolokia.request({ type: "exec", mbean: $scope.selectedSchedulerMBean, operation: "standby" }, onSuccess(function (response) {
                    Core.notification("success", "Paused scheduler " + $scope.selectedScheduler.SchedulerName);
                }));
            }
        };
        $scope.startScheduler = function () {
            if ($scope.selectedSchedulerMBean) {
                jolokia.request({ type: "exec", mbean: $scope.selectedSchedulerMBean, operation: "start" }, onSuccess(function (response) {
                    Core.notification("success", "Started scheduler " + $scope.selectedScheduler.SchedulerName);
                }));
            }
        };
        $scope.enableSampleStatistics = function () {
            if ($scope.selectedSchedulerMBean) {
                jolokia.setAttribute($scope.selectedSchedulerMBean, "SampledStatisticsEnabled", true);
            }
        };
        $scope.disableSampleStatistics = function () {
            if ($scope.selectedSchedulerMBean) {
                jolokia.setAttribute($scope.selectedSchedulerMBean, "SampledStatisticsEnabled", false);
            }
        };
        $scope.pauseTrigger = function () {
            if ($scope.gridOptions.selectedItems.length === 1) {
                var groupName = $scope.gridOptions.selectedItems[0].group;
                var triggerName = $scope.gridOptions.selectedItems[0].name;
                jolokia.request({ type: "exec", mbean: $scope.selectedSchedulerMBean, operation: "pauseTrigger", arguments: [triggerName, groupName] }, onSuccess(function (response) {
                    Core.notification("success", "Paused trigger " + groupName + "/" + triggerName);
                }));
            }
        };
        $scope.resumeTrigger = function () {
            if ($scope.gridOptions.selectedItems.length === 1) {
                var groupName = $scope.gridOptions.selectedItems[0].group;
                var triggerName = $scope.gridOptions.selectedItems[0].name;
                jolokia.request({ type: "exec", mbean: $scope.selectedSchedulerMBean, operation: "resumeTrigger", arguments: [triggerName, groupName] }, onSuccess(function (response) {
                    Core.notification("success", "Resumed trigger " + groupName + "/" + triggerName);
                }));
            }
        };
        $scope.onBeforeUpdateTrigger = function () {
            var row = $scope.gridOptions.selectedItems[0];
            if (row && row.type === 'cron') {
                $scope.updatedTrigger["type"] = 'cron';
                $scope.updatedTrigger["cron"] = row.expression;
                $scope.updatedTrigger["repeatCount"] = null;
                $scope.updatedTrigger["repeatInterval"] = null;
                $scope.updatedTrigger["misfireInstruction"] = '' + row.misfireInstruction;
                $scope.triggerSchema.properties["cron"].hidden = false;
                $scope.triggerSchema.properties["repeatCount"].hidden = true;
                $scope.triggerSchema.properties["repeatInterval"].hidden = true;
                $scope.showTriggerDialog = true;
            }
            else if (row && row.type === 'simple') {
                $scope.updatedTrigger["type"] = 'simple';
                $scope.updatedTrigger["cron"] = null;
                $scope.updatedTrigger["repeatCount"] = row.repeatCounter;
                $scope.updatedTrigger["repeatInterval"] = row.repeatInterval;
                $scope.updatedTrigger["misfireInstruction"] = '' + row.misfireInstruction;
                $scope.triggerSchema.properties["cron"].hidden = true;
                $scope.triggerSchema.properties["repeatCount"].hidden = false;
                $scope.triggerSchema.properties["repeatInterval"].hidden = false;
                $scope.showTriggerDialog = true;
            }
            else {
                $scope.updatedTrigger = {};
                $scope.showTriggerDialog = false;
            }
        };
        $scope.onUpdateTrigger = function () {
            var cron = $scope.updatedTrigger["cron"];
            var repeatCounter = $scope.updatedTrigger["repeatCount"];
            var repeatInterval = $scope.updatedTrigger["repeatInterval"];
            var misfireInstruction = parseInt($scope.updatedTrigger["misfireInstruction"]);
            $scope.updatedTrigger = {};
            var groupName = $scope.gridOptions.selectedItems[0].group;
            var triggerName = $scope.gridOptions.selectedItems[0].name;
            if (cron) {
                log.info("Updating trigger " + groupName + "/" + triggerName + " with cron " + cron);
                jolokia.request({ type: "exec", mbean: "hawtio:type=QuartzFacade", operation: "updateCronTrigger", arguments: [
                    $scope.selectedSchedulerMBean,
                    triggerName,
                    groupName,
                    misfireInstruction,
                    cron,
                    null
                ] }, onSuccess(function (response) {
                    Core.notification("success", "Updated trigger " + groupName + "/" + triggerName);
                }));
            }
            else if (repeatCounter || repeatInterval) {
                if (repeatCounter == null) {
                    repeatCounter = -1;
                }
                if (repeatInterval == null) {
                    repeatInterval = 1000;
                }
                log.info("Updating trigger " + groupName + "/" + triggerName + " with interval " + repeatInterval + " ms. for " + repeatCounter + " times");
                jolokia.request({ type: "exec", mbean: "hawtio:type=QuartzFacade", operation: "updateSimpleTrigger", arguments: [
                    $scope.selectedSchedulerMBean,
                    triggerName,
                    groupName,
                    misfireInstruction,
                    repeatCounter,
                    repeatInterval
                ] }, onSuccess(function (response) {
                    Core.notification("success", "Updated trigger " + groupName + "/" + triggerName);
                }));
            }
        };
        function reloadTree() {
            log.debug("Reloading Quartz Tree");
            var mbean = Quartz.getQuartzMBean(workspace);
            var domain = "quartz";
            var rootFolder = new Folder("Quartz Schedulers");
            rootFolder.addClass = "quartz-folder";
            rootFolder.typeName = "quartzSchedulers";
            rootFolder.domain = domain;
            rootFolder.key = "";
            var children = [rootFolder];
            if (mbean) {
                function render(results) {
                    angular.forEach(results, function (value, key) {
                        var name = jolokia.request({ type: "read", mbean: value, attribute: ["SchedulerName"] });
                        var txt = name.value["SchedulerName"];
                        var scheduler = new Folder(txt);
                        scheduler.addClass = "quartz-scheduler";
                        scheduler.typeName = "quartzScheduler";
                        scheduler.domain = domain;
                        scheduler.objectName = value;
                        scheduler.key = txt;
                        rootFolder.children.push(scheduler);
                    });
                    log.debug("Setitng up Quartz tree with nid " + $location.search()["nid"]);
                    var nid = $location.search()["nid"];
                    if (nid) {
                        var data = rootFolder.children.filter(function (folder) {
                            return folder.key === nid;
                        });
                        log.debug("Found nid in tree " + data);
                        if (data && data.length === 1) {
                            selectionChanged(data[0]);
                        }
                    }
                    Core.$apply($scope);
                    var treeElement = $("#quartztree");
                    Jmx.enableTree($scope, $location, workspace, treeElement, children, true, function (selectedNode) {
                        var data = selectedNode.data;
                        selectionChanged(data);
                        Core.$apply($scope);
                    });
                    setTimeout(updateSelectionFromURL, 50);
                }
                jolokia.search("quartz:type=QuartzScheduler,*", onSuccess(render));
            }
        }
        function updateSelectionFromURL() {
            Jmx.updateTreeSelectionFromURLAndAutoSelect($location, $("#quartztree"), function (first) {
                var schedulers = first.getChildren();
                if (schedulers && schedulers.length === 1) {
                    first = schedulers[0];
                    return first;
                }
                else {
                    return first;
                }
            }, true);
        }
        function selectionChanged(data) {
            var selectionKey = data ? data.objectName : null;
            log.debug("Selection is now: " + selectionKey);
            if (selectionKey) {
                $scope.selectedSchedulerMBean = selectionKey;
                $location.search("nid", data.key);
                var request = [
                    { type: "read", mbean: $scope.selectedSchedulerMBean }
                ];
                Core.unregister(jolokia, $scope);
                Core.register(jolokia, $scope, request, onSuccess($scope.renderQuartz));
            }
            else {
                Core.unregister(jolokia, $scope);
                $scope.selectedSchedulerMBean = null;
                $scope.selectedScheduler = null;
                $scope.triggers = [];
                $scope.jobs = [];
                $scope.updatedTrigger = {};
            }
        }
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateSelectionFromURL, 50);
        });
        $scope.$on('jmxTreeUpdated', function () {
            reloadTree();
        });
        reloadTree();
    }]);
})(Quartz || (Quartz = {}));
var RBAC;
(function (RBAC) {
    RBAC.log = Logger.get("RBAC");
    function flattenMBeanTree(mbeans, tree) {
        if (!Core.isBlank(tree.objectName)) {
            mbeans[tree.objectName] = tree;
        }
        if (tree.children && tree.children.length > 0) {
            tree.children.forEach(function (child) {
                flattenMBeanTree(mbeans, child);
            });
        }
    }
    RBAC.flattenMBeanTree = flattenMBeanTree;
    function stripClasses(css) {
        if (Core.isBlank(css)) {
            return css;
        }
        var parts = css.split(" ");
        var answer = [];
        parts.forEach(function (part) {
            if (part !== "can-invoke" || part !== "cant-invoke") {
                answer.push(part);
            }
        });
        return answer.join(" ").trim();
    }
    RBAC.stripClasses = stripClasses;
    function addClass(css, _class) {
        if (Core.isBlank(css)) {
            return _class;
        }
        var parts = css.split(" ");
        parts.push(_class);
        return parts.unique().join(" ").trim();
    }
    RBAC.addClass = addClass;
})(RBAC || (RBAC = {}));
var RBAC;
(function (RBAC) {
    var RBACTasksImpl = (function (_super) {
        __extends(RBACTasksImpl, _super);
        function RBACTasksImpl(deferred) {
            _super.call(this);
            this.deferred = deferred;
            this.ACLMBean = null;
        }
        RBACTasksImpl.prototype.initialize = function (mbean) {
            this.ACLMBean = mbean;
            this.deferred.resolve(this.ACLMBean);
            _super.prototype.execute.call(this);
        };
        RBACTasksImpl.prototype.getACLMBean = function () {
            if (this.deferred === null) {
            }
            return this.deferred.promise;
        };
        return RBACTasksImpl;
    })(Core.TasksImpl);
    RBAC.RBACTasksImpl = RBACTasksImpl;
    RBAC.rbacTasks = null;
})(RBAC || (RBAC = {}));
var RBAC;
(function (RBAC) {
    RBAC.pluginName = "hawtioRbac";
    RBAC._module = angular.module(RBAC.pluginName, ["hawtioCore"]);
    var TREE_POSTPROCESSOR_NAME = "rbacTreePostprocessor";
    RBAC._module.factory('rbacTasks', ["postLoginTasks", "jolokia", "$q", function (postLoginTasks, jolokia, $q) {
        RBAC.rbacTasks = new RBAC.RBACTasksImpl($q.defer());
        postLoginTasks.addTask("FetchJMXSecurityMBeans", function () {
            jolokia.request({
                type: 'search',
                mbean: '*:type=security,area=jmx,*'
            }, onSuccess(function (response) {
                var mbeans = response.value;
                var chosen = "";
                if (mbeans.length === 0) {
                    RBAC.log.info("Didn't discover any JMXSecurity mbeans, client-side role based access control is disabled");
                    return;
                }
                else if (mbeans.length === 1) {
                    chosen = mbeans.first();
                }
                else if (mbeans.length > 1) {
                    var picked = false;
                    mbeans.forEach(function (mbean) {
                        if (picked) {
                            return;
                        }
                        if (mbean.has("HawtioDummy")) {
                            return;
                        }
                        if (!mbean.has("rank=")) {
                            chosen = mbean;
                            picked = true;
                        }
                    });
                }
                RBAC.log.info("Using mbean ", chosen, " for client-side role based access control");
                RBAC.rbacTasks.initialize(chosen);
            }));
        });
        return RBAC.rbacTasks;
    }]);
    RBAC._module.factory('rbacACLMBean', ["rbacTasks", function (rbacTasks) {
        return rbacTasks.getACLMBean();
    }]);
    RBAC._module.run(["jolokia", "rbacTasks", "preLogoutTasks", "workspace", "$rootScope", function (jolokia, rbacTasks, preLogoutTasks, workspace, $rootScope) {
        preLogoutTasks.addTask("resetRBAC", function () {
            RBAC.log.debug("Resetting RBAC tasks");
            rbacTasks.reset();
            workspace.removeTreePostProcessors(TREE_POSTPROCESSOR_NAME);
        });
        rbacTasks.addTask("JMXTreePostProcess", function () {
            workspace.addTreePostProcessor(function (tree) {
                rbacTasks.getACLMBean().then(function (mbean) {
                    var mbeans = {};
                    RBAC.flattenMBeanTree(mbeans, tree);
                    var requests = [];
                    var bulkRequest = {};
                    angular.forEach(mbeans, function (value, key) {
                        if (!('canInvoke' in value)) {
                            requests.push({
                                type: 'exec',
                                mbean: mbean,
                                operation: 'canInvoke(java.lang.String)',
                                arguments: [key]
                            });
                            if (value.mbean && value.mbean.op) {
                                var ops = value.mbean.op;
                                value.mbean.opByString = {};
                                var opList = [];
                                angular.forEach(ops, function (op, opName) {
                                    function addOp(opName, op) {
                                        var operationString = Core.operationToString(opName, op.args);
                                        value.mbean.opByString[operationString] = op;
                                        opList.push(operationString);
                                    }
                                    if (angular.isArray(op)) {
                                        op.forEach(function (op) {
                                            addOp(opName, op);
                                        });
                                    }
                                    else {
                                        addOp(opName, op);
                                    }
                                });
                                bulkRequest[key] = opList;
                            }
                        }
                    });
                    requests.push({
                        type: 'exec',
                        mbean: mbean,
                        operation: 'canInvoke(java.util.Map)',
                        arguments: [bulkRequest]
                    });
                    var numResponses = 0;
                    var maybeRedraw = function () {
                        numResponses = numResponses + 1;
                        if (numResponses >= requests.length) {
                            workspace.redrawTree();
                            RBAC.log.debug("Enriched workspace tree: ", tree);
                            Core.$apply($rootScope);
                        }
                    };
                    jolokia.request(requests, onSuccess(function (response) {
                        var mbean = response.request.arguments[0];
                        if (mbean && angular.isString(mbean)) {
                            mbeans[mbean]['canInvoke'] = response.value;
                            var toAdd = "cant-invoke";
                            if (response.value) {
                                toAdd = "can-invoke";
                            }
                            mbeans[mbean]['addClass'] = RBAC.stripClasses(mbeans[mbean]['addClass']);
                            mbeans[mbean]['addClass'] = RBAC.addClass(mbeans[mbean]['addClass'], toAdd);
                            maybeRedraw();
                        }
                        else {
                            var responseMap = response.value;
                            angular.forEach(responseMap, function (operations, mbeanName) {
                                angular.forEach(operations, function (data, operationName) {
                                    mbeans[mbeanName].mbean.opByString[operationName]['canInvoke'] = data['CanInvoke'];
                                });
                            });
                            maybeRedraw();
                        }
                    }, {
                        error: function (response) {
                            maybeRedraw();
                        }
                    }));
                });
            }, -1, TREE_POSTPROCESSOR_NAME);
        });
    }]);
    hawtioPluginLoader.addModule(RBAC.pluginName);
})(RBAC || (RBAC = {}));
var RBAC;
(function (RBAC) {
    var MBEAN_ONLY = 'canInvoke(java.lang.String)';
    var OVERLOADED_METHOD = 'canInvoke(java.lang.String,java.lang.String)';
    var EXACT_METHOD = 'canInvoke(java.lang.String,java.lang.String,[Ljava.lang.String;)';
    var HIDE = 'hide';
    var REMOVE = 'remove';
    var INVERSE = 'inverse';
    function getOp(objectName, methodName, argumentTypes) {
        var answer = MBEAN_ONLY;
        if (!Core.isBlank(methodName)) {
            answer = OVERLOADED_METHOD;
        }
        if (!Core.isBlank(argumentTypes)) {
            answer = EXACT_METHOD;
        }
        return answer;
    }
    function getArguments(op, objectName, methodName, argumentTypes) {
        var arguments = [];
        if (op === MBEAN_ONLY) {
            arguments.push(objectName);
        }
        else if (op === OVERLOADED_METHOD) {
            arguments.push(objectName);
            arguments.push(methodName);
        }
        else if (op === EXACT_METHOD) {
            arguments.push(objectName);
            arguments.push(methodName);
            arguments.push(argumentTypes.split(',').map(function (s) {
                return s.trim();
            }));
        }
        return arguments;
    }
    RBAC.hawtioShow = RBAC._module.directive('hawtioShow', ['workspace', function (workspace) {
        return {
            restrict: 'A',
            replace: false,
            link: function (scope, element, attr) {
                var objectName = attr['objectName'];
                if (!objectName) {
                    return;
                }
                function applyInvokeRights(value, mode) {
                    if (value) {
                        if (mode === INVERSE) {
                            element.css({
                                display: 'none'
                            });
                        }
                    }
                    else {
                        if (mode === REMOVE) {
                            element.css({
                                display: 'none'
                            });
                        }
                        else if (mode === HIDE) {
                            element.css({
                                visibility: 'hidden'
                            });
                        }
                    }
                }
                ;
                scope.$watch(function () {
                    var methodName = attr['methodName'];
                    var argumentTypes = attr['argumentTypes'];
                    var mode = attr['mode'] || HIDE;
                    var op = getOp(objectName, methodName, argumentTypes);
                    var args = getArguments(op, objectName, methodName, argumentTypes);
                    objectName = args[0];
                    methodName = args[1];
                    if (objectName) {
                        var mbean = Core.parseMBean(objectName);
                        var folder = workspace.findMBeanWithProperties(mbean.domain, mbean.attributes);
                        if (folder) {
                            var invokeRights;
                            if (methodName) {
                                invokeRights = workspace.hasInvokeRights(folder, methodName);
                            }
                            else {
                                invokeRights = workspace.hasInvokeRights(folder);
                            }
                            applyInvokeRights(invokeRights, mode);
                        }
                    }
                });
            }
        };
    }]);
})(RBAC || (RBAC = {}));
var Service;
(function (Service) {
    Service._module = angular.module(Service.pluginName, ['hawtioCore']);
    Service._module.factory("ServiceRegistry", ['$http', '$rootScope', 'workspace', function ($http, $rootScope, workspace) {
        var self = {
            name: 'ServiceRegistry',
            services: [],
            fetch: function (next) {
                if (Kubernetes.isKubernetesTemplateManager(workspace) || Service.pollServices) {
                    $http({
                        method: 'GET',
                        url: 'service'
                    }).success(function (data, status, headers, config) {
                        self.onSuccessfulPoll(next, data, status, headers, config);
                    }).error(function (data, status, headers, config) {
                        self.onFailedPoll(next, data, status, headers, config);
                    });
                }
            },
            onSuccessfulPoll: function (next, data, status, headers, config) {
                var triggerUpdate = ArrayHelpers.sync(self.services, data.items);
                if (triggerUpdate) {
                    Service.log.debug("Services updated: ", self.services);
                    Core.$apply($rootScope);
                }
                next();
            },
            onFailedPoll: function (next, data, status, headers, config) {
                Service.log.debug("Failed poll, data: ", data, " status: ", status);
                next();
            }
        };
        return self;
    }]);
    Service._module.run(['ServiceRegistry', '$timeout', 'jolokia', function (ServiceRegistry, $timeout, jolokia) {
        ServiceRegistry.go = PollHelpers.setupPolling(ServiceRegistry, function (next) {
            ServiceRegistry.fetch(next);
        }, 2000, $timeout, jolokia);
        ServiceRegistry.go();
        Service.log.debug("Loaded");
    }]);
    hawtioPluginLoader.addModule(Service.pluginName);
})(Service || (Service = {}));
var Site;
(function (Site) {
    var pluginName = 'site';
    Site._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ngGrid', 'datatable', 'hawtioCore', 'hawtio-ui']);
    Site._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/site', { templateUrl: 'app/site/html/index.html' }).when('/site/', { templateUrl: 'app/site/html/index.html' }).when('/site/book/*page', { templateUrl: 'app/site/html/book.html', reloadOnSearch: false }).when('/site/*page', { templateUrl: 'app/site/html/page.html' });
    }]);
    Site._module.run(["$location", "workspace", "viewRegistry", "layoutFull", "helpRegistry", function ($location, workspace, viewRegistry, layoutFull, helpRegistry) {
        viewRegistry[pluginName] = layoutFull;
        workspace.topLevelTabs.push({
            id: "site",
            content: "Site",
            title: "View the documentation for Hawtio",
            isValid: function (workspace) { return false; },
            href: function () { return "#/site"; }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Site || (Site = {}));
var Site;
(function (Site) {
    Site._module.controller("Site.IndexController", ["$scope", "$location", function ($scope, $location) {
        $scope.slideInterval = 5000;
    }]);
})(Site || (Site = {}));
var Site;
(function (Site) {
    Site._module.controller("Site.PageController", ["$scope", "$routeParams", "$location", "$compile", "$http", "fileExtensionTypeRegistry", function ($scope, $routeParams, $location, $compile, $http, fileExtensionTypeRegistry) {
        var log = Logger.get("Site");
        var pageId = $routeParams["page"];
        if (!pageId) {
            pageId = "README.md";
        }
        if (!pageId.startsWith("/") && pageId.indexOf(":/") < 0 && pageId.indexOf("app/site/") < 0) {
            pageId = "app/site/" + pageId;
        }
        $scope.pageId = pageId;
        $scope.pageFolder = pageId.substring(0, pageId.lastIndexOf('/') + 1);
        log.info("Loading page '" + $scope.pageId + "'");
        $scope.getContents = function (filename, cb) {
            var fullPath = $scope.pageFolder + filename;
            log.info("Loading the contents of: " + fullPath);
            $http.get(fullPath).success(cb).error(function () { return cb(" "); });
        };
        $http.get($scope.pageId).success(onResults);
        function onResults(contents, status, headers, config) {
            $scope.contents = contents;
            $scope.html = contents;
            var format = Wiki.fileFormat($scope.pageId, fileExtensionTypeRegistry) || "markdown";
            if ("markdown" === format) {
                $scope.html = contents ? marked(contents) : "";
            }
            else if (format && format.startsWith("html")) {
                $scope.html = contents;
            }
            else {
            }
            $compile($scope.html)($scope);
            Core.$apply($scope);
        }
    }]);
})(Site || (Site = {}));
var Source;
(function (Source) {
    Source.log = Logger.get("Source");
    function getInsightMBean(workspace) {
        var mavenStuff = workspace.mbeanTypesToDomain["LogQuery"] || {};
        var insight = mavenStuff["org.fusesource.insight"] || mavenStuff["io.fabric8.insight"] || {};
        var mbean = insight.objectName;
        return mbean;
    }
    Source.getInsightMBean = getInsightMBean;
    function createBreadcrumbLinks(mavenCoords, pathName) {
        var linkPrefix = "#/source/index/" + mavenCoords;
        var answer = [{ href: linkPrefix, name: "root" }];
        if (pathName) {
            var pathNames = pathName.split("/");
            var fullPath = "";
            angular.forEach(pathNames, function (path) {
                fullPath += "/" + path;
                var href = linkPrefix + fullPath;
                if (!path.isBlank()) {
                    answer.push({ href: href, name: path || "/", fileName: "/" + fullPath });
                }
            });
        }
        return answer;
    }
    Source.createBreadcrumbLinks = createBreadcrumbLinks;
})(Source || (Source = {}));
var Source;
(function (Source) {
    var pluginName = 'source';
    Source._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'hawtioCore', 'wiki']);
    Source._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/source/index/:mavenCoords', { templateUrl: 'app/source/html/index.html' }).when('/source/index/:mavenCoords/*page', { templateUrl: 'app/source/html/index.html' }).when('/source/view/:mavenCoords/class/:className/*page', { templateUrl: 'app/source/html/source.html' }).when('/source/view/:mavenCoords/*page', { templateUrl: 'app/source/html/source.html' }).when('/source/javadoc/:mavenCoords/*page', { templateUrl: 'app/source/html/javadoc.html' });
    }]);
    Source._module.run(["$location", "workspace", "viewRegistry", "jolokia", "localStorage", "layoutFull", "helpRegistry", function ($location, workspace, viewRegistry, jolokia, localStorage, layoutFull, helpRegistry) {
        viewRegistry['source'] = layoutFull;
        helpRegistry.addUserDoc('source', 'app/source/doc/help.md');
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Source || (Source = {}));
var Source;
(function (Source) {
    Source._module.controller("Source.IndexController", ["$scope", "$location", "$routeParams", "workspace", "jolokia", function ($scope, $location, $routeParams, workspace, jolokia) {
        $scope.pageId = Wiki.pageId($routeParams, $location);
        $scope.mavenCoords = $routeParams["mavenCoords"];
        var fileName = $scope.pageId;
        if (fileName === '/') {
            fileName = undefined;
        }
        $scope.loadingMessage = "Loading source code from artifacts <b>" + $scope.mavenCoords + "</b>";
        createBreadcrumbs();
        $scope.setFileName = function (breadcrumb) {
            fileName = Core.trimLeading(breadcrumb.fileName, "/");
            fileName = Core.trimLeading(fileName, "/");
            console.log("selected fileName '" + fileName + "'");
            createBreadcrumbs();
            filterFileNames();
        };
        $scope.$watch('workspace.tree', function (newValue, oldValue) {
            if (!$scope.git && Git.getGitMBean(workspace)) {
                setTimeout(maybeUpdateView, 50);
            }
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(maybeUpdateView, 50);
        });
        function filterFileNames() {
            if (fileName) {
                $scope.sourceFiles = $scope.allSourceFiles.filter(function (n) { return n && n.startsWith(fileName); }).map(function (n) { return n.substring(fileName.length + 1); }).filter(function (n) { return n; });
            }
            else {
                $scope.sourceFiles = $scope.allSourceFiles;
            }
        }
        $scope.sourceLinks = function (aFile) {
            var name = aFile;
            var paths = null;
            var idx = aFile.lastIndexOf('/');
            if (idx > 0) {
                name = aFile.substring(idx + 1);
                paths = aFile.substring(0, idx);
            }
            var answer = "";
            var fullName = fileName || "";
            if (paths) {
                angular.forEach(paths.split("/"), function (path) {
                    if (fullName) {
                        fullName += "/";
                    }
                    fullName += path;
                    answer += "<a href='#/source/index/" + $scope.mavenCoords + "/" + fullName + "'>" + path + "</a>/";
                });
            }
            answer += "<a href='#/source/view/" + $scope.mavenCoords + "/" + fullName + "/" + name + "'>" + name + "</a>";
            return answer;
        };
        function createBreadcrumbs() {
            $scope.breadcrumbs = Source.createBreadcrumbLinks($scope.mavenCoords, fileName);
            angular.forEach($scope.breadcrumbs, function (breadcrumb) {
                breadcrumb.active = false;
            });
            $scope.breadcrumbs.last().active = true;
        }
        function viewContents(response) {
            if (response) {
                $scope.allSourceFiles = response.split("\n").map(function (n) { return n.trim(); }).filter(function (n) { return n; });
            }
            else {
                $scope.allSourceFiles = [];
            }
            filterFileNames();
            $scope.loadingMessage = null;
            Core.$apply($scope);
        }
        function updateView() {
            if (!$scope.mavenCoords) {
                return;
            }
            var mbean = Source.getInsightMBean(workspace);
            Source.log.debug("In update view, mbean: ", mbean);
            if (mbean) {
                jolokia.execute(mbean, "getSource", $scope.mavenCoords, null, "/", {
                    success: viewContents,
                    error: function (response) {
                        Source.log.error("Failed to download the source code for the maven artifact: ", $scope.mavenCoords);
                        Source.log.info("Stack trace: ", response.stacktrace);
                        $scope.loadingMessage = "Could not download index, please see console for details";
                        Core.$apply($scope);
                    }
                });
            }
        }
        var maybeUpdateView = Core.throttled(updateView, 1000);
        setTimeout(maybeUpdateView, 50);
    }]);
})(Source || (Source = {}));
var Source;
(function (Source) {
    Source._module.controller("Source.JavaDocController", ["$scope", "$location", "$routeParams", "workspace", "fileExtensionTypeRegistry", "jolokia", function ($scope, $location, $routeParams, workspace, fileExtensionTypeRegistry, jolokia) {
        $scope.pageId = Wiki.pageId($routeParams, $location);
        var mavenCoords = $routeParams["mavenCoords"];
        var fileName = $scope.pageId;
        $scope.loadingMessage = "Loading javadoc code for file <b>" + fileName + "</b> from artifacts <b>" + mavenCoords + "</b>";
        $scope.breadcrumbs = [];
        $scope.$watch('workspace.tree', function () {
            if (!$scope.git && Git.getGitMBean(workspace)) {
                setTimeout(updateView, 50);
            }
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateView, 50);
        });
        function viewContents(response) {
            $scope.source = response;
            $scope.loadingMessage = null;
            if (!response) {
                var time = new Date().getTime();
                if (!$scope.lastErrorTime || time - $scope.lastErrorTime > 3000) {
                    $scope.lastErrorTime = time;
                    Core.notification("error", "Could not download the source code for the maven artifacts: " + mavenCoords);
                }
            }
            Core.$apply($scope);
        }
        function updateView() {
            var mbean = Source.getInsightMBean(workspace);
            if (mbean) {
                jolokia.execute(mbean, "getJavaDoc", mavenCoords, fileName, onSuccess(viewContents));
            }
        }
    }]);
})(Source || (Source = {}));
var Source;
(function (Source) {
    Source._module.controller("Source.SourceController", ["$scope", "$location", "$routeParams", "workspace", "fileExtensionTypeRegistry", "jolokia", function ($scope, $location, $routeParams, workspace, fileExtensionTypeRegistry, jolokia) {
        $scope.pageId = Wiki.pageId($routeParams, $location);
        $scope.format = Wiki.fileFormat($scope.pageId, fileExtensionTypeRegistry);
        var lineNumber = $location.search()["line"] || 1;
        var mavenCoords = $routeParams["mavenCoords"];
        var className = $routeParams["className"] || "";
        var fileName = $scope.pageId || "/";
        var classNamePath = className.replace(/\./g, '/');
        $scope.loadingMessage = "Loading source code for class <b>" + className + "</b> from artifacts <b>" + mavenCoords + "</b>";
        $scope.breadcrumbs = [];
        var idx = fileName.lastIndexOf('/');
        var path = "/";
        var name = fileName;
        if (idx > 0) {
            path = fileName.substring(0, idx);
            name = fileName.substring(idx + 1);
        }
        else if (className && className.indexOf('.') > 0) {
            path = classNamePath;
            idx = path.lastIndexOf('/');
            if (idx > 0) {
                name = path.substring(idx + 1);
                path = path.substring(0, idx);
            }
        }
        $scope.breadcrumbs = Source.createBreadcrumbLinks(mavenCoords, path);
        $scope.breadcrumbs.push({ href: $location.url(), name: name, active: true });
        $scope.javaDocLink = function () {
            var path = classNamePath;
            if (!path && fileName && fileName.endsWith(".java")) {
                path = fileName.substring(0, fileName.length - 5);
            }
            if (path) {
                return "javadoc/" + mavenCoords + "/" + path + ".html";
            }
            return null;
        };
        function updateLineSelection() {
            var codeMirror = $scope.codeMirror;
            if (codeMirror && lineNumber) {
                var line = lineNumber - 1;
                var lineText = codeMirror.getLine(line);
                var endChar = (lineText) ? lineText.length : 1000;
                var start = { line: line, ch: 0 };
                var end = { line: line, ch: endChar };
                codeMirror.scrollIntoView(start);
                codeMirror.setCursor(start);
                codeMirror.setSelection(start, end);
                codeMirror.refresh();
                codeMirror.focus();
            }
        }
        $scope.$watch('workspace.tree', function (oldValue, newValue) {
            if (!$scope.git && Git.getGitMBean(workspace)) {
                setTimeout(maybeUpdateView, 50);
            }
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(maybeUpdateView, 50);
        });
        function viewContents(response) {
            if (response) {
                Source.log.debug("Downloaded file for the maven artifact: " + mavenCoords);
                $scope.source = response;
                $scope.loadingMessage = null;
            }
            else {
                $scope.source = null;
                $scope.loadingMessage = "Cannot download file, please see logging console for details.";
                Source.log.error("Failed to download the source code for the Maven artifact: ", mavenCoords);
            }
            Core.$apply($scope);
            setTimeout(updateLineSelection, 100);
        }
        function updateView() {
            var mbean = Source.getInsightMBean(workspace);
            if (mbean) {
                jolokia.execute(mbean, "getSource", mavenCoords, className, fileName, {
                    success: viewContents,
                    error: function (response) {
                        Source.log.error("Failed to download the source code for the Maven artifact: ", mavenCoords);
                        Source.log.info("Stack trace: ", response.stacktrace);
                        $scope.loadingMessage = "Cannot not download file, please see logging console for details.";
                        Core.$apply($scope);
                    }
                });
            }
        }
        var maybeUpdateView = Core.throttled(updateView, 1000);
        setTimeout(maybeUpdateView, 50);
    }]);
})(Source || (Source = {}));
var SpringBoot;
(function (SpringBoot) {
    var pluginName = 'springBoot';
    SpringBoot._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ui.bootstrap.dialog', 'hawtioCore']);
    SpringBoot._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/springBoot/metrics', { templateUrl: 'app/springBoot/html/metrics.html' }).when('/springBoot/beans', { templateUrl: 'app/springBoot/html/beans.html' });
    }]);
    SpringBoot._module.run(["$location", "$http", "workspace", "viewRegistry", "helpRegistry", "jolokia", function ($location, $http, workspace, viewRegistry, helpRegistry, jolokia) {
        viewRegistry['springBoot'] = "app/springBoot/html/layoutSpringBootTabs.html";
        SpringBoot.callIfSpringBootAppAvailable(jolokia, function () {
            workspace.topLevelTabs.push({
                id: "springBoot",
                content: "Spring Boot",
                title: "Manage your Spring Boot application",
                isValid: function (workspace) {
                    return true;
                },
                href: function () {
                    return "#/springBoot/metrics";
                },
                isActive: function (workspace) {
                    return workspace.isTopTabActive("springBoot");
                }
            });
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(SpringBoot || (SpringBoot = {}));
var SpringBoot;
(function (SpringBoot) {
    SpringBoot.metricsMBean = 'org.springframework.boot:type=Endpoint,name=metricsEndpoint';
    SpringBoot.metricsMBeanOperation = 'getData()';
    function callIfSpringBootAppAvailable(jolokia, callbackFunc) {
        jolokia.execute(SpringBoot.metricsMBean, SpringBoot.metricsMBeanOperation, onSuccess(function (data) {
            callbackFunc();
        }));
    }
    SpringBoot.callIfSpringBootAppAvailable = callIfSpringBootAppAvailable;
    var metricsFriendlyNames = {
        'counter.status.200.favicon.ico': 'Successful Favicon requests',
        'counter.status.200.jolokia': 'Successful Jolokia requests',
        'counter.status.200.jolokia.exec.org.springframework.boot:type=Endpoint,name=metricsEndpoint.getData()': 'Successful metrics Jolokia requests',
        'counter.status.200.jolokia.read.java.lang:type=Runtime.Name': 'Successful Jolokia Runtime.Name reads',
        'counter.status.200.jolokia.root': 'Successful Jolokia root requests',
        'counter.status.200.jolokia.search.*:type=Connector,*': 'Successful Jolokia connectors search queries',
        'counter.status.200.metrics': 'Successful metrics REST requests',
        'counter.status.405.auth.login.root': 'Method Not Allowed (405) login responses',
        'gauge.response.auth.login.root': 'Authentication time (ms)',
        'gauge.response.jolokia': 'Jolokia response time (ms)',
        'gauge.response.jolokia.exec.org.springframework.boot:type=Endpoint,name=metricsEndpoint.getData()': 'Metrics Jolokia response time (ms)',
        'gauge.response.jolokia.root': 'Jolokia root response time (ms)',
        'gauge.response.metrics': 'Metrics response time (ms)',
        'gc.ps_marksweep.count': 'Parallel scavenge mark-sweep collector count',
        'gc.ps_marksweep.time': 'Parallel scavenge mark-sweep collector time (ms)',
        'gc.ps_scavenge.count': 'Parallel scavenge collector count',
        'gc.ps_scavenge.time': 'Parallel scavenge collector time (ms)',
        'mem': 'Memory used (bytes)',
        'mem.free': 'Memory available (bytes)',
        'processors': 'Processors number',
        'uptime': 'Node uptime (ms)',
        'instance.uptime': 'Service uptime (ms)',
        'heap.committed': 'Heap committed (bytes)',
        'heap.init': 'Initial heap (bytes)',
        'heap.used': 'Heap used (bytes)',
        'heap': 'Total Heap (bytes)',
        'classes': 'Classes',
        'classes.loaded': 'Classes loaded',
        'classes.unloaded': 'Classes unloaded',
        'threads': 'Threads count',
        'threads.daemon': 'Daemon threads',
        'threads.peak': 'Threads peak count'
    };
    function convertRawMetricsToUserFriendlyFormat(scope, data) {
        var userFriendlyData = [];
        var metricIndex;
        for (metricIndex in Object.keys(data)) {
            var metric = Object.keys(data)[metricIndex];
            var friendlyName = metricsFriendlyNames[metric];
            if (!friendlyName) {
                userFriendlyData[metricIndex] = { code: metric, name: metric, value: data[metric] };
            }
            else {
                userFriendlyData[metricIndex] = { code: metric, name: friendlyName, value: data[metric] };
            }
        }
        scope.metrics = userFriendlyData;
        scope.$apply();
    }
    SpringBoot.convertRawMetricsToUserFriendlyFormat = convertRawMetricsToUserFriendlyFormat;
})(SpringBoot || (SpringBoot = {}));
var SpringBoot;
(function (SpringBoot) {
    SpringBoot._module.controller("SpringBoot.BeansController", ["$scope", "jolokia", function ($scope, jolokia) {
        jolokia.execute('org.springframework.boot:type=Endpoint,name=beansEndpoint', SpringBoot.metricsMBeanOperation, onSuccess(function (data) {
            $scope.beans = data[0]['beans'];
            $scope.$apply();
        }, { error: function () {
            $scope.loadingError = 'Cannot read beans data.';
            $scope.$apply();
        } }));
    }]);
})(SpringBoot || (SpringBoot = {}));
var SpringBoot;
(function (SpringBoot) {
    SpringBoot._module.controller("SpringBoot.MetricsController", ["$scope", "jolokia", function ($scope, jolokia) {
        jolokia.execute(SpringBoot.metricsMBean, SpringBoot.metricsMBeanOperation, onSuccess(function (data) {
            SpringBoot.convertRawMetricsToUserFriendlyFormat($scope, data);
        }, { error: function () {
            $scope.loadingError = 'Cannot read metrics data.';
            $scope.$apply();
        } }));
        $scope.metricsGridOptions = {
            data: 'metrics',
            showSelectionCheckbox: false,
            sortInfo: {
                sortBy: 'name',
                ascending: true
            },
            columnDefs: [
                {
                    field: 'name',
                    displayName: 'Metric',
                    cellTemplate: '<div class="ngCellText" hawtio-template-popover content="metricDetails" title="Metric details">{{row.entity.name}}</div>'
                },
                {
                    field: 'value',
                    displayName: 'Metric value'
                }
            ]
        };
    }]);
})(SpringBoot || (SpringBoot = {}));
var SpringBatch;
(function (SpringBatch) {
    function getHost(link) {
        var endIdx;
        if (link.indexOf('\\') >= 0)
            endIdx = link.indexOf('\\');
        else
            endIdx = link.indexOf(':');
        return link.substring(0, endIdx);
    }
    SpringBatch.getHost = getHost;
    function getPort(link) {
        return link.substring(link.indexOf(':') + 1, link.indexOf('/'));
    }
    SpringBatch.getPort = getPort;
    function getServerSuffix(link) {
        if (link.indexOf('/') != link.lastIndexOf('/'))
            return link.substring(link.indexOf('/') + 1, link.lastIndexOf('/'));
        else
            return '';
    }
    SpringBatch.getServerSuffix = getServerSuffix;
    function getServerUrl(host, port, path) {
        var server = '';
        server = host + '\\:' + port;
        if (path) {
            if (path.charAt(0) != '/')
                server = server + '/' + path;
            else
                server = server + path;
        }
        if (server.charAt(server.length - 1) != '/') {
            server = server + '/';
        }
        return server;
    }
    SpringBatch.getServerUrl = getServerUrl;
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch.templatePath = 'app/springbatch/html/';
    SpringBatch.pluginName = 'SpringBatch';
    SpringBatch._module = angular.module(SpringBatch.pluginName, ['bootstrap', 'ngResource', 'hawtioCore', 'hawtio-ui']);
    SpringBatch._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/springbatch/servers', { templateUrl: SpringBatch.templatePath + 'serverList.html' }).when('/springbatch/jobs', { templateUrl: SpringBatch.templatePath + 'jobs.html' }).when('/springbatch/jobs/:jobName/executions', { templateUrl: SpringBatch.templatePath + 'overview.html' }).when('/springbatch/jobs/:jobName/executions/:jobInstanceId', { templateUrl: SpringBatch.templatePath + 'overview.html' }).when('/springbatch/jobs/executions', { templateUrl: SpringBatch.templatePath + 'jobsExecutionList.html' }).when('/springbatch/connect', { templateUrl: SpringBatch.templatePath + 'connectSpringBatch.html' }).when('/springbatch/jobs/:jobId/executions/:jobName/:jobExecutionId', { templateUrl: SpringBatch.templatePath + 'jobExecutionContext.html' }).when('/springbatch/jobs/:jobName/:jobId/history/executions', { templateUrl: SpringBatch.templatePath + 'executionHistory.html' }).when('/springbatch/jobs/:jobId/executions/:jobName/:jobExecutionId/steps/:stepExecutionId', { templateUrl: SpringBatch.templatePath + 'stepExecutionContext.html' }).when('/springbatch/jobs/:host/:port/:serverSuffix', { templateUrl: SpringBatch.templatePath + 'jobs.html' }).when('/springbatch/jobs/:host/:port', { templateUrl: SpringBatch.templatePath + 'jobs.html' });
    }]);
    SpringBatch._module.run(["$location", "workspace", "viewRegistry", "$rootScope", "$resource", function ($location, workspace, viewRegistry, $rootScope, $resource) {
        viewRegistry['springbatch'] = 'app/springbatch/html/layoutSpringBatch.html';
        workspace.topLevelTabs.push({
            id: "springbatch",
            content: "SpringBatch",
            title: "View Spring-Batch jobs",
            isValid: function (workspace) {
                return false;
            },
            href: function () { return "#/springbatch/servers"; },
            isActive: function (workspace) { return workspace.isTopTabActive("springbatch"); }
        });
        $rootScope.proxyUrl = '/hawtio/proxy/';
        $rootScope.alert = {
            enable: false,
            content: '',
            type: '',
            hide: function () {
                this.enable = false;
            },
            show: function () {
                this.enable = true;
            }
        };
    }]);
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch._module.controller("SpringBatch.ConnectSpringBatchController", ["$scope", "$routeParams", "$location", "workspace", "$rootScope", "$resource", "$http", function ($scope, $routeParams, $location, workspace, $rootScope, $resource, $http) {
        $scope.host = 'localhost';
        $scope.port = 8080;
        $scope.connectSpringBatch = function () {
            if ($scope.selectedSpringBatchServer) {
                $rootScope.springBatchServer = $scope.selectedSpringBatchServer;
                $rootScope.alert.content = 'Connected successfully.';
                $rootScope.alert.type = 'alert-success';
                $rootScope.alert.show();
            }
        };
        $scope.addSpringBatchServerToGlobalList = function () {
            var server = SpringBatch.getServerUrl($scope.host, $scope.port, $scope.path);
            if ($rootScope.springBatchServerList.indexOf($scope.selectedSpringBatchServer) > 0) {
                $rootScope.alert.content = 'Server already in the list.';
                $rootScope.alert.type = 'alert-error';
                $rootScope.alert.show();
                return;
            }
            $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
            $http.post('/hawtio/springBatch', 'server=' + server).success(function (data) {
                $rootScope.springBatchServerList.add(server);
                $rootScope.springBatchServer = $scope.selectedSpringBatchServer;
                $rootScope.alert.content = 'Server added.';
                $rootScope.alert.type = 'alert-success';
                $rootScope.alert.show();
            }).error(function (data) {
                $rootScope.alert.content = 'Could not add server.';
                $rootScope.alert.type = 'alert-error';
                $rootScope.alert.show();
            });
        };
        $scope.removeServer = function (index) {
            $http.delete('/hawtio/springBatch?server=' + encodeURIComponent($scope.selectedSpringBatchServer)).success(function (data) {
                $scope.springBatchServerList.splice($scope.springBatchServerList.indexOf($scope.selectedSpringBatchServer), 1);
                $rootScope.alert.content = 'Server deleted.';
                $rootScope.alert.type = 'alert-info';
                $rootScope.alert.show();
            }).error(function (data) {
                $rootScope.alert.content = 'Could not delete server.';
                $rootScope.alert.type = 'alert-error';
                $rootScope.alert.show();
            });
        };
        $scope.editServer = function () {
            $scope.host = SpringBatch.getHost($scope.selectedSpringBatchServer);
            $scope.port = parseInt(SpringBatch.getPort($scope.selectedSpringBatchServer));
            $scope.path = SpringBatch.getServerSuffix($scope.selectedSpringBatchServer);
        };
        $scope.updateServer = function () {
            var server = SpringBatch.getServerUrl($scope.host, $scope.port, $scope.path);
            var replaceServer = $scope.selectedSpringBatchServer;
            $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
            $http.post('/hawtio/springBatch', 'server=' + server + '&replaceServer=' + replaceServer).success(function (data) {
                $rootScope.springBatchServerList[$rootScope.springBatchServerList.indexOf($scope.selectedSpringBatchServer)] = server;
                $rootScope.alert.content = 'Server updated.';
                $rootScope.alert.type = 'alert-success';
                $rootScope.alert.show();
            }).error(function (data) {
                $rootScope.alert.content = 'Could not add server.';
                $rootScope.alert.type = 'alert-error';
                $rootScope.alert.show();
            });
        };
    }]);
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch._module.controller("SpringBatch.ExecutionHistoryController", ["$scope", "$routeParams", "$location", "workspace", "$resource", "$rootScope", function ($scope, $routeParams, $location, workspace, $resource, $rootScope) {
        var springBatchServerOrigin = $rootScope.springBatchServer;
        var proxyUrl = '/hawtio/proxy/';
        var executionHistoryPath = 'jobs/:jobName/executions.json';
        $scope.predicate = 'id';
        $scope.reverse = false;
        var jobExecutionRes = $resource(proxyUrl + springBatchServerOrigin + executionHistoryPath);
        jobExecutionRes.get({ 'jobName': $routeParams.jobName }, function (data) {
            var executionList = new Array();
            for (var execution in data.jobExecutions) {
                data.jobExecutions[execution].id = execution;
                executionList.add(data.jobExecutions[execution]);
            }
            $scope.executionHistory = executionList;
            $scope.jobName = $routeParams.jobName;
            $scope.jobId = $routeParams.jobId;
        });
    }]);
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch._module.controller("SpringBatch.jobExecutionContextController", ["$scope", "$routeParams", "$http", "$rootScope", function ($scope, $routeParams, $http, $rootScope) {
        var springBatchServerOrigin = $rootScope.springBatchServer;
        var proxyUrl = '/hawtio';
        var jobExecutionId = $routeParams.jobExecutionId;
        var jobName = $routeParams.jobName;
        var jobId = $routeParams.jobId;
        $scope.springBatchServer = springBatchServerOrigin;
        var jobExecutionContext = $http.get(proxyUrl + "/contextFormatter?jobExecutionId=" + jobExecutionId + "&server=" + springBatchServerOrigin + "&contextType=jobExecution").success(function (data) {
            $scope.htmlView = data;
        });
        $scope.jobId = jobId;
        $scope.jobName = jobName;
    }]);
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch._module.controller("SpringBatch.NavBarController", ["$scope", "$routeParams", "$location", "workspace", function ($scope, $routeParams, $location, workspace) {
        var subLevelTabs = [
            { uri: 'servers', name: 'Servers List' },
            { uri: 'jobs/executions', name: 'Jobs Execution List' },
            { uri: 'connect', name: 'Connect' }
        ];
        $scope.subLevelTabs = subLevelTabs;
        $scope.isActive = function (tab) {
            return false;
        };
    }]);
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch._module.controller("SpringBatch.JobOverviewExecListController", ["$scope", "$routeParams", "$location", "workspace", "jolokia", "$resource", "$rootScope", "$http", function ($scope, $routeParams, $location, workspace, jolokia, $resource, $rootScope, $http) {
        var springBatchServerOrigin = $rootScope.springBatchServer;
        var springBatchServerPath = springBatchServerOrigin + 'jobs/:jobName';
        var proxyUrl = $rootScope.proxyUrl;
        var executionsListPath = '/:jobInstanceId/executions.json';
        var paramsListPath = 'jobs/:jobName/:jobInstanceId';
        var jobName = $routeParams.jobName;
        $scope.jobName = $routeParams.jobName;
        var jobInstances = null;
        var jobList = $resource(proxyUrl + springBatchServerPath);
        $scope.springBatchServer = encodeURIComponent(springBatchServerOrigin);
        $scope.executionPredicate = 'name';
        $scope.executionReverse = false;
        $scope.stepPredicate = 'name';
        $scope.stepReverse = false;
        $scope.fetchAllExecutions = function (jobInstance) {
            if (jobInstance != undefined) {
                var jobList = $resource(proxyUrl + springBatchServerPath + executionsListPath);
                jobList.get({ 'jobName': jobName, jobInstanceId: jobInstance.id }, function (data) {
                    var jobExecutionList = new Array();
                    for (var execution in data.jobInstance.jobExecutions) {
                        data.jobInstance.jobExecutions[execution].id = execution;
                        jobExecutionList.add(data.jobInstance.jobExecutions[execution]);
                    }
                    $scope.jobName = jobName;
                    $scope.jobExecutionList = jobExecutionList;
                });
            }
        };
        $scope.fetchParams = function (jobName, jobInstanceId, executionId) {
            var paramsResource = $resource(proxyUrl + springBatchServerPath + paramsListPath);
            paramsResource.get({ 'jobName': jobName, 'jobInstanceId': jobInstanceId + '.json' }, function (data) {
                var jobParams = new Array();
                if (executionId) {
                    for (var param in data.jobInstance.jobExecutions[executionId].jobParameters) {
                        jobParams.add({ 'name': param, 'value': data.jobInstance.jobExecutions[executionId].jobParameters[param] });
                    }
                }
                else {
                    for (var execution in data.jobInstance.jobExecutions) {
                        for (var param in data.jobInstance.jobExecutions[execution].jobParameters) {
                            jobParams.add({ 'name': param, 'value': data.jobInstance.jobExecutions[execution].jobParameters[param] });
                        }
                        break;
                    }
                    $scope.jobParams = jobParams;
                }
            });
        };
        $scope.removeParam = function (jobParams, index) {
            jobParams.splice(index, 1);
        };
        $scope.addParam = function (jobParams, index) {
            jobParams.add({ name: '', value: '' });
        };
        $scope.runJob = function (jobName, jobParams) {
            if (jobName && jobParams) {
                var springServerOrigin = springBatchServerOrigin.replace('\\', '');
                var postUrl = proxyUrl + springServerOrigin + 'jobs/' + jobName + '.json';
                $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
                var params = '';
                for (var param in jobParams) {
                    params = params + jobParams[param].name + '=' + jobParams[param].value;
                    if ((param + 1) != jobParams.length) {
                        params = params + ',';
                    }
                }
                params = encodeURIComponent(params);
                $http.post(postUrl, 'jobParameters=' + params).success(function (data) {
                    if (data.jobExecution) {
                        $rootScope.alert.content = 'Job started successfully.';
                        $rootScope.alert.type = 'alert-success';
                        $rootScope.alert.show();
                    }
                    else if (data.errors) {
                        $rootScope.alert.content = '';
                        for (var message in data.errors) {
                            $rootScope.alert.content += data.errors[message] + '\n';
                            $rootScope.alert.type = 'alert-error';
                            $rootScope.alert.show();
                        }
                    }
                }).error(function (data) {
                    $rootScope.alert.content = 'Count not start the job';
                    $rootScope.alert.type = 'alert-error';
                    $rootScope.alert.show();
                });
            }
        };
        jobList.get({ 'jobName': jobName + '.json' }, function (data) {
            for (var job in data.job.jobInstances) {
                data.job.jobInstances[job].id = job;
                jobInstances = data.job.jobInstances;
            }
            if ($routeParams.jobInstanceId == undefined) {
                for (var job in data.job.jobInstances) {
                    $scope.jobInstance = jobInstances[job];
                    break;
                }
            }
            else {
                if (jobInstances && jobInstances[$routeParams.jobInstanceId]) {
                    $scope.jobInstance = jobInstances[$routeParams.jobInstanceId];
                }
            }
            if ($scope.jobInstance) {
                $scope.fetchAllExecutions($scope.jobInstance);
                $scope.fetchParams(jobName, $scope.jobInstance.id);
            }
            else {
                $scope.jobParams = new Array();
            }
        });
        $scope.refreshJobInstance = function (jobInstance) {
            var jobList = $resource(proxyUrl + springBatchServerPath);
            jobList.get({ 'jobName': jobName + '.json' }, function (data) {
                for (var job in data.job.jobInstances) {
                    data.job.jobInstances[job].id = job;
                }
                var jobInstanceId = null;
                if (jobInstance && jobInstance.id) {
                    jobInstanceId = jobInstance.id;
                    $scope.jobInstance = data.job.jobInstances[jobInstanceId];
                    $scope.fetchAllExecutions(data.job.jobInstances[jobInstanceId]);
                    $scope.fetchParams(jobName, jobInstanceId);
                }
                else {
                    for (var job in data.job.jobInstances) {
                        $scope.jobInstance = data.job.jobInstances[job];
                        $scope.fetchAllExecutions(data.job.jobInstances[job]);
                        $scope.fetchParams(jobName, job);
                        break;
                    }
                }
                $scope.stepExecutionList = null;
            });
        };
        $scope.fetchNextJobInstance = function (jobInstance) {
            var tempId = null;
            var jobList = $resource(proxyUrl + springBatchServerPath);
            jobList.get({ 'jobName': jobName + '.json' }, function (data) {
                for (var job in data.job.jobInstances) {
                    data.job.jobInstances[job].id = job;
                    if (jobInstance && jobInstance.id && (parseInt(job) > parseInt(jobInstance.id))) {
                        tempId = job;
                        break;
                    }
                    else if (jobInstance && jobInstance.id) {
                        tempId = jobInstance.id;
                    }
                }
                if (jobInstance) {
                    $scope.jobInstance = data.job.jobInstances[tempId];
                }
                else {
                    for (var job in data.job.jobInstances) {
                        $scope.jobInstance = data.job.jobInstances[job];
                        break;
                    }
                }
                if ($scope.jobInstance) {
                    $scope.fetchAllExecutions($scope.jobInstance);
                    $scope.fetchParams(jobName, $scope.jobInstance.id);
                }
                $scope.stepExecutionList = null;
            });
        };
        $scope.fetchPrevJobInstance = function (jobInstance) {
            var tempId = null;
            var jobList = $resource(proxyUrl + springBatchServerPath);
            jobList.get({ 'jobName': jobName + '.json' }, function (data) {
                for (var job in data.job.jobInstances) {
                    data.job.jobInstances[job].id = job;
                    if (jobInstance && jobInstance.id && (parseInt(job) < parseInt(jobInstance.id))) {
                        tempId = job;
                    }
                }
                if (jobInstance) {
                    if ((tempId == null) && jobInstance.id) {
                        tempId = jobInstance.id;
                    }
                    $scope.jobInstance = data.job.jobInstances[tempId];
                }
                else {
                    for (var job in data.job.jobInstances) {
                        $scope.jobInstance = data.job.jobInstances[job];
                        break;
                    }
                }
                if ($scope.jobInstance) {
                    $scope.fetchAllExecutions($scope.jobInstance);
                    $scope.fetchParams(jobName, $scope.jobInstance.id);
                }
                $scope.stepExecutionList = null;
            });
        };
        $scope.fetchStepsForExecution = function (executionId) {
            var jobList = $resource(proxyUrl + springBatchServerOrigin + 'jobs/executions/:executionId');
            jobList.get({ 'executionId': executionId + '.json' }, function (data) {
                var stepList = new Array();
                for (var execution in data.jobExecution.stepExecutions) {
                    data.jobExecution.stepExecutions[execution].name = execution;
                    stepList.add(data.jobExecution.stepExecutions[execution]);
                }
                $scope.executionId = executionId;
                $scope.stepExecutionList = stepList;
            });
        };
    }]);
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch._module.controller("SpringBatch.ServerListController", ["$scope", "$location", "workspace", "jolokia", "$resource", "$rootScope", "$http", function ($scope, $location, workspace, jolokia, $resource, $rootScope, $http) {
        var serverList = [];
        var serverHref = '';
        for (var server in $rootScope.springBatchServerList) {
            serverHref += '#/springbatch/jobs/';
            serverHref += SpringBatch.getHost($rootScope.springBatchServerList[server]) + '/';
            serverHref += SpringBatch.getPort($rootScope.springBatchServerList[server]);
            if (SpringBatch.getServerSuffix($rootScope.springBatchServerList[server]).length > 0)
                serverHref += '/' + SpringBatch.getServerSuffix($rootScope.springBatchServerList[server]);
            serverList.add({
                href: serverHref,
                hostname: SpringBatch.getHost($rootScope.springBatchServerList[server]),
                port: SpringBatch.getPort($rootScope.springBatchServerList[server])
            });
            serverHref = '';
        }
        $scope.serverList = serverList;
    }]);
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch._module.controller("SpringBatch.SpringBatchJobExecutionListController", ["$scope", "$resource", "$rootScope", function ($scope, $resource, $rootScope) {
        var springBatchServerOrigin = $rootScope.springBatchServer;
        if (springBatchServerOrigin == undefined) {
            $rootScope.alert.content = 'No Server selected. Please, use Connect or Server List screen to select one.';
            $rootScope.alert.type = 'alert-error';
            $rootScope.alert.show();
            return;
        }
        var springBatchServerPath = springBatchServerOrigin + 'jobs';
        var proxyUrl = $rootScope.proxyUrl;
        var executionsListPath = '/executions.json';
        $scope.predicate = 'name';
        $scope.reverse = false;
        var executionListRes = $resource(proxyUrl + springBatchServerPath + executionsListPath);
        executionListRes.get(function (data) {
            var executionList = new Array();
            for (var execution in data.jobExecutions) {
                data.jobExecutions[execution].id = execution;
                executionList.add(data.jobExecutions[execution]);
            }
            $scope.jobExecutions = executionList;
        });
    }]);
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch._module.controller("SpringBatch.JobListController", ["$scope", "$location", "workspace", "jolokia", "$resource", "$rootScope", "$http", "$routeParams", function ($scope, $location, workspace, jolokia, $resource, $rootScope, $http, $routeParams) {
        var targetServerHost = $routeParams.host;
        var targetServerPort = $routeParams.port;
        var targetServerSuffix = $routeParams.serverSuffix;
        var targetServer = targetServerHost + '\\:' + targetServerPort + '/';
        if ((targetServerSuffix != undefined) && (targetServerSuffix.length > 0))
            targetServer += (targetServerSuffix + '/');
        $rootScope.springBatchServer = targetServer;
        var springBatchServerPath = $rootScope.springBatchServer + 'jobs.json';
        var proxyUrl = $rootScope.proxyUrl;
        $scope.predicate = 'name';
        $scope.reverse = false;
        $scope.getJobList = function () {
            var jobList = $resource(proxyUrl + springBatchServerPath);
            jobList.get(function (data) {
                if (data.jobs && data.jobs.registrations) {
                    var jobList = new Array();
                    for (var job in data.jobs.registrations) {
                        data.jobs.registrations[job].showLaunchForm = false;
                        data.jobs.registrations[job].launchParams = '';
                        jobList.add(data.jobs.registrations[job]);
                    }
                    $scope.jobList = jobList;
                }
            });
        };
        $scope.getJobList();
        $scope.launchJob = function (jobName) {
            var job;
            for (var idx in $scope.jobList) {
                if ($scope.jobList[idx].name == jobName)
                    job = $scope.jobList[idx];
            }
            var params = job.launchParams;
            if (jobName && params) {
                var springServerOrigin = $rootScope.springBatchServer.replace('\\', '');
                var postUrl = proxyUrl + springServerOrigin + 'jobs/' + jobName + '.json';
                $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
                params = encodeURIComponent(params);
                $http.post(postUrl, 'jobParameters=' + params).success(function (data) {
                    if (data.jobExecution) {
                        $rootScope.alert.content = 'Job started successfully.';
                        $rootScope.alert.type = 'alert-success';
                        $rootScope.alert.show();
                        $scope.getJobList();
                    }
                    else if (data.errors) {
                        $rootScope.alert.content = '';
                        for (var message in data.errors) {
                            $rootScope.alert.content += data.errors[message] + '\n';
                            $rootScope.alert.type = 'alert-error';
                            $rootScope.alert.show();
                        }
                    }
                }).error(function (data) {
                    $rootScope.alert.content = 'Count not start the job';
                    $rootScope.alert.type = 'alert-error';
                    $rootScope.alert.show();
                });
            }
        };
    }]);
})(SpringBatch || (SpringBatch = {}));
var SpringBatch;
(function (SpringBatch) {
    SpringBatch._module.controller("SpringBatch.stepExecutionContextController", ["$scope", "$routeParams", "$http", "$rootScope", function ($scope, $routeParams, $http, $rootScope) {
        var springBatchServerOrigin = $rootScope.springBatchServer;
        var proxyUrl = '/hawtio';
        var jobExecutionId = $routeParams.jobExecutionId;
        var stepExecutionId = $routeParams.stepExecutionId;
        var jobName = $routeParams.jobName;
        var jobId = $routeParams.jobId;
        $scope.springBatchServer = springBatchServerOrigin;
        var stepExecutionContext = $http.get(proxyUrl + "/contextFormatter?jobExecutionId=" + jobExecutionId + "&stepExecutionId=" + stepExecutionId + "&server=" + springBatchServerOrigin + "&contextType=stepExecution").success(function (data) {
            $scope.htmlView = data;
        });
        $scope.jobName = jobName;
        $scope.jobId = jobId;
    }]);
})(SpringBatch || (SpringBatch = {}));
var Themes;
(function (Themes) {
    Themes._module.controller("Themes.PreferencesController", ["$scope", "localStorage", "branding", function ($scope, localStorage, branding) {
        $scope.availableThemes = Themes.getAvailableThemes();
        $scope.availableBrandings = Themes.getAvailableBrandings();
        Core.initPreferenceScope($scope, localStorage, {
            'theme': {
                'value': Themes.currentTheme,
                'override': function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        Themes.setTheme(newValue, branding);
                    }
                }
            },
            'branding': {
                'value': Themes.currentBranding,
                'override': function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        Themes.setBranding(newValue, branding);
                    }
                }
            }
        });
    }]);
})(Themes || (Themes = {}));
var Threads;
(function (Threads) {
    Threads.pluginName = 'threads';
    Threads.templatePath = 'app/threads/html/';
    Threads.log = Logger.get("Threads");
    Threads.jmxDomain = 'java.lang';
    Threads.mbeanType = 'Threading';
    Threads.mbean = Threads.jmxDomain + ":type=" + Threads.mbeanType;
    Threads._module = angular.module(Threads.pluginName, ['bootstrap', 'ngResource', 'hawtioCore', 'ui']);
    Threads._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/threads', { templateUrl: Threads.templatePath + 'index.html' });
    }]);
    Threads._module.run(["$location", "workspace", "viewRegistry", "layoutFull", "helpRegistry", function ($location, workspace, viewRegistry, layoutFull, helpRegistry) {
        viewRegistry['threads'] = layoutFull;
        helpRegistry.addUserDoc('threads', 'app/threads/doc/help.md');
        workspace.topLevelTabs.push({
            id: "threads",
            content: "Threads",
            title: "JVM Threads",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties(Threads.jmxDomain, { type: Threads.mbeanType }); },
            href: function () { return "#/threads"; },
            isActive: function (workspace) { return workspace.isTopTabActive("threads"); }
        });
    }]);
    hawtioPluginLoader.addModule(Threads.pluginName);
})(Threads || (Threads = {}));
var Threads;
(function (Threads) {
    Threads._module.controller("Threads.ThreadsController", ["$scope", "$routeParams", "$templateCache", "jolokia", function ($scope, $routeParams, $templateCache, jolokia) {
        $scope.selectedRowJson = '';
        $scope.lastThreadJson = '';
        $scope.getThreadInfoResponseJson = '';
        $scope.threads = [];
        $scope.totals = {};
        $scope.support = {};
        $scope.row = {};
        $scope.threadSelected = false;
        $scope.selectedRowIndex = -1;
        $scope.stateFilter = 'NONE';
        $scope.showRaw = {
            expanded: false
        };
        $scope.addToDashboardLink = function () {
            var href = "#/threads";
            var size = angular.toJson({
                size_x: 8,
                size_y: 2
            });
            var title = "Threads";
            return "#/dashboard/add?tab=dashboard&href=" + encodeURIComponent(href) + "&title=" + encodeURIComponent(title) + "&size=" + encodeURIComponent(size);
        };
        $scope.isInDashboardClass = function () {
            if (angular.isDefined($scope.inDashboard && $scope.inDashboard)) {
                return "threads-dashboard";
            }
            return "threads logbar";
        };
        $scope.$watch('searchFilter', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.threadGridOptions.filterOptions.filterText = newValue;
            }
        });
        $scope.$watch('stateFilter', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if ($scope.stateFilter === 'NONE') {
                    $scope.threads = $scope.unfilteredThreads;
                }
                else {
                    $scope.threads = $scope.filterThreads($scope.stateFilter, $scope.unfilteredThreads);
                }
            }
        });
        $scope.threadGridOptions = {
            selectedItems: [],
            data: 'threads',
            showSelectionCheckbox: false,
            enableRowClickSelection: true,
            multiSelect: false,
            primaryKeyFn: function (entity, idx) {
                return entity.threadId;
            },
            filterOptions: {
                filterText: ''
            },
            sortInfo: {
                sortBy: 'threadId',
                ascending: false
            },
            columnDefs: [
                {
                    field: 'threadId',
                    displayName: 'ID'
                },
                {
                    field: 'threadState',
                    displayName: 'State',
                    cellTemplate: $templateCache.get("threadStateTemplate")
                },
                {
                    field: 'threadName',
                    displayName: 'Name'
                },
                {
                    field: 'waitedTime',
                    displayName: 'Waited Time',
                    cellTemplate: '<div class="ngCellText" ng-show="row.entity.waitedTime > 0">{{row.entity.waitedTime | humanizeMs}}</div>'
                },
                {
                    field: 'blockedTime',
                    displayName: 'Blocked Time',
                    cellTemplate: '<div class="ngCellText" ng-show="row.entity.blockedTime > 0">{{row.entity.blockedTime | humanizeMs}}</div>'
                },
                {
                    field: 'inNative',
                    displayName: 'Native',
                    cellTemplate: '<div class="ngCellText"><span ng-show="row.entity.inNative" class="orange">(in native)</span></div>'
                },
                {
                    field: 'suspended',
                    displayName: 'Suspended',
                    cellTemplate: '<div class="ngCellText"><span ng-show="row.entity.suspended" class="red">(suspended)</span></div>'
                }
            ]
        };
        $scope.$watch('threadGridOptions.selectedItems', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                if (newValue.length === 0) {
                    $scope.row = {};
                    $scope.threadSelected = false;
                    $scope.selectedRowIndex = -1;
                }
                else {
                    $scope.row = newValue.first();
                    $scope.threadSelected = true;
                    $scope.selectedRowIndex = Core.pathGet($scope, ['hawtioSimpleTable', 'threads', 'rows']).findIndex(function (t) {
                        return t.entity['threadId'] === $scope.row['threadId'];
                    });
                }
                $scope.selectedRowJson = angular.toJson($scope.row, true);
            }
        }, true);
        $scope.filterOn = function (state) {
            $scope.stateFilter = state;
        };
        $scope.filterThreads = function (state, threads) {
            Threads.log.debug("Filtering threads by: ", state);
            if (state === 'NONE') {
                return threads;
            }
            return threads.filter(function (t) {
                return t && t['threadState'] === state;
            });
        };
        $scope.selectedFilterClass = function (state) {
            if (state === $scope.stateFilter) {
                return "active";
            }
            else {
                return "";
            }
        };
        $scope.deselect = function () {
            $scope.threadGridOptions.selectedItems = [];
        };
        $scope.selectThreadById = function (id) {
            $scope.threadGridOptions.selectedItems = $scope.threads.filter(function (t) {
                return t.threadId === id;
            });
        };
        $scope.selectThreadByIndex = function (idx) {
            var selectedThread = Core.pathGet($scope, ['hawtioSimpleTable', 'threads', 'rows'])[idx];
            $scope.threadGridOptions.selectedItems = $scope.threads.filter(function (t) {
                return t && t['threadId'] == selectedThread.entity['threadId'];
            });
        };
        $scope.init = function () {
            jolokia.request([{
                type: 'read',
                mbean: Threads.mbean,
                attribute: 'ThreadContentionMonitoringSupported'
            }, {
                type: 'read',
                mbean: Threads.mbean,
                attribute: 'ObjectMonitorUsageSupported'
            }, {
                type: 'read',
                mbean: Threads.mbean,
                attribute: 'SynchronizerUsageSupported'
            }], {
                method: 'post',
                success: [
                    function (response) {
                        $scope.support.threadContentionMonitoringSupported = response.value;
                        Threads.log.debug("ThreadContentionMonitoringSupported: ", $scope.support.threadContentionMonitoringSupported);
                        $scope.maybeRegister();
                    },
                    function (response) {
                        $scope.support.objectMonitorUsageSupported = response.value;
                        Threads.log.debug("ObjectMonitorUsageSupported: ", $scope.support.objectMonitorUsageSupported);
                        $scope.maybeRegister();
                    },
                    function (response) {
                        $scope.support.synchronizerUsageSupported = response.value;
                        Threads.log.debug("SynchronizerUsageSupported: ", $scope.support.synchronizerUsageSupported);
                        $scope.maybeRegister();
                    }
                ],
                error: function (response) {
                    Threads.log.error('Failed to query for supported usages: ', response.error);
                }
            });
        };
        var initFunc = Core.throttled($scope.init, 500);
        $scope.maybeRegister = function () {
            if ('objectMonitorUsageSupported' in $scope.support && 'synchronizerUsageSupported' in $scope.support && 'threadContentionMonitoringSupported' in $scope.support) {
                Threads.log.debug("Registering dumpAllThreads polling");
                Core.register(jolokia, $scope, {
                    type: 'exec',
                    mbean: Threads.mbean,
                    operation: 'dumpAllThreads',
                    arguments: [$scope.support.objectMonitorUsageSupported, $scope.support.synchronizerUsageSupported]
                }, onSuccess(render));
                if ($scope.support.threadContentionMonitoringSupported) {
                    jolokia.request({
                        type: 'read',
                        mbean: Threads.mbean,
                        attribute: 'ThreadContentionMonitoringEnabled'
                    }, onSuccess($scope.maybeEnableThreadContentionMonitoring));
                }
            }
        };
        function disabledContentionMonitoring(response) {
            Threads.log.info("Disabled contention monitoring: ", response);
            Core.$apply($scope);
        }
        function enabledContentionMonitoring(response) {
            $scope.$on('$routeChangeStart', function () {
                jolokia.setAttribute(Threads.mbean, 'ThreadContentionMonitoringEnabled', false, onSuccess(disabledContentionMonitoring));
            });
            Threads.log.info("Enabled contention monitoring");
            Core.$apply($scope);
        }
        $scope.maybeEnableThreadContentionMonitoring = function (response) {
            if (response.value === false) {
                Threads.log.info("Thread contention monitoring not enabled, enabling");
                jolokia.setAttribute(Threads.mbean, 'ThreadContentionMonitoringEnabled', true, onSuccess(enabledContentionMonitoring));
            }
            else {
                Threads.log.info("Thread contention monitoring already enabled");
            }
            Core.$apply($scope);
        };
        $scope.getMonitorClass = function (name, value) {
            return value.toString();
        };
        $scope.getMonitorName = function (name) {
            name = name.replace('Supported', '');
            return name.titleize();
        };
        function render(response) {
            var responseJson = angular.toJson(response.value, true);
            if ($scope.getThreadInfoResponseJson !== responseJson) {
                $scope.getThreadInfoResponseJson = responseJson;
                var threads = response.value.exclude(function (t) {
                    return t === null;
                });
                $scope.unfilteredThreads = threads;
                $scope.totals = {};
                threads.forEach(function (t) {
                    var state = t.threadState;
                    if (!(state in $scope.totals)) {
                        $scope.totals[state] = 1;
                    }
                    else {
                        $scope.totals[state]++;
                    }
                });
                threads = $scope.filterThreads($scope.stateFilter, threads);
                $scope.threads = threads;
                Core.$apply($scope);
            }
        }
        initFunc();
    }]);
})(Threads || (Threads = {}));
var Tomcat;
(function (Tomcat) {
    function filerTomcatOrCatalina(response) {
        if (response) {
            response = response.filter(function (name) {
                return name.startsWith("Catalina") || name.startsWith("Tomcat");
            });
        }
        return response;
    }
    Tomcat.filerTomcatOrCatalina = filerTomcatOrCatalina;
    ;
    function iconClass(state) {
        if (state) {
            switch (state.toString().toLowerCase()) {
                case '1':
                    return "green icon-play-circle";
                case 'started':
                    return "green icon-play-circle";
                case '0':
                    return "orange icon-off";
                case 'stopped':
                    return "orange icon-off";
            }
        }
        if (angular.isNumber(state)) {
            if (state.toString() === '0') {
                return "orange icon-off";
            }
        }
        return "icon-question-sign";
    }
    Tomcat.iconClass = iconClass;
    function millisToDateFormat(time) {
        if (time) {
            var date = new Date(time);
            return date.toLocaleDateString() + " " + date.toLocaleTimeString();
        }
        else {
            return "";
        }
    }
    Tomcat.millisToDateFormat = millisToDateFormat;
    function isTomcat5(name) {
        return name.toString().indexOf("Apache Tomcat/5") !== -1;
    }
    Tomcat.isTomcat5 = isTomcat5;
    function isTomcat6(name) {
        return name.toString().indexOf("Apache Tomcat/6") !== -1;
    }
    Tomcat.isTomcat6 = isTomcat6;
})(Tomcat || (Tomcat = {}));
var Tomcat;
(function (Tomcat) {
    var pluginName = 'tomcat';
    Tomcat._module = angular.module(pluginName, ['bootstrap', 'ngResource', 'ui.bootstrap.dialog', 'hawtioCore']);
    Tomcat._module.config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when('/tomcat/server', { templateUrl: 'app/tomcat/html/server.html' }).when('/tomcat/applications', { templateUrl: 'app/tomcat/html/applications.html' }).when('/tomcat/connectors', { templateUrl: 'app/tomcat/html/connectors.html' }).when('/tomcat/sessions', { templateUrl: 'app/tomcat/html/sessions.html' });
    }]);
    Tomcat._module.filter('tomcatIconClass', function () { return Tomcat.iconClass; });
    Tomcat._module.run(["$location", "workspace", "viewRegistry", "helpRegistry", function ($location, workspace, viewRegistry, helpRegistry) {
        viewRegistry['tomcat'] = "app/tomcat/html/layoutTomcatTabs.html";
        helpRegistry.addUserDoc('tomcat', 'app/tomcat/doc/help.md', function () {
            return workspace.treeContainsDomainAndProperties("Tomcat") || workspace.treeContainsDomainAndProperties("Catalina");
        });
        workspace.topLevelTabs.push({
            id: "tomcat",
            content: "Tomcat",
            title: "Manage your Tomcat container",
            isValid: function (workspace) { return workspace.treeContainsDomainAndProperties("Tomcat") || workspace.treeContainsDomainAndProperties("Catalina"); },
            href: function () { return "#/tomcat/applications"; },
            isActive: function (workspace) { return workspace.isTopTabActive("tomcat"); }
        });
    }]);
    hawtioPluginLoader.addModule(pluginName);
})(Tomcat || (Tomcat = {}));
var Tomcat;
(function (Tomcat) {
    Tomcat._module.controller("Tomcat.ConnectorsController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(col.field) | tomcatIconClass}}"></i></div>';
        $scope.connectors = [];
        $scope.selected = [];
        var columnDefs = [
            {
                field: 'stateName',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'port',
                displayName: 'Port',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'scheme',
                displayName: 'Scheme',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'protocol',
                displayName: 'Protocol',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'secure',
                displayName: 'Secure',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'connectionLinger',
                displayName: 'Connection Linger',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'connectionTimeout',
                displayName: 'Connection Timeout',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'keepAliveTimeout',
                displayName: 'Keep Alive Timeout',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'minSpareThreads',
                displayName: 'Minimum Threads',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'maxThreads',
                displayName: 'Maximum Threads',
                cellFilter: null,
                width: "*",
                resizable: true
            },
        ];
        $scope.gridOptions = {
            data: 'connectors',
            displayFooter: true,
            selectedItems: $scope.selected,
            selectWithCheckboxOnly: true,
            columnDefs: columnDefs,
            filterOptions: {
                filterText: ''
            }
        };
        function render(response) {
            response = Tomcat.filerTomcatOrCatalina(response);
            $scope.connectors = [];
            $scope.selected.length = 0;
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    obj.mbean = response.request.mbean;
                    $scope.connectors.push(obj);
                    Core.$apply($scope);
                }
            }
            angular.forEach(response, function (value, key) {
                var mbean = value;
                jolokia.request({ type: "read", mbean: mbean, attribute: ["scheme", "port", "protocol", "secure", "connectionLinger", "connectionTimeout", "keepAliveTimeout", "minSpareThreads", "maxThreads", "stateName"] }, onSuccess(onAttributes));
            });
            Core.$apply($scope);
        }
        ;
        $scope.controlConnector = function (op) {
            var ids = $scope.selected.map(function (b) {
                return b.mbean;
            });
            if (!angular.isArray(ids)) {
                ids = [ids];
            }
            ids.forEach(function (id) {
                jolokia.request({
                    type: 'exec',
                    mbean: id,
                    operation: op,
                    arguments: null
                }, onSuccess($scope.onResponse, { error: $scope.onResponse }));
            });
        };
        $scope.stop = function () {
            $scope.controlConnector('stop');
        };
        $scope.start = function () {
            $scope.controlConnector('start');
        };
        $scope.destroy = function () {
            $scope.controlConnector('destroy');
        };
        $scope.onResponse = function (response) {
            loadData();
        };
        $scope.$on('jmxTreeUpdated', reloadFunction);
        $scope.$watch('workspace.tree', reloadFunction);
        function reloadFunction() {
            setTimeout(loadData, 50);
        }
        function loadData() {
            console.log("Loading tomcat connector data...");
            jolokia.search("*:type=Connector,*", onSuccess(render));
        }
    }]);
})(Tomcat || (Tomcat = {}));
var Tomcat;
(function (Tomcat) {
    Tomcat._module.controller("Tomcat.SessionsController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(col.field) | tomcatIconClass}}"></i></div>';
        $scope.sessions = [];
        $scope.search = "";
        var columnDefs = [
            {
                field: 'stateName',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'path',
                displayName: 'Context-Path',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'activeSessions',
                displayName: 'Active Sessions',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'expiredSessions',
                displayName: 'Expired Sessions',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'rejectedSessions',
                displayName: 'Rejected Sessions',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'maxActive',
                displayName: 'Max Active Sessions',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'maxActiveSessions',
                displayName: 'Max Active Sessions Allowed',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'maxInactiveInterval',
                displayName: 'Max Inactive Interval',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'sessionCounter',
                displayName: 'Session Counter',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'sessionCreateRate',
                displayName: 'Session Create Rate',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'sessionExpireRate',
                displayName: 'Session Expire Rate',
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        $scope.gridOptions = {
            data: 'sessions',
            displayFooter: false,
            displaySelectionCheckbox: false,
            canSelectRows: false,
            columnDefs: columnDefs,
            filterOptions: {
                filterText: ''
            }
        };
        function render(response) {
            response = Tomcat.filerTomcatOrCatalina(response);
            $scope.sessions = [];
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    obj.mbean = response.request.mbean;
                    var mbean = obj.mbean;
                    if (mbean) {
                        var context = mbean.toString().split(",")[1];
                        if (context) {
                            if (context.toString().indexOf("path=") !== -1) {
                                obj.path = context.toString().substr(5);
                            }
                            else {
                                obj.path = context.toString().substr(9);
                            }
                        }
                        else {
                            obj.path = "";
                        }
                        $scope.sessions.push(obj);
                        Core.$apply($scope);
                    }
                }
            }
            angular.forEach(response, function (value, key) {
                var mbean = value;
                jolokia.request({ type: "read", mbean: mbean }, onSuccess(onAttributes));
            });
            Core.$apply($scope);
        }
        ;
        $scope.$on('jmxTreeUpdated', reloadFunction);
        $scope.$watch('workspace.tree', reloadFunction);
        function reloadFunction() {
            setTimeout(loadData, 50);
        }
        function loadData() {
            console.log("Loading tomcat session data...");
            jolokia.search("*:type=Manager,*", onSuccess(render));
        }
    }]);
})(Tomcat || (Tomcat = {}));
var Tomcat;
(function (Tomcat) {
    Tomcat._module.controller("Tomcat.TomcatController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
        var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(col.field) | tomcatIconClass}}"></i></div>';
        var urlTemplate = '<div class="ngCellText" title="{{row.getProperty(col.field)}}">' + '<a ng-href="{{row.getProperty(col.field)}}" target="_blank">{{row.getProperty(col.field)}}</a>' + '</div>';
        $scope.uninstallDialog = new UI.Dialog();
        $scope.httpPort;
        $scope.httpScheme = "http";
        $scope.webapps = [];
        $scope.selected = [];
        var columnDefsTomcat5 = [
            {
                field: 'state',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'path',
                displayName: 'Context-Path',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'url',
                displayName: 'Url',
                cellTemplate: urlTemplate,
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'startTime',
                displayName: 'Start Time',
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        var columnDefsTomcat6 = [
            {
                field: 'stateName',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'path',
                displayName: 'Context-Path',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'url',
                displayName: 'Url',
                cellTemplate: urlTemplate,
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'startTime',
                displayName: 'Start Time',
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        var columnDefsTomcat7 = [
            {
                field: 'stateName',
                displayName: 'State',
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false
            },
            {
                field: 'path',
                displayName: 'Context-Path',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'displayName',
                displayName: 'Display Name',
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'url',
                displayName: 'Url',
                cellTemplate: urlTemplate,
                cellFilter: null,
                width: "*",
                resizable: true
            },
            {
                field: 'startTime',
                displayName: 'Start Time',
                cellFilter: null,
                width: "*",
                resizable: true
            }
        ];
        $scope.gridOptions = {
            data: 'webapps',
            displayFooter: true,
            selectedItems: $scope.selected,
            selectWithCheckboxOnly: true,
            filterOptions: {
                filterText: ''
            }
        };
        function render(response) {
            response = Tomcat.filerTomcatOrCatalina(response);
            $scope.webapps = [];
            $scope.mbeanIndex = {};
            $scope.selected.length = 0;
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    obj.mbean = response.request.mbean;
                    var mbean = obj.mbean;
                    var hostname = Core.extractTargetUrl($location, $scope.httpScheme, $scope.httpPort);
                    obj.url = hostname + obj['path'];
                    if (mbean) {
                        obj.startTime = Tomcat.millisToDateFormat(obj.startTime);
                        var idx = $scope.mbeanIndex[mbean];
                        if (angular.isDefined(idx)) {
                            $scope.webapps[mbean] = obj;
                        }
                        else {
                            $scope.mbeanIndex[mbean] = $scope.webapps.length;
                            $scope.webapps.push(obj);
                        }
                        Core.$apply($scope);
                    }
                }
            }
            angular.forEach(response, function (value, key) {
                var mbean = value;
                if (Tomcat.isTomcat5($scope.tomcatServerVersion)) {
                    jolokia.request({ type: "read", mbean: mbean, attribute: ["path", "state", "startTime"] }, onSuccess(onAttributes));
                }
                else if (Tomcat.isTomcat6($scope.tomcatServerVersion)) {
                    jolokia.request({ type: "read", mbean: mbean, attribute: ["path", "stateName", "startTime"] }, onSuccess(onAttributes));
                }
                else {
                    jolokia.request({ type: "read", mbean: mbean, attribute: ["displayName", "path", "stateName", "startTime"] }, onSuccess(onAttributes));
                }
            });
            Core.$apply($scope);
        }
        ;
        $scope.controlWebApps = function (op) {
            var mbeanNames = $scope.selected.map(function (b) {
                return b.mbean;
            });
            if (!angular.isArray(mbeanNames)) {
                mbeanNames = [mbeanNames];
            }
            var lastIndex = (mbeanNames.length || 1) - 1;
            angular.forEach(mbeanNames, function (mbean, idx) {
                var onResponse = (idx >= lastIndex) ? $scope.onLastResponse : $scope.onResponse;
                jolokia.request({
                    type: 'exec',
                    mbean: mbean,
                    operation: op,
                    arguments: null
                }, onSuccess(onResponse, { error: onResponse }));
            });
        };
        $scope.stop = function () {
            $scope.controlWebApps('stop');
        };
        $scope.start = function () {
            $scope.controlWebApps('start');
        };
        $scope.reload = function () {
            $scope.controlWebApps('reload');
        };
        $scope.uninstall = function () {
            $scope.controlWebApps('destroy');
            $scope.uninstallDialog.close();
        };
        $scope.onLastResponse = function (response) {
            $scope.onResponse(response);
            loadData();
        };
        $scope.onResponse = function (response) {
        };
        $scope.$on('jmxTreeUpdated', reloadFunction);
        $scope.$watch('workspace.tree', reloadFunction);
        function reloadFunction() {
            setTimeout(loadData, 50);
        }
        function loadData() {
            console.log("Loading tomcat webapp data...");
            var connectors = jolokia.search("*:type=Connector,*");
            if (connectors) {
                var found = false;
                angular.forEach(connectors, function (key, value) {
                    var mbean = key;
                    if (!found) {
                        var data = jolokia.request({ type: "read", mbean: mbean, attribute: ["port", "scheme", "protocol"] });
                        if (data && data.value) {
                            function isHttp(value) {
                                return value && value.toString().toLowerCase().indexOf("http") >= 0;
                            }
                            if (isHttp(data.value.protocol)) {
                                found = true;
                                $scope.httpPort = data.value.port;
                                $scope.httpScheme = data.value.scheme;
                            }
                        }
                    }
                });
            }
            jolokia.search("*:j2eeType=WebModule,*", onSuccess(render));
        }
        $scope.tomcatServerVersion = "";
        var servers = jolokia.search("*:type=Server");
        servers = Tomcat.filerTomcatOrCatalina(servers);
        if (servers && servers.length === 1) {
            $scope.tomcatServerVersion = jolokia.getAttribute(servers[0], "serverInfo");
        }
        else {
            console.log("Cannot find Tomcat server or there was more than one server. response is: " + servers);
        }
        if (Tomcat.isTomcat5($scope.tomcatServerVersion)) {
            console.log("Using Tomcat 5");
            $scope.gridOptions.columnDefs = columnDefsTomcat5;
        }
        else if (Tomcat.isTomcat6($scope.tomcatServerVersion)) {
            console.log("Using Tomcat 6");
            $scope.gridOptions.columnDefs = columnDefsTomcat6;
        }
        else {
            console.log("Using Tomcat 7");
            $scope.gridOptions.columnDefs = columnDefsTomcat7;
        }
    }]);
})(Tomcat || (Tomcat = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioAutoColumns', function () {
        return new UI.AutoColumns();
    });
    var AutoColumns = (function () {
        function AutoColumns() {
            this.restrict = 'A';
            this.link = function ($scope, $element, $attr) {
                var selector = UI.getIfSet('hawtioAutoColumns', $attr, 'div');
                var minMargin = UI.getIfSet('minMargin', $attr, '3').toNumber();
                var go = Core.throttled(function () {
                    var containerWidth = $element.innerWidth();
                    var childWidth = 0;
                    var children = $element.children(selector);
                    if (children.length === 0) {
                        return;
                    }
                    children.each(function (child) {
                        var self = $(this);
                        if (!self.is(':visible')) {
                            return;
                        }
                        if (self.outerWidth() > childWidth) {
                            childWidth = self.outerWidth();
                        }
                    });
                    if (childWidth === 0) {
                        return;
                    }
                    childWidth = childWidth + (minMargin * 2);
                    var columns = Math.floor(containerWidth / childWidth);
                    if (children.length < columns) {
                        columns = children.length;
                    }
                    var margin = (containerWidth - (columns * childWidth)) / columns / 2;
                    children.each(function (child) {
                        $(this).css({
                            'margin-left': margin,
                            'margin-right': margin
                        });
                    });
                }, 500);
                setTimeout(go, 300);
                $scope.$watch(go);
                $(window).resize(go);
            };
        }
        return AutoColumns;
    })();
    UI.AutoColumns = AutoColumns;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioAutoDropdown', function () {
        return UI.AutoDropDown;
    });
    UI.AutoDropDown = {
        restrict: 'A',
        link: function ($scope, $element, $attrs) {
            function locateElements(event) {
                var el = $element.get(0);
                if (event && event.relatedNode !== el && event.type) {
                    if (event && event.type !== 'resize') {
                        return;
                    }
                }
                var overflowEl = $($element.find('.overflow'));
                var overflowMenu = $(overflowEl.find('ul.dropdown-menu'));
                var margin = 0;
                var availableWidth = 0;
                try {
                    margin = overflowEl.outerWidth() - overflowEl.innerWidth();
                    availableWidth = overflowEl.position().left - $element.position().left - 50;
                }
                catch (e) {
                    UI.log.debug("caught " + e);
                }
                $element.children('li:not(.overflow):not(.pull-right):not(:hidden)').each(function () {
                    var self = $(this);
                    availableWidth = availableWidth - self.outerWidth(true);
                    if (availableWidth < 0) {
                        self.detach();
                        self.prependTo(overflowMenu);
                    }
                });
                if (overflowMenu.children().length > 0) {
                    overflowEl.css({ visibility: "visible" });
                }
                if (availableWidth > 130) {
                    var noSpace = false;
                    overflowMenu.children('li:not(.overflow):not(.pull-right)').filter(function () {
                        return $(this).css('display') !== 'none';
                    }).each(function () {
                        if (noSpace) {
                            return;
                        }
                        var self = $(this);
                        if (availableWidth > self.outerWidth()) {
                            availableWidth = availableWidth - self.outerWidth();
                            self.detach();
                            self.insertBefore(overflowEl);
                        }
                        else {
                            noSpace = true;
                        }
                    });
                }
                if (overflowMenu.children().length === 0) {
                    overflowEl.css({ visibility: "hidden" });
                }
            }
            $(window).resize(locateElements);
            $element.get(0).addEventListener("DOMNodeInserted", locateElements);
            $scope.$watch(setTimeout(locateElements, 500));
        }
    };
})(UI || (UI = {}));
var UI;
(function (UI) {
    function hawtioBreadcrumbs() {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: UI.templatePath + 'breadcrumbs.html',
            require: 'hawtioDropDown',
            scope: {
                config: '='
            },
            controller: ["$scope", "$element", "$attrs", function ($scope, $element, $attrs) {
                $scope.action = "itemClicked(config, $event)";
                $scope.levels = {};
                $scope.itemClicked = function (config, $event) {
                    if (config.level && angular.isNumber(config.level)) {
                        $scope.levels[config.level] = config;
                        var keys = Object.extended($scope.levels).keys().sortBy("");
                        var toRemove = keys.from(config.level + 1);
                        toRemove.forEach(function (i) {
                            if (i in $scope.levels) {
                                $scope.levels[i] = {};
                                delete $scope.levels[i];
                            }
                        });
                        angular.forEach($scope.levels, function (value, key) {
                            if (value.items && value.items.length > 0) {
                                value.items.forEach(function (i) {
                                    i['action'] = $scope.action;
                                });
                            }
                        });
                        if (config.items) {
                            config.open = true;
                            config.items.forEach(function (i) {
                                i['action'] = $scope.action;
                            });
                            delete config.action;
                        }
                        else {
                            var keys = Object.extended($scope.levels).keys().sortBy("");
                            var path = [];
                            keys.forEach(function (key) {
                                path.push($scope.levels[key]['title']);
                            });
                            var pathString = '/' + path.join("/");
                            $scope.config.path = pathString;
                        }
                        if (config.level > 1) {
                            $event.preventDefault();
                            $event.stopPropagation();
                        }
                    }
                };
                function addAction(config, level) {
                    config.level = level;
                    if (level > 0) {
                        config.breadcrumbAction = config.action;
                        config.action = $scope.action;
                    }
                    if (config.items) {
                        config.items.forEach(function (item) {
                            addAction(item, level + 1);
                        });
                    }
                }
                function setLevels(config, pathParts, level) {
                    if (pathParts.length === 0) {
                        return;
                    }
                    var part = pathParts.removeAt(0)[0];
                    if (config && config.items) {
                        var matched = false;
                        config.items.forEach(function (item) {
                            if (!matched && item['title'] === part) {
                                matched = true;
                                $scope.levels[level] = item;
                                setLevels(item, pathParts, level + 1);
                            }
                        });
                    }
                }
                $scope.$watch('config.path', function (newValue, oldValue) {
                    if (!Core.isBlank(newValue)) {
                        var pathParts = newValue.split('/').exclude(function (p) {
                            return Core.isBlank(p);
                        });
                        var matches = true;
                        pathParts.forEach(function (part, index) {
                            if (!matches) {
                                return;
                            }
                            if (!$scope.levels[index] || Core.isBlank($scope.levels[index]['title']) || $scope.levels[index]['title'] !== part) {
                                matches = false;
                            }
                        });
                        if (matches) {
                            return;
                        }
                        $scope.levels = [];
                        $scope.levels['0'] = $scope.config;
                        setLevels($scope.config, pathParts.from(0), 1);
                    }
                });
                $scope.$watch('config', function (newValue, oldValue) {
                    addAction($scope.config, 0);
                    $scope.levels['0'] = $scope.config;
                });
            }]
        };
    }
    UI.hawtioBreadcrumbs = hawtioBreadcrumbs;
    UI._module.directive('hawtioBreadcrumbs', UI.hawtioBreadcrumbs);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioColorPicker', function () {
        return new UI.ColorPicker();
    });
    UI.selected = "selected";
    UI.unselected = "unselected";
    var ColorPicker = (function () {
        function ColorPicker() {
            this.restrict = 'A';
            this.replace = true;
            this.scope = {
                property: '=hawtioColorPicker'
            };
            this.templateUrl = UI.templatePath + "colorPicker.html";
            this.compile = function (tElement, tAttrs, transclude) {
                return {
                    post: function postLink(scope, iElement, iAttrs, controller) {
                        scope.colorList = [];
                        angular.forEach(UI.colors, function (color) {
                            var select = UI.unselected;
                            if (scope.property === color) {
                                select = UI.selected;
                            }
                            scope.colorList.push({
                                color: color,
                                select: select
                            });
                        });
                    }
                };
            };
            this.controller = ["$scope", "$element", "$timeout", function ($scope, $element, $timeout) {
                $scope.popout = false;
                $scope.$watch('popout', function () {
                    $element.find('.color-picker-popout').toggleClass('popout-open', $scope.popout);
                });
                $scope.selectColor = function (color) {
                    for (var i = 0; i < $scope.colorList.length; i++) {
                        $scope.colorList[i].select = UI.unselected;
                        if ($scope.colorList[i] === color) {
                            $scope.property = color.color;
                            $scope.colorList[i].select = UI.selected;
                        }
                    }
                };
            }];
        }
        return ColorPicker;
    })();
    UI.ColorPicker = ColorPicker;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioConfirmDialog', function () {
        return new UI.ConfirmDialog();
    });
    var ConfirmDialog = (function () {
        function ConfirmDialog() {
            this.restrict = 'A';
            this.replace = true;
            this.transclude = true;
            this.templateUrl = UI.templatePath + 'confirmDialog.html';
            this.scope = {
                show: '=hawtioConfirmDialog',
                title: '@',
                okButtonText: '@',
                showOkButton: '@',
                cancelButtonText: '@',
                onCancel: '&?',
                onOk: '&?',
                onClose: '&?'
            };
            this.controller = ["$scope", "$element", "$attrs", "$transclude", "$compile", function ($scope, $element, $attrs, $transclude, $compile) {
                $scope.clone = null;
                $transclude(function (clone) {
                    $scope.clone = $(clone).filter('.dialog-body');
                });
                $scope.$watch('show', function () {
                    if ($scope.show) {
                        setTimeout(function () {
                            $scope.body = $('.modal-body');
                            $scope.body.html($compile($scope.clone.html())($scope.$parent));
                            Core.$apply($scope);
                        }, 50);
                    }
                });
                $attrs.$observe('okButtonText', function (value) {
                    if (!angular.isDefined(value)) {
                        $scope.okButtonText = "OK";
                    }
                });
                $attrs.$observe('cancelButtonText', function (value) {
                    if (!angular.isDefined(value)) {
                        $scope.cancelButtonText = "Cancel";
                    }
                });
                $attrs.$observe('title', function (value) {
                    if (!angular.isDefined(value)) {
                        $scope.title = "Are you sure?";
                    }
                });
                function checkClosed() {
                    setTimeout(function () {
                        var backdrop = $("div.modal-backdrop");
                        if (backdrop && backdrop.length) {
                            Logger.get("ConfirmDialog").debug("Removing the backdrop div! " + backdrop);
                            backdrop.remove();
                        }
                    }, 200);
                }
                $scope.cancel = function () {
                    $scope.show = false;
                    $scope.$parent.$eval($scope.onCancel);
                    checkClosed();
                };
                $scope.submit = function () {
                    $scope.show = false;
                    $scope.$parent.$eval($scope.onOk);
                    checkClosed();
                };
                $scope.close = function () {
                    $scope.$parent.$eval($scope.onClose);
                    checkClosed();
                };
            }];
        }
        return ConfirmDialog;
    })();
    UI.ConfirmDialog = ConfirmDialog;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.controller("UI.DeveloperPageController", ["$scope", "$http", function ($scope, $http) {
        $scope.getContents = function (filename, cb) {
            var fullUrl = "app/ui/html/test/" + filename;
            $http({ method: 'GET', url: fullUrl }).success(function (data, status, headers, config) {
                cb(data);
            }).error(function (data, status, headers, config) {
                cb("Failed to fetch " + filename + ": " + data);
            });
        };
    }]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI.hawtioDrag = UI._module.directive("hawtioDrag", [function () {
        return {
            replace: false,
            transclude: true,
            restrict: 'A',
            template: '<span ng-transclude></span>',
            scope: {
                data: '=hawtioDrag'
            },
            link: function (scope, element, attrs) {
                element.attr({
                    draggable: 'true'
                });
                var el = element[0];
                el.draggable = true;
                el.addEventListener('dragstart', function (event) {
                    event.dataTransfer.effectAllowed = 'move';
                    event.dataTransfer.setData('text', scope.data);
                    element.addClass('drag-started');
                    return false;
                }, false);
                el.addEventListener('dragend', function (event) {
                    element.removeClass('drag-started');
                }, false);
            }
        };
    }]);
    UI.hawtioDrop = UI._module.directive("hawtioDrop", [function () {
        return {
            replace: false,
            transclude: true,
            restrict: 'A',
            template: '<span ng-transclude></span>',
            scope: {
                onDrop: '&?hawtioDrop',
                ngModel: '=',
                property: '@',
                prefix: '@'
            },
            link: function (scope, element, attrs) {
                var dragEnter = function (event) {
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                    element.addClass('drag-over');
                    return false;
                };
                var el = element[0];
                el.addEventListener('dragenter', dragEnter, false);
                el.addEventListener('dragover', dragEnter, false);
                el.addEventListener('dragleave', function (event) {
                    element.removeClass('drag-over');
                    return false;
                }, false);
                el.addEventListener('drop', function (event) {
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    element.removeClass('drag-over');
                    var data = event.dataTransfer.getData('text');
                    if (scope.onDrop) {
                        scope.$eval(scope.onDrop, {
                            data: data,
                            model: scope.ngModel,
                            property: scope.property
                        });
                    }
                    var eventName = 'hawtio-drop';
                    if (!Core.isBlank(scope.prefix)) {
                        eventName = scope.prefix + '-' + eventName;
                    }
                    scope.$emit(eventName, {
                        data: data,
                        model: scope.ngModel,
                        property: scope.property
                    });
                    Core.$apply(scope);
                    return false;
                }, false);
            }
        };
    }]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('editableProperty', ["$parse", function ($parse) {
        return new UI.EditableProperty($parse);
    }]);
    var EditableProperty = (function () {
        function EditableProperty($parse) {
            this.$parse = $parse;
            this.restrict = 'E';
            this.scope = true;
            this.templateUrl = UI.templatePath + 'editableProperty.html';
            this.require = 'ngModel';
            this.link = null;
            this.link = function (scope, element, attrs, ngModel) {
                scope.inputType = attrs['type'] || 'text';
                scope.min = attrs['min'];
                scope.max = attrs['max'];
                scope.getText = function () {
                    if (!scope.text) {
                        return '';
                    }
                    if (scope.inputType === 'password') {
                        return StringHelpers.obfusicate(scope.text);
                    }
                    else {
                        return scope.text;
                    }
                };
                scope.editing = false;
                $(element.find(".icon-pencil")[0]).hide();
                scope.getPropertyName = function () {
                    var propertyName = $parse(attrs['property'])(scope);
                    if (!propertyName && propertyName !== 0) {
                        propertyName = attrs['property'];
                    }
                    return propertyName;
                };
                ngModel.$render = function () {
                    if (!ngModel.$viewValue) {
                        return;
                    }
                    scope.text = ngModel.$viewValue[scope.getPropertyName()];
                };
                scope.getInputStyle = function () {
                    if (!scope.text) {
                        return {};
                    }
                    var calculatedWidth = (scope.text + "").length / 1.2;
                    if (calculatedWidth < 5) {
                        calculatedWidth = 5;
                    }
                    return {
                        width: calculatedWidth + 'em'
                    };
                };
                scope.showEdit = function () {
                    $(element.find(".icon-pencil")[0]).show();
                };
                scope.hideEdit = function () {
                    $(element.find(".icon-pencil")[0]).hide();
                };
                function inputSelector() {
                    return ':input[type=' + scope.inputType + ']';
                }
                scope.$watch('editing', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        if (newValue) {
                            $(element.find(inputSelector())).focus().select();
                        }
                        else {
                            scope.$emit('editablePropertyEdit', false);
                        }
                    }
                });
                scope.doEdit = function () {
                    scope.editing = true;
                    scope.$emit('editablePropertyEdit', true);
                };
                scope.stopEdit = function () {
                    $(element.find(inputSelector())[0]).val(ngModel.$viewValue[scope.getPropertyName()]);
                    scope.editing = false;
                };
                scope.saveEdit = function () {
                    var value = $(element.find(inputSelector())[0]).val();
                    var obj = ngModel.$viewValue;
                    if (scope.inputType == 'number' && value != '') {
                        try {
                            var n = parseInt(value);
                            var min = scope.min != '' ? parseInt(scope.min) : Number.MIN_VALUE;
                            var max = scope.max != '' ? parseInt(scope.max) : Number.MAX_VALUE;
                            if (n < min || n > max) {
                            }
                            else {
                                obj[scope.getPropertyName()] = value;
                                ngModel.$setViewValue(obj);
                                ngModel.$render();
                                scope.editing = false;
                                scope.$parent.$eval(attrs['onSave']);
                            }
                        }
                        catch (e) {
                        }
                    }
                    else {
                        obj[scope.getPropertyName()] = value;
                        ngModel.$setViewValue(obj);
                        ngModel.$render();
                        scope.editing = false;
                        scope.$parent.$eval(attrs['onSave']);
                    }
                };
            };
        }
        return EditableProperty;
    })();
    UI.EditableProperty = EditableProperty;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioEditor', ["$parse", function ($parse) {
        return UI.Editor($parse);
    }]);
    function Editor($parse) {
        return {
            restrict: 'A',
            replace: true,
            templateUrl: UI.templatePath + "editor.html",
            scope: {
                text: '=hawtioEditor',
                mode: '=',
                outputEditor: '@',
                name: '@'
            },
            controller: ["$scope", "$element", "$attrs", function ($scope, $element, $attrs) {
                $scope.codeMirror = null;
                $scope.doc = null;
                $scope.options = [];
                UI.observe($scope, $attrs, 'name', 'editor');
                $scope.applyOptions = function () {
                    if ($scope.codeMirror) {
                        $scope.options.each(function (option) {
                            $scope.codeMirror.setOption(option.key, option['value']);
                        });
                        $scope.options = [];
                    }
                };
                $scope.$watch('doc', function () {
                    if ($scope.doc) {
                        $scope.codeMirror.on('change', function (changeObj) {
                            $scope.text = $scope.doc.getValue();
                            $scope.dirty = !$scope.doc.isClean();
                            Core.$apply($scope);
                        });
                    }
                });
                $scope.$watch('codeMirror', function () {
                    if ($scope.codeMirror) {
                        $scope.doc = $scope.codeMirror.getDoc();
                    }
                });
                $scope.$watch('text', function (oldValue, newValue) {
                    if ($scope.codeMirror && $scope.doc) {
                        if (!$scope.codeMirror.hasFocus()) {
                            var text = $scope.text || "";
                            if (angular.isArray(text) || angular.isObject(text)) {
                                text = JSON.stringify(text, null, "  ");
                                $scope.mode = "javascript";
                                $scope.codeMirror.setOption("mode", "javascript");
                            }
                            $scope.doc.setValue(text);
                        }
                    }
                });
            }],
            link: function ($scope, $element, $attrs) {
                if ('dirty' in $attrs) {
                    $scope.dirtyTarget = $attrs['dirty'];
                    $scope.$watch("$parent['" + $scope.dirtyTarget + "']", function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            $scope.dirty = newValue;
                        }
                    });
                }
                var config = Object.extended($attrs).clone();
                delete config['$$element'];
                delete config['$attr'];
                delete config['class'];
                delete config['hawtioEditor'];
                delete config['mode'];
                delete config['dirty'];
                delete config['outputEditor'];
                if ('onChange' in $attrs) {
                    var onChange = $attrs['onChange'];
                    delete config['onChange'];
                    $scope.options.push({
                        onChange: function (codeMirror) {
                            var func = $parse(onChange);
                            if (func) {
                                func($scope.$parent, { codeMirror: codeMirror });
                            }
                        }
                    });
                }
                angular.forEach(config, function (value, key) {
                    $scope.options.push({
                        key: key,
                        'value': value
                    });
                });
                $scope.$watch('mode', function () {
                    if ($scope.mode) {
                        if (!$scope.codeMirror) {
                            $scope.options.push({
                                key: 'mode',
                                'value': $scope.mode
                            });
                        }
                        else {
                            $scope.codeMirror.setOption('mode', $scope.mode);
                        }
                    }
                });
                $scope.$watch('dirty', function (newValue, oldValue) {
                    if ($scope.dirty && !$scope.doc.isClean()) {
                        $scope.doc.markClean();
                    }
                    if (newValue !== oldValue && 'dirtyTarget' in $scope) {
                        $scope.$parent[$scope.dirtyTarget] = $scope.dirty;
                    }
                });
                $scope.$watch(function () {
                    return $element.is(':visible');
                }, function (newValue, oldValue) {
                    if (newValue !== oldValue && $scope.codeMirror) {
                        $scope.codeMirror.refresh();
                    }
                });
                $scope.$watch('text', function () {
                    if (!$scope.codeMirror) {
                        var options = {
                            value: $scope.text
                        };
                        options = CodeEditor.createEditorSettings(options);
                        $scope.codeMirror = CodeMirror.fromTextArea($element.find('textarea').get(0), options);
                        var outputEditor = $scope.outputEditor;
                        if (outputEditor) {
                            var outputScope = $scope.$parent || $scope;
                            Core.pathSet(outputScope, outputEditor, $scope.codeMirror);
                        }
                        $scope.applyOptions();
                    }
                });
            }
        };
    }
    UI.Editor = Editor;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('expandable', function () {
        return new UI.Expandable();
    });
    var Expandable = (function () {
        function Expandable() {
            var _this = this;
            this.log = Logger.get("Expandable");
            this.restrict = 'C';
            this.replace = false;
            this.link = null;
            this.link = function (scope, element, attrs) {
                var self = _this;
                var expandable = element;
                var modelName = null;
                var model = null;
                if (angular.isDefined(attrs['model'])) {
                    modelName = attrs['model'];
                    model = scope[modelName];
                    if (!angular.isDefined(scope[modelName]['expanded'])) {
                        model['expanded'] = expandable.hasClass('opened');
                    }
                    else {
                        if (model['expanded']) {
                            self.forceOpen(model, expandable, scope);
                        }
                        else {
                            self.forceClose(model, expandable, scope);
                        }
                    }
                    if (modelName) {
                        scope.$watch(modelName + '.expanded', function (newValue, oldValue) {
                            if (asBoolean(newValue) !== asBoolean(oldValue)) {
                                if (newValue) {
                                    self.open(model, expandable, scope);
                                }
                                else {
                                    self.close(model, expandable, scope);
                                }
                            }
                        });
                    }
                }
                var title = expandable.find('.title');
                var button = expandable.find('.cancel');
                button.bind('click', function () {
                    model = scope[modelName];
                    self.forceClose(model, expandable, scope);
                    return false;
                });
                title.bind('click', function () {
                    model = scope[modelName];
                    if (isOpen(expandable)) {
                        self.close(model, expandable, scope);
                    }
                    else {
                        self.open(model, expandable, scope);
                    }
                    return false;
                });
            };
        }
        Expandable.prototype.open = function (model, expandable, scope) {
            expandable.find('.expandable-body').slideDown(400, function () {
                if (!expandable.hasClass('opened')) {
                    expandable.addClass('opened');
                }
                expandable.removeClass('closed');
                if (model) {
                    model['expanded'] = true;
                }
                Core.$apply(scope);
            });
        };
        Expandable.prototype.close = function (model, expandable, scope) {
            expandable.find('.expandable-body').slideUp(400, function () {
                expandable.removeClass('opened');
                if (!expandable.hasClass('closed')) {
                    expandable.addClass('closed');
                }
                if (model) {
                    model['expanded'] = false;
                }
                Core.$apply(scope);
            });
        };
        Expandable.prototype.forceClose = function (model, expandable, scope) {
            expandable.find('.expandable-body').slideUp(0, function () {
                if (!expandable.hasClass('closed')) {
                    expandable.addClass('closed');
                }
                expandable.removeClass('opened');
                if (model) {
                    model['expanded'] = false;
                }
                Core.$apply(scope);
            });
        };
        Expandable.prototype.forceOpen = function (model, expandable, scope) {
            expandable.find('.expandable-body').slideDown(0, function () {
                if (!expandable.hasClass('opened')) {
                    expandable.addClass('opened');
                }
                expandable.removeClass('closed');
                if (model) {
                    model['expanded'] = true;
                }
                Core.$apply(scope);
            });
        };
        return Expandable;
    })();
    UI.Expandable = Expandable;
    function isOpen(expandable) {
        return expandable.hasClass('opened') || !expandable.hasClass("closed");
    }
    function asBoolean(value) {
        return value ? true : false;
    }
})(UI || (UI = {}));
var UI;
(function (UI) {
    var hawtioFileDrop = UI._module.directive("hawtioFileDrop", [function () {
        return {
            restrict: 'A',
            replace: false,
            link: function (scope, element, attr) {
                var fileName = attr['hawtioFileDrop'];
                var downloadURL = attr['downloadUrl'];
                var mimeType = attr['mimeType'] || 'application/octet-stream';
                if (Core.isBlank(fileName) || Core.isBlank(downloadURL)) {
                    return;
                }
                if (!downloadURL.startsWith("http")) {
                    var uri = new URI();
                    downloadURL = uri.path(downloadURL).toString();
                }
                var fileDetails = mimeType + ":" + fileName + ":" + downloadURL;
                element.attr({
                    draggable: true
                });
                element[0].addEventListener("dragstart", function (event) {
                    if (event.dataTransfer) {
                        UI.log.debug("Drag started, event: ", event, "File details: ", fileDetails);
                        event.dataTransfer.setData("DownloadURL", fileDetails);
                    }
                    else {
                        UI.log.debug("Drag event object doesn't contain data transfer: ", event);
                    }
                });
            }
        };
    }]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI.hawtioFilter = UI._module.directive("hawtioFilter", [function () {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: UI.templatePath + 'filter.html',
            scope: {
                placeholder: '@',
                cssClass: '@',
                saveAs: '@?',
                ngModel: '='
            },
            controller: ["$scope", "localStorage", "$location", "$element", function ($scope, localStorage, $location, $element) {
                $scope.getClass = function () {
                    var answer = [];
                    if (!Core.isBlank($scope.cssClass)) {
                        answer.push($scope.cssClass);
                    }
                    if (!Core.isBlank($scope.ngModel)) {
                        answer.push("has-text");
                    }
                    return answer.join(' ');
                };
                if (!Core.isBlank($scope.saveAs)) {
                    if ($scope.saveAs in localStorage) {
                        var val = localStorage[$scope.saveAs];
                        if (!Core.isBlank(val)) {
                            $scope.ngModel = val;
                        }
                        else {
                            $scope.ngModel = '';
                        }
                    }
                    else {
                        $scope.ngModel = '';
                    }
                    var updateFunc = function () {
                        localStorage[$scope.saveAs] = $scope.ngModel;
                    };
                    $scope.$watch('ngModel', updateFunc);
                }
            }]
        };
    }]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('gridster', function () {
        return new UI.GridsterDirective();
    });
    var GridsterDirective = (function () {
        function GridsterDirective() {
            this.restrict = 'A';
            this.replace = true;
            this.controller = ["$scope", "$element", "$attrs", function ($scope, $element, $attrs) {
            }];
            this.link = function ($scope, $element, $attrs) {
                var widgetMargins = [6, 6];
                var widgetBaseDimensions = [150, 150];
                var gridSize = [150, 150];
                var extraRows = 10;
                var extraCols = 6;
                if (angular.isDefined($attrs['extraRows'])) {
                    extraRows = $attrs['extraRows'].toNumber();
                }
                if (angular.isDefined($attrs['extraCols'])) {
                    extraCols = $attrs['extraCols'].toNumber();
                }
                var grid = $('<ul style="margin: 0"></ul>');
                var styleStr = '<style type="text/css">';
                var styleStr = styleStr + '</style>';
                $element.append($(styleStr));
                $element.append(grid);
                $scope.gridster = grid.gridster({
                    widget_margins: widgetMargins,
                    grid_size: gridSize,
                    extra_rows: extraRows,
                    extra_cols: extraCols
                }).data('gridster');
            };
        }
        return GridsterDirective;
    })();
    UI.GridsterDirective = GridsterDirective;
})(UI || (UI = {}));
var UI;
(function (UI) {
    function groupBy() {
        return function (list, group) {
            if (list.length === 0) {
                return list;
            }
            if (Core.isBlank(group)) {
                return list;
            }
            var newGroup = 'newGroup';
            var endGroup = 'endGroup';
            var currentGroup = undefined;
            function createNewGroup(list, item, index) {
                item[newGroup] = true;
                item[endGroup] = false;
                currentGroup = item[group];
                if (index > 0) {
                    list[index - 1][endGroup] = true;
                }
            }
            function addItemToExistingGroup(item) {
                item[newGroup] = false;
                item[endGroup] = false;
            }
            list.forEach(function (item, index) {
                var createGroup = item[group] !== currentGroup;
                if (angular.isArray(item[group])) {
                    if (currentGroup === undefined) {
                        createGroup = true;
                    }
                    else {
                        var targetGroup = item[group];
                        if (targetGroup.length !== currentGroup.length) {
                            createGroup = true;
                        }
                        else {
                            createGroup = false;
                            targetGroup.forEach(function (item) {
                                if (!createGroup && !currentGroup.any(function (i) {
                                    return i === item;
                                })) {
                                    createGroup = true;
                                }
                            });
                        }
                    }
                }
                if (createGroup) {
                    createNewGroup(list, item, index);
                }
                else {
                    addItemToExistingGroup(item);
                }
            });
            return list;
        };
    }
    UI.groupBy = groupBy;
    UI._module.filter('hawtioGroupBy', UI.groupBy);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI.IconTestController = UI._module.controller("UI.IconTestController", ["$scope", "$templateCache", function ($scope, $templateCache) {
        $scope.exampleHtml = $templateCache.get('example-html');
        $scope.exampleConfigJson = $templateCache.get('example-config-json');
        $scope.$watch('exampleConfigJson', function (newValue, oldValue) {
            $scope.icons = angular.fromJson($scope.exampleConfigJson);
        });
    }]);
    function hawtioIcon() {
        UI.log.debug("Creating icon directive");
        return {
            restrict: 'E',
            replace: true,
            templateUrl: UI.templatePath + 'icon.html',
            scope: {
                icon: '=config'
            },
            link: function ($scope, $element, $attrs) {
                if (!$scope.icon) {
                    return;
                }
                if (!('type' in $scope.icon) && !Core.isBlank($scope.icon.src)) {
                    if ($scope.icon.src.startsWith("icon-")) {
                        $scope.icon.type = "icon";
                    }
                    else {
                        $scope.icon.type = "img";
                    }
                }
            }
        };
    }
    UI.hawtioIcon = hawtioIcon;
    UI._module.directive('hawtioIcon', UI.hawtioIcon);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioJsplumb', ["$timeout", "$window", function ($timeout, $window) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attrs) {
                $window.addEventListener("resize", function () {
                    if ($scope.jsPlumb) {
                        $scope.jsPlumb.recalculateOffsets($element);
                        $scope.jsPlumb.repaintEverything();
                    }
                });
                var enableDragging = true;
                if (angular.isDefined($attrs['draggable'])) {
                    enableDragging = Core.parseBooleanValue($attrs['draggable']);
                }
                var useLayout = true;
                if (angular.isDefined($attrs['layout'])) {
                    useLayout = Core.parseBooleanValue($attrs['layout']);
                }
                var direction = 'TB';
                if (angular.isDefined($attrs['direction'])) {
                    switch ($attrs['direction']) {
                        case 'down':
                            direction = 'LR';
                            break;
                        default:
                            direction = 'TB';
                    }
                }
                var nodeSep = 50;
                var edgeSep = 10;
                var rankSep = 50;
                if (angular.isDefined($attrs['nodeSep'])) {
                    nodeSep = Core.parseIntValue($attrs['nodeSep']);
                }
                if (angular.isDefined($attrs['edgeSep'])) {
                    edgeSep = Core.parseIntValue($attrs['edgeSep']);
                }
                if (angular.isDefined($attrs['rankSep'])) {
                    rankSep = Core.parseIntValue($attrs['rankSep']);
                }
                var timeout = 100;
                if (angular.isDefined($attrs['timeout'])) {
                    timeout = Core.parseIntValue($attrs['timeout'], "timeout");
                }
                var endpointStyle = ["Dot", { radius: 10, cssClass: 'jsplumb-circle', hoverClass: 'jsplumb-circle-hover' }];
                var labelStyles = ["Label"];
                var arrowStyles = ["Arrow", {
                    location: 1,
                    id: "arrow",
                    length: 8,
                    width: 8,
                    foldback: 0.8
                }];
                var connectorStyle = ["Flowchart", { cornerRadius: 4, gap: 8 }];
                if (angular.isDefined($scope.connectorStyle)) {
                    connectorStyle = $scope.connectorStyle;
                }
                function createNode(nodeEl) {
                    var el = $(nodeEl);
                    var id = el.attr('id');
                    var anchors = el.attr('anchors');
                    if (!Core.isBlank(anchors) && (anchors.has("{{") || anchors.has("}}"))) {
                        return null;
                    }
                    if (!Core.isBlank(anchors)) {
                        anchors = anchors.split(',').map(function (anchor) {
                            return anchor.trim();
                        });
                    }
                    else {
                        anchors = ["Continuous"];
                    }
                    var node = {
                        id: id,
                        label: 'node ' + id,
                        el: el,
                        width: el.outerWidth(),
                        height: el.outerHeight(),
                        edges: [],
                        connections: [],
                        endpoints: [],
                        anchors: anchors
                    };
                    return node;
                }
                ;
                function createEndpoint(jsPlumb, node) {
                    var options = {
                        isSource: true,
                        isTarget: true,
                        anchor: node.anchors,
                        connector: connectorStyle,
                        maxConnections: -1
                    };
                    if (angular.isFunction($scope.customizeEndpointOptions)) {
                        $scope.customizeEndpointOptions(jsPlumb, node, options);
                    }
                    var endpoint = jsPlumb.addEndpoint(node.el, options);
                    node.endpoints.push(endpoint);
                    if (enableDragging) {
                        jsPlumb.draggable(node.el, {
                            containment: $element
                        });
                    }
                }
                ;
                var nodes = [];
                var transitions = [];
                var nodesById = {};
                function gatherElements() {
                    var nodeEls = $element.find('.jsplumb-node');
                    if (nodes.length > 0) {
                    }
                    angular.forEach(nodeEls, function (nodeEl) {
                        if (!nodesById[nodeEl.id]) {
                            var node = createNode(nodeEl);
                            if (node) {
                                nodes.push(node);
                                nodesById[node.id] = node;
                            }
                        }
                    });
                    angular.forEach(nodes, function (sourceNode) {
                        var targets = sourceNode.el.attr('connect-to');
                        if (targets) {
                            targets = targets.split(',');
                            angular.forEach(targets, function (target) {
                                var targetNode = nodesById[target.trim()];
                                if (targetNode) {
                                    var edge = {
                                        source: sourceNode,
                                        target: targetNode
                                    };
                                    transitions.push(edge);
                                    sourceNode.edges.push(edge);
                                    targetNode.edges.push(edge);
                                }
                            });
                        }
                    });
                }
                ;
                $scope.$on('jsplumbDoWhileSuspended', function (event, op) {
                    if ($scope.jsPlumb) {
                        var jsPlumb = $scope.jsPlumb;
                        jsPlumb.doWhileSuspended(function () {
                            UI.log.debug("Suspended jsplumb");
                            $scope.jsPlumb.reset();
                            op();
                            nodes = [];
                            nodesById = {};
                            transitions = [];
                            go();
                        });
                    }
                });
                function go() {
                    if (!$scope.jsPlumb) {
                        $scope.jsPlumb = jsPlumb.getInstance({
                            Container: $element
                        });
                        var defaultOptions = {
                            Anchor: "AutoDefault",
                            Connector: "Flowchart",
                            ConnectorStyle: connectorStyle,
                            DragOptions: { cursor: "pointer", zIndex: 2000 },
                            Endpoint: endpointStyle,
                            PaintStyle: { strokeStyle: "#42a62c", lineWidth: 4 },
                            HoverPaintStyle: { strokeStyle: "#42a62c", lineWidth: 4 },
                            ConnectionOverlays: [
                                arrowStyles,
                                labelStyles
                            ]
                        };
                        if (!enableDragging) {
                            defaultOptions['ConnectionsDetachable'] = false;
                        }
                        if (angular.isFunction($scope.customizeDefaultOptions)) {
                            $scope.customizeDefaultOptions(defaultOptions);
                        }
                        $scope.jsPlumb.importDefaults(defaultOptions);
                    }
                    gatherElements();
                    $scope.jsPlumbNodes = nodes;
                    $scope.jsPlumbNodesById = nodesById;
                    $scope.jsPlumbTransitions = transitions;
                    if (useLayout) {
                        $scope.layout = dagre.layout().nodeSep(nodeSep).edgeSep(edgeSep).rankSep(rankSep).rankDir(direction).nodes(nodes).edges(transitions).run();
                    }
                    angular.forEach($scope.jsPlumbNodes, function (node) {
                        if (useLayout) {
                            var divWidth = node.el.width();
                            var divHeight = node.el.height();
                            var y = node.dagre.y - (divHeight / 2);
                            var x = node.dagre.x - (divWidth / 2);
                            node.el.css({ top: y, left: x });
                        }
                        createEndpoint($scope.jsPlumb, node);
                    });
                    angular.forEach($scope.jsPlumbTransitions, function (edge) {
                        var options = {
                            connector: connectorStyle,
                            maxConnections: -1
                        };
                        var params = {
                            source: edge.source.el,
                            target: edge.target.el
                        };
                        if (angular.isFunction($scope.customizeConnectionOptions)) {
                            $scope.customizeConnectionOptions($scope.jsPlumb, edge, params, options);
                        }
                        var connection = $scope.jsPlumb.connect(params, options);
                        edge.source.connections.push(connection);
                        edge.target.connections.push(connection);
                    });
                    $scope.jsPlumb.recalculateOffsets($element);
                    if (!$scope.jsPlumb.isSuspendDrawing()) {
                        $scope.jsPlumb.repaintEverything();
                    }
                    if (angular.isDefined($scope.jsPlumbCallback) && angular.isFunction($scope.jsPlumbCallback)) {
                        $scope.jsPlumbCallback($scope.jsPlumb, $scope.jsPlumbNodes, $scope.jsPlumbNodesById, $scope.jsPlumbTransitions);
                    }
                }
                $timeout(go, timeout);
            }
        };
    }]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    function hawtioList($templateCache, $compile) {
        return {
            restrict: '',
            replace: true,
            templateUrl: UI.templatePath + 'list.html',
            scope: {
                'config': '=hawtioList'
            },
            link: function ($scope, $element, $attr) {
                $scope.rows = [];
                $scope.name = "hawtioListScope";
                if (!$scope.config.selectedItems) {
                    $scope.config.selectedItems = [];
                }
                $scope.$watch('rows', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        $scope.config.selectedItems.length = 0;
                        var selected = $scope.rows.findAll(function (row) {
                            return row.selected;
                        });
                        selected.forEach(function (row) {
                            $scope.config.selectedItems.push(row.entity);
                        });
                    }
                }, true);
                $scope.cellTemplate = $templateCache.get('cellTemplateForList.html');
                $scope.rowTemplate = $templateCache.get('rowTemplateForList.html');
                var columnDefs = $scope.config['columnDefs'];
                var fieldName = 'name';
                var displayName = 'Name';
                if (columnDefs && columnDefs.length > 0) {
                    var def = columnDefs.first();
                    fieldName = def['field'] || fieldName;
                    displayName = def['displayName'] || displayName;
                    if (def['cellTemplate']) {
                        $scope.cellTemplate = def['cellTemplate'];
                    }
                }
                var configName = $attr['hawtioList'];
                var dataName = $scope.config['data'];
                if (Core.isBlank(configName) || Core.isBlank(dataName)) {
                    return;
                }
                $scope.listRoot = function () {
                    return $element.find('.list-root');
                };
                $scope.getContents = function (row) {
                    var innerScope = $scope.$new();
                    innerScope.row = row;
                    var rowEl = $compile($scope.rowTemplate)(innerScope);
                    var innerParentScope = $scope.parentScope.$new();
                    innerParentScope.row = row;
                    innerParentScope.col = {
                        field: fieldName
                    };
                    var cellEl = $compile($scope.cellTemplate)(innerParentScope);
                    $(rowEl).find('.list-row-contents').append(cellEl);
                    return rowEl;
                };
                $scope.setRows = function (data) {
                    $scope.rows = [];
                    var list = $scope.listRoot();
                    list.empty();
                    if (data) {
                        data.forEach(function (row) {
                            var newRow = {
                                entity: row,
                                getProperty: function (name) {
                                    if (!angular.isDefined(name)) {
                                        return null;
                                    }
                                    return row[name];
                                }
                            };
                            list.append($scope.getContents(newRow));
                            $scope.rows.push(newRow);
                        });
                    }
                };
                var parentScope = UI.findParentWith($scope, configName);
                if (parentScope) {
                    $scope.parentScope = parentScope;
                    parentScope.$watch(dataName, $scope.setRows, true);
                }
            }
        };
    }
    UI.hawtioList = hawtioList;
    UI._module.directive('hawtioList', ["$templateCache", "$compile", UI.hawtioList]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    var objectView = UI._module.directive("hawtioObject", ["$templateCache", "$interpolate", "$compile", function ($templateCache, $interpolate, $compile) {
        return {
            restrict: "A",
            replace: true,
            templateUrl: UI.templatePath + "object.html",
            scope: {
                "entity": "=?hawtioObject",
                "config": "=?",
                "path": "=?",
                "row": "=?"
            },
            link: function ($scope, $element, $attr) {
                function interpolate(template, path, key, value) {
                    var interpolateFunc = $interpolate(template);
                    if (!key) {
                        return interpolateFunc({
                            data: value,
                            path: path
                        });
                    }
                    else {
                        return interpolateFunc({
                            key: key.titleize(),
                            data: value,
                            path: path
                        });
                    }
                }
                function getEntityConfig(path, config) {
                    var answer = undefined;
                    var properties = Core.pathGet(config, ['properties']);
                    if (!answer && properties) {
                        angular.forEach(properties, function (config, propertySelector) {
                            var regex = new RegExp(propertySelector);
                            if (regex.test(path)) {
                                if (answer && !answer.override && !config.override) {
                                    answer = Object.merge(answer, config);
                                }
                                else {
                                    answer = Object.clone(config, true);
                                }
                            }
                        });
                    }
                    return answer;
                }
                function getTemplate(path, config, def) {
                    var answer = def;
                    var config = getEntityConfig(path, config);
                    if (config && config.template) {
                        answer = config.template;
                    }
                    return answer;
                }
                function compile(template, path, key, value, config) {
                    var config = getEntityConfig(path, config);
                    if (config && config.hidden) {
                        return;
                    }
                    var interpolated = null;
                    if (config && config.template) {
                        interpolated = config.template;
                    }
                    else {
                        interpolated = interpolate(template, path, key, value);
                    }
                    var scope = $scope.$new();
                    scope.row = $scope.row;
                    scope.entityConfig = config;
                    scope.data = value;
                    scope.path = path;
                    return $compile(interpolated)(scope);
                }
                function renderPrimitiveValue(path, entity, config) {
                    var template = getTemplate(path, config, $templateCache.get('primitiveValueTemplate.html'));
                    return compile(template, path, undefined, entity, config);
                }
                function renderDateValue(path, entity, config) {
                    var template = getTemplate(path, config, $templateCache.get('dateValueTemplate.html'));
                    return compile(template, path, undefined, entity, config);
                }
                function renderObjectValue(path, entity, config) {
                    var isArray = false;
                    var el = undefined;
                    angular.forEach(entity, function (value, key) {
                        if (angular.isNumber(key) && "length" in entity) {
                            isArray = true;
                        }
                        if (isArray) {
                            return;
                        }
                        if (key.startsWith("$")) {
                            return;
                        }
                        if (!el) {
                            el = angular.element('<span></span>');
                        }
                        if (angular.isArray(value)) {
                            el.append(renderArrayAttribute(path + '/' + key, key, value, config));
                        }
                        else if (angular.isObject(value)) {
                            if (Object.extended(value).size() === 0) {
                                el.append(renderPrimitiveAttribute(path + '/' + key, key, 'empty', config));
                            }
                            else {
                                el.append(renderObjectAttribute(path + '/' + key, key, value, config));
                            }
                        }
                        else if (StringHelpers.isDate(value)) {
                            el.append(renderDateAttribute(path + '/' + key, key, Date.create(value), config));
                        }
                        else {
                            el.append(renderPrimitiveAttribute(path + '/' + key, key, value, config));
                        }
                    });
                    if (el) {
                        return el.children();
                    }
                    else {
                        return el;
                    }
                }
                function getColumnHeaders(path, entity, config) {
                    var answer = undefined;
                    if (!entity) {
                        return answer;
                    }
                    var hasPrimitive = false;
                    entity.forEach(function (item) {
                        if (!hasPrimitive && angular.isObject(item)) {
                            if (!answer) {
                                answer = [];
                            }
                            answer = Object.extended(item).keys().filter(function (key) {
                                return !angular.isFunction(item[key]);
                            }).filter(function (key) {
                                var conf = getEntityConfig(path + '/' + key, config);
                                if (conf && conf.hidden) {
                                    return false;
                                }
                                return true;
                            }).union(answer);
                        }
                        else {
                            answer = undefined;
                            hasPrimitive = true;
                        }
                    });
                    if (answer) {
                        answer = answer.exclude(function (item) {
                            return ("" + item).startsWith('$');
                        });
                    }
                    return answer;
                }
                function renderTable(template, path, key, value, headers, config) {
                    var el = angular.element(interpolate(template, path, key, value));
                    var thead = el.find('thead');
                    var tbody = el.find('tbody');
                    var headerTemplate = $templateCache.get('headerTemplate.html');
                    var cellTemplate = $templateCache.get('cellTemplate.html');
                    var rowTemplate = $templateCache.get('rowTemplate.html');
                    var headerRow = angular.element(interpolate(rowTemplate, path, undefined, undefined));
                    headers.forEach(function (header) {
                        headerRow.append(interpolate(headerTemplate, path + '/' + header, header, undefined));
                    });
                    thead.append(headerRow);
                    value.forEach(function (item, index) {
                        var tr = angular.element(interpolate(rowTemplate, path + '/' + index, undefined, undefined));
                        headers.forEach(function (header) {
                            var td = angular.element(interpolate(cellTemplate, path + '/' + index + '/' + header, undefined, undefined));
                            td.append(renderThing(path + '/' + index + '/' + header, item[header], config));
                            tr.append(td);
                        });
                        tbody.append(tr);
                    });
                    return el;
                }
                function renderArrayValue(path, entity, config) {
                    var headers = getColumnHeaders(path, entity, config);
                    if (!headers) {
                        var template = getTemplate(path, config, $templateCache.get('arrayValueListTemplate.html'));
                        return compile(template, path, undefined, entity, config);
                    }
                    else {
                        var template = getTemplate(path, config, $templateCache.get('arrayValueTableTemplate.html'));
                        return renderTable(template, path, undefined, entity, headers, config);
                    }
                }
                function renderPrimitiveAttribute(path, key, value, config) {
                    var template = getTemplate(path, config, $templateCache.get('primitiveAttributeTemplate.html'));
                    return compile(template, path, key, value, config);
                }
                function renderDateAttribute(path, key, value, config) {
                    var template = getTemplate(path, config, $templateCache.get('dateAttributeTemplate.html'));
                    return compile(template, path, key, value, config);
                }
                function renderObjectAttribute(path, key, value, config) {
                    var template = getTemplate(path, config, $templateCache.get('objectAttributeTemplate.html'));
                    return compile(template, path, key, value, config);
                }
                function renderArrayAttribute(path, key, value, config) {
                    var headers = getColumnHeaders(path, value, config);
                    if (!headers) {
                        var template = getTemplate(path, config, $templateCache.get('arrayAttributeListTemplate.html'));
                        return compile(template, path, key, value, config);
                    }
                    else {
                        var template = getTemplate(path, config, $templateCache.get('arrayAttributeTableTemplate.html'));
                        return renderTable(template, path, key, value, headers, config);
                    }
                }
                function renderThing(path, entity, config) {
                    if (angular.isArray(entity)) {
                        return renderArrayValue(path, entity, config);
                    }
                    else if (angular.isObject(entity)) {
                        return renderObjectValue(path, entity, config);
                    }
                    else if (StringHelpers.isDate(entity)) {
                        return renderDateValue(path, Date.create(entity), config);
                    }
                    else {
                        return renderPrimitiveValue(path, entity, config);
                    }
                }
                $scope.$watch('entity', function (entity) {
                    if (!entity) {
                        $element.empty();
                        return;
                    }
                    if (!$scope.path) {
                        $scope.path = "";
                    }
                    if (!angular.isDefined($scope.row)) {
                        $scope.row = {
                            entity: entity
                        };
                    }
                    $element.html(renderThing($scope.path, entity, $scope.config));
                }, true);
            }
        };
    }]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    function hawtioPane() {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: UI.templatePath + 'pane.html',
            scope: {
                position: '@',
                width: '@',
                header: '@'
            },
            controller: ["$scope", "$element", "$attrs", "$transclude", "$document", "$timeout", "$compile", "$templateCache", "$window", function ($scope, $element, $attrs, $transclude, $document, $timeout, $compile, $templateCache, $window) {
                $scope.moving = false;
                $transclude(function (clone) {
                    $element.find(".pane-content").append(clone);
                    if (Core.isBlank($scope.header)) {
                        return;
                    }
                    var headerTemplate = $templateCache.get($scope.header);
                    var wrapper = $element.find(".pane-header-wrapper");
                    wrapper.html($compile(headerTemplate)($scope));
                    $timeout(function () {
                        $element.find(".pane-viewport").css("top", wrapper.height());
                    }, 500);
                });
                $scope.setViewportTop = function () {
                    var wrapper = $element.find(".pane-header-wrapper");
                    $timeout(function () {
                        $element.find(".pane-viewport").css("top", wrapper.height());
                    }, 10);
                };
                $scope.setWidth = function (width) {
                    if (width < 6) {
                        return;
                    }
                    $element.width(width);
                    $element.parent().css($scope.padding, $element.width() + "px");
                    $scope.setViewportTop();
                };
                $scope.open = function () {
                    $scope.setWidth($scope.width);
                };
                $scope.close = function () {
                    $scope.width = $element.width();
                    $scope.setWidth(6);
                };
                $scope.$on('pane.close', $scope.close);
                $scope.$on('pane.open', $scope.open);
                $scope.toggle = function () {
                    if ($scope.moving) {
                        return;
                    }
                    if ($element.width() > 6) {
                        $scope.close();
                    }
                    else {
                        $scope.open();
                    }
                };
                $scope.startMoving = function ($event) {
                    $event.stopPropagation();
                    $event.preventDefault();
                    $event.stopImmediatePropagation();
                    $document.on("mouseup.hawtio-pane", function ($event) {
                        $timeout(function () {
                            $scope.moving = false;
                        }, 250);
                        $event.stopPropagation();
                        $event.preventDefault();
                        $event.stopImmediatePropagation();
                        $document.off(".hawtio-pane");
                        Core.$apply($scope);
                    });
                    $document.on("mousemove.hawtio-pane", function ($event) {
                        $scope.moving = true;
                        $event.stopPropagation();
                        $event.preventDefault();
                        $event.stopImmediatePropagation();
                        if ($scope.position === 'left') {
                            $scope.setWidth($event.pageX + 2);
                        }
                        else {
                            $scope.setWidth($window.innerWidth - $event.pageX + 2);
                        }
                        Core.$apply($scope);
                    });
                };
            }],
            link: function ($scope, $element, $attr) {
                var parent = $element.parent();
                var position = "left";
                if ($scope.position) {
                    position = $scope.position;
                }
                $element.addClass(position);
                var width = $element.width();
                var padding = "padding-" + position;
                $scope.padding = padding;
                var original = parent.css(padding);
                parent.css(padding, width + "px");
                $scope.$on('$destroy', function () {
                    parent.css(padding, original);
                });
            }
        };
    }
    UI.hawtioPane = hawtioPane;
    UI._module.directive('hawtioPane', UI.hawtioPane);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioMessagePanel', function () {
        return new UI.MessagePanel();
    });
    var MessagePanel = (function () {
        function MessagePanel() {
            this.restrict = 'A';
            this.link = function ($scope, $element, $attrs) {
                var height = "100%";
                if ('hawtioMessagePanel' in $attrs) {
                    var wantedHeight = $attrs['hawtioMessagePanel'];
                    if (wantedHeight && !wantedHeight.isBlank()) {
                        height = wantedHeight;
                    }
                }
                var speed = "1s";
                if ('speed' in $attrs) {
                    var wantedSpeed = $attrs['speed'];
                    if (speed && !speed.isBlank()) {
                        speed = wantedSpeed;
                    }
                }
                $element.css({
                    position: 'absolute',
                    bottom: 0,
                    height: 0,
                    'min-height': 0,
                    transition: 'all ' + speed + ' ease-in-out'
                });
                $element.parent().mouseover(function () {
                    $element.css({
                        height: height,
                        'min-height': 'auto'
                    });
                });
                $element.parent().mouseout(function () {
                    $element.css({
                        height: 0,
                        'min-height': 0
                    });
                });
            };
        }
        return MessagePanel;
    })();
    UI.MessagePanel = MessagePanel;
    UI._module.directive('hawtioInfoPanel', function () {
        return new UI.InfoPanel();
    });
    var InfoPanel = (function () {
        function InfoPanel() {
            this.restrict = 'A';
            this.link = function ($scope, $element, $attrs) {
                var validDirections = {
                    'left': {
                        side: 'right',
                        out: 'width'
                    },
                    'right': {
                        side: 'left',
                        out: 'width'
                    },
                    'up': {
                        side: 'bottom',
                        out: 'height'
                    },
                    'down': {
                        side: 'top',
                        out: 'height'
                    }
                };
                var direction = "right";
                if ('hawtioInfoPanel' in $attrs) {
                    var wantedDirection = $attrs['hawtioInfoPanel'];
                    if (wantedDirection && !wantedDirection.isBlank()) {
                        if (Object.extended(validDirections).keys().any(wantedDirection)) {
                            direction = wantedDirection;
                        }
                    }
                }
                var speed = "1s";
                if ('speed' in $attrs) {
                    var wantedSpeed = $attrs['speed'];
                    if (speed && !speed.isBlank()) {
                        speed = wantedSpeed;
                    }
                }
                var toggle = "open";
                if ('toggle' in $attrs) {
                    var wantedToggle = $attrs['toggle'];
                    if (toggle && !toggle.isBlank()) {
                        toggle = wantedToggle;
                    }
                }
                var initialCss = {
                    position: 'absolute',
                    transition: 'all ' + speed + ' ease-in-out'
                };
                var openCss = {};
                openCss[validDirections[direction]['out']] = '100%';
                var closedCss = {};
                closedCss[validDirections[direction]['out']] = 0;
                initialCss[validDirections[direction]['side']] = 0;
                initialCss[validDirections[direction]['out']] = 0;
                $element.css(initialCss);
                $scope.$watch(toggle, function (newValue, oldValue) {
                    if (Core.parseBooleanValue(newValue)) {
                        $element.css(openCss);
                    }
                    else {
                        $element.css(closedCss);
                    }
                });
                $element.click(function () {
                    $scope[toggle] = false;
                    Core.$apply($scope);
                });
            };
        }
        return InfoPanel;
    })();
    UI.InfoPanel = InfoPanel;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioRow', function () {
        return new UI.DivRow();
    });
    var DivRow = (function () {
        function DivRow() {
            this.restrict = 'A';
            this.link = function ($scope, $element, $attrs) {
                $element.get(0).addEventListener("DOMNodeInserted", function () {
                    var targets = $element.children();
                    var width = 0;
                    angular.forEach(targets, function (target) {
                        var el = angular.element(target);
                        switch (el.css('display')) {
                            case 'none':
                                break;
                            default:
                                width = width + el.outerWidth(true) + 5;
                        }
                    });
                    $element.width(width);
                });
            };
        }
        return DivRow;
    })();
    UI.DivRow = DivRow;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioSlideout', function () {
        return new UI.SlideOut();
    });
    var SlideOut = (function () {
        function SlideOut() {
            this.restrict = 'A';
            this.replace = true;
            this.transclude = true;
            this.templateUrl = UI.templatePath + 'slideout.html';
            this.scope = {
                show: '=hawtioSlideout',
                direction: '@',
                top: '@',
                height: '@',
                title: '@'
            };
            this.controller = ["$scope", "$element", "$attrs", "$transclude", "$compile", function ($scope, $element, $attrs, $transclude, $compile) {
                $scope.clone = null;
                $transclude(function (clone) {
                    $scope.clone = $(clone).filter('.dialog-body');
                });
                UI.observe($scope, $attrs, 'direction', 'right');
                UI.observe($scope, $attrs, 'top', '10%', function (value) {
                    $element.css('top', value);
                });
                UI.observe($scope, $attrs, 'height', '80%', function (value) {
                    $element.css('height', value);
                });
                UI.observe($scope, $attrs, 'title', '');
                $scope.$watch('show', function () {
                    if ($scope.show) {
                        $scope.body = $element.find('.slideout-body');
                        $scope.body.html($compile($scope.clone.html())($scope.$parent));
                    }
                });
                $scope.hidePanel = function ($event) {
                    UI.log.debug("Event: ", $event);
                    $scope.show = false;
                };
            }];
            this.link = function ($scope, $element, $attrs) {
                $scope.$watch('show', function () {
                    if ($scope.show) {
                        $element.addClass('out');
                        $element.focus();
                    }
                    else {
                        $element.removeClass('out');
                    }
                });
            };
        }
        return SlideOut;
    })();
    UI.SlideOut = SlideOut;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioPager', function () {
        return new UI.TablePager();
    });
    var TablePager = (function () {
        function TablePager() {
            var _this = this;
            this.restrict = 'A';
            this.scope = true;
            this.templateUrl = UI.templatePath + 'tablePager.html';
            this.$scope = null;
            this.element = null;
            this.attrs = null;
            this.tableName = null;
            this.setRowIndexName = null;
            this.rowIndexName = null;
            this.link = function (scope, element, attrs) {
                return _this.doLink(scope, element, attrs);
            };
        }
        TablePager.prototype.doLink = function (scope, element, attrs) {
            var _this = this;
            this.$scope = scope;
            this.element = element;
            this.attrs = attrs;
            this.tableName = attrs["hawtioPager"] || attrs["array"] || "data";
            this.setRowIndexName = attrs["onIndexChange"] || "onIndexChange";
            this.rowIndexName = attrs["rowIndex"] || "rowIndex";
            scope.first = function () {
                _this.goToIndex(0);
            };
            scope.last = function () {
                _this.goToIndex(scope.tableLength() - 1);
            };
            scope.previous = function () {
                _this.goToIndex(scope.rowIndex() - 1);
            };
            scope.next = function () {
                _this.goToIndex(scope.rowIndex() + 1);
            };
            scope.isEmptyOrFirst = function () {
                var idx = scope.rowIndex();
                var length = scope.tableLength();
                return length <= 0 || idx <= 0;
            };
            scope.isEmptyOrLast = function () {
                var idx = scope.rowIndex();
                var length = scope.tableLength();
                return length < 1 || idx + 1 >= length;
            };
            scope.rowIndex = function () {
                return Core.pathGet(scope.$parent, _this.rowIndexName.split('.'));
            };
            scope.tableLength = function () {
                var data = _this.tableData();
                return data ? data.length : 0;
            };
        };
        TablePager.prototype.tableData = function () {
            return Core.pathGet(this.$scope.$parent, this.tableName.split('.')) || [];
        };
        TablePager.prototype.goToIndex = function (idx) {
            var name = this.setRowIndexName;
            var fn = this.$scope[name];
            if (angular.isFunction(fn)) {
                fn(idx);
            }
            else {
                console.log("No function defined in scope for " + name + " but was " + fn);
                this.$scope[this.rowIndexName] = idx;
            }
        };
        return TablePager;
    })();
    UI.TablePager = TablePager;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI.hawtioTagFilter = UI._module.directive("hawtioTagFilter", [function () {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: UI.templatePath + 'tagFilter.html',
            scope: {
                selected: '=',
                tags: '=',
                collection: '=?',
                collectionProperty: '@',
                saveAs: '@'
            },
            controller: ["$scope", "localStorage", "$location", function ($scope, localStorage, $location) {
                SelectionHelpers.decorate($scope);
                if (!Core.isBlank($scope.saveAs)) {
                    var search = $location.search();
                    if ($scope.saveAs in search) {
                        $scope.selected.add(angular.fromJson(search[$scope.saveAs]));
                    }
                    else if ($scope.saveAs in localStorage) {
                        $scope.selected.add(angular.fromJson(localStorage[$scope.saveAs]));
                    }
                }
                function maybeFilterVisibleTags() {
                    if ($scope.collection && $scope.collectionProperty) {
                        if (!$scope.selected.length) {
                            $scope.visibleTags = $scope.tags;
                            $scope.filteredCollection = $scope.collection;
                        }
                        else {
                            filterVisibleTags();
                        }
                        $scope.visibleTags = $scope.visibleTags.map(function (t) {
                            return {
                                id: t,
                                count: $scope.filteredCollection.map(function (c) {
                                    return c[$scope.collectionProperty];
                                }).reduce(function (count, c) {
                                    if (c.any(t)) {
                                        return count + 1;
                                    }
                                    return count;
                                }, 0)
                            };
                        });
                    }
                    else {
                        $scope.visibleTags = $scope.tags;
                    }
                }
                function filterVisibleTags() {
                    $scope.filteredCollection = $scope.collection.filter(function (c) {
                        return SelectionHelpers.filterByGroup($scope.selected, c[$scope.collectionProperty]);
                    });
                    $scope.visibleTags = [];
                    $scope.filteredCollection.forEach(function (c) {
                        $scope.visibleTags = $scope.visibleTags.union(c[$scope.collectionProperty]);
                    });
                }
                $scope.$watch('tags', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        SelectionHelpers.syncGroupSelection($scope.selected, $scope.tags);
                        maybeFilterVisibleTags();
                    }
                });
                $scope.$watch('selected', function (newValue, oldValue) {
                    if (!Core.isBlank($scope.saveAs)) {
                        var saveAs = angular.toJson($scope.selected);
                        localStorage[$scope.saveAs] = saveAs;
                        $location.search($scope.saveAs, saveAs);
                    }
                    maybeFilterVisibleTags();
                }, true);
            }]
        };
    }]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI.hawtioTagList = UI._module.directive("hawtioTagList", ['$interpolate', '$compile', function ($interpolate, $compile) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                ngModel: '=?',
                property: '@',
                onChange: '&'
            },
            link: function (scope, $element, attr) {
                if (!scope.ngModel || !scope.property || !scope.ngModel[scope.property]) {
                    return;
                }
                scope.collection = scope.ngModel[scope.property];
                scope.removeTag = function (tag) {
                    scope.ngModel[scope.property].remove(tag);
                    if (scope.onChange) {
                        scope.$eval(scope.onChange);
                    }
                };
                scope.$watch('collection', function (newValue, oldValue) {
                    if (!scope.ngModel || !scope.property || !scope.ngModel[scope.property]) {
                        return;
                    }
                    var tags = scope.ngModel[scope.property];
                    var tmp = angular.element("<div></div>");
                    tags.forEach(function (tag) {
                        var func = $interpolate('<span class="badge badge-success mouse-pointer">{{tag}} <i class="icon-remove" ng-click="removeTag(\'{{tag}}\')"></i></span>&nbsp;');
                        tmp.append(func({
                            tag: tag
                        }));
                    });
                    $element.html($compile(tmp.children())(scope));
                }, true);
            }
        };
    }]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    function TemplatePopover($templateCache, $compile, $document) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attr) {
                var title = UI.getIfSet('title', $attr, undefined);
                var trigger = UI.getIfSet('trigger', $attr, 'hover');
                var html = true;
                var contentTemplate = UI.getIfSet('content', $attr, 'popoverTemplate');
                var placement = UI.getIfSet('placement', $attr, 'auto');
                var delay = UI.getIfSet('delay', $attr, '100');
                var container = UI.getIfSet('container', $attr, 'body');
                var selector = UI.getIfSet('selector', $attr, 'false');
                if (container === 'false') {
                    container = false;
                }
                if (selector === 'false') {
                    selector = false;
                }
                var template = $templateCache.get(contentTemplate);
                if (!template) {
                    return;
                }
                $element.on('$destroy', function () {
                    $element.popover('destroy');
                });
                $element.popover({
                    title: title,
                    trigger: trigger,
                    html: html,
                    content: function () {
                        var res = $compile(template)($scope);
                        Core.$digest($scope);
                        return res;
                    },
                    delay: delay,
                    container: container,
                    selector: selector,
                    placement: function (tip, element) {
                        if (placement !== 'auto') {
                            return placement;
                        }
                        var el = $element;
                        var offset = el.offset();
                        var width = $document.innerWidth();
                        var elHorizontalCenter = offset['left'] + (el.outerWidth() / 2);
                        var midpoint = width / 2;
                        if (elHorizontalCenter < midpoint) {
                            return 'right';
                        }
                        else {
                            return 'left';
                        }
                    }
                });
            }
        };
    }
    UI.TemplatePopover = TemplatePopover;
    UI._module.directive('hawtioTemplatePopover', ["$templateCache", "$compile", "$document", UI.TemplatePopover]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.controller("UI.UITestController2", ["$scope", "$templateCache", function ($scope, $templateCache) {
        $scope.fileUploadExMode = 'text/html';
        $scope.menuItems = [];
        $scope.divs = [];
        for (var i = 0; i < 20; i++) {
            $scope.menuItems.push("Some Item " + i);
        }
        for (var i = 0; i < 20; i++) {
            $scope.divs.push(i + 1);
        }
        $scope.things = [
            {
                'name': 'stuff1',
                'foo1': 'bar1',
                'foo2': 'bar2'
            },
            {
                'name': 'stuff2',
                'foo3': 'bar3',
                'foo4': 'bar4'
            }
        ];
        $scope.someVal = 1;
        $scope.dropDownConfig = {
            icon: 'icon-cogs',
            title: 'My Awesome Menu',
            items: [{
                title: 'Some Item',
                action: 'someVal=2'
            }, {
                title: 'Some other stuff',
                icon: 'icon-twitter',
                action: 'someVal=3'
            }, {
                title: "I've got children",
                icon: 'icon-file-text',
                items: [{
                    title: 'Hi!',
                    action: 'someVal=4'
                }, {
                    title: 'Yo!',
                    items: [{
                        title: 'More!',
                        action: 'someVal=5'
                    }, {
                        title: 'Child',
                        action: 'someVal=6'
                    }, {
                        title: 'Menus!',
                        action: 'someVal=7'
                    }]
                }]
            }, {
                title: "Call a function!",
                action: function () {
                    Core.notification("info", "Function called!");
                }
            }]
        };
        $scope.dropDownConfigTxt = angular.toJson($scope.dropDownConfig, true);
        $scope.$watch('dropDownConfigTxt', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.dropDownConfig = angular.fromJson($scope.dropDownConfigTxt);
            }
        });
        $scope.breadcrumbSelection = 1;
        $scope.breadcrumbConfig = {
            path: '/root/first child',
            icon: 'icon-cogs',
            title: 'root',
            items: [{
                title: 'first child',
                icon: 'icon-folder-close-alt',
                items: [{
                    title: "first child's first child",
                    icon: 'icon-file-text'
                }]
            }, {
                title: 'second child',
                icon: 'icon-file'
            }, {
                title: "third child",
                icon: 'icon-folder-close-alt',
                items: [{
                    title: "third child's first child",
                    icon: 'icon-file-text'
                }, {
                    title: "third child's second child",
                    icon: 'icon-file-text'
                }, {
                    title: "third child's third child",
                    icon: 'icon-folder-close-alt',
                    items: [{
                        title: 'More!',
                        icon: 'icon-file-text'
                    }, {
                        title: 'Child',
                        icon: 'icon-file-text'
                    }, {
                        title: 'Menus!',
                        icon: 'icon-file-text'
                    }]
                }]
            }]
        };
        $scope.breadcrumbConfigTxt = angular.toJson($scope.breadcrumbConfig, true);
        $scope.$watch('breadcrumbConfigTxt', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.breadcrumbconfig = angular.toJson($scope.breadcrumbConfigTxt);
            }
        });
        $scope.breadcrumbEx = $templateCache.get("breadcrumbTemplate");
        $scope.dropDownEx = $templateCache.get("dropDownTemplate");
        $scope.autoDropDown = $templateCache.get("autoDropDownTemplate");
        $scope.zeroClipboard = $templateCache.get("zeroClipboardTemplate");
        $scope.popoverEx = $templateCache.get("myTemplate");
        $scope.popoverUsageEx = $templateCache.get("popoverExTemplate");
        $scope.autoColumnEx = $templateCache.get("autoColumnTemplate");
    }]);
    UI._module.controller("UI.UITestController1", ["$scope", "$templateCache", function ($scope, $templateCache) {
        $scope.jsplumbEx = $templateCache.get("jsplumbTemplate");
        $scope.nodes = ["node1", "node2"];
        $scope.otherNodes = ["node4", "node5", "node6"];
        $scope.anchors = ["Top", "Right", "Bottom", "Left"];
        $scope.createEndpoint = function (nodeId) {
            var node = $scope.jsPlumbNodesById[nodeId];
            if (node) {
                var anchors = $scope.anchors.subtract(node.anchors);
                console.log("anchors: ", anchors);
                if (anchors && anchors.length > 0) {
                    var anchor = anchors.first();
                    node.anchors.push(anchor);
                    node.endpoints.push($scope.jsPlumb.addEndpoint(node.el, {
                        anchor: anchor,
                        isSource: true,
                        isTarget: true,
                        maxConnections: -1
                    }));
                }
            }
        };
        $scope.expandableEx = '' + '<div class="expandable closed">\n' + '   <div title="The title" class="title">\n' + '     <i class="expandable-indicator"></i> Expandable title\n' + '   </div>\n' + '   <div class="expandable-body well">\n' + '     This is the expandable content...  Note that adding the "well" class isn\'t necessary but makes for a nice inset look\n' + '   </div>\n' + '</div>';
        $scope.editablePropertyEx1 = '<editable-property ng-model="editablePropertyModelEx1" property="property"></editable-property>';
        $scope.editablePropertyModelEx1 = {
            property: "This is editable (hover to edit)"
        };
        $scope.showDeleteOne = new UI.Dialog();
        $scope.showDeleteTwo = new UI.Dialog();
        $scope.fileUploadEx1 = '<div hawtio-file-upload="files" target="test1"></div>';
        $scope.fileUploadEx2 = '<div hawtio-file-upload="files" target="test2" show-files="false"></div>';
        $scope.fileUploadExMode = 'text/html';
        $scope.colorPickerEx = 'My Color ({{myColor}}): <div hawtio-color-picker="myColor"></div>';
        $scope.confirmationEx1 = '' + '<button class="btn" ng-click="showDeleteOne.open()">Delete stuff</button>\n' + '\n' + '<div hawtio-confirm-dialog="showDeleteOne.show"\n' + 'title="Delete stuff?"\n' + 'ok-button-text="Yes, Delete the Stuff"\n' + 'cancel-button-text="No, Keep the Stuff"\n' + 'on-cancel="onCancelled(\'One\')"\n' + 'on-ok="onOk(\'One\')">\n' + '  <div class="dialog-body">\n' + '    <p>\n' + '        Are you sure you want to delete all the stuff?\n' + '    </p>\n' + '  </div>\n' + '</div>\n';
        $scope.confirmationEx2 = '' + '<button class="btn" ng-click="showDeleteTwo.open()">Delete other stuff</button>\n' + '\n' + '<!-- Use more defaults -->\n' + '<div hawtio-confirm-dialog="showDeleteTwo.show\n"' + '  on-cancel="onCancelled(\'Two\')"\n' + '  on-ok="onOk(\'Two\')">\n' + '  <div class="dialog-body">\n' + '    <p>\n' + '      Are you sure you want to delete all the other stuff?\n' + '    </p>\n' + '  </div>\n' + '</div>';
        $scope.sliderEx1 = '' + '<button class="btn" ng-click="showSlideoutRight = !showSlideoutRight">Show slideout right</button>\n' + '<div hawtio-slideout="showSlideoutRight" title="Hey look a slider!">\n' + '   <div class="dialog-body">\n' + '     <div>\n' + '       Here is some content or whatever {{transcludedValue}}\n' + '     </div>\n' + '   </div>\n' + '</div>';
        $scope.sliderEx2 = '' + '<button class="btn" ng-click="showSlideoutLeft = !showSlideoutLeft">Show slideout left</button>\n' + '<div hawtio-slideout="showSlideoutLeft" direction="left" title="Hey, another slider!">\n' + '   <div class="dialog-body">\n' + '     <div hawtio-editor="someText" mode="javascript"></div>\n' + '   </div>\n' + '</div>\n';
        $scope.editorEx1 = '' + 'Instance 1\n' + '<div class="row-fluid">\n' + '   <div hawtio-editor="someText" mode="mode" dirty="dirty"></div>\n' + '   <div>Text : {{someText}}</div>\n' + '</div>\n' + '\n' + 'Instance 2 (readonly)\n' + '<div class="row-fluid">\n' + '   <div hawtio-editor="someText" read-only="true" mode="mode" dirty="dirty"></div>\n' + '   <div>Text : {{someText}}</div>\n' + '</div>';
        $scope.transcludedValue = "and this is transcluded";
        $scope.onCancelled = function (number) {
            Core.notification('info', 'cancelled ' + number);
        };
        $scope.onOk = function (number) {
            Core.notification('info', number + ' ok!');
        };
        $scope.showSlideoutRight = false;
        $scope.showSlideoutLeft = false;
        $scope.dirty = false;
        $scope.mode = 'javascript';
        $scope.someText = "var someValue = 0;\n" + "var someFunc = function() {\n" + "  return \"Hello World!\";\n" + "}\n";
        $scope.myColor = "#FF887C";
        $scope.showColorDialog = false;
        $scope.files = [];
        $scope.$watch('files', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                console.log("Files: ", $scope.files);
            }
        }, true);
    }]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    function HawtioTocDisplay(marked, $location, $anchorScroll, $compile) {
        var log = Logger.get("UI");
        return {
            restrict: 'A',
            scope: {
                getContents: '&'
            },
            controller: ["$scope", "$element", "$attrs", function ($scope, $element, $attrs) {
                $scope.remaining = -1;
                $scope.render = false;
                $scope.chapters = [];
                $scope.addChapter = function (item) {
                    console.log("Adding: ", item);
                    $scope.chapters.push(item);
                    if (!angular.isDefined(item['text'])) {
                        $scope.fetchItemContent(item);
                    }
                };
                $scope.getTarget = function (id) {
                    if (!id) {
                        return '';
                    }
                    return id.replace(".", "_");
                };
                $scope.getFilename = function (href, ext) {
                    var filename = href.split('/').last();
                    if (ext && !filename.endsWith(ext)) {
                        filename = filename + '.' + ext;
                    }
                    return filename;
                };
                $scope.$watch('remaining', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        var renderIfPageLoadFails = false;
                        if (newValue === 0 || renderIfPageLoadFails) {
                            $scope.render = true;
                        }
                    }
                });
                $scope.fetchItemContent = function (item) {
                    var me = $scope;
                    $scope.$eval(function (parent) {
                        parent.getContents({
                            filename: item['filename'],
                            cb: function (data) {
                                if (data) {
                                    if (item['filename'].endsWith(".md")) {
                                        item['text'] = marked(data);
                                    }
                                    else {
                                        item['text'] = data;
                                    }
                                    $scope.remaining--;
                                    Core.$apply(me);
                                }
                            }
                        });
                    });
                };
            }],
            link: function ($scope, $element, $attrs) {
                var offsetTop = 0;
                var logbar = $('.logbar');
                var contentDiv = $("#toc-content");
                if (logbar.length) {
                    offsetTop = logbar.height() + logbar.offset().top;
                }
                else if (contentDiv.length) {
                    var offsetContentDiv = contentDiv.offset();
                    if (offsetContentDiv) {
                        offsetTop = offsetContentDiv.top;
                    }
                }
                if (!offsetTop) {
                    offsetTop = 90;
                }
                var previousHtml = null;
                var html = $element;
                if (!contentDiv || !contentDiv.length) {
                    contentDiv = $element;
                }
                var ownerScope = $scope.$parent || $scope;
                var scrollDuration = 1000;
                var linkFilter = $attrs["linkFilter"];
                var htmlName = $attrs["html"];
                if (htmlName) {
                    ownerScope.$watch(htmlName, function () {
                        var htmlText = ownerScope[htmlName];
                        if (htmlText && htmlText !== previousHtml) {
                            previousHtml = htmlText;
                            var markup = $compile(htmlText)(ownerScope);
                            $element.children().remove();
                            $element.append(markup);
                            loadChapters();
                        }
                    });
                }
                else {
                    loadChapters();
                }
                $(window).scroll(setFirstChapterActive);
                function setFirstChapterActive() {
                    var cutoff = $(window).scrollTop();
                    $element.find("li a").removeClass("active");
                    $('.panel-body').each(function () {
                        var offset = $(this).offset();
                        if (offset && offset.top >= cutoff) {
                            var id = $(this).attr("id");
                            if (id) {
                                var link = html.find("a[chapter-id='" + id + "']");
                                link.addClass("active");
                                return false;
                            }
                        }
                    });
                }
                function findLinks() {
                    var answer = html.find('a');
                    if (linkFilter) {
                        answer = answer.filter(linkFilter);
                    }
                    return answer;
                }
                function loadChapters() {
                    if (!html.get(0).id) {
                        html.get(0).id = 'toc';
                    }
                    $scope.tocId = '#' + html.get(0).id;
                    $scope.remaining = findLinks().length;
                    findLinks().each(function (index, a) {
                        log.debug("Found: ", a);
                        var filename = $scope.getFilename(a.href, a.getAttribute('file-extension'));
                        var item = {
                            filename: filename,
                            title: a.textContent,
                            link: a
                        };
                        $scope.addChapter(item);
                    });
                    setTimeout(function () {
                        setFirstChapterActive();
                    }, 100);
                }
                $scope.$watch('render', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        if (newValue) {
                            if (!contentDiv.next('.hawtio-toc').length) {
                                var div = $('<div class="hawtio-toc"></div>');
                                div.appendTo(contentDiv);
                                var selectedChapter = $location.search()["chapter"];
                                $scope.chapters.forEach(function (chapter, index) {
                                    log.debug("index:", index);
                                    var panel = $('<div></div>');
                                    var panelHeader = null;
                                    var chapterId = $scope.getTarget(chapter['filename']);
                                    var link = chapter["link"];
                                    if (link) {
                                        link.setAttribute("chapter-id", chapterId);
                                    }
                                    if (index > 0) {
                                        panelHeader = $('<div class="panel-title"><a class="toc-back" href="">Back to Top</a></div>');
                                    }
                                    var panelBody = $('<div class="panel-body" id="' + chapterId + '">' + chapter['text'] + '</div>');
                                    if (panelHeader) {
                                        panel.append(panelHeader).append($compile(panelBody)($scope));
                                    }
                                    else {
                                        panel.append($compile(panelBody)($scope));
                                    }
                                    panel.hide().appendTo(div).fadeIn(1000);
                                    if (chapterId === selectedChapter) {
                                        scrollToChapter(chapterId);
                                    }
                                });
                                var pageTop = contentDiv.offset().top - offsetTop;
                                div.find('a.toc-back').each(function (index, a) {
                                    $(a).click(function (e) {
                                        e.preventDefault();
                                        $('body,html').animate({
                                            scrollTop: pageTop
                                        }, 2000);
                                    });
                                });
                                findLinks().each(function (index, a) {
                                    var href = a.href;
                                    var filename = $scope.getFilename(href, a.getAttribute('file-extension'));
                                    $(a).click(function (e) {
                                        log.debug("Clicked: ", e);
                                        e.preventDefault();
                                        var chapterId = $scope.getTarget(filename);
                                        $location.search("chapter", chapterId);
                                        Core.$apply(ownerScope);
                                        scrollToChapter(chapterId);
                                        return true;
                                    });
                                });
                            }
                        }
                    }
                });
                ownerScope.$on("$locationChangeSuccess", function (event, current, previous) {
                    setTimeout(function () {
                        var currentChapter = $location.search()["chapter"];
                        scrollToChapter(currentChapter);
                    }, 50);
                });
                function scrollToChapter(chapterId) {
                    log.debug("selected chapter changed: " + chapterId);
                    if (chapterId) {
                        var target = '#' + chapterId;
                        var top = 0;
                        var targetElements = $(target);
                        if (targetElements.length) {
                            var offset = targetElements.offset();
                            if (offset) {
                                top = offset.top - offsetTop;
                            }
                            $('body,html').animate({
                                scrollTop: top
                            }, scrollDuration);
                        }
                    }
                }
            }
        };
    }
    UI.HawtioTocDisplay = HawtioTocDisplay;
    UI._module.directive('hawtioTocDisplay', ["marked", "$location", "$anchorScroll", "$compile", UI.HawtioTocDisplay]);
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('hawtioViewport', function () {
        return new UI.ViewportHeight();
    });
    var ViewportHeight = (function () {
        function ViewportHeight() {
            this.restrict = 'A';
            this.link = function ($scope, $element, $attrs) {
                var lastHeight = 0;
                var resizeFunc = function () {
                    var neighbor = angular.element($attrs['hawtioViewport']);
                    var container = angular.element($attrs['containingDiv']);
                    var start = neighbor.position().top + neighbor.height();
                    var myHeight = container.height() - start;
                    if (angular.isDefined($attrs['heightAdjust'])) {
                        var heightAdjust = $attrs['heightAdjust'].toNumber();
                    }
                    myHeight = myHeight + heightAdjust;
                    $element.css({
                        height: myHeight,
                        'min-height': myHeight
                    });
                    if (lastHeight !== myHeight) {
                        lastHeight = myHeight;
                        $element.trigger('resize');
                    }
                };
                resizeFunc();
                $scope.$watch(resizeFunc);
                $().resize(function () {
                    resizeFunc();
                    Core.$apply($scope);
                    return false;
                });
            };
        }
        return ViewportHeight;
    })();
    UI.ViewportHeight = ViewportHeight;
    UI._module.directive('hawtioHorizontalViewport', function () {
        return new UI.HorizontalViewport();
    });
    var HorizontalViewport = (function () {
        function HorizontalViewport() {
            this.restrict = 'A';
            this.link = function ($scope, $element, $attrs) {
                var adjustParent = angular.isDefined($attrs['adjustParent']) && Core.parseBooleanValue($attrs['adjustParent']);
                $element.get(0).addEventListener("DOMNodeInserted", function () {
                    var canvas = $element.children();
                    $element.height(canvas.outerHeight(true));
                    if (adjustParent) {
                        $element.parent().height($element.outerHeight(true) + UI.getScrollbarWidth());
                    }
                });
            };
        }
        return HorizontalViewport;
    })();
    UI.HorizontalViewport = HorizontalViewport;
})(UI || (UI = {}));
var UI;
(function (UI) {
    UI._module.directive('zeroClipboard', ["$parse", function ($parse) {
        return UI.ZeroClipboardDirective($parse);
    }]);
    function ZeroClipboardDirective($parse) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attr) {
                var clip = new window.ZeroClipboard($element.get(0), {
                    moviePath: "img/ZeroClipboard.swf"
                });
                clip.on('complete', function (client, args) {
                    if (args.text && angular.isString(args.text)) {
                        Core.notification('info', "Copied text to clipboard: " + args.text.truncate(20));
                    }
                    Core.$apply($scope);
                });
                if ('useCallback' in $attr) {
                    var func = $parse($attr['useCallback']);
                    if (func) {
                        func($scope, { clip: clip });
                    }
                }
            }
        };
    }
    UI.ZeroClipboardDirective = ZeroClipboardDirective;
})(UI || (UI = {}));
var WikiDrop;
(function (WikiDrop) {
    WikiDrop.log = Logger.get('WikiDrop');
    WikiDrop.pluginName = 'wiki-drop';
    WikiDrop.templatePath = 'app/' + WikiDrop.pluginName + '/html/';
    WikiDrop._module = angular.module(WikiDrop.pluginName, ['bootstrap', 'wiki']);
    WikiDrop._module.config(['$routeProvider', function ($routeProvider) {
        $routeProvider.when('/wiki/drop', { templateUrl: WikiDrop.templatePath + 'deploy.html' });
    }]);
    WikiDrop._module.run(['viewRegistry', 'layoutFull', 'workspace', function (viewRegistry, layoutFull, workspace) {
        WikiDrop.log.debug("started");
    }]);
    hawtioPluginLoader.addModule(WikiDrop.pluginName);
})(WikiDrop || (WikiDrop = {}));
var WikiDrop;
(function (WikiDrop) {
    WikiDrop.DropFile = WikiDrop._module.directive("wikiDropFile", [function () {
        WikiDrop.log.debug("Creating wiki drop directive...");
        return {
            restrict: 'A',
            replace: true,
            scope: {
                branch: '@',
                path: '@',
                unzip: '@'
            },
            templateUrl: WikiDrop.templatePath + "deploy.html",
            controller: ["$scope", "$element", "FileUploader", "jolokiaUrl", "$templateCache", "$route", "$timeout", "jolokia", "userDetails", function ($scope, $element, FileUploader, jolokiaUrl, $templateCache, $route, $timeout, jolokia, userDetails) {
                $scope.artifactTemplate = '';
                function updateURL() {
                    var uploadURI = Wiki.gitRestURL($scope.branch, $scope.path);
                    WikiDrop.log.info("Upload URI: " + uploadURI);
                    var uploader = $scope.artifactUploader = new FileUploader({
                        headers: {
                            'Authorization': Core.authHeaderValue(userDetails)
                        },
                        autoUpload: true,
                        withCredentials: true,
                        method: 'POST',
                        url: uploadURI
                    });
                    $scope.doUpload = function () {
                        uploader.uploadAll();
                    };
                    uploader.onWhenAddingFileFailed = function (item, filter, options) {
                        WikiDrop.log.debug('onWhenAddingFileFailed', item, filter, options);
                    };
                    uploader.onAfterAddingFile = function (fileItem) {
                        WikiDrop.log.debug('onAfterAddingFile', fileItem);
                    };
                    uploader.onAfterAddingAll = function (addedFileItems) {
                        WikiDrop.log.debug('onAfterAddingAll', addedFileItems);
                    };
                    uploader.onBeforeUploadItem = function (item) {
                        if ('file' in item) {
                            item.fileSizeMB = (item.file.size / 1024 / 1024).toFixed(2);
                        }
                        else {
                            item.fileSizeMB = 0;
                        }
                        item.url = uploadURI;
                        if ($scope.unzip === false || $scope.unzip === "false") {
                            item.url += "?unzip=false";
                        }
                        WikiDrop.log.info("Uploading files to " + uploadURI);
                        WikiDrop.log.debug('onBeforeUploadItem', item);
                    };
                    uploader.onProgressItem = function (fileItem, progress) {
                        WikiDrop.log.debug('onProgressItem', fileItem, progress);
                    };
                    uploader.onProgressAll = function (progress) {
                        WikiDrop.log.debug('onProgressAll', progress);
                    };
                    uploader.onSuccessItem = function (fileItem, response, status, headers) {
                        WikiDrop.log.debug('onSuccessItem', fileItem, response, status, headers);
                    };
                    uploader.onErrorItem = function (fileItem, response, status, headers) {
                        WikiDrop.log.debug('onErrorItem', fileItem, response, status, headers);
                    };
                    uploader.onCancelItem = function (fileItem, response, status, headers) {
                        WikiDrop.log.debug('onCancelItem', fileItem, response, status, headers);
                    };
                    uploader.onCompleteItem = function (fileItem, response, status, headers) {
                        WikiDrop.log.debug('onCompleteItem', fileItem, response, status, headers);
                    };
                    uploader.onCompleteAll = function () {
                        WikiDrop.log.debug('onCompleteAll');
                        uploader.clearQueue();
                        $timeout(function () {
                            WikiDrop.log.info("Completed all uploads. Lets force a reload");
                            $route.reload();
                            Core.$apply($scope);
                        }, 200);
                    };
                    WikiDrop.log.debug('uploader', uploader);
                    $scope.artifactTemplate = $templateCache.get('fileUpload.html');
                    Core.$apply($scope);
                }
                $scope.$watch("branch", updateURL);
                $scope.$watch("path", updateURL);
            }]
        };
    }]);
})(WikiDrop || (WikiDrop = {}));
var Wiki;
(function (Wiki) {
    Wiki.CamelController = Wiki._module.controller("Wiki.CamelController", ["$scope", "$location", "$routeParams", "localStorage", "workspace", "wikiRepository", "jolokia", function ($scope, $location, $routeParams, localStorage, workspace, wikiRepository, jolokia) {
        Wiki.initScope($scope, $routeParams, $location);
        Camel.initEndpointChooserScope($scope, $location, localStorage, workspace, jolokia);
        $scope.schema = Camel.getConfiguredCamelModel();
        $scope.modified = false;
        $scope.switchToCanvasView = new UI.Dialog();
        $scope.findProfileCamelContext = true;
        $scope.camelSelectionDetails = {
            selectedCamelContextId: null,
            selectedRouteId: null
        };
        $scope.isValid = function (nav) {
            return nav && nav.isValid(workspace);
        };
        $scope.camelSubLevelTabs = [
            {
                content: '<i class=" icon-sitemap"></i> Tree',
                title: "View the routes as a tree",
                isValid: function (workspace) { return true; },
                href: function () { return Wiki.startLink($scope.branch) + "/camel/properties/" + $scope.pageId; }
            },
        ];
        var routeModel = _apacheCamelModel.definitions.route;
        routeModel["_id"] = "route";
        $scope.addDialog = new UI.Dialog();
        $scope.addDialog.options["dialogClass"] = "modal-large";
        $scope.addDialog.options["cssClass"] = "modal-large";
        $scope.paletteItemSearch = "";
        $scope.paletteTree = new Folder("Palette");
        $scope.paletteActivations = ["Routing_aggregate"];
        angular.forEach(_apacheCamelModel.definitions, function (value, key) {
            if (value.group) {
                var group = (key === "route") ? $scope.paletteTree : $scope.paletteTree.getOrElse(value.group);
                if (!group.key) {
                    group.key = value.group;
                }
                value["_id"] = key;
                var title = value["title"] || key;
                var node = new Folder(title);
                node.key = group.key + "_" + key;
                node["nodeModel"] = value;
                var imageUrl = Camel.getRouteNodeIcon(value);
                node.icon = imageUrl;
                var tooltip = value["tooltip"] || value["description"] || '';
                node.tooltip = tooltip;
                group.children.push(node);
            }
        });
        $scope.componentTree = new Folder("Endpoints");
        $scope.$watch("componentNames", function () {
            var componentNames = $scope.componentNames;
            if (componentNames && componentNames.length) {
                $scope.componentTree = new Folder("Endpoints");
                angular.forEach($scope.componentNames, function (endpointName) {
                    var category = Camel.getEndpointCategory(endpointName);
                    var groupName = category.label || "Core";
                    var groupKey = category.id || groupName;
                    var group = $scope.componentTree.getOrElse(groupName);
                    var value = Camel.getEndpointConfig(endpointName, category);
                    var key = endpointName;
                    var label = value["label"] || endpointName;
                    var node = new Folder(label);
                    node.key = groupKey + "_" + key;
                    node.key = key;
                    node["nodeModel"] = value;
                    var tooltip = value["tooltip"] || value["description"] || label;
                    var imageUrl = Core.url(value["icon"] || Camel.endpointIcon);
                    node.icon = imageUrl;
                    node.tooltip = tooltip;
                    group.children.push(node);
                });
            }
        });
        $scope.componentActivations = ["bean"];
        $scope.$watch('addDialog.show', function () {
            if ($scope.addDialog.show) {
                setTimeout(function () {
                    $('#submit').focus();
                }, 50);
            }
        });
        $scope.$on("hawtio.form.modelChange", onModelChangeEvent);
        $scope.onRootTreeNode = function (rootTreeNode) {
            $scope.rootTreeNode = rootTreeNode;
            rootTreeNode.data = $scope.camelContextTree;
        };
        $scope.addNode = function () {
            if ($scope.nodeXmlNode) {
                $scope.addDialog.open();
            }
            else {
                addNewNode(routeModel);
            }
        };
        $scope.onPaletteSelect = function (node) {
            $scope.selectedPaletteNode = (node && node["nodeModel"]) ? node : null;
            if ($scope.selectedPaletteNode) {
                $scope.selectedComponentNode = null;
            }
            console.log("Selected " + $scope.selectedPaletteNode + " : " + $scope.selectedComponentNode);
        };
        $scope.onComponentSelect = function (node) {
            $scope.selectedComponentNode = (node && node["nodeModel"]) ? node : null;
            if ($scope.selectedComponentNode) {
                $scope.selectedPaletteNode = null;
                var nodeName = node.key;
                console.log("loading endpoint schema for node " + nodeName);
                $scope.loadEndpointSchema(nodeName);
                $scope.selectedComponentName = nodeName;
            }
            console.log("Selected " + $scope.selectedPaletteNode + " : " + $scope.selectedComponentNode);
        };
        $scope.selectedNodeModel = function () {
            var nodeModel = null;
            if ($scope.selectedPaletteNode) {
                nodeModel = $scope.selectedPaletteNode["nodeModel"];
                $scope.endpointConfig = null;
            }
            else if ($scope.selectedComponentNode) {
                var endpointConfig = $scope.selectedComponentNode["nodeModel"];
                var endpointSchema = $scope.endpointSchema;
                nodeModel = $scope.schema.definitions.endpoint;
                $scope.endpointConfig = {
                    key: $scope.selectedComponentNode.key,
                    schema: endpointSchema,
                    details: endpointConfig
                };
            }
            return nodeModel;
        };
        $scope.addAndCloseDialog = function () {
            var nodeModel = $scope.selectedNodeModel();
            if (nodeModel) {
                addNewNode(nodeModel);
            }
            else {
                console.log("WARNING: no nodeModel!");
            }
            $scope.addDialog.close();
        };
        $scope.removeNode = function () {
            if ($scope.selectedFolder && $scope.treeNode) {
                $scope.selectedFolder.detach();
                $scope.treeNode.remove();
                $scope.selectedFolder = null;
                $scope.treeNode = null;
            }
        };
        $scope.canDelete = function () {
            return $scope.selectedFolder ? true : false;
        };
        $scope.isActive = function (nav) {
            if (angular.isString(nav))
                return workspace.isLinkActive(nav);
            var fn = nav.isActive;
            if (fn) {
                return fn(workspace);
            }
            return workspace.isLinkActive(nav.href());
        };
        $scope.save = function () {
            if ($scope.modified && $scope.rootTreeNode) {
                var xmlNode = Camel.generateXmlFromFolder($scope.rootTreeNode);
                if (xmlNode) {
                    var text = Core.xmlNodeToString(xmlNode);
                    if (text) {
                        var commitMessage = $scope.commitMessage || "Updated page " + $scope.pageId;
                        wikiRepository.putPage($scope.branch, $scope.pageId, text, commitMessage, function (status) {
                            Wiki.onComplete(status);
                            Core.notification("success", "Saved " + $scope.pageId);
                            $scope.modified = false;
                            goToView();
                            Core.$apply($scope);
                        });
                    }
                }
            }
        };
        $scope.cancel = function () {
            console.log("cancelling...");
        };
        $scope.$watch('workspace.tree', function () {
            if (!$scope.git) {
                setTimeout(updateView, 50);
            }
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateView, 50);
        });
        function getFolderXmlNode(treeNode) {
            var routeXmlNode = Camel.createFolderXmlTree(treeNode, null);
            if (routeXmlNode) {
                $scope.nodeXmlNode = routeXmlNode;
            }
            return routeXmlNode;
        }
        $scope.onNodeSelect = function (folder, treeNode) {
            $scope.selectedFolder = folder;
            $scope.treeNode = treeNode;
            $scope.propertiesTemplate = null;
            $scope.diagramTemplate = null;
            $scope.nodeXmlNode = null;
            if (folder) {
                $scope.nodeData = Camel.getRouteFolderJSON(folder);
                $scope.nodeDataChangedFields = {};
            }
            var nodeName = Camel.getFolderCamelNodeId(folder);
            var routeXmlNode = getFolderXmlNode(treeNode);
            if (nodeName) {
                $scope.nodeModel = Camel.getCamelSchema(nodeName);
                if ($scope.nodeModel) {
                    $scope.propertiesTemplate = "app/wiki/html/camelPropertiesEdit.html";
                }
                $scope.diagramTemplate = "app/camel/html/routes.html";
                Core.$apply($scope);
            }
        };
        $scope.onNodeDragEnter = function (node, sourceNode) {
            var nodeFolder = node.data;
            var sourceFolder = sourceNode.data;
            if (nodeFolder && sourceFolder) {
                var nodeId = Camel.getFolderCamelNodeId(nodeFolder);
                var sourceId = Camel.getFolderCamelNodeId(sourceFolder);
                if (nodeId && sourceId) {
                    if (sourceId === "route") {
                        return nodeId === "route";
                    }
                    return true;
                }
            }
            return false;
        };
        $scope.onNodeDrop = function (node, sourceNode, hitMode, ui, draggable) {
            var nodeFolder = node.data;
            var sourceFolder = sourceNode.data;
            if (nodeFolder && sourceFolder) {
                var nodeId = Camel.getFolderCamelNodeId(nodeFolder);
                var sourceId = Camel.getFolderCamelNodeId(sourceFolder);
                if (nodeId === "route") {
                    if (sourceId === "route") {
                        if (hitMode === "over") {
                            hitMode = "after";
                        }
                    }
                    else {
                        hitMode = "over";
                    }
                }
                else {
                    if (Camel.acceptOutput(nodeId)) {
                        hitMode = "over";
                    }
                    else {
                        if (hitMode !== "before") {
                            hitMode = "after";
                        }
                    }
                }
                console.log("nodeDrop nodeId: " + nodeId + " sourceId: " + sourceId + " hitMode: " + hitMode);
                sourceNode.move(node, hitMode);
            }
        };
        updateView();
        function addNewNode(nodeModel) {
            var doc = $scope.doc || document;
            var parentFolder = $scope.selectedFolder || $scope.camelContextTree;
            var key = nodeModel["_id"];
            var beforeNode = null;
            if (!key) {
                console.log("WARNING: no id for model " + JSON.stringify(nodeModel));
            }
            else {
                var treeNode = $scope.treeNode;
                if (key === "route") {
                    treeNode = $scope.rootTreeNode;
                }
                else {
                    if (!treeNode) {
                        var root = $scope.rootTreeNode;
                        var children = root.getChildren();
                        if (!children || !children.length) {
                            addNewNode(Camel.getCamelSchema("route"));
                            children = root.getChildren();
                        }
                        if (children && children.length) {
                            treeNode = children[children.length - 1];
                        }
                        else {
                            console.log("Could not add a new route to the empty tree!");
                            return;
                        }
                    }
                    var parentId = Camel.getFolderCamelNodeId(treeNode.data);
                    if (!Camel.acceptOutput(parentId)) {
                        beforeNode = treeNode.getNextSibling();
                        treeNode = treeNode.getParent() || treeNode;
                    }
                }
                if (treeNode) {
                    var node = doc.createElement(key);
                    parentFolder = treeNode.data;
                    var addedNode = Camel.addRouteChild(parentFolder, node);
                    if (addedNode) {
                        var added = treeNode.addChild(addedNode, beforeNode);
                        if (added) {
                            getFolderXmlNode(added);
                            added.expand(true);
                            added.select(true);
                            added.activate(true);
                        }
                    }
                }
            }
        }
        function onModelChangeEvent(event, name) {
            if ($scope.nodeData) {
                var fieldMap = $scope.nodeDataChangedFields;
                if (fieldMap) {
                    if (fieldMap[name]) {
                        onNodeDataChanged();
                    }
                    else {
                        fieldMap[name] = true;
                    }
                }
            }
        }
        function onNodeDataChanged() {
            $scope.modified = true;
            var selectedFolder = $scope.selectedFolder;
            if ($scope.treeNode && selectedFolder) {
                var routeXmlNode = getFolderXmlNode($scope.treeNode);
                if (routeXmlNode) {
                    var nodeName = routeXmlNode.localName;
                    var nodeSettings = Camel.getCamelSchema(nodeName);
                    if (nodeSettings) {
                        Camel.updateRouteNodeLabelAndTooltip(selectedFolder, routeXmlNode, nodeSettings);
                        $scope.treeNode.render(false, false);
                    }
                }
                selectedFolder["camelNodeData"] = $scope.nodeData;
            }
        }
        function onResults(response) {
            var text = response.text;
            if (text) {
                var tree = Camel.loadCamelTree(text, $scope.pageId);
                if (tree) {
                    $scope.camelContextTree = tree;
                }
            }
            else {
                console.log("No XML found for page " + $scope.pageId);
            }
            Core.$applyLater($scope);
        }
        function updateView() {
            $scope.loadEndpointNames();
            $scope.pageId = Wiki.pageId($routeParams, $location);
            console.log("Has page id: " + $scope.pageId + " with $routeParams " + JSON.stringify($routeParams));
            if (Git.getGitMBean(workspace)) {
                $scope.git = wikiRepository.getPage($scope.branch, $scope.pageId, $scope.objectId, onResults);
            }
        }
        function goToView() {
        }
        $scope.doSwitchToCanvasView = function () {
            $location.url(Core.trimLeading((Wiki.startLink($scope.branch) + "/camel/canvas/" + $scope.pageId), '#'));
        };
        $scope.confirmSwitchToCanvasView = function () {
            if ($scope.modified) {
                $scope.switchToCanvasView.open();
            }
            else {
                $scope.doSwitchToCanvasView();
            }
        };
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki.CamelCanvasController = Wiki._module.controller("Wiki.CamelCanvasController", ["$scope", "$element", "workspace", "jolokia", "wikiRepository", "$templateCache", "$interpolate", "$location", function ($scope, $element, workspace, jolokia, wikiRepository, $templateCache, $interpolate, $location) {
        var jsPlumbInstance = jsPlumb.getInstance();
        $scope.addDialog = new UI.Dialog();
        $scope.propertiesDialog = new UI.Dialog();
        $scope.switchToTreeView = new UI.Dialog();
        $scope.modified = false;
        $scope.camelIgnoreIdForLabel = Camel.ignoreIdForLabel(localStorage);
        $scope.camelMaximumLabelWidth = Camel.maximumLabelWidth(localStorage);
        $scope.camelMaximumTraceOrDebugBodyLength = Camel.maximumTraceOrDebugBodyLength(localStorage);
        $scope.forms = {};
        $scope.nodeTemplate = $interpolate($templateCache.get("nodeTemplate"));
        $scope.$watch("camelContextTree", function () {
            var tree = $scope.camelContextTree;
            $scope.rootFolder = tree;
            $scope.folders = Camel.addFoldersToIndex($scope.rootFolder);
            var doc = Core.pathGet(tree, ["xmlDocument"]);
            if (doc) {
                $scope.doc = doc;
                reloadRouteIds();
                onRouteSelectionChanged();
            }
        });
        $scope.addAndCloseDialog = function () {
            var nodeModel = $scope.selectedNodeModel();
            if (nodeModel) {
                addNewNode(nodeModel);
            }
            $scope.addDialog.close();
        };
        $scope.removeNode = function () {
            var folder = getSelectedOrRouteFolder();
            if (folder) {
                var nodeName = Camel.getFolderCamelNodeId(folder);
                folder.detach();
                if ("route" === nodeName) {
                    $scope.selectedRouteId = null;
                }
                updateSelection(null);
                treeModified();
            }
        };
        $scope.doLayout = function () {
            $scope.drawnRouteId = null;
            onRouteSelectionChanged();
        };
        function isRouteOrNode() {
            return !$scope.selectedFolder;
        }
        $scope.getDeleteTitle = function () {
            if (isRouteOrNode()) {
                return "Delete this route";
            }
            return "Delete this node";
        };
        $scope.getDeleteTarget = function () {
            if (isRouteOrNode()) {
                return "Route";
            }
            return "Node";
        };
        $scope.isFormDirty = function () {
            Wiki.log.debug("endpointForm: ", $scope.endpointForm);
            if ($scope.endpointForm.$dirty) {
                return true;
            }
            if (!$scope.forms['formEditor']) {
                return false;
            }
            else {
                return $scope.forms['formEditor']['$dirty'];
            }
        };
        function createEndpointURI(endpointScheme, slashesText, endpointPath, endpointParameters) {
            console.log("scheme " + endpointScheme + " path " + endpointPath + " parameters " + endpointParameters);
            var uri = ((endpointScheme) ? endpointScheme + ":" + slashesText : "") + (endpointPath ? endpointPath : "");
            var paramText = Core.hashToString(endpointParameters);
            if (paramText) {
                uri += "?" + paramText;
            }
            return uri;
        }
        $scope.updateProperties = function () {
            Wiki.log.info("old URI is " + $scope.nodeData.uri);
            var uri = createEndpointURI($scope.endpointScheme, ($scope.endpointPathHasSlashes ? "//" : ""), $scope.endpointPath, $scope.endpointParameters);
            Wiki.log.info("new URI is " + uri);
            if (uri) {
                $scope.nodeData.uri = uri;
            }
            var key = null;
            var selectedFolder = $scope.selectedFolder;
            if (selectedFolder) {
                key = selectedFolder.key;
                var elements = $element.find(".canvas").find("[id='" + key + "']").first().remove();
            }
            treeModified();
            if (key) {
                updateSelection(key);
            }
            if ($scope.isFormDirty()) {
                $scope.endpointForm.$setPristine();
                if ($scope.forms['formEditor']) {
                    $scope.forms['formEditor'].$setPristine();
                }
            }
            Core.$apply($scope);
        };
        $scope.save = function () {
            if ($scope.modified && $scope.rootFolder) {
                var xmlNode = Camel.generateXmlFromFolder($scope.rootFolder);
                if (xmlNode) {
                    var text = Core.xmlNodeToString(xmlNode);
                    if (text) {
                        var decoded = decodeURIComponent(text);
                        Wiki.log.debug("Saving xml decoded: " + decoded);
                        var commitMessage = $scope.commitMessage || "Updated page " + $scope.pageId;
                        wikiRepository.putPage($scope.branch, $scope.pageId, decoded, commitMessage, function (status) {
                            Wiki.onComplete(status);
                            Core.notification("success", "Saved " + $scope.pageId);
                            $scope.modified = false;
                            goToView();
                            Core.$apply($scope);
                        });
                    }
                }
            }
        };
        $scope.cancel = function () {
            console.log("cancelling...");
        };
        $scope.$watch("selectedRouteId", onRouteSelectionChanged);
        function goToView() {
        }
        function addNewNode(nodeModel) {
            var doc = $scope.doc || document;
            var parentFolder = $scope.selectedFolder || $scope.rootFolder;
            var key = nodeModel["_id"];
            if (!key) {
                console.log("WARNING: no id for model " + JSON.stringify(nodeModel));
            }
            else {
                var treeNode = $scope.selectedFolder;
                if (key === "route") {
                    treeNode = $scope.rootFolder;
                }
                else {
                    if (!treeNode) {
                        var root = $scope.rootFolder;
                        var children = root.children;
                        if (!children || !children.length) {
                            addNewNode(Camel.getCamelSchema("route"));
                            children = root.children;
                        }
                        if (children && children.length) {
                            treeNode = getRouteFolder($scope.rootFolder, $scope.selectedRouteId) || children[children.length - 1];
                        }
                        else {
                            console.log("Could not add a new route to the empty tree!");
                            return;
                        }
                    }
                    var parentTypeName = Camel.getFolderCamelNodeId(treeNode);
                    if (!Camel.acceptOutput(parentTypeName)) {
                        treeNode = treeNode.parent || treeNode;
                    }
                }
                if (treeNode) {
                    var node = doc.createElement(key);
                    parentFolder = treeNode;
                    var addedNode = Camel.addRouteChild(parentFolder, node);
                    var nodeData = {};
                    if (key === "endpoint" && $scope.endpointConfig) {
                        var key = $scope.endpointConfig.key;
                        if (key) {
                            nodeData["uri"] = key + ":";
                        }
                    }
                    addedNode["camelNodeData"] = nodeData;
                    addedNode["endpointConfig"] = $scope.endpointConfig;
                    if (key === "route") {
                        var count = $scope.routeIds.length;
                        var nodeId = null;
                        while (true) {
                            nodeId = "route" + (++count);
                            if (!$scope.routeIds.find(nodeId)) {
                                break;
                            }
                        }
                        addedNode["routeXmlNode"].setAttribute("id", nodeId);
                        $scope.selectedRouteId = nodeId;
                    }
                }
            }
            treeModified();
        }
        function treeModified(reposition) {
            if (reposition === void 0) { reposition = true; }
            var newDoc = Camel.generateXmlFromFolder($scope.rootFolder);
            var tree = Camel.loadCamelTree(newDoc, $scope.pageId);
            if (tree) {
                $scope.rootFolder = tree;
                $scope.doc = Core.pathGet(tree, ["xmlDocument"]);
            }
            $scope.modified = true;
            reloadRouteIds();
            $scope.doLayout();
            Core.$apply($scope);
        }
        function reloadRouteIds() {
            $scope.routeIds = [];
            var doc = $($scope.doc);
            $scope.camelSelectionDetails.selectedCamelContextId = doc.find("camelContext").attr("id");
            doc.find("route").each(function (idx, route) {
                var id = route.getAttribute("id");
                if (id) {
                    $scope.routeIds.push(id);
                }
            });
        }
        function onRouteSelectionChanged() {
            if ($scope.doc) {
                if (!$scope.selectedRouteId && $scope.routeIds && $scope.routeIds.length) {
                    $scope.selectedRouteId = $scope.routeIds[0];
                }
                if ($scope.selectedRouteId && $scope.selectedRouteId !== $scope.drawnRouteId) {
                    var nodes = [];
                    var links = [];
                    Camel.loadRouteXmlNodes($scope, $scope.doc, $scope.selectedRouteId, nodes, links, getWidth());
                    updateSelection($scope.selectedRouteId);
                    $scope.folders = Camel.addFoldersToIndex($scope.rootFolder);
                    showGraph(nodes, links);
                    $scope.drawnRouteId = $scope.selectedRouteId;
                }
                $scope.camelSelectionDetails.selectedRouteId = $scope.selectedRouteId;
            }
        }
        function showGraph(nodes, links) {
            layoutGraph(nodes, links);
        }
        function getNodeId(node) {
            if (angular.isNumber(node)) {
                var idx = node;
                node = $scope.nodeStates[idx];
                if (!node) {
                    console.log("Cant find node at " + idx);
                    return "node-" + idx;
                }
            }
            return node.cid || "node-" + node.id;
        }
        function getSelectedOrRouteFolder() {
            return $scope.selectedFolder || getRouteFolder($scope.rootFolder, $scope.selectedRouteId);
        }
        function getContainerElement() {
            var rootElement = $element;
            var containerElement = rootElement.find(".canvas");
            if (!containerElement || !containerElement.length)
                containerElement = rootElement;
            return containerElement;
        }
        var endpointStyle = ["Dot", { radius: 4, cssClass: 'camel-canvas-endpoint' }];
        var hoverPaintStyle = { strokeStyle: "red", lineWidth: 3 };
        var labelStyles = ["Label"];
        var arrowStyles = ["Arrow", {
            location: 1,
            id: "arrow",
            length: 8,
            width: 8,
            foldback: 0.8
        }];
        var connectorStyle = ["StateMachine", { curviness: 10, proximityLimit: 50 }];
        jsPlumbInstance.importDefaults({
            Endpoint: endpointStyle,
            HoverPaintStyle: hoverPaintStyle,
            ConnectionOverlays: [
                arrowStyles,
                labelStyles
            ]
        });
        $scope.$on('$destroy', function () {
            jsPlumbInstance.reset();
            delete jsPlumbInstance;
        });
        jsPlumbInstance.bind("dblclick", function (connection, originalEvent) {
            if (jsPlumbInstance.isSuspendDrawing()) {
                return;
            }
            alert("double click on connection from " + connection.sourceId + " to " + connection.targetId);
        });
        jsPlumbInstance.bind('connection', function (info, evt) {
            Wiki.log.debug("Creating connection from ", info.sourceId, " to ", info.targetId);
            var link = getLink(info);
            var source = $scope.nodes[link.source];
            var sourceFolder = $scope.folders[link.source];
            var targetFolder = $scope.folders[link.target];
            if (Camel.isNextSiblingAddedAsChild(source.type)) {
                sourceFolder.moveChild(targetFolder);
            }
            else {
                sourceFolder.parent.insertAfter(targetFolder, sourceFolder);
            }
            treeModified();
        });
        jsPlumbInstance.bind("click", function (c) {
            if (jsPlumbInstance.isSuspendDrawing()) {
                return;
            }
            jsPlumbInstance.detach(c);
        });
        function layoutGraph(nodes, links) {
            var transitions = [];
            var states = Core.createGraphStates(nodes, links, transitions);
            Wiki.log.debug("links: ", links);
            Wiki.log.debug("transitions: ", transitions);
            $scope.nodeStates = states;
            var containerElement = getContainerElement();
            jsPlumbInstance.doWhileSuspended(function () {
                containerElement.css({
                    'width': '800px',
                    'height': '800px',
                    'min-height': '800px',
                    'min-width': '800px'
                });
                var containerHeight = 0;
                var containerWidth = 0;
                containerElement.find('div.component').each(function (i, el) {
                    Wiki.log.debug("Checking: ", el, " ", i);
                    if (!states.any(function (node) {
                        return el.id === getNodeId(node);
                    })) {
                        Wiki.log.debug("Removing element: ", el.id);
                        jsPlumbInstance.remove(el);
                    }
                });
                angular.forEach(states, function (node) {
                    Wiki.log.debug("node: ", node);
                    var id = getNodeId(node);
                    var div = containerElement.find('#' + id);
                    if (!div[0]) {
                        div = $($scope.nodeTemplate({
                            id: id,
                            node: node
                        }));
                        div.appendTo(containerElement);
                    }
                    jsPlumbInstance.makeSource(div, {
                        filter: "img.nodeIcon",
                        anchor: "Continuous",
                        connector: connectorStyle,
                        connectorStyle: { strokeStyle: "#666", lineWidth: 3 },
                        maxConnections: -1
                    });
                    jsPlumbInstance.makeTarget(div, {
                        dropOptions: { hoverClass: "dragHover" },
                        anchor: "Continuous"
                    });
                    jsPlumbInstance.draggable(div, {
                        containment: '.camel-canvas'
                    });
                    div.click(function () {
                        var newFlag = !div.hasClass("selected");
                        containerElement.find('div.component').toggleClass("selected", false);
                        div.toggleClass("selected", newFlag);
                        var id = div.attr("id");
                        updateSelection(newFlag ? id : null);
                        Core.$apply($scope);
                    });
                    div.dblclick(function () {
                        var id = div.attr("id");
                        updateSelection(id);
                        Core.$apply($scope);
                    });
                    var height = div.height();
                    var width = div.width();
                    if (height || width) {
                        node.width = width;
                        node.height = height;
                        div.css({
                            'min-width': width,
                            'min-height': height
                        });
                    }
                });
                var edgeSep = 10;
                dagre.layout().nodeSep(100).edgeSep(edgeSep).rankSep(75).nodes(states).edges(transitions).debugLevel(1).run();
                angular.forEach(states, function (node) {
                    var id = getNodeId(node);
                    var div = $("#" + id);
                    var divHeight = div.height();
                    var divWidth = div.width();
                    var leftOffset = node.dagre.x + divWidth;
                    var bottomOffset = node.dagre.y + divHeight;
                    if (containerHeight < bottomOffset) {
                        containerHeight = bottomOffset + edgeSep * 2;
                    }
                    if (containerWidth < leftOffset) {
                        containerWidth = leftOffset + edgeSep * 2;
                    }
                    div.css({ top: node.dagre.y, left: node.dagre.x });
                });
                containerElement.css({
                    'width': containerWidth,
                    'height': containerHeight,
                    'min-height': containerHeight,
                    'min-width': containerWidth
                });
                containerElement.dblclick(function () {
                    $scope.propertiesDialog.open();
                });
                jsPlumbInstance.setSuspendEvents(true);
                jsPlumbInstance.detachEveryConnection({ fireEvent: false });
                angular.forEach(links, function (link) {
                    jsPlumbInstance.connect({
                        source: getNodeId(link.source),
                        target: getNodeId(link.target)
                    });
                });
                jsPlumbInstance.setSuspendEvents(false);
            });
            return states;
        }
        function getLink(info) {
            var sourceId = info.sourceId;
            var targetId = info.targetId;
            return {
                source: sourceId,
                target: targetId
            };
        }
        function getNodeByCID(nodes, cid) {
            return nodes.find(function (node) {
                return node.cid === cid;
            });
        }
        function updateSelection(folderOrId) {
            var folder = null;
            if (angular.isString(folderOrId)) {
                var id = folderOrId;
                folder = (id && $scope.folders) ? $scope.folders[id] : null;
            }
            else {
                folder = folderOrId;
            }
            $scope.selectedFolder = folder;
            folder = getSelectedOrRouteFolder();
            $scope.nodeXmlNode = null;
            $scope.propertiesTemplate = null;
            if (folder) {
                var nodeName = Camel.getFolderCamelNodeId(folder);
                $scope.nodeData = Camel.getRouteFolderJSON(folder);
                $scope.nodeDataChangedFields = {};
                $scope.nodeModel = Camel.getCamelSchema(nodeName);
                if ($scope.nodeModel) {
                    $scope.propertiesTemplate = "app/wiki/html/camelPropertiesEdit.html";
                }
                $scope.selectedEndpoint = null;
                if ("endpoint" === nodeName) {
                    var uri = $scope.nodeData["uri"];
                    if (uri) {
                        var idx = uri.indexOf(":");
                        if (idx > 0) {
                            var endpointScheme = uri.substring(0, idx);
                            var endpointPath = uri.substring(idx + 1);
                            $scope.endpointPathHasSlashes = endpointPath ? false : true;
                            if (endpointPath.startsWith("//")) {
                                endpointPath = endpointPath.substring(2);
                                $scope.endpointPathHasSlashes = true;
                            }
                            idx = endpointPath.indexOf("?");
                            var endpointParameters = {};
                            if (idx > 0) {
                                var parameters = endpointPath.substring(idx + 1);
                                endpointPath = endpointPath.substring(0, idx);
                                endpointParameters = Core.stringToHash(parameters);
                            }
                            $scope.endpointScheme = endpointScheme;
                            $scope.endpointPath = endpointPath;
                            $scope.endpointParameters = endpointParameters;
                            console.log("endpoint " + endpointScheme + " path " + endpointPath + " and parameters " + JSON.stringify(endpointParameters));
                            $scope.loadEndpointSchema(endpointScheme);
                            $scope.selectedEndpoint = {
                                endpointScheme: endpointScheme,
                                endpointPath: endpointPath,
                                parameters: endpointParameters
                            };
                        }
                    }
                }
            }
        }
        function getWidth() {
            var canvasDiv = $($element);
            return canvasDiv.width();
        }
        function getFolderIdAttribute(route) {
            var id = null;
            if (route) {
                var xmlNode = route["routeXmlNode"];
                if (xmlNode) {
                    id = xmlNode.getAttribute("id");
                }
            }
            return id;
        }
        function getRouteFolder(tree, routeId) {
            var answer = null;
            if (tree) {
                angular.forEach(tree.children, function (route) {
                    if (!answer) {
                        var id = getFolderIdAttribute(route);
                        if (routeId === id) {
                            answer = route;
                        }
                    }
                });
            }
            return answer;
        }
        $scope.doSwitchToTreeView = function () {
            $location.url(Core.trimLeading(($scope.startLink + "/camel/properties/" + $scope.pageId), '#'));
        };
        $scope.confirmSwitchToTreeView = function () {
            if ($scope.modified) {
                $scope.switchToTreeView.open();
            }
            else {
                $scope.doSwitchToTreeView();
            }
        };
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki._module.controller("Wiki.CommitController", ["$scope", "$location", "$routeParams", "$templateCache", "workspace", "marked", "fileExtensionTypeRegistry", "wikiRepository", "jolokia", function ($scope, $location, $routeParams, $templateCache, workspace, marked, fileExtensionTypeRegistry, wikiRepository, jolokia) {
        var isFmc = Fabric.isFMCContainer(workspace);
        Wiki.initScope($scope, $routeParams, $location);
        $scope.commitId = $scope.objectId;
        $scope.selectedItems = [];
        $scope.dateFormat = 'EEE, MMM d, y : hh:mm:ss a';
        $scope.gridOptions = {
            data: 'commits',
            showFilter: false,
            multiSelect: false,
            selectWithCheckboxOnly: true,
            showSelectionCheckbox: true,
            displaySelectionCheckbox: true,
            selectedItems: $scope.selectedItems,
            filterOptions: {
                filterText: ''
            },
            columnDefs: [
                {
                    field: 'path',
                    displayName: 'File Name',
                    cellTemplate: $templateCache.get('fileCellTemplate.html'),
                    width: "***",
                    cellFilter: ""
                },
            ]
        };
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateView, 50);
        });
        $scope.$watch('workspace.tree', function () {
            if (!$scope.git && Git.getGitMBean(workspace)) {
                setTimeout(updateView, 50);
            }
        });
        $scope.canRevert = function () {
            return $scope.selectedItems.length === 1;
        };
        $scope.revert = function () {
            if ($scope.selectedItems.length > 0) {
                var path = commitPath($scope.selectedItems[0]);
                var objectId = $scope.commitId;
                if (path && objectId) {
                    var commitMessage = "Reverting file " + $scope.pageId + " to previous version " + objectId;
                    wikiRepository.revertTo($scope.branch, objectId, $scope.pageId, commitMessage, function (result) {
                        Wiki.onComplete(result);
                        updateView();
                    });
                }
            }
        };
        function commitPath(commit) {
            return commit.path || commit.name;
        }
        $scope.diff = function () {
            if ($scope.selectedItems.length > 0) {
                var commit = $scope.selectedItems[0];
                var link = Wiki.startLink($scope.branch) + "/diff/" + commitPath(commit) + "/" + $scope.commitId + "/";
                var path = Core.trimLeading(link, "#");
                $location.path(path);
            }
        };
        updateView();
        function updateView() {
            var commitId = $scope.commitId;
            Wiki.loadBranches(jolokia, wikiRepository, $scope, isFmc);
            wikiRepository.commitInfo(commitId, function (commitInfo) {
                $scope.commitInfo = commitInfo;
                Core.$apply($scope);
            });
            wikiRepository.commitTree(commitId, function (commits) {
                $scope.commits = commits;
                angular.forEach(commits, function (commit) {
                    commit.fileIconHtml = Wiki.fileIconHtml(commit);
                    commit.fileClass = commit.name.endsWith(".profile") ? "green" : "";
                    var changeType = commit.changeType;
                    var path = commitPath(commit);
                    if (path) {
                        commit.fileLink = Wiki.startLink($scope.branch) + '/version/' + path + '/' + commitId;
                    }
                    if (changeType) {
                        changeType = changeType.toLowerCase();
                        if (changeType.startsWith("a")) {
                            commit.changeClass = "change-add";
                            commit.change = "add";
                            commit.title = "added";
                        }
                        else if (changeType.startsWith("d")) {
                            commit.changeClass = "change-delete";
                            commit.change = "delete";
                            commit.title = "deleted";
                            commit.fileLink = null;
                        }
                        else {
                            commit.changeClass = "change-modify";
                            commit.change = "modify";
                            commit.title = "modified";
                        }
                        commit.changeTypeHtml = '<span class="' + commit.changeClass + '">' + commit.title + '</span>';
                    }
                });
                Core.$apply($scope);
            });
        }
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    var CreateController = Wiki.controller("CreateController", ["$scope", "$location", "$routeParams", "$route", "$http", "$timeout", "workspace", "jolokia", "wikiRepository", function ($scope, $location, $routeParams, $route, $http, $timeout, workspace, jolokia, wikiRepository) {
        var isFmc = Fabric.isFMCContainer(workspace);
        Wiki.initScope($scope, $routeParams, $location);
        $scope.createDocumentTree = Wiki.createWizardTree(workspace, $scope);
        $scope.createDocumentTreeActivations = ["camel-spring.xml", "ReadMe.md"];
        $scope.fileExists = {
            exists: false,
            name: ""
        };
        $scope.newDocumentName = "";
        $scope.selectedCreateDocumentExtension = null;
        $scope.fileExists.exists = false;
        $scope.fileExists.name = "";
        $scope.newDocumentName = "";
        function returnToDirectory() {
            var link = Wiki.viewLink($scope.branch, $scope.pageId, $location);
            Wiki.log.debug("Cancelling, going to link: ", link);
            Wiki.goToLink(link, $timeout, $location);
        }
        $scope.cancel = function () {
            returnToDirectory();
        };
        $scope.onCreateDocumentSelect = function (node) {
            $scope.fileExists.exists = false;
            $scope.fileExists.name = "";
            var entity = node ? node.entity : null;
            $scope.selectedCreateDocumentTemplate = entity;
            $scope.selectedCreateDocumentTemplateRegex = $scope.selectedCreateDocumentTemplate.regex || /.*/;
            $scope.selectedCreateDocumentTemplateInvalid = $scope.selectedCreateDocumentTemplate.invalid || "invalid name";
            $scope.selectedCreateDocumentTemplateExtension = $scope.selectedCreateDocumentTemplate.extension || null;
            Wiki.log.debug("Entity: ", entity);
            if (entity) {
                if (entity.generated) {
                    $scope.formSchema = entity.generated.schema;
                    $scope.formData = entity.generated.form(workspace, $scope);
                }
                else {
                    $scope.formSchema = {};
                    $scope.formData = {};
                }
                Core.$apply($scope);
            }
        };
        $scope.addAndCloseDialog = function (fileName) {
            $scope.newDocumentName = fileName;
            var template = $scope.selectedCreateDocumentTemplate;
            var path = getNewDocumentPath();
            $scope.newDocumentName = null;
            $scope.fileExists.exists = false;
            $scope.fileExists.name = "";
            $scope.fileExtensionInvalid = null;
            if (!template || !path) {
                return;
            }
            if ($scope.selectedCreateDocumentTemplateExtension) {
                var idx = path.lastIndexOf('.');
                if (idx > 0) {
                    var ext = path.substring(idx);
                    if ($scope.selectedCreateDocumentTemplateExtension !== ext) {
                        $scope.fileExtensionInvalid = "File extension must be: " + $scope.selectedCreateDocumentTemplateExtension;
                        Core.$apply($scope);
                        return;
                    }
                }
            }
            var exists = wikiRepository.exists($scope.branch, path, null);
            if (exists) {
                $scope.fileExists.exists = true;
                $scope.fileExists.name = path;
                Core.$apply($scope);
                return;
            }
            var name = Wiki.fileName(path);
            var folder = Wiki.fileParent(path);
            var exemplar = template.exemplar;
            var commitMessage = "Created " + template.label;
            var exemplarUri = Core.url("/app/wiki/exemplar/" + exemplar);
            if (template.folder) {
                Core.notification("success", "Creating new folder " + name);
                wikiRepository.createDirectory($scope.branch, path, commitMessage, function (status) {
                    var link = Wiki.viewLink($scope.branch, path, $location);
                    Wiki.goToLink(link, $timeout, $location);
                });
            }
            else if (template.profile) {
                function toPath(profileName) {
                    var answer = "fabric/profiles/" + profileName;
                    answer = answer.replace(/-/g, "/");
                    answer = answer + ".profile";
                    return answer;
                }
                function toProfileName(path) {
                    var answer = path.replace(/^fabric\/profiles\//, "");
                    answer = answer.replace(/\//g, "-");
                    answer = answer.replace(/\.profile$/, "");
                    return answer;
                }
                folder = folder.replace(/\/=?(\w*)\.profile$/, "");
                var concatenated = folder + "/" + name;
                var profileName = toProfileName(concatenated);
                var targetPath = toPath(profileName);
                var profile = Fabric.getProfile(workspace.jolokia, $scope.branch, profileName, false);
                if (profile) {
                    $scope.fileExists.exists = true;
                    $scope.fileExists.name = profileName;
                    Core.$apply($scope);
                    return;
                }
                Fabric.createProfile(workspace.jolokia, $scope.branch, profileName, ['default'], function () {
                    Core.$apply($scope);
                    Fabric.newConfigFile(workspace.jolokia, $scope.branch, profileName, 'ReadMe.md', function () {
                        Core.$apply($scope);
                        var contents = "Here's an empty ReadMe.md for '" + profileName + "', please update!";
                        Fabric.saveConfigFile(workspace.jolokia, $scope.branch, profileName, 'ReadMe.md', contents.encodeBase64(), function () {
                            Core.$apply($scope);
                            var link = Wiki.viewLink($scope.branch, targetPath, $location);
                            Wiki.goToLink(link, $timeout, $location);
                        }, function (response) {
                            Core.notification('error', 'Failed to set ReadMe.md data in profile ' + profileName + ' due to ' + response.error);
                            Core.$apply($scope);
                        });
                    }, function (response) {
                        Core.notification('error', 'Failed to create ReadMe.md in profile ' + profileName + ' due to ' + response.error);
                        Core.$apply($scope);
                    });
                }, function (response) {
                    Core.notification('error', 'Failed to create profile ' + profileName + ' due to ' + response.error);
                    Core.$apply($scope);
                });
            }
            else if (template.generated) {
                var options = {
                    workspace: workspace,
                    form: $scope.formData,
                    name: fileName,
                    parentId: folder,
                    branch: $scope.branch,
                    success: function (contents) {
                        if (contents) {
                            wikiRepository.putPageBase64($scope.branch, path, contents, commitMessage, function (status) {
                                Wiki.log.debug("Created file " + name);
                                Wiki.onComplete(status);
                                returnToDirectory();
                            });
                        }
                        else {
                            returnToDirectory();
                        }
                    },
                    error: function (error) {
                        Core.notification('error', error);
                        Core.$apply($scope);
                    }
                };
                template.generated.generate(options);
            }
            else {
                $http.get(exemplarUri).success(function (data, status, headers, config) {
                    putPage(path, name, folder, data, commitMessage);
                }).error(function (data, status, headers, config) {
                    putPage(path, name, folder, "", commitMessage);
                });
            }
        };
        function putPage(path, name, folder, contents, commitMessage) {
            wikiRepository.putPage($scope.branch, path, contents, commitMessage, function (status) {
                Wiki.log.debug("Created file " + name);
                Wiki.onComplete(status);
                $scope.git = wikiRepository.getPage($scope.branch, folder, $scope.objectId, function (details) {
                    var link = null;
                    if (details && details.children) {
                        Wiki.log.debug("scanned the directory " + details.children.length + " children");
                        var child = details.children.find(function (c) { return c.name === Wiki.fileName; });
                        if (child) {
                            link = $scope.childLink(child);
                        }
                        else {
                            Wiki.log.debug("Could not find name '" + Wiki.fileName + "' in the list of file names " + JSON.stringify(details.children.map(function (c) { return c.name; })));
                        }
                    }
                    if (!link) {
                        Wiki.log.debug("WARNING: could not find the childLink so reverting to the wiki edit page!");
                        link = Wiki.editLink($scope.branch, path, $location);
                    }
                    Wiki.goToLink(link, $timeout, $location);
                });
            });
        }
        function getNewDocumentPath() {
            var template = $scope.selectedCreateDocumentTemplate;
            if (!template) {
                Wiki.log.debug("No template selected.");
                return null;
            }
            var exemplar = template.exemplar || "";
            var name = $scope.newDocumentName || exemplar;
            if (name.indexOf('.') < 0) {
                var idx = exemplar.lastIndexOf(".");
                if (idx > 0) {
                    name += exemplar.substring(idx);
                }
            }
            var folder = $scope.pageId;
            if ($scope.isFile) {
                var idx = folder.lastIndexOf("/");
                if (idx <= 0) {
                    folder = "";
                }
                else {
                    folder = folder.substring(0, idx);
                }
            }
            var idx = name.lastIndexOf("/");
            if (idx > 0) {
                folder += "/" + name.substring(0, idx);
                name = name.substring(idx + 1);
            }
            folder = Core.trimLeading(folder, "/");
            return folder + (folder ? "/" : "") + name;
        }
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki._module.controller("Wiki.DozerMappingsController", ["$scope", "$location", "$routeParams", "workspace", "jolokia", "wikiRepository", "$templateCache", function ($scope, $location, $routeParams, workspace, jolokia, wikiRepository, $templateCache) {
        var log = Logger.get("Dozer");
        Wiki.initScope($scope, $routeParams, $location);
        Dozer.schemaConfigure();
        $scope.profileId = Fabric.pagePathToProfileId($scope.pageId);
        $scope.versionId = $scope.branch || "1.0";
        $scope.schema = {};
        $scope.addDialog = new UI.Dialog();
        $scope.propertiesDialog = new UI.Dialog();
        $scope.deleteDialog = false;
        $scope.unmappedFieldsHasValid = false;
        $scope.modified = false;
        $scope.selectedItems = [];
        $scope.mappings = [];
        $scope.schemas = [];
        $scope.aName = '';
        $scope.bName = '';
        $scope.connectorStyle = ["Bezier"];
        $scope.main = "";
        $scope.tab = "Mappings";
        $scope.gridOptions = {
            selectedItems: $scope.selectedItems,
            data: 'mappings',
            displayFooter: false,
            showFilter: false,
            filterOptions: {
                filterText: "searchText"
            },
            columnDefs: [
                {
                    field: 'class_a',
                    displayName: 'From',
                    cellTemplate: '<div class="ngCellText">{{row.entity.class_a.name}}</div>'
                },
                {
                    field: 'class_b',
                    displayName: 'To',
                    cellTemplate: '<div class="ngCellText">{{row.entity.class_b.name}}</div>'
                }
            ]
        };
        if ($scope.profileId) {
            Fabric.profileJolokia(jolokia, $scope.profileId, $scope.versionId, function (containerJolokia) {
                $scope.containerJolokia = containerJolokia;
                $scope.missingContainer = !containerJolokia ? true : false;
            });
        }
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateView, 50);
        });
        $scope.triggerRefresh = function (timeout) {
            if (timeout === void 0) { timeout = 500; }
            $scope.main = "";
            setTimeout(function () {
                $scope.main = $templateCache.get("pageTemplate.html");
                Core.$apply($scope);
            }, timeout);
        };
        $scope.disableReload = function () {
            var aValue = Core.pathGet($scope, ["selectedMapping", "class_a", "value"]);
            var bValue = Core.pathGet($scope, ["selectedMapping", "class_b", "value"]);
            return aValue === $scope.aName && bValue === $scope.bName;
        };
        $scope.doReload = function () {
            $scope.selectedMapping.class_a.value = $scope.aName;
            $scope.selectedMapping.class_b.value = $scope.bName;
            $scope.triggerRefresh();
        };
        $scope.$watch('selectedMapping', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                $scope.aName = newValue.class_a.value;
                $scope.bName = newValue.class_b.value;
                $scope.triggerRefresh();
            }
        });
        $scope.$watch('selectedMapping.class_a.value', function (newValue, oldValue) {
            if (newValue !== oldValue && newValue !== '') {
                $scope.fetchProperties(newValue, $scope.selectedMapping.class_a, 'Right');
            }
        });
        $scope.$watch('selectedMapping.class_b.value', function (newValue, oldValue) {
            if (newValue !== oldValue && newValue !== '') {
                $scope.fetchProperties(newValue, $scope.selectedMapping.class_b, 'Left');
            }
        });
        $scope.fetchProperties = function (className, target, anchor) {
            var introspectorMBean = Dozer.getIntrospectorMBean(workspace);
            if (introspectorMBean && !$scope.missingContainer) {
                var aJolokia = $scope.containerJolokia || jolokia;
                aJolokia.request({
                    type: 'exec',
                    mbean: introspectorMBean,
                    operation: 'getProperties(java.lang.String)',
                    arguments: [className]
                }, {
                    success: function (response) {
                        target.error = null;
                        target.properties = response.value;
                        var parentId = '';
                        if (angular.isDefined(target.value)) {
                            parentId = target.value;
                        }
                        else {
                            parentId = target.path;
                        }
                        angular.forEach(target.properties, function (property) {
                            property.id = Core.getUUID();
                            property.path = parentId + '/' + property.displayName;
                            property.anchor = anchor;
                        });
                        Core.$apply($scope);
                    },
                    error: function (response) {
                        target.properties = null;
                        target.error = {
                            'type': response.error_type,
                            'stackTrace': response.error
                        };
                        log.error("got: " + response);
                        Core.$apply($scope);
                    }
                });
            }
        };
        $scope.getSourceAndTarget = function (info) {
            var sourcePath = info.source.attr('field-path');
            var targetPath = info.target.attr('field-path');
            var sourceField = sourcePath.split('/').last();
            var targetField = sourcePath.split('/').last();
            return {
                from: sourceField,
                to: targetField
            };
        };
        function extractProperty(clazz, prop) {
            return (!clazz || !clazz.properties) ? null : clazz.properties.find(function (property) {
                return property.path.endsWith('/' + prop);
            });
        }
        function addConnectionClickHandler(connection, jsplumb) {
            connection.bind('click', function (connection) {
                jsplumb.detach(connection);
            });
        }
        function getPaintStyle() {
            return {
                strokeStyle: UI.colors.sample(),
                lineWidth: 4
            };
        }
        $scope.jsPlumbCallback = function (jsplumb, nodes, nodesById, connections) {
            angular.forEach($scope.selectedMapping.fields, function (field) {
                var a_property = extractProperty($scope.selectedMapping.class_a, field.a.value);
                var b_property = extractProperty($scope.selectedMapping.class_b, field.b.value);
                if (a_property && b_property) {
                    var a_node = nodesById[a_property.id];
                    var b_node = nodesById[b_property.id];
                    var connection = $scope.jsPlumb.connect({
                        source: a_node.el,
                        target: b_node.el
                    }, {
                        connector: $scope.connectorStyle,
                        maxConnections: 1,
                        paintStyle: getPaintStyle()
                    });
                    addConnectionClickHandler(connection, jsplumb);
                    a_node.connections.push(connection);
                    b_node.connections.push(connection);
                }
            });
            jsplumb.bind('connection', function (info) {
                addConnectionClickHandler(info.connection, jsplumb);
                info.connection.setPaintStyle(getPaintStyle());
                var newMapping = $scope.getSourceAndTarget(info);
                var field = new Dozer.Field(new Dozer.FieldDefinition(newMapping.from), new Dozer.FieldDefinition(newMapping.to));
                $scope.selectedMapping.fields.push(field);
                $scope.modified = true;
                Core.$apply($scope);
            });
            jsplumb.bind('connectionDetached', function (info) {
                var toDetach = $scope.getSourceAndTarget(info);
                var field = new Dozer.Field(new Dozer.FieldDefinition(toDetach.from), new Dozer.FieldDefinition(toDetach.to));
                $scope.selectedMapping.fields.remove(field);
                $scope.modified = true;
                Core.$apply($scope);
            });
        };
        $scope.formatStackTrace = function (exception) {
            return Log.formatStackTrace(exception);
        };
        $scope.addMapping = function () {
            var treeNode = $scope.rootTreeNode;
            if (treeNode) {
                var parentFolder = treeNode.data;
                var mapping = new Dozer.Mapping();
                var addedNode = Dozer.createMappingFolder(mapping, parentFolder);
                var added = treeNode.addChild(addedNode);
                if (added) {
                    added.expand(true);
                    added.select(true);
                    added.activate(true);
                    onTreeModified();
                }
                $scope.mappings.push(mapping);
                $scope.selectedMapping = mapping;
            }
        };
        $scope.addField = function () {
            if ($scope.selectedMapping) {
                Dozer.findUnmappedFields(workspace, $scope.selectedMapping, function (data) {
                    log.warn("has unmapped data fields: " + data);
                    $scope.unmappedFields = data;
                    $scope.unmappedFieldsHasValid = false;
                    $scope.addDialog.open();
                    Core.$apply($scope);
                });
            }
        };
        $scope.addAndCloseDialog = function () {
            log.info("About to add the unmapped fields " + JSON.stringify($scope.unmappedFields, null, "  "));
            if ($scope.selectedMapping) {
                angular.forEach($scope.unmappedFields, function (unmappedField) {
                    if (unmappedField.valid) {
                        var field = new Dozer.Field(new Dozer.FieldDefinition(unmappedField.fromField), new Dozer.FieldDefinition(unmappedField.toField));
                        $scope.selectedMapping.fields.push(field);
                        var treeNode = $scope.selectedMappingTreeNode;
                        var mappingFolder = $scope.selectedMappingFolder;
                        if (treeNode && mappingFolder) {
                            var fieldFolder = Dozer.addMappingFieldFolder(field, mappingFolder);
                            var added = treeNode.addChild(fieldFolder);
                            if (added) {
                                added.expand(true);
                                added.select(true);
                                added.activate(true);
                                onTreeModified();
                            }
                        }
                        else {
                            log.warn("No treenode and folder for mapping node! treeNode " + treeNode + " mappingFolder " + mappingFolder);
                        }
                    }
                });
            }
            $scope.addDialog.close();
        };
        $scope.canDelete = function () {
            return $scope.selectedFolder ? true : false;
        };
        $scope.removeNode = function () {
            if ($scope.selectedFolder && $scope.treeNode) {
                var folder = $scope.selectedFolder;
                var entity = folder.entity;
                if (entity instanceof Dozer.Field) {
                    var mapping = Core.pathGet(folder, ["parent", "entity"]);
                    if (mapping) {
                        mapping.fields.remove(entity);
                    }
                }
                $scope.selectedFolder.detach();
                $scope.treeNode.remove();
                $scope.selectedFolder = null;
                $scope.treeNode = null;
                onTreeModified();
            }
        };
        $scope.saveMappings = function () {
            $scope.model.mappings = $scope.mappings;
            var text = Dozer.saveToXmlText($scope.model);
            if (text) {
                var commitMessage = $scope.commitMessage || "Updated page " + $scope.pageId;
                wikiRepository.putPage($scope.branch, $scope.pageId, text, commitMessage, function (status) {
                    Wiki.onComplete(status);
                    $scope.modified = false;
                    Core.notification("success", "Saved " + $scope.pageId);
                    goToView();
                    Core.$apply($scope);
                });
            }
        };
        $scope.save = function () {
            if ($scope.tab === "Mappings") {
                $scope.saveMappings();
                return;
            }
            if ($scope.model) {
                var model = Dozer.loadModelFromTree($scope.rootTreeNode, $scope.model);
                var text = Dozer.saveToXmlText(model);
                if (text) {
                    var commitMessage = $scope.commitMessage || "Updated page " + $scope.pageId;
                    wikiRepository.putPage($scope.branch, $scope.pageId, text, commitMessage, function (status) {
                        Wiki.onComplete(status);
                        $scope.modified = false;
                        Core.notification("success", "Saved " + $scope.pageId);
                        goToView();
                        Core.$apply($scope);
                    });
                }
            }
        };
        $scope.cancel = function () {
            log.info("cancelling...");
        };
        $scope.onRootTreeNode = function (rootTreeNode) {
            $scope.rootTreeNode = rootTreeNode;
        };
        $scope.onNodeSelect = function (folder, treeNode) {
            $scope.selectedFolder = folder;
            $scope.treeNode = treeNode;
            $scope.propertiesTemplate = null;
            $scope.dozerEntity = null;
            $scope.selectedDescription = "";
            $scope.selectedMapping = null;
            $scope.selectedMappingTreeNode = null;
            $scope.selectedMappingFolder = null;
            if ($scope.removeModelChangeListener) {
                $scope.removeModelChangeListener();
                $scope.removeModelChangeListener = null;
            }
            if (folder) {
                var entity = folder.entity;
                $scope.dozerEntity = entity;
                var propertiesTemplate = "app/wiki/html/dozerPropertiesEdit.html";
                if (entity instanceof Dozer.Field) {
                    $scope.propertiesTemplate = propertiesTemplate;
                    $scope.nodeModel = io_hawt_dozer_schema_Field;
                    $scope.selectedDescription = "Field Mapping";
                    $scope.selectedMapping = Core.pathGet(folder, ["parent", "entity"]);
                    $scope.selectedMappingFolder = folder.parent;
                    $scope.selectedMappingTreeNode = treeNode.parent;
                }
                else if (entity instanceof Dozer.Mapping) {
                    $scope.propertiesTemplate = propertiesTemplate;
                    $scope.nodeModel = io_hawt_dozer_schema_Mapping;
                    $scope.selectedDescription = "Class Mapping";
                    $scope.selectedMapping = entity;
                    $scope.selectedMappingFolder = folder;
                    $scope.selectedMappingTreeNode = treeNode;
                }
                if ($scope.selectedMapping && !$scope.removeModelChangeListener) {
                }
            }
            Core.$apply($scope);
        };
        $scope.onUnmappedFieldChange = function (unmappedField) {
            unmappedField.valid = unmappedField.toField ? true : false;
            $scope.unmappedFieldsHasValid = $scope.unmappedFields.find(function (f) { return f.valid; });
        };
        function findFieldNames(className, text) {
            var properties = Dozer.findProperties(workspace, className, text, null);
            return properties.map(function (p) { return p.name; });
        }
        $scope.fromFieldNames = function (text) {
            var className = Core.pathGet($scope.selectedMapping, ["class_a", "value"]);
            return findFieldNames(className, text);
        };
        $scope.toFieldNames = function (text) {
            var className = Core.pathGet($scope.selectedMapping, ["class_b", "value"]);
            return findFieldNames(className, text);
        };
        $scope.classNames = function (text) {
            if (!text || text.length < 2)
                return [];
            return Core.time("Time the query of classes", function () {
                log.info("searching for class names with filter '" + text + "'");
                var answer = Dozer.findClassNames(workspace, text);
                log.info("Found results: " + answer.length);
                return answer;
            });
        };
        updateView();
        function updateView() {
            $scope.pageId = Wiki.pageId($routeParams, $location);
            if (Git.getGitMBean(workspace)) {
                $scope.git = wikiRepository.getPage($scope.branch, $scope.pageId, $scope.objectId, onResults);
            }
        }
        function onResults(response) {
            var text = response.text;
            if (text) {
                if ($scope.responseText !== text) {
                    $scope.responseText = text;
                    $scope.model = Dozer.loadDozerModel(text, $scope.pageId);
                    $scope.mappings = Core.pathGet($scope.model, ["mappings"]);
                    $scope.mappingTree = Dozer.createDozerTree($scope.model);
                    if (!angular.isDefined($scope.selectedMapping)) {
                        $scope.selectedMapping = $scope.mappings.first();
                    }
                    $scope.main = $templateCache.get("pageTemplate.html");
                }
            }
            else {
                log.warn("No XML found for page " + $scope.pageId);
            }
            Core.$apply($scope);
        }
        function onTreeModified() {
            $scope.modified = true;
        }
        function goToView() {
        }
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki._module.controller("Wiki.EditController", ["$scope", "$location", "$routeParams", "fileExtensionTypeRegistry", "wikiRepository", function ($scope, $location, $routeParams, fileExtensionTypeRegistry, wikiRepository) {
        Wiki.initScope($scope, $routeParams, $location);
        $scope.entity = {
            source: null
        };
        var format = Wiki.fileFormat($scope.pageId, fileExtensionTypeRegistry);
        var form = null;
        if ((format && format === "javascript") || isCreate()) {
            form = $location.search()["form"];
        }
        var options = {
            mode: {
                name: format
            }
        };
        $scope.codeMirrorOptions = CodeEditor.createEditorSettings(options);
        $scope.modified = false;
        $scope.isValid = function () { return $scope.fileName; };
        $scope.canSave = function () { return !$scope.modified; };
        $scope.$watch('entity.source', function (newValue, oldValue) {
            $scope.modified = newValue && oldValue && newValue !== oldValue;
        }, true);
        Wiki.log.debug("path: ", $scope.path);
        $scope.$watch('modified', function (newValue, oldValue) {
            Wiki.log.debug("modified: ", newValue);
        });
        $scope.viewLink = function () { return Wiki.viewLink($scope.branch, $scope.pageId, $location, $scope.fileName); };
        $scope.cancel = function () {
            goToView();
        };
        $scope.save = function () {
            if ($scope.modified && $scope.fileName) {
                saveTo($scope["pageId"]);
            }
        };
        $scope.create = function () {
            var path = $scope.pageId + "/" + $scope.fileName;
            console.log("creating new file at " + path);
            saveTo(path);
        };
        $scope.onSubmit = function (json, form) {
            if (isCreate()) {
                $scope.create();
            }
            else {
                $scope.save();
            }
        };
        $scope.onCancel = function (form) {
            setTimeout(function () {
                goToView();
                Core.$apply($scope);
            }, 50);
        };
        updateView();
        function isCreate() {
            return $location.path().startsWith("/wiki/create");
        }
        function updateView() {
            if (isCreate()) {
                updateSourceView();
            }
            else {
                Wiki.log.debug("Getting page, branch: ", $scope.branch, " pageId: ", $scope.pageId, " objectId: ", $scope.objectId);
                wikiRepository.getPage($scope.branch, $scope.pageId, $scope.objectId, onFileContents);
            }
        }
        function onFileContents(details) {
            var contents = details.text;
            $scope.entity.source = contents;
            $scope.fileName = $scope.pageId.split('/').last();
            Wiki.log.debug("file name: ", $scope.fileName);
            Wiki.log.debug("file details: ", details);
            updateSourceView();
            Core.$apply($scope);
        }
        function updateSourceView() {
            if (form) {
                if (isCreate()) {
                    if (!$scope.fileName) {
                        $scope.fileName = "" + Core.getUUID() + ".json";
                    }
                }
                $scope.sourceView = null;
                if (form === "/") {
                    onFormSchema(_jsonSchema);
                }
                else {
                    $scope.git = wikiRepository.getPage($scope.branch, form, $scope.objectId, function (details) {
                        onFormSchema(Wiki.parseJson(details.text));
                    });
                }
            }
            else {
                $scope.sourceView = "app/wiki/html/sourceEdit.html";
            }
        }
        function onFormSchema(json) {
            $scope.formDefinition = json;
            if ($scope.entity.source) {
                $scope.formEntity = Wiki.parseJson($scope.entity.source);
            }
            $scope.sourceView = "app/wiki/html/formEdit.html";
            Core.$apply($scope);
        }
        function goToView() {
            var path = Core.trimLeading($scope.viewLink(), "#");
            Wiki.log.debug("going to view " + path);
            $location.path(Wiki.decodePath(path));
            Wiki.log.debug("location is now " + $location.path());
        }
        function saveTo(path) {
            var commitMessage = $scope.commitMessage || "Updated page " + $scope.pageId;
            var contents = $scope.entity.source;
            if ($scope.formEntity) {
                contents = JSON.stringify($scope.formEntity, null, "  ");
            }
            Wiki.log.debug("Saving file, branch: ", $scope.branch, " path: ", $scope.path);
            wikiRepository.putPage($scope.branch, path, contents, commitMessage, function (status) {
                Wiki.onComplete(status);
                $scope.modified = false;
                Core.notification("success", "Saved " + path);
                goToView();
                Core.$apply($scope);
            });
        }
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki._module.controller("Wiki.FormTableController", ["$scope", "$location", "$routeParams", "workspace", "wikiRepository", function ($scope, $location, $routeParams, workspace, wikiRepository) {
        Wiki.initScope($scope, $routeParams, $location);
        $scope.columnDefs = [];
        $scope.gridOptions = {
            data: 'list',
            displayFooter: false,
            showFilter: false,
            filterOptions: {
                filterText: ''
            },
            columnDefs: $scope.columnDefs
        };
        $scope.viewLink = function (row) {
            return childLink(row, "/view");
        };
        $scope.editLink = function (row) {
            return childLink(row, "/edit");
        };
        function childLink(child, prefix) {
            var start = Wiki.startLink($scope.branch);
            var childId = (child) ? child["_id"] || "" : "";
            return Core.createHref($location, start + prefix + "/" + $scope.pageId + "/" + childId);
        }
        var linksColumn = {
            field: '_id',
            displayName: 'Actions',
            cellTemplate: '<div class="ngCellText""><a ng-href="{{viewLink(row.entity)}}" class="btn">View</a> <a ng-href="{{editLink(row.entity)}}" class="btn">Edit</a></div>'
        };
        $scope.$watch('workspace.tree', function () {
            if (!$scope.git && Git.getGitMBean(workspace)) {
                setTimeout(updateView, 50);
            }
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateView, 50);
        });
        var form = $location.search()["form"];
        if (form) {
            wikiRepository.getPage($scope.branch, form, $scope.objectId, onFormData);
        }
        updateView();
        function onResults(response) {
            var list = [];
            var map = Wiki.parseJson(response);
            angular.forEach(map, function (value, key) {
                value["_id"] = key;
                list.push(value);
            });
            $scope.list = list;
            Core.$apply($scope);
        }
        function updateView() {
            var filter = Core.pathGet($scope, ["gridOptions", "filterOptions", "filterText"]) || "";
            $scope.git = wikiRepository.jsonChildContents($scope.pageId, "*.json", filter, onResults);
        }
        function onFormData(details) {
            var text = details.text;
            if (text) {
                $scope.formDefinition = Wiki.parseJson(text);
                var columnDefs = [];
                var schema = $scope.formDefinition;
                angular.forEach(schema.properties, function (property, name) {
                    if (name) {
                        if (!Forms.isArrayOrNestedObject(property, schema)) {
                            var colDef = {
                                field: name,
                                displayName: property.description || name,
                                visible: true
                            };
                            columnDefs.push(colDef);
                        }
                    }
                });
                columnDefs.push(linksColumn);
                $scope.columnDefs = columnDefs;
                $scope.gridOptions.columnDefs = columnDefs;
                $scope.tableView = "app/wiki/html/formTableDatatable.html";
            }
        }
        Core.$apply($scope);
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki._module.controller("Wiki.GitPreferences", ["$scope", "localStorage", "userDetails", function ($scope, localStorage, userDetails) {
        Core.initPreferenceScope($scope, localStorage, {
            'gitUserName': {
                'value': userDetails.username
            },
            'gitUserEmail': {
                'value': ''
            }
        });
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki._module.controller("Wiki.HistoryController", ["$scope", "$location", "$routeParams", "$templateCache", "workspace", "marked", "fileExtensionTypeRegistry", "wikiRepository", "jolokia", function ($scope, $location, $routeParams, $templateCache, workspace, marked, fileExtensionTypeRegistry, wikiRepository, jolokia) {
        var isFmc = Fabric.isFMCContainer(workspace);
        Wiki.initScope($scope, $routeParams, $location);
        $scope.dateFormat = 'EEE, MMM d, y : hh:mm:ss a';
        $scope.gridOptions = {
            data: 'logs',
            showFilter: false,
            selectedItems: [],
            showSelectionCheckbox: true,
            displaySelectionCheckbox: true,
            filterOptions: {
                filterText: ''
            },
            columnDefs: [
                {
                    field: 'commitHashText',
                    displayName: 'Change',
                    cellTemplate: $templateCache.get('changeCellTemplate.html'),
                    cellFilter: "",
                    width: "*"
                },
                {
                    field: 'date',
                    displayName: 'Modified',
                    cellFilter: "date: dateFormat",
                    width: "**"
                },
                {
                    field: 'author',
                    displayName: 'Author',
                    cellFilter: "",
                    width: "**"
                },
                {
                    field: 'shortMessage',
                    displayName: 'Message',
                    cellTemplate: '<div class="ngCellText" title="{{row.entity.shortMessage}}">{{row.entity.trimmedMessage}}</div>',
                    cellFilter: "",
                    width: "****"
                }
            ]
        };
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(updateView, 50);
        });
        $scope.$watch('workspace.tree', function () {
            if (!$scope.git && Git.getGitMBean(workspace)) {
                setTimeout(updateView, 50);
            }
        });
        $scope.canRevert = function () {
            return $scope.gridOptions.selectedItems.length === 1 && $scope.gridOptions.selectedItems[0] !== $scope.logs[0];
        };
        $scope.revert = function () {
            if ($scope.gridOptions.selectedItems.length > 0) {
                var objectId = $scope.gridOptions.selectedItems[0].name;
                if (objectId) {
                    var commitMessage = "Reverting file " + $scope.pageId + " to previous version " + objectId;
                    wikiRepository.revertTo($scope.branch, objectId, $scope.pageId, commitMessage, function (result) {
                        Wiki.onComplete(result);
                        Core.notification('success', "Successfully reverted " + $scope.pageId);
                        updateView();
                    });
                }
                $scope.gridOptions.selectedItems.splice(0, $scope.gridOptions.selectedItems.length);
            }
        };
        $scope.diff = function () {
            var defaultValue = " ";
            var objectId = defaultValue;
            if ($scope.gridOptions.selectedItems.length > 0) {
                objectId = $scope.gridOptions.selectedItems[0].name || defaultValue;
            }
            var baseObjectId = defaultValue;
            if ($scope.gridOptions.selectedItems.length > 1) {
                baseObjectId = $scope.gridOptions.selectedItems[1].name || defaultValue;
                if ($scope.gridOptions.selectedItems[0].date < $scope.gridOptions.selectedItems[1].date) {
                    var _ = baseObjectId;
                    baseObjectId = objectId;
                    objectId = _;
                }
            }
            var link = Wiki.startLink($scope.branch) + "/diff/" + $scope.pageId + "/" + objectId + "/" + baseObjectId;
            var path = Core.trimLeading(link, "#");
            $location.path(path);
        };
        updateView();
        function updateView() {
            var objectId = "";
            var limit = 0;
            $scope.git = wikiRepository.history($scope.branch, objectId, $scope.pageId, limit, function (logArray) {
                angular.forEach(logArray, function (log) {
                    var commitId = log.commitHashText || log.name;
                    log.commitLink = Wiki.startLink($scope.branch) + "/commit/" + $scope.pageId + "/" + commitId;
                });
                $scope.logs = logArray;
                Core.$apply($scope);
            });
            Wiki.loadBranches(jolokia, wikiRepository, $scope, isFmc);
        }
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki._module.controller("Wiki.NavBarController", ["$scope", "$location", "$routeParams", "workspace", "jolokia", "wikiRepository", "wikiBranchMenu", function ($scope, $location, $routeParams, workspace, jolokia, wikiRepository, wikiBranchMenu) {
        var isFmc = Fabric.isFMCContainer(workspace);
        Wiki.initScope($scope, $routeParams, $location);
        $scope.branchMenuConfig = {
            title: $scope.branch,
            items: []
        };
        $scope.ViewMode = Wiki.ViewMode;
        $scope.setViewMode = function (mode) {
            $scope.$emit('Wiki.SetViewMode', mode);
        };
        wikiBranchMenu.applyMenuExtensions($scope.branchMenuConfig.items);
        $scope.$watch('branches', function (newValue, oldValue) {
            if (newValue === oldValue || !newValue) {
                return;
            }
            $scope.branchMenuConfig.items = [];
            if (newValue.length > 0) {
                $scope.branchMenuConfig.items.push({
                    heading: isFmc ? "Versions" : "Branches"
                });
            }
            newValue.sort().forEach(function (item) {
                var menuItem = {
                    title: item,
                    icon: '',
                    action: function () {
                    }
                };
                if (item === $scope.branch) {
                    menuItem.icon = "icon-ok";
                }
                else {
                    menuItem.action = function () {
                        var targetUrl = Wiki.branchLink(item, $scope.pageId, $location);
                        $location.path(Core.toPath(targetUrl));
                        Core.$apply($scope);
                    };
                }
                $scope.branchMenuConfig.items.push(menuItem);
            });
            wikiBranchMenu.applyMenuExtensions($scope.branchMenuConfig.items);
        }, true);
        $scope.createLink = function () {
            var pageId = Wiki.pageId($routeParams, $location);
            return Wiki.createLink($scope.branch, pageId, $location, $scope);
        };
        $scope.startLink = Wiki.startLink($scope.branch);
        $scope.sourceLink = function () {
            var path = $location.path();
            var answer = null;
            angular.forEach(Wiki.customViewLinks($scope), function (link) {
                if (path.startsWith(link)) {
                    answer = Core.createHref($location, Wiki.startLink($scope.branch) + "/view" + path.substring(link.length));
                }
            });
            return (!answer && $location.search()["form"]) ? Core.createHref($location, "#" + path, ["form"]) : answer;
        };
        $scope.isActive = function (href) {
            if (!href) {
                return false;
            }
            return href.endsWith($routeParams['page']);
        };
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(loadBreadcrumbs, 50);
        });
        loadBreadcrumbs();
        function switchFromViewToCustomLink(breadcrumb, link) {
            var href = breadcrumb.href;
            if (href) {
                breadcrumb.href = href.replace("wiki/view", link);
            }
        }
        function loadBreadcrumbs() {
            var start = Wiki.startLink($scope.branch);
            var href = start + "/view";
            $scope.breadcrumbs = [
                { href: href, name: "root" }
            ];
            var path = Wiki.pageId($routeParams, $location);
            var array = path ? path.split("/") : [];
            angular.forEach(array, function (name) {
                if (!name.startsWith("/") && !href.endsWith("/")) {
                    href += "/";
                }
                href += Wiki.encodePath(name);
                if (!name.isBlank()) {
                    $scope.breadcrumbs.push({ href: href, name: name });
                }
            });
            var loc = $location.path();
            if ($scope.breadcrumbs.length) {
                var last = $scope.breadcrumbs[$scope.breadcrumbs.length - 1];
                last.name = Wiki.hideFileNameExtensions(last.name);
                var swizzled = false;
                angular.forEach(Wiki.customViewLinks($scope), function (link) {
                    if (!swizzled && loc.startsWith(link)) {
                        switchFromViewToCustomLink($scope.breadcrumbs.last(), Core.trimLeading(link, "/"));
                        swizzled = true;
                    }
                });
                if (!swizzled && $location.search()["form"]) {
                    var lastName = $scope.breadcrumbs.last().name;
                    if (lastName && lastName.endsWith(".json")) {
                        switchFromViewToCustomLink($scope.breadcrumbs[$scope.breadcrumbs.length - 2], "wiki/formTable");
                    }
                }
            }
            var name = null;
            if (loc.startsWith("/wiki/version")) {
                name = ($routeParams["objectId"] || "").substring(0, 6) || "Version";
                $scope.breadcrumbs.push({ href: "#" + loc, name: name });
            }
            if (loc.startsWith("/wiki/diff")) {
                var v1 = ($routeParams["objectId"] || "").substring(0, 6);
                var v2 = ($routeParams["baseObjectId"] || "").substring(0, 6);
                name = "Diff";
                if (v1) {
                    if (v2) {
                        name += " " + v1 + " " + v2;
                    }
                    else {
                        name += " " + v1;
                    }
                }
                $scope.breadcrumbs.push({ href: "#" + loc, name: name });
            }
            Core.$apply($scope);
        }
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    function getRenameDialog($dialog, $scope) {
        return $dialog.dialog({
            resolve: $scope,
            templateUrl: 'app/wiki/html/modal/renameDialog.html',
            controller: ["$scope", "dialog", "callbacks", "rename", "fileExists", "fileName", function ($scope, dialog, callbacks, rename, fileExists, fileName) {
                $scope.rename = rename;
                $scope.fileExists = fileExists;
                $scope.fileName = fileName;
                $scope.close = function (result) {
                    dialog.close();
                };
                $scope.renameAndCloseDialog = callbacks;
            }]
        });
    }
    Wiki.getRenameDialog = getRenameDialog;
    function getMoveDialog($dialog, $scope) {
        return $dialog.dialog({
            resolve: $scope,
            templateUrl: 'app/wiki/html/modal/moveDialog.html',
            controller: ["$scope", "dialog", "callbacks", "move", "folderNames", function ($scope, dialog, callbacks, move, folderNames) {
                $scope.move = move;
                $scope.folderNames = folderNames;
                $scope.close = function (result) {
                    dialog.close();
                };
                $scope.moveAndCloseDialog = callbacks;
            }]
        });
    }
    Wiki.getMoveDialog = getMoveDialog;
    function getDeleteDialog($dialog, $scope) {
        return $dialog.dialog({
            resolve: $scope,
            templateUrl: 'app/wiki/html/modal/deleteDialog.html',
            controller: ["$scope", "dialog", "callbacks", "selectedFileHtml", "warning", function ($scope, dialog, callbacks, selectedFileHtml, warning) {
                $scope.selectedFileHtml = selectedFileHtml;
                $scope.close = function (result) {
                    dialog.close();
                };
                $scope.deleteAndCloseDialog = callbacks;
                $scope.warning = warning;
            }]
        });
    }
    Wiki.getDeleteDialog = getDeleteDialog;
    function getCantDeleteDialog($dialog, $scope) {
        return $dialog.dialog({
            resolve: $scope,
            templateUrl: 'app/wiki/html/modal/cantDeleteDialog.html',
            controller: ["$scope", "dialog", "warning", function ($scope, dialog, warning) {
                $scope.close = function (result) {
                    dialog.close();
                };
                $scope.warning = warning;
            }]
        });
    }
    Wiki.getCantDeleteDialog = getCantDeleteDialog;
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki.FileDropController = Wiki._module.controller("Wiki.FileDropController", ["$scope", "FileUploader", "$route", "$timeout", "userDetails", function ($scope, FileUploader, $route, $timeout, userDetails) {
        var uploadURI = Wiki.gitRestURL($scope.branch, $scope.pageId) + '/';
        var uploader = $scope.uploader = new FileUploader({
            headers: {
                'Authorization': Core.authHeaderValue(userDetails)
            },
            autoUpload: true,
            withCredentials: true,
            method: 'POST',
            url: uploadURI
        });
        $scope.doUpload = function () {
            uploader.uploadAll();
        };
        uploader.onWhenAddingFileFailed = function (item, filter, options) {
            Wiki.log.debug('onWhenAddingFileFailed', item, filter, options);
        };
        uploader.onAfterAddingFile = function (fileItem) {
            Wiki.log.debug('onAfterAddingFile', fileItem);
        };
        uploader.onAfterAddingAll = function (addedFileItems) {
            Wiki.log.debug('onAfterAddingAll', addedFileItems);
        };
        uploader.onBeforeUploadItem = function (item) {
            if ('file' in item) {
                item.fileSizeMB = (item.file.size / 1024 / 1024).toFixed(2);
            }
            else {
                item.fileSizeMB = 0;
            }
            item.url = uploadURI;
            Wiki.log.info("Loading files to " + uploadURI);
            Wiki.log.debug('onBeforeUploadItem', item);
        };
        uploader.onProgressItem = function (fileItem, progress) {
            Wiki.log.debug('onProgressItem', fileItem, progress);
        };
        uploader.onProgressAll = function (progress) {
            Wiki.log.debug('onProgressAll', progress);
        };
        uploader.onSuccessItem = function (fileItem, response, status, headers) {
            Wiki.log.debug('onSuccessItem', fileItem, response, status, headers);
        };
        uploader.onErrorItem = function (fileItem, response, status, headers) {
            Wiki.log.debug('onErrorItem', fileItem, response, status, headers);
        };
        uploader.onCancelItem = function (fileItem, response, status, headers) {
            Wiki.log.debug('onCancelItem', fileItem, response, status, headers);
        };
        uploader.onCompleteItem = function (fileItem, response, status, headers) {
            Wiki.log.debug('onCompleteItem', fileItem, response, status, headers);
        };
        uploader.onCompleteAll = function () {
            Wiki.log.debug('onCompleteAll');
            uploader.clearQueue();
            $timeout(function () {
                Wiki.log.info("Completed all uploads. Lets force a reload");
                $route.reload();
                Core.$apply($scope);
            }, 200);
        };
    }]);
    Wiki.ViewController = Wiki._module.controller("Wiki.ViewController", ["$scope", "$location", "$routeParams", "$route", "$http", "$timeout", "workspace", "marked", "fileExtensionTypeRegistry", "wikiRepository", "$compile", "$templateCache", "jolokia", "localStorage", "$interpolate", "$dialog", function ($scope, $location, $routeParams, $route, $http, $timeout, workspace, marked, fileExtensionTypeRegistry, wikiRepository, $compile, $templateCache, jolokia, localStorage, $interpolate, $dialog) {
        $scope.name = "WikiViewController";
        var isFmc = Fabric.isFMCContainer(workspace);
        Wiki.initScope($scope, $routeParams, $location);
        SelectionHelpers.decorate($scope);
        $scope.fabricTopLevel = "fabric/profiles/";
        $scope.versionId = $scope.branch;
        $scope.paneTemplate = '';
        $scope.profileId = Fabric.pagePathToProfileId($scope.pageId);
        $scope.showProfileHeader = $scope.profileId && $scope.pageId.endsWith(Fabric.profileSuffix) ? true : false;
        $scope.showAppHeader = false;
        $scope.operationCounter = 1;
        $scope.renameDialog = null;
        $scope.moveDialog = null;
        $scope.deleteDialog = null;
        $scope.isFile = false;
        $scope.rename = {
            newFileName: ""
        };
        $scope.move = {
            moveFolder: ""
        };
        $scope.ViewMode = Wiki.ViewMode;
        Core.bindModelToSearchParam($scope, $location, "searchText", "q", "");
        StorageHelpers.bindModelToLocalStorage({
            $scope: $scope,
            $location: $location,
            localStorage: localStorage,
            modelName: 'mode',
            paramName: 'wikiViewMode',
            initialValue: 0 /* List */,
            to: Core.numberToString,
            from: Core.parseIntValue
        });
        Core.reloadWhenParametersChange($route, $scope, $location, ['wikiViewMode']);
        $scope.gridOptions = {
            data: 'children',
            displayFooter: false,
            selectedItems: [],
            showSelectionCheckbox: true,
            enableSorting: false,
            useExternalSorting: true,
            columnDefs: [
                {
                    field: 'name',
                    displayName: 'Name',
                    cellTemplate: $templateCache.get('fileCellTemplate.html'),
                    headerCellTemplate: $templateCache.get('fileColumnTemplate.html')
                }
            ]
        };
        $scope.$on('Wiki.SetViewMode', function ($event, mode) {
            $scope.mode = mode;
            switch (mode) {
                case 0 /* List */:
                    Wiki.log.debug("List view mode");
                    break;
                case 1 /* Icon */:
                    Wiki.log.debug("Icon view mode");
                    break;
                default:
                    $scope.mode = 0 /* List */;
                    Wiki.log.debug("Defaulting to list view mode");
                    break;
            }
        });
        $scope.childActions = [];
        var maybeUpdateView = Core.throttled(updateView, 1000);
        $scope.marked = function (text) {
            if (text) {
                return marked(text);
            }
            else {
                return '';
            }
        };
        $scope.$on('wikiBranchesUpdated', function () {
            updateView();
        });
        $scope.createDashboardLink = function () {
            var href = '/wiki/branch/:branch/view/*page';
            var page = $routeParams['page'];
            var title = page ? page.split("/").last() : null;
            var size = angular.toJson({
                size_x: 2,
                size_y: 2
            });
            var answer = "#/dashboard/add?tab=dashboard" + "&href=" + encodeURIComponent(href) + "&size=" + encodeURIComponent(size) + "&routeParams=" + encodeURIComponent(angular.toJson($routeParams));
            if (title) {
                answer += "&title=" + encodeURIComponent(title);
            }
            return answer;
        };
        $scope.displayClass = function () {
            if (!$scope.children || $scope.children.length === 0) {
                return "";
            }
            return "span9";
        };
        $scope.parentLink = function () {
            var start = Wiki.startLink($scope.branch);
            var prefix = start + "/view";
            var parts = $scope.pageId.split("/");
            var path = "/" + parts.first(parts.length - 1).join("/");
            return Core.createHref($location, prefix + path, []);
        };
        $scope.childLink = function (child) {
            var start = Wiki.startLink($scope.branch);
            var prefix = start + "/view";
            var postFix = "";
            var path = Wiki.encodePath(child.path);
            if (child.directory) {
                var formPath = path + ".form";
                var children = $scope.children;
                if (children) {
                    var formFile = children.find(function (child) {
                        return child['path'] === formPath;
                    });
                    if (formFile) {
                        prefix = start + "/formTable";
                        postFix = "?form=" + formPath;
                    }
                }
            }
            else {
                var xmlNamespaces = child.xmlNamespaces;
                if (xmlNamespaces && xmlNamespaces.length) {
                    if (xmlNamespaces.any(function (ns) { return Wiki.camelNamespaces.any(ns); })) {
                        prefix = start + "/camel/canvas";
                    }
                    else if (xmlNamespaces.any(function (ns) { return Wiki.dozerNamespaces.any(ns); })) {
                        prefix = start + "/dozer/mappings";
                    }
                    else {
                        Wiki.log.debug("child " + path + " has namespaces " + xmlNamespaces);
                    }
                }
                if (child.path.endsWith(".form")) {
                    postFix = "?form=/";
                }
                else if (Wiki.isIndexPage(child.path)) {
                    prefix = start + "/book";
                }
            }
            return Core.createHref($location, prefix + path + postFix, ["form"]);
        };
        $scope.fileName = function (entity) {
            return Wiki.hideFileNameExtensions(entity.displayName || entity.name);
        };
        $scope.fileClass = function (entity) {
            if (entity.name.has(".profile")) {
                return "green";
            }
            return "";
        };
        $scope.fileIconHtml = function (entity) {
            return Wiki.fileIconHtml(entity);
        };
        $scope.format = Wiki.fileFormat($scope.pageId, fileExtensionTypeRegistry);
        var options = {
            readOnly: true,
            mode: {
                name: $scope.format
            }
        };
        $scope.codeMirrorOptions = CodeEditor.createEditorSettings(options);
        $scope.editLink = function () {
            var pageName = ($scope.directory) ? $scope.readMePath : $scope.pageId;
            return (pageName) ? Wiki.editLink($scope.branch, pageName, $location) : null;
        };
        $scope.branchLink = function (branch) {
            if (branch) {
                return Wiki.branchLink(branch, $scope.pageId, $location);
            }
            return null;
        };
        $scope.historyLink = "#/wiki" + ($scope.branch ? "/branch/" + $scope.branch : "") + "/history/" + $scope.pageId;
        $scope.$watch('workspace.tree', function () {
            if (!$scope.git && Git.getGitMBean(workspace)) {
                setTimeout(maybeUpdateView, 50);
            }
        });
        $scope.$on("$routeChangeSuccess", function (event, current, previous) {
            setTimeout(maybeUpdateView, 50);
        });
        $scope.openDeleteDialog = function () {
            if ($scope.gridOptions.selectedItems.length) {
                $scope.selectedFileHtml = "<ul>" + $scope.gridOptions.selectedItems.map(function (file) { return "<li>" + file.name + "</li>"; }).sort().join("") + "</ul>";
                var cantDelete = false;
                if (Fabric.isFMCContainer(workspace)) {
                    var profileIds = [];
                    var profileFolderNames = [];
                    $scope.gridOptions.selectedItems.map(function (file) {
                        if (file.mimeType !== "inode/directory")
                            return null;
                        var name = file.path;
                        if (name.match(/\.profile$/))
                            name = name.substring(0, name.length - 8);
                        if (name.match(/^\/fabric\/profiles\//))
                            name = name.substring(17);
                        profileIds.push(name.replace(/\//g, "-"));
                        profileFolderNames.push(file.name);
                        return null;
                    });
                    if (profileFolderNames.length > 0) {
                        var containerIds = Fabric.getContainerIdsForProfiles(jolokia, $scope.versionId, profileIds, true);
                        if (containerIds.find(function (containersOfProfile) { return containersOfProfile.length > 0; })) {
                            cantDelete = true;
                            $scope.deleteWarning = "You can't delete document(s) which represent Fabric8 profile(s).";
                            $scope.deleteWarning += "<br/>These folders are profiles that are used by existing containers:<ul>";
                            for (var pn = 0; pn < profileFolderNames.length; pn++) {
                                if (containerIds[pn].length > 0) {
                                    $scope.deleteWarning += "<li>" + profileFolderNames[pn] + " (";
                                    for (var cn = 0; cn < containerIds[pn].length; cn++) {
                                        if (cn > 0) {
                                            $scope.deleteWarning += ", ";
                                        }
                                        $scope.deleteWarning += containerIds[pn][cn];
                                    }
                                    $scope.deleteWarning += ")</li>";
                                }
                            }
                            $scope.deleteWarning += "</ul>";
                        }
                        else {
                            $scope.deleteWarning = "You are about to delete document(s) which may be part of Fabric8 profile(s). This really can't be undone! Wiki operations are low level and may lead to non-functional state of Fabric.";
                        }
                    }
                }
                else {
                    $scope.deleteWarning = null;
                }
                if (cantDelete) {
                    $scope.deleteDialog = Wiki.getCantDeleteDialog($dialog, {
                        warning: function () {
                            return $scope.deleteWarning;
                        }
                    });
                }
                else {
                    $scope.deleteDialog = Wiki.getDeleteDialog($dialog, {
                        callbacks: function () {
                            return $scope.deleteAndCloseDialog;
                        },
                        selectedFileHtml: function () {
                            return $scope.selectedFileHtml;
                        },
                        warning: function () {
                            return $scope.deleteWarning;
                        }
                    });
                }
                $scope.deleteDialog.open();
            }
            else {
                Wiki.log.debug("No items selected right now! " + $scope.gridOptions.selectedItems);
            }
        };
        $scope.deleteAndCloseDialog = function () {
            var files = $scope.gridOptions.selectedItems;
            var fileCount = files.length;
            Wiki.log.debug("Deleting selection: " + files);
            angular.forEach(files, function (file, idx) {
                var path = $scope.pageId + "/" + file.name;
                Wiki.log.debug("About to delete " + path);
                $scope.git = wikiRepository.removePage($scope.branch, path, null, function (result) {
                    if (idx + 1 === fileCount) {
                        $scope.gridOptions.selectedItems.splice(0, fileCount);
                        var message = Core.maybePlural(fileCount, "document");
                        Core.notification("success", "Deleted " + message);
                        Core.$apply($scope);
                        updateView();
                    }
                });
            });
            $scope.deleteDialog.close();
        };
        $scope.$watch("rename.newFileName", function () {
            var path = getRenameFilePath();
            if ($scope.originalRenameFilePath === path) {
                $scope.fileExists = { exists: false, name: null };
            }
            else {
                checkFileExists(path);
            }
        });
        $scope.renameAndCloseDialog = function () {
            if ($scope.gridOptions.selectedItems.length) {
                var selected = $scope.gridOptions.selectedItems[0];
                var newPath = getRenameFilePath();
                if (selected && newPath) {
                    var oldName = selected.name;
                    var newName = Wiki.fileName(newPath);
                    var oldPath = $scope.pageId + "/" + oldName;
                    Wiki.log.debug("About to rename file " + oldPath + " to " + newPath);
                    $scope.git = wikiRepository.rename($scope.branch, oldPath, newPath, null, function (result) {
                        Core.notification("success", "Renamed file to  " + newName);
                        $scope.gridOptions.selectedItems.splice(0, 1);
                        $scope.renameDialog.close();
                        Core.$apply($scope);
                        updateView();
                    });
                }
            }
            $scope.renameDialog.close();
        };
        $scope.openRenameDialog = function () {
            var name = null;
            if ($scope.gridOptions.selectedItems.length) {
                var selected = $scope.gridOptions.selectedItems[0];
                name = selected.name;
            }
            if (name) {
                $scope.rename.newFileName = name;
                $scope.originalRenameFilePath = getRenameFilePath();
                $scope.renameDialog = Wiki.getRenameDialog($dialog, {
                    rename: function () {
                        return $scope.rename;
                    },
                    fileExists: function () {
                        return $scope.fileExists;
                    },
                    fileName: function () {
                        return $scope.fileName;
                    },
                    callbacks: function () {
                        return $scope.renameAndCloseDialog;
                    }
                });
                $scope.renameDialog.open();
                $timeout(function () {
                    $('#renameFileName').focus();
                }, 50);
            }
            else {
                Wiki.log.debug("No items selected right now! " + $scope.gridOptions.selectedItems);
            }
        };
        $scope.moveAndCloseDialog = function () {
            var files = $scope.gridOptions.selectedItems;
            var fileCount = files.length;
            var moveFolder = $scope.move.moveFolder;
            var oldFolder = $scope.pageId;
            if (moveFolder && fileCount && moveFolder !== oldFolder) {
                Wiki.log.debug("Moving " + fileCount + " file(s) to " + moveFolder);
                angular.forEach(files, function (file, idx) {
                    var oldPath = oldFolder + "/" + file.name;
                    var newPath = moveFolder + "/" + file.name;
                    Wiki.log.debug("About to move " + oldPath + " to " + newPath);
                    $scope.git = wikiRepository.rename($scope.branch, oldPath, newPath, null, function (result) {
                        if (idx + 1 === fileCount) {
                            $scope.gridOptions.selectedItems.splice(0, fileCount);
                            var message = Core.maybePlural(fileCount, "document");
                            Core.notification("success", "Moved " + message + " to " + newPath);
                            $scope.moveDialog.close();
                            Core.$apply($scope);
                            updateView();
                        }
                    });
                });
            }
            $scope.moveDialog.close();
        };
        $scope.folderNames = function (text) {
            return wikiRepository.completePath($scope.branch, text, true, null);
        };
        $scope.openMoveDialog = function () {
            if ($scope.gridOptions.selectedItems.length) {
                $scope.move.moveFolder = $scope.pageId;
                $scope.moveDialog = Wiki.getMoveDialog($dialog, {
                    move: function () {
                        return $scope.move;
                    },
                    folderNames: function () {
                        return $scope.folderNames;
                    },
                    callbacks: function () {
                        return $scope.moveAndCloseDialog;
                    }
                });
                $scope.moveDialog.open();
                $timeout(function () {
                    $('#moveFolder').focus();
                }, 50);
            }
            else {
                Wiki.log.debug("No items selected right now! " + $scope.gridOptions.selectedItems);
            }
        };
        setTimeout(maybeUpdateView, 50);
        function isDiffView() {
            var path = $location.path();
            return path && (path.startsWith("/wiki/diff") || path.startsWith("/wiki/branch/" + $scope.branch + "/diff"));
        }
        function updateView() {
            if (isDiffView()) {
                var baseObjectId = $routeParams["baseObjectId"];
                $scope.git = wikiRepository.diff($scope.objectId, baseObjectId, $scope.pageId, onFileDetails);
            }
            else {
                $scope.git = wikiRepository.getPage($scope.branch, $scope.pageId, $scope.objectId, onFileDetails);
            }
            Wiki.loadBranches(jolokia, wikiRepository, $scope, isFmc);
        }
        $scope.updateView = updateView;
        function viewContents(pageName, contents) {
            $scope.sourceView = null;
            var format = null;
            if (isDiffView()) {
                format = "diff";
            }
            else {
                format = Wiki.fileFormat(pageName, fileExtensionTypeRegistry) || $scope.format;
            }
            Wiki.log.debug("File format: ", format);
            switch (format) {
                case "image":
                    var imageURL = 'git/' + $scope.branch;
                    Wiki.log.debug("$scope: ", $scope);
                    imageURL = UrlHelpers.join(imageURL, $scope.pageId);
                    var interpolateFunc = $interpolate($templateCache.get("imageTemplate.html"));
                    $scope.html = interpolateFunc({
                        imageURL: imageURL
                    });
                    break;
                case "markdown":
                    $scope.html = contents ? marked(contents) : "";
                    break;
                case "javascript":
                    var form = null;
                    form = $location.search()["form"];
                    $scope.source = contents;
                    $scope.form = form;
                    if (form) {
                        $scope.sourceView = null;
                        if (form === "/") {
                            onFormSchema(_jsonSchema);
                        }
                        else {
                            $scope.git = wikiRepository.getPage($scope.branch, form, $scope.objectId, function (details) {
                                onFormSchema(Wiki.parseJson(details.text));
                            });
                        }
                    }
                    else {
                        $scope.sourceView = "app/wiki/html/sourceView.html";
                    }
                    break;
                default:
                    $scope.html = null;
                    $scope.source = contents;
                    $scope.sourceView = "app/wiki/html/sourceView.html";
            }
            Core.$apply($scope);
        }
        function onFormSchema(json) {
            $scope.formDefinition = json;
            if ($scope.source) {
                $scope.formEntity = Wiki.parseJson($scope.source);
            }
            $scope.sourceView = "app/wiki/html/formView.html";
            Core.$apply($scope);
        }
        function onFileDetails(details) {
            var contents = details.text;
            $scope.directory = details.directory;
            $scope.fileDetails = details;
            if (details && details.format) {
                $scope.format = details.format;
            }
            else {
                $scope.format = Wiki.fileFormat($scope.pageId, fileExtensionTypeRegistry);
            }
            $scope.codeMirrorOptions.mode.name = $scope.format;
            $scope.children = null;
            if (details.directory) {
                var directories = details.children.filter(function (dir) {
                    return dir.directory && !dir.name.has(".profile");
                });
                var profiles = details.children.filter(function (dir) {
                    return dir.directory && dir.name.has(".profile");
                });
                var files = details.children.filter(function (file) {
                    return !file.directory;
                });
                directories = directories.sortBy(function (dir) {
                    return dir.name;
                });
                profiles = profiles.sortBy(function (dir) {
                    return dir.name;
                });
                files = files.sortBy(function (file) {
                    return file.name;
                }).sortBy(function (file) {
                    return file.name.split('.').last();
                });
                $scope.children = Array.create(directories, profiles, files).map(function (file) {
                    file.branch = $scope.branch;
                    file.fileName = file.name;
                    if (file.directory) {
                        file.fileName += ".zip";
                    }
                    file.downloadURL = Wiki.gitRestURL($scope.branch, file.path);
                    return file;
                });
            }
            $scope.html = null;
            $scope.source = null;
            $scope.readMePath = null;
            $scope.isFile = false;
            if ($scope.children) {
                $scope.$broadcast('pane.open');
                var item = $scope.children.find(function (info) {
                    var name = (info.name || "").toLowerCase();
                    var ext = Wiki.fileExtension(name);
                    return name && ext && ((name.startsWith("readme.") || name === "readme") || (name.startsWith("index.") || name === "index"));
                });
                if (item) {
                    var pageName = item.path;
                    $scope.readMePath = pageName;
                    wikiRepository.getPage($scope.branch, pageName, $scope.objectId, function (readmeDetails) {
                        viewContents(pageName, readmeDetails.text);
                    });
                }
                var kubernetesJson = $scope.children.find(function (child) {
                    var name = (child.name || "").toLowerCase();
                    var ext = Wiki.fileExtension(name);
                    return name && ext && name.startsWith("kubernetes") && ext === "json";
                });
                if (kubernetesJson) {
                    wikiRepository.getPage($scope.branch, kubernetesJson.path, undefined, function (json) {
                        if (json && json.text) {
                            try {
                                $scope.kubernetesJson = angular.fromJson(json.text);
                            }
                            catch (e) {
                                $scope.kubernetesJson = {
                                    errorParsing: true,
                                    error: e
                                };
                            }
                            $scope.showAppHeader = true;
                            Core.$apply($scope);
                        }
                    });
                }
                $scope.$broadcast('Wiki.ViewPage.Children', $scope.pageId, $scope.children);
            }
            else {
                $scope.$broadcast('pane.close');
                var pageName = $scope.pageId;
                viewContents(pageName, contents);
                $scope.isFile = true;
            }
            Core.$apply($scope);
        }
        function checkFileExists(path) {
            $scope.operationCounter += 1;
            var counter = $scope.operationCounter;
            if (path) {
                wikiRepository.exists($scope.branch, path, function (result) {
                    if ($scope.operationCounter === counter) {
                        Wiki.log.debug("checkFileExists for path " + path + " got result " + result);
                        $scope.fileExists.exists = result ? true : false;
                        $scope.fileExists.name = result ? result.name : null;
                        Core.$apply($scope);
                    }
                    else {
                    }
                });
            }
        }
        $scope.getContents = function (filename, cb) {
            var pageId = filename;
            if ($scope.directory) {
                pageId = $scope.pageId + '/' + filename;
            }
            else {
                var pathParts = $scope.pageId.split('/');
                pathParts = pathParts.remove(pathParts.last());
                pathParts.push(filename);
                pageId = pathParts.join('/');
            }
            Wiki.log.debug("pageId: ", $scope.pageId);
            Wiki.log.debug("branch: ", $scope.branch);
            Wiki.log.debug("filename: ", filename);
            Wiki.log.debug("using pageId: ", pageId);
            wikiRepository.getPage($scope.branch, pageId, undefined, function (data) {
                cb(data.text);
            });
        };
        function getRenameFilePath() {
            var newFileName = $scope.rename.newFileName;
            return ($scope.pageId && newFileName) ? $scope.pageId + "/" + newFileName : null;
        }
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki._module.directive('wikiHrefAdjuster', ["$location", function ($location) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attr) {
                $element.bind('DOMNodeInserted', function (event) {
                    var ays = $element.find('a');
                    angular.forEach(ays, function (a) {
                        if (a.hasAttribute('no-adjust')) {
                            return;
                        }
                        a = $(a);
                        var href = (a.attr('href') || "").trim();
                        if (href) {
                            var fileExtension = a.attr('file-extension');
                            var newValue = Wiki.adjustHref($scope, $location, href, fileExtension);
                            if (newValue) {
                                a.attr('href', newValue);
                            }
                        }
                    });
                    var imgs = $element.find('img');
                    angular.forEach(imgs, function (a) {
                        if (a.hasAttribute('no-adjust')) {
                            return;
                        }
                        a = $(a);
                        var href = (a.attr('src') || "").trim();
                        if (href) {
                            if (href.startsWith("/")) {
                                href = Core.url(href);
                                a.attr('src', href);
                                a.attr('no-adjust', 'true');
                            }
                        }
                    });
                });
            }
        };
    }]);
    Wiki._module.directive('wikiTitleLinker', ["$location", function ($location) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attr) {
                var loaded = false;
                function offsetTop(elements) {
                    if (elements) {
                        var offset = elements.offset();
                        if (offset) {
                            return offset.top;
                        }
                    }
                    return 0;
                }
                function scrollToHash() {
                    var answer = false;
                    var id = $location.search()["hash"];
                    return scrollToId(id);
                }
                function scrollToId(id) {
                    var answer = false;
                    var id = $location.search()["hash"];
                    if (id) {
                        var selector = 'a[name="' + id + '"]';
                        var targetElements = $element.find(selector);
                        if (targetElements && targetElements.length) {
                            var scrollDuration = 1;
                            var delta = offsetTop($($element));
                            var top = offsetTop(targetElements) - delta;
                            if (top < 0) {
                                top = 0;
                            }
                            $('body,html').animate({
                                scrollTop: top
                            }, scrollDuration);
                            answer = true;
                        }
                        else {
                        }
                    }
                    return answer;
                }
                function addLinks(event) {
                    var headings = $element.find('h1,h2,h3,h4,h5,h6,h7');
                    var updated = false;
                    angular.forEach(headings, function (he) {
                        var h1 = $(he);
                        var a = h1.parent("a");
                        if (!a || !a.length) {
                            var text = h1.text();
                            if (text) {
                                var target = text.replace(/ /g, "-");
                                var pathWithHash = "#" + $location.path() + "?hash=" + target;
                                var link = Core.createHref($location, pathWithHash, ['hash']);
                                var newA = $('<a name="' + target + '" href="' + link + '" ng-click="onLinkClick()"></a>');
                                newA.on("click", function () {
                                    setTimeout(function () {
                                        if (scrollToId(target)) {
                                        }
                                    }, 50);
                                });
                                newA.insertBefore(h1);
                                h1.detach();
                                newA.append(h1);
                                updated = true;
                            }
                        }
                    });
                    if (updated && !loaded) {
                        setTimeout(function () {
                            if (scrollToHash()) {
                                loaded = true;
                            }
                        }, 50);
                    }
                }
                function onEventInserted(event) {
                    $element.unbind('DOMNodeInserted', onEventInserted);
                    addLinks(event);
                    $element.bind('DOMNodeInserted', onEventInserted);
                }
                $element.bind('DOMNodeInserted', onEventInserted);
            }
        };
    }]);
    Wiki._module.directive('wikiFixed', ["$timeout", function ($timeout) {
        return {
            restrict: "C",
            link: function ($scope, $element, $attr) {
                $timeout(function () {
                    var wikiLinks = $(".logbar");
                    var top = (wikiLinks.height() + 8) + "px";
                    $element.css({ "margin-top": top, "visibility": "visible" });
                }, 100, false);
            }
        };
    }]);
})(Wiki || (Wiki = {}));
var Wiki;
(function (Wiki) {
    Wiki.TopLevelController = Wiki._module.controller("Wiki.TopLevelController", ['$scope', 'workspace', 'jolokia', function ($scope, workspace, jolokia) {
        $scope.managerMBean = Fabric.managerMBean;
        $scope.clusterBootstrapManagerMBean = Fabric.clusterBootstrapManagerMBean;
        $scope.clusterManagerMBean = Fabric.clusterManagerMBean;
        $scope.openShiftFabricMBean = Fabric.openShiftFabricMBean;
        $scope.mqManagerMBean = Fabric.mqManagerMBean;
        $scope.healthMBean = Fabric.healthMBean;
        $scope.schemaLookupMBean = Fabric.schemaLookupMBean;
        $scope.gitMBean = Git.getGitMBean(workspace);
        $scope.configAdminMBean = Osgi.getHawtioConfigAdminMBean(workspace);
        $scope.defaultVersion = Fabric.isFMCContainer(workspace) ? Fabric.getDefaultVersionId(jolokia) : "1.0";
    }]);
})(Wiki || (Wiki = {}));
//# sourceMappingURL=app.js.map